(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module2) => () => {
    if (!module2) {
      module2 = {exports: {}};
      callback(module2.exports, module2);
    }
    return module2.exports;
  };
  var __export = (target, all2) => {
    for (var name284 in all2)
      __defProp(target, name284, {get: all2[name284], enumerable: true});
  };
  var __exportStar = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
  };

  // node_modules/typed-function/typed-function.js
  var require_typed_function = __commonJS((exports2, module2) => {
    "use strict";
    (function(root, factory2) {
      if (typeof define === "function" && define.amd) {
        define([], factory2);
      } else if (typeof exports2 === "object") {
        module2.exports = factory2();
      } else {
        root.typed = factory2();
      }
    })(exports2, function() {
      function ok() {
        return true;
      }
      function notOk() {
        return false;
      }
      function undef() {
        return void 0;
      }
      function create2() {
        var _types = [
          {name: "number", test: function(x) {
            return typeof x === "number";
          }},
          {name: "string", test: function(x) {
            return typeof x === "string";
          }},
          {name: "boolean", test: function(x) {
            return typeof x === "boolean";
          }},
          {name: "Function", test: function(x) {
            return typeof x === "function";
          }},
          {name: "Array", test: Array.isArray},
          {name: "Date", test: function(x) {
            return x instanceof Date;
          }},
          {name: "RegExp", test: function(x) {
            return x instanceof RegExp;
          }},
          {name: "Object", test: function(x) {
            return typeof x === "object" && x !== null && x.constructor === Object;
          }},
          {name: "null", test: function(x) {
            return x === null;
          }},
          {name: "undefined", test: function(x) {
            return x === void 0;
          }}
        ];
        var anyType = {
          name: "any",
          test: ok
        };
        var _ignore = [];
        var _conversions = [];
        var typed = {
          types: _types,
          conversions: _conversions,
          ignore: _ignore
        };
        function findTypeByName(typeName) {
          var entry = findInArray(typed.types, function(entry2) {
            return entry2.name === typeName;
          });
          if (entry) {
            return entry;
          }
          if (typeName === "any") {
            return anyType;
          }
          var hint = findInArray(typed.types, function(entry2) {
            return entry2.name.toLowerCase() === typeName.toLowerCase();
          });
          throw new TypeError('Unknown type "' + typeName + '"' + (hint ? '. Did you mean "' + hint.name + '"?' : ""));
        }
        function findTypeIndex(type) {
          if (type === anyType) {
            return 999;
          }
          return typed.types.indexOf(type);
        }
        function findTypeName(value) {
          var entry = findInArray(typed.types, function(entry2) {
            return entry2.test(value);
          });
          if (entry) {
            return entry.name;
          }
          throw new TypeError("Value has unknown type. Value: " + value);
        }
        function find(fn, signature) {
          if (!fn.signatures) {
            throw new TypeError("Function is no typed-function");
          }
          var arr;
          if (typeof signature === "string") {
            arr = signature.split(",");
            for (var i = 0; i < arr.length; i++) {
              arr[i] = arr[i].trim();
            }
          } else if (Array.isArray(signature)) {
            arr = signature;
          } else {
            throw new TypeError("String array or a comma separated string expected");
          }
          var str = arr.join(",");
          var match = fn.signatures[str];
          if (match) {
            return match;
          }
          throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + arr.join(", ") + "))");
        }
        function convert(value, type) {
          var from = findTypeName(value);
          if (type === from) {
            return value;
          }
          for (var i = 0; i < typed.conversions.length; i++) {
            var conversion = typed.conversions[i];
            if (conversion.from === from && conversion.to === type) {
              return conversion.convert(value);
            }
          }
          throw new Error("Cannot convert from " + from + " to " + type);
        }
        function stringifyParams(params) {
          return params.map(function(param) {
            var typeNames = param.types.map(getTypeName);
            return (param.restParam ? "..." : "") + typeNames.join("|");
          }).join(",");
        }
        function parseParam(param, conversions) {
          var restParam = param.indexOf("...") === 0;
          var types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
          var typeNames = types.split("|").map(trim).filter(notEmpty).filter(notIgnore);
          var matchingConversions = filterConversions(conversions, typeNames);
          var exactTypes = typeNames.map(function(typeName) {
            var type = findTypeByName(typeName);
            return {
              name: typeName,
              typeIndex: findTypeIndex(type),
              test: type.test,
              conversion: null,
              conversionIndex: -1
            };
          });
          var convertibleTypes = matchingConversions.map(function(conversion) {
            var type = findTypeByName(conversion.from);
            return {
              name: conversion.from,
              typeIndex: findTypeIndex(type),
              test: type.test,
              conversion,
              conversionIndex: conversions.indexOf(conversion)
            };
          });
          return {
            types: exactTypes.concat(convertibleTypes),
            restParam
          };
        }
        function parseSignature(signature, fn, conversions) {
          var params = [];
          if (signature.trim() !== "") {
            params = signature.split(",").map(trim).map(function(param, index, array) {
              var parsedParam = parseParam(param, conversions);
              if (parsedParam.restParam && index !== array.length - 1) {
                throw new SyntaxError('Unexpected rest parameter "' + param + '": only allowed for the last parameter');
              }
              return parsedParam;
            });
          }
          if (params.some(isInvalidParam)) {
            return null;
          }
          return {
            params,
            fn
          };
        }
        function hasRestParam(params) {
          var param = last(params);
          return param ? param.restParam : false;
        }
        function hasConversions(param) {
          return param.types.some(function(type) {
            return type.conversion != null;
          });
        }
        function compileTest(param) {
          if (!param || param.types.length === 0) {
            return ok;
          } else if (param.types.length === 1) {
            return findTypeByName(param.types[0].name).test;
          } else if (param.types.length === 2) {
            var test0 = findTypeByName(param.types[0].name).test;
            var test1 = findTypeByName(param.types[1].name).test;
            return function or(x) {
              return test0(x) || test1(x);
            };
          } else {
            var tests = param.types.map(function(type) {
              return findTypeByName(type.name).test;
            });
            return function or(x) {
              for (var i = 0; i < tests.length; i++) {
                if (tests[i](x)) {
                  return true;
                }
              }
              return false;
            };
          }
        }
        function compileTests(params) {
          var tests, test0, test1;
          if (hasRestParam(params)) {
            tests = initial(params).map(compileTest);
            var varIndex = tests.length;
            var lastTest = compileTest(last(params));
            var testRestParam = function(args) {
              for (var i = varIndex; i < args.length; i++) {
                if (!lastTest(args[i])) {
                  return false;
                }
              }
              return true;
            };
            return function testArgs(args) {
              for (var i = 0; i < tests.length; i++) {
                if (!tests[i](args[i])) {
                  return false;
                }
              }
              return testRestParam(args) && args.length >= varIndex + 1;
            };
          } else {
            if (params.length === 0) {
              return function testArgs(args) {
                return args.length === 0;
              };
            } else if (params.length === 1) {
              test0 = compileTest(params[0]);
              return function testArgs(args) {
                return test0(args[0]) && args.length === 1;
              };
            } else if (params.length === 2) {
              test0 = compileTest(params[0]);
              test1 = compileTest(params[1]);
              return function testArgs(args) {
                return test0(args[0]) && test1(args[1]) && args.length === 2;
              };
            } else {
              tests = params.map(compileTest);
              return function testArgs(args) {
                for (var i = 0; i < tests.length; i++) {
                  if (!tests[i](args[i])) {
                    return false;
                  }
                }
                return args.length === tests.length;
              };
            }
          }
        }
        function getParamAtIndex(signature, index) {
          return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;
        }
        function getExpectedTypeNames(signature, index, excludeConversions) {
          var param = getParamAtIndex(signature, index);
          var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];
          return types.map(getTypeName);
        }
        function getTypeName(type) {
          return type.name;
        }
        function isExactType(type) {
          return type.conversion === null || type.conversion === void 0;
        }
        function mergeExpectedParams(signatures, index) {
          var typeNames = uniq(flatMap(signatures, function(signature) {
            return getExpectedTypeNames(signature, index, false);
          }));
          return typeNames.indexOf("any") !== -1 ? ["any"] : typeNames;
        }
        function createError(name284, args, signatures) {
          var err, expected;
          var _name = name284 || "unnamed";
          var matchingSignatures = signatures;
          var index;
          for (index = 0; index < args.length; index++) {
            var nextMatchingDefs = matchingSignatures.filter(function(signature) {
              var test = compileTest(getParamAtIndex(signature, index));
              return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);
            });
            if (nextMatchingDefs.length === 0) {
              expected = mergeExpectedParams(matchingSignatures, index);
              if (expected.length > 0) {
                var actualType = findTypeName(args[index]);
                err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualType + ", index: " + index + ")");
                err.data = {
                  category: "wrongType",
                  fn: _name,
                  index,
                  actual: actualType,
                  expected
                };
                return err;
              }
            } else {
              matchingSignatures = nextMatchingDefs;
            }
          }
          var lengths = matchingSignatures.map(function(signature) {
            return hasRestParam(signature.params) ? Infinity : signature.params.length;
          });
          if (args.length < Math.min.apply(null, lengths)) {
            expected = mergeExpectedParams(matchingSignatures, index);
            err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
            err.data = {
              category: "tooFewArgs",
              fn: _name,
              index: args.length,
              expected
            };
            return err;
          }
          var maxLength = Math.max.apply(null, lengths);
          if (args.length > maxLength) {
            err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
            err.data = {
              category: "tooManyArgs",
              fn: _name,
              index: args.length,
              expectedLength: maxLength
            };
            return err;
          }
          err = new TypeError('Arguments of type "' + args.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
          err.data = {
            category: "mismatch",
            actual: args.map(findTypeName)
          };
          return err;
        }
        function getLowestTypeIndex(param) {
          var min = 999;
          for (var i = 0; i < param.types.length; i++) {
            if (isExactType(param.types[i])) {
              min = Math.min(min, param.types[i].typeIndex);
            }
          }
          return min;
        }
        function getLowestConversionIndex(param) {
          var min = 999;
          for (var i = 0; i < param.types.length; i++) {
            if (!isExactType(param.types[i])) {
              min = Math.min(min, param.types[i].conversionIndex);
            }
          }
          return min;
        }
        function compareParams(param1, param2) {
          var c;
          c = param1.restParam - param2.restParam;
          if (c !== 0) {
            return c;
          }
          c = hasConversions(param1) - hasConversions(param2);
          if (c !== 0) {
            return c;
          }
          c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
          if (c !== 0) {
            return c;
          }
          return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
        }
        function compareSignatures(signature1, signature2) {
          var len = Math.min(signature1.params.length, signature2.params.length);
          var i;
          var c;
          c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
          if (c !== 0) {
            return c;
          }
          for (i = 0; i < len; i++) {
            c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);
            if (c !== 0) {
              return c;
            }
          }
          for (i = 0; i < len; i++) {
            c = compareParams(signature1.params[i], signature2.params[i]);
            if (c !== 0) {
              return c;
            }
          }
          return signature1.params.length - signature2.params.length;
        }
        function filterConversions(conversions, typeNames) {
          var matches = {};
          conversions.forEach(function(conversion) {
            if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {
              matches[conversion.from] = conversion;
            }
          });
          return Object.keys(matches).map(function(from) {
            return matches[from];
          });
        }
        function compileArgsPreprocessing(params, fn) {
          var fnConvert = fn;
          if (params.some(hasConversions)) {
            var restParam = hasRestParam(params);
            var compiledConversions = params.map(compileArgConversion);
            fnConvert = function convertArgs() {
              var args = [];
              var last2 = restParam ? arguments.length - 1 : arguments.length;
              for (var i = 0; i < last2; i++) {
                args[i] = compiledConversions[i](arguments[i]);
              }
              if (restParam) {
                args[last2] = arguments[last2].map(compiledConversions[last2]);
              }
              return fn.apply(this, args);
            };
          }
          var fnPreprocess = fnConvert;
          if (hasRestParam(params)) {
            var offset = params.length - 1;
            fnPreprocess = function preprocessRestParams() {
              return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
            };
          }
          return fnPreprocess;
        }
        function compileArgConversion(param) {
          var test0, test1, conversion0, conversion1;
          var tests = [];
          var conversions = [];
          param.types.forEach(function(type) {
            if (type.conversion) {
              tests.push(findTypeByName(type.conversion.from).test);
              conversions.push(type.conversion.convert);
            }
          });
          switch (conversions.length) {
            case 0:
              return function convertArg(arg) {
                return arg;
              };
            case 1:
              test0 = tests[0];
              conversion0 = conversions[0];
              return function convertArg(arg) {
                if (test0(arg)) {
                  return conversion0(arg);
                }
                return arg;
              };
            case 2:
              test0 = tests[0];
              test1 = tests[1];
              conversion0 = conversions[0];
              conversion1 = conversions[1];
              return function convertArg(arg) {
                if (test0(arg)) {
                  return conversion0(arg);
                }
                if (test1(arg)) {
                  return conversion1(arg);
                }
                return arg;
              };
            default:
              return function convertArg(arg) {
                for (var i = 0; i < conversions.length; i++) {
                  if (tests[i](arg)) {
                    return conversions[i](arg);
                  }
                }
                return arg;
              };
          }
        }
        function createSignaturesMap(signatures) {
          var signaturesMap = {};
          signatures.forEach(function(signature) {
            if (!signature.params.some(hasConversions)) {
              splitParams(signature.params, true).forEach(function(params) {
                signaturesMap[stringifyParams(params)] = signature.fn;
              });
            }
          });
          return signaturesMap;
        }
        function splitParams(params, ignoreConversionTypes) {
          function _splitParams(params2, index, types) {
            if (index < params2.length) {
              var param = params2[index];
              var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;
              var typeGroups;
              if (param.restParam) {
                var exactTypes = filteredTypes.filter(isExactType);
                typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];
              } else {
                typeGroups = filteredTypes.map(function(type) {
                  return [type];
                });
              }
              return flatMap(typeGroups, function(typeGroup) {
                return _splitParams(params2, index + 1, types.concat([typeGroup]));
              });
            } else {
              var splittedParams = types.map(function(type, typeIndex) {
                return {
                  types: type,
                  restParam: typeIndex === params2.length - 1 && hasRestParam(params2)
                };
              });
              return [splittedParams];
            }
          }
          return _splitParams(params, 0, []);
        }
        function hasConflictingParams(signature1, signature2) {
          var ii = Math.max(signature1.params.length, signature2.params.length);
          for (var i = 0; i < ii; i++) {
            var typesNames1 = getExpectedTypeNames(signature1, i, true);
            var typesNames2 = getExpectedTypeNames(signature2, i, true);
            if (!hasOverlap(typesNames1, typesNames2)) {
              return false;
            }
          }
          var len1 = signature1.params.length;
          var len2 = signature2.params.length;
          var restParam1 = hasRestParam(signature1.params);
          var restParam2 = hasRestParam(signature2.params);
          return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
        }
        function createTypedFunction(name284, signaturesMap) {
          if (Object.keys(signaturesMap).length === 0) {
            throw new SyntaxError("No signatures provided");
          }
          var parsedSignatures = [];
          Object.keys(signaturesMap).map(function(signature) {
            return parseSignature(signature, signaturesMap[signature], typed.conversions);
          }).filter(notNull).forEach(function(parsedSignature) {
            var conflictingSignature = findInArray(parsedSignatures, function(s) {
              return hasConflictingParams(s, parsedSignature);
            });
            if (conflictingSignature) {
              throw new TypeError('Conflicting signatures "' + stringifyParams(conflictingSignature.params) + '" and "' + stringifyParams(parsedSignature.params) + '".');
            }
            parsedSignatures.push(parsedSignature);
          });
          var signatures = flatMap(parsedSignatures, function(parsedSignature) {
            var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];
            return params.map(function(params2) {
              return {
                params: params2,
                fn: parsedSignature.fn
              };
            });
          }).filter(notNull);
          signatures.sort(compareSignatures);
          var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
          var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
          var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
          var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
          var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
          var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
          var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
          var tests = signatures.map(function(signature) {
            return compileTests(signature.params);
          });
          var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
          var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
          var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
          var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
          var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
          var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
          var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
          var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
          var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
          var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
          var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
          var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
          var fns = signatures.map(function(signature) {
            return compileArgsPreprocessing(signature.params, signature.fn);
          });
          var fn0 = ok0 ? fns[0] : undef;
          var fn1 = ok1 ? fns[1] : undef;
          var fn2 = ok2 ? fns[2] : undef;
          var fn3 = ok3 ? fns[3] : undef;
          var fn4 = ok4 ? fns[4] : undef;
          var fn5 = ok5 ? fns[5] : undef;
          var len0 = ok0 ? signatures[0].params.length : -1;
          var len1 = ok1 ? signatures[1].params.length : -1;
          var len2 = ok2 ? signatures[2].params.length : -1;
          var len3 = ok3 ? signatures[3].params.length : -1;
          var len4 = ok4 ? signatures[4].params.length : -1;
          var len5 = ok5 ? signatures[5].params.length : -1;
          var iStart = allOk ? 6 : 0;
          var iEnd = signatures.length;
          var generic = function generic2() {
            "use strict";
            for (var i = iStart; i < iEnd; i++) {
              if (tests[i](arguments)) {
                return fns[i].apply(this, arguments);
              }
            }
            throw createError(name284, arguments, signatures);
          };
          var fn = function fn6(arg0, arg1) {
            "use strict";
            if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
              return fn0.apply(fn6, arguments);
            }
            if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
              return fn1.apply(fn6, arguments);
            }
            if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
              return fn2.apply(fn6, arguments);
            }
            if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
              return fn3.apply(fn6, arguments);
            }
            if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
              return fn4.apply(fn6, arguments);
            }
            if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
              return fn5.apply(fn6, arguments);
            }
            return generic.apply(fn6, arguments);
          };
          try {
            Object.defineProperty(fn, "name", {value: name284});
          } catch (err) {
          }
          fn.signatures = createSignaturesMap(signatures);
          return fn;
        }
        function notIgnore(typeName) {
          return typed.ignore.indexOf(typeName) === -1;
        }
        function trim(str) {
          return str.trim();
        }
        function notEmpty(str) {
          return !!str;
        }
        function notNull(value) {
          return value !== null;
        }
        function isInvalidParam(param) {
          return param.types.length === 0;
        }
        function initial(arr) {
          return arr.slice(0, arr.length - 1);
        }
        function last(arr) {
          return arr[arr.length - 1];
        }
        function slice(arr, start, end) {
          return Array.prototype.slice.call(arr, start, end);
        }
        function contains3(array, item) {
          return array.indexOf(item) !== -1;
        }
        function hasOverlap(array1, array2) {
          for (var i = 0; i < array1.length; i++) {
            if (contains3(array2, array1[i])) {
              return true;
            }
          }
          return false;
        }
        function findInArray(arr, test) {
          for (var i = 0; i < arr.length; i++) {
            if (test(arr[i])) {
              return arr[i];
            }
          }
          return void 0;
        }
        function uniq(arr) {
          var entries = {};
          for (var i = 0; i < arr.length; i++) {
            entries[arr[i]] = true;
          }
          return Object.keys(entries);
        }
        function flatMap(arr, callback) {
          return Array.prototype.concat.apply([], arr.map(callback));
        }
        function getName(fns) {
          var name284 = "";
          for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];
            if ((typeof fn.signatures === "object" || typeof fn.signature === "string") && fn.name !== "") {
              if (name284 === "") {
                name284 = fn.name;
              } else if (name284 !== fn.name) {
                var err = new Error("Function names do not match (expected: " + name284 + ", actual: " + fn.name + ")");
                err.data = {
                  actual: fn.name,
                  expected: name284
                };
                throw err;
              }
            }
          }
          return name284;
        }
        function extractSignatures(fns) {
          var err;
          var signaturesMap = {};
          function validateUnique(_signature, _fn) {
            if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
              err = new Error('Signature "' + _signature + '" is defined twice');
              err.data = {signature: _signature};
              throw err;
            }
          }
          for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];
            if (typeof fn.signatures === "object") {
              for (var signature in fn.signatures) {
                if (fn.signatures.hasOwnProperty(signature)) {
                  validateUnique(signature, fn.signatures[signature]);
                  signaturesMap[signature] = fn.signatures[signature];
                }
              }
            } else if (typeof fn.signature === "string") {
              validateUnique(fn.signature, fn);
              signaturesMap[fn.signature] = fn;
            } else {
              err = new TypeError("Function is no typed-function (index: " + i + ")");
              err.data = {index: i};
              throw err;
            }
          }
          return signaturesMap;
        }
        typed = createTypedFunction("typed", {
          "string, Object": createTypedFunction,
          Object: function(signaturesMap) {
            var fns = [];
            for (var signature in signaturesMap) {
              if (signaturesMap.hasOwnProperty(signature)) {
                fns.push(signaturesMap[signature]);
              }
            }
            var name284 = getName(fns);
            return createTypedFunction(name284, signaturesMap);
          },
          "...Function": function(fns) {
            return createTypedFunction(getName(fns), extractSignatures(fns));
          },
          "string, ...Function": function(name284, fns) {
            return createTypedFunction(name284, extractSignatures(fns));
          }
        });
        typed.create = create2;
        typed.types = _types;
        typed.conversions = _conversions;
        typed.ignore = _ignore;
        typed.convert = convert;
        typed.find = find;
        typed.addType = function(type, beforeObjectTest) {
          if (!type || typeof type.name !== "string" || typeof type.test !== "function") {
            throw new TypeError("Object with properties {name: string, test: function} expected");
          }
          if (beforeObjectTest !== false) {
            for (var i = 0; i < typed.types.length; i++) {
              if (typed.types[i].name === "Object") {
                typed.types.splice(i, 0, type);
                return;
              }
            }
          }
          typed.types.push(type);
        };
        typed.addConversion = function(conversion) {
          if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
            throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
          }
          typed.conversions.push(conversion);
        };
        return typed;
      }
      return create2();
    });
  });

  // node_modules/decimal.js/decimal.js
  var require_decimal = __commonJS((exports2, module2) => {
    (function(globalScope) {
      "use strict";
      var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
        precision: 20,
        rounding: 4,
        modulo: 1,
        toExpNeg: -7,
        toExpPos: 21,
        minE: -EXP_LIMIT,
        maxE: EXP_LIMIT,
        crypto: false
      }, Decimal4, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P2 = {name: "[object Decimal]"};
      P2.absoluteValue = P2.abs = function() {
        var x = new this.constructor(this);
        if (x.s < 0)
          x.s = 1;
        return finalise(x);
      };
      P2.ceil = function() {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };
      P2.comparedTo = P2.cmp = function(y) {
        var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0])
          return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys)
          return xs;
        if (x.e !== y.e)
          return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i])
            return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P2.cosine = P2.cos = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.d)
          return new Ctor(NaN);
        if (!x.d[0])
          return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
      };
      P2.cubeRoot = P2.cbrt = function() {
        var e2, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        external = false;
        s = x.s * mathpow(x.s * x, 1 / 3);
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString(x.d);
          e2 = x.e;
          if (s = (e2 - n.length + 1) % 3)
            n += s == 1 || s == -2 ? "0" : "00";
          s = mathpow(n, 1 / 3);
          e2 = mathfloor((e2 + 1) / 3) - (e2 % 3 == (e2 < 0 ? -1 : 2));
          if (s == 1 / 0) {
            n = "5e" + e2;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e2;
          }
          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e2 = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e2 + 1, 0);
                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e2 + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e2, Ctor.rounding, m);
      };
      P2.decimalPlaces = P2.dp = function() {
        var w, d = this.d, n = NaN;
        if (d) {
          w = d.length - 1;
          n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
          w = d[w];
          if (w)
            for (; w % 10 == 0; w /= 10)
              n--;
          if (n < 0)
            n = 0;
        }
        return n;
      };
      P2.dividedBy = P2.div = function(y) {
        return divide(this, new this.constructor(y));
      };
      P2.dividedToIntegerBy = P2.divToInt = function(y) {
        var x = this, Ctor = x.constructor;
        return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P2.equals = P2.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P2.floor = function() {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };
      P2.greaterThan = P2.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P2.greaterThanOrEqualTo = P2.gte = function(y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      P2.hyperbolicCosine = P2.cosh = function() {
        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
        if (!x.isFinite())
          return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero())
          return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          n = "2.3283064365386962890625e-10";
        }
        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
        var cosh2_x, i = k, d8 = new Ctor(8);
        for (; i--; ) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P2.hyperbolicSine = P2.sinh = function() {
        var k, pr, rm, len, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 3) {
          x = taylorSeries(Ctor, 2, x, x, true);
        } else {
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow(5, k));
          x = taylorSeries(Ctor, 2, x, x, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(x, pr, rm, true);
      };
      P2.hyperbolicTangent = P2.tanh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(x.s);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P2.inverseCosine = P2.acos = function() {
        var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k !== -1) {
          return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x.isZero())
          return getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.asin();
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return halfPi.minus(x);
      };
      P2.inverseHyperbolicCosine = P2.acosh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (x.lte(1))
          return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P2.inverseHyperbolicSine = P2.asinh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P2.inverseHyperbolicTangent = P2.atanh = function() {
        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.e >= 0)
          return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1)
          return finalise(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      P2.inverseSine = P2.asin = function() {
        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
        if (x.isZero())
          return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k !== -1) {
          if (k === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P2.inverseTangent = P2.atan = function() {
        var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x.isFinite()) {
          if (!x.s)
            return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k = Math.min(28, wpr / LOG_BASE + 2 | 0);
        for (i = k; i; --i)
          x = x.div(x.times(x).plus(1).sqrt().plus(1));
        external = false;
        j = Math.ceil(wpr / LOG_BASE);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;
        for (; i !== -1; ) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0)
            for (i = j; r.d[i] === t.d[i] && i--; )
              ;
        }
        if (k)
          r = r.times(2 << k - 1);
        external = true;
        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P2.isFinite = function() {
        return !!this.d;
      };
      P2.isInteger = P2.isInt = function() {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };
      P2.isNaN = function() {
        return !this.s;
      };
      P2.isNegative = P2.isNeg = function() {
        return this.s < 0;
      };
      P2.isPositive = P2.isPos = function() {
        return this.s > 0;
      };
      P2.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P2.lessThan = P2.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P2.lessThanOrEqualTo = P2.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P2.logarithm = P2.log = function(base) {
        var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;
          if (base.s < 0 || !d || !d[0] || base.eq(1))
            return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d = arg.d;
        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0; )
              k /= 10;
            inf = k !== 1;
          }
        }
        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (checkRoundingDigits(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm(arg, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r = divide(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits(r.d, k += 10, rm));
        }
        external = true;
        return finalise(r, pr, rm);
      };
      P2.minus = P2.sub = function(y) {
        var d, e2, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s)
            y = new Ctor(NaN);
          else if (x.d)
            y.s = -y.s;
          else
            y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0])
            y.s = -y.s;
          else if (xd[0])
            y = new Ctor(x);
          else
            return new Ctor(rm === 3 ? -0 : 0);
          return external ? finalise(y, pr, rm) : y;
        }
        e2 = mathfloor(y.e / LOG_BASE);
        xe = mathfloor(x.e / LOG_BASE);
        xd = xd.slice();
        k = xe - e2;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e2 = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; )
            d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy)
            len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i)
          xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; )
              xd[j] = BASE - 1;
            --xd[j];
            xd[i] += BASE;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; )
          xd.pop();
        for (; xd[0] === 0; xd.shift())
          --e2;
        if (!xd[0])
          return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent(xd, e2);
        return external ? finalise(y, pr, rm) : y;
      };
      P2.modulo = P2.mod = function(y) {
        var q, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.s || y.d && !y.d[0])
          return new Ctor(NaN);
        if (!y.d || x.d && !x.d[0]) {
          return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
        }
        external = false;
        if (Ctor.modulo == 9) {
          q = divide(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide(x, y, 0, Ctor.modulo, 1);
        }
        q = q.times(y);
        external = true;
        return x.minus(q);
      };
      P2.naturalExponential = P2.exp = function() {
        return naturalExponential(this);
      };
      P2.naturalLogarithm = P2.ln = function() {
        return naturalLogarithm(this);
      };
      P2.negated = P2.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise(x);
      };
      P2.plus = P2.add = function(y) {
        var carry, d, e2, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s)
            y = new Ctor(NaN);
          else if (!x.d)
            y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0])
            y = new Ctor(x);
          return external ? finalise(y, pr, rm) : y;
        }
        k = mathfloor(x.e / LOG_BASE);
        e2 = mathfloor(y.e / LOG_BASE);
        xd = xd.slice();
        i = k - e2;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e2 = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; )
            d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
          xd[i] %= BASE;
        }
        if (carry) {
          xd.unshift(carry);
          ++e2;
        }
        for (len = xd.length; xd[--len] == 0; )
          xd.pop();
        y.d = xd;
        y.e = getBase10Exponent(xd, e2);
        return external ? finalise(y, pr, rm) : y;
      };
      P2.precision = P2.sd = function(z) {
        var k, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
          throw Error(invalidArgument + z);
        if (x.d) {
          k = getPrecision(x.d);
          if (z && x.e + 1 > k)
            k = x.e + 1;
        } else {
          k = NaN;
        }
        return k;
      };
      P2.round = function() {
        var x = this, Ctor = x.constructor;
        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      P2.sine = P2.sin = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = sine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
      };
      P2.squareRoot = P2.sqrt = function() {
        var m, n, sd, r, rep, t, x = this, d = x.d, e2 = x.e, s = x.s, Ctor = x.constructor;
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }
        external = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString(d);
          if ((n.length + e2) % 2 == 0)
            n += "0";
          s = Math.sqrt(n);
          e2 = mathfloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
          if (s == 1 / 0) {
            n = "5e" + e2;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e2;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e2 = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e2 + 1, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e2 + 1, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e2, Ctor.rounding, m);
      };
      P2.tangent = P2.tan = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
      };
      P2.times = P2.mul = function(y) {
        var carry, e2, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        y.s *= x.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
        }
        e2 = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; )
          r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }
          r[k] = (r[k] + carry) % BASE | 0;
        }
        for (; !r[--rL]; )
          r.pop();
        if (carry)
          ++e2;
        else
          r.shift();
        y.d = r;
        y.e = getBase10Exponent(r, e2);
        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
      };
      P2.toBinary = function(sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };
      P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0)
          return x;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        return finalise(x, dp + x.e + 1, rm);
      };
      P2.toExponential = function(dp, rm) {
        var str, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), dp + 1, rm);
          str = finiteToString(x, true, dp + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toFixed = function(dp, rm) {
        var str, y, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          y = finalise(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString(y, false, dp + y.e + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toFraction = function(maxD) {
        var d, d0, d1, d2, e2, k, n, n0, n16, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
        if (!xd)
          return new Ctor(x);
        n16 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e2 = d.e = getPrecision(xd) - x.e - 1;
        k = e2 % LOG_BASE;
        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
        if (maxD == null) {
          maxD = e2 > 0 ? d : n16;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n16))
            throw Error(invalidArgument + n);
          maxD = n.gt(d) ? e2 > 0 ? d : n16 : n;
        }
        external = false;
        n = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e2 = xd.length * LOG_BASE * 2;
        for (; ; ) {
          q = divide(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1)
            break;
          d0 = d1;
          d1 = d2;
          d2 = n16;
          n16 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }
        d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n16));
        d0 = d0.plus(d2.times(d1));
        n0.s = n16.s = x.s;
        r = divide(n16, d1, e2, 1).minus(x).abs().cmp(divide(n0, d0, e2, 1).minus(x).abs()) < 1 ? [n16, d1] : [n0, d0];
        Ctor.precision = pr;
        external = true;
        return r;
      };
      P2.toHexadecimal = P2.toHex = function(sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };
      P2.toNearest = function(y, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (y == null) {
          if (!x.d)
            return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          }
          if (!x.d)
            return y.s ? x : y;
          if (!y.d) {
            if (y.s)
              y.s = x.s;
            return y;
          }
        }
        if (y.d[0]) {
          external = false;
          x = divide(x, y, 0, rm, 1).times(y);
          external = true;
          finalise(x);
        } else {
          y.s = x.s;
          x = y;
        }
        return x;
      };
      P2.toNumber = function() {
        return +this;
      };
      P2.toOctal = function(sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };
      P2.toPower = P2.pow = function(y) {
        var e2, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
        if (!x.d || !y.d || !x.d[0] || !y.d[0])
          return new Ctor(mathpow(+x, yn));
        x = new Ctor(x);
        if (x.eq(1))
          return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1))
          return finalise(x, pr, rm);
        e2 = mathfloor(y.e / LOG_BASE);
        if (e2 >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = intPow(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
        }
        s = x.s;
        if (s < 0) {
          if (e2 < y.d.length - 1)
            return new Ctor(NaN);
          if ((y.d[e2] & 1) == 0)
            s = 1;
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }
        k = mathpow(+x, yn);
        e2 = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
        if (e2 > Ctor.maxE + 1 || e2 < Ctor.minE - 1)
          return new Ctor(e2 > 0 ? s / 0 : 0);
        external = false;
        Ctor.rounding = x.s = 1;
        k = Math.min(12, (e2 + "").length);
        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
        if (r.d) {
          r = finalise(r, pr + 5, 1);
          if (checkRoundingDigits(r.d, pr, rm)) {
            e2 = pr + 10;
            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e2 + k)), e2), e2 + 5, 1);
            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
          }
        }
        r.s = s;
        external = true;
        Ctor.rounding = rm;
        return finalise(r, pr, rm);
      };
      P2.toPrecision = function(sd, rm) {
        var str, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), sd, rm);
          str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toSignificantDigits = P2.toSD = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
        }
        return finalise(new Ctor(x), sd, rm);
      };
      P2.toString = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.truncated = P2.trunc = function() {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };
      P2.valueOf = P2.toJSON = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? "-" + str : str;
      };
      function digitsToString(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
        if (indexOfLastWord > 0) {
          str += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE - ws.length;
            if (k)
              str += getZeroString(k);
            str += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE - ws.length;
          if (k)
            str += getZeroString(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; )
          w /= 10;
        return str + w;
      }
      function checkInt32(i, min2, max2) {
        if (i !== ~~i || i < min2 || i > max2) {
          throw Error(invalidArgument + i);
        }
      }
      function checkRoundingDigits(d, i, rm, repeating) {
        var di, k, r, rd;
        for (k = d[0]; k >= 10; k /= 10)
          --i;
        if (--i < 0) {
          i += LOG_BASE;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE);
          i %= LOG_BASE;
        }
        k = mathpow(10, LOG_BASE - i);
        rd = d[di] % k | 0;
        if (repeating == null) {
          if (i < 3) {
            if (i == 0)
              rd = rd / 100 | 0;
            else if (i == 1)
              rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0)
              rd = rd / 1e3 | 0;
            else if (i == 1)
              rd = rd / 100 | 0;
            else if (i == 2)
              rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
          }
        }
        return r;
      }
      function convertBase(str, baseIn, baseOut) {
        var j, arr = [0], arrL, i = 0, strL = str.length;
        for (; i < strL; ) {
          for (arrL = arr.length; arrL--; )
            arr[arrL] *= baseIn;
          arr[0] += NUMERALS.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0)
                arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function cosine(Ctor, x) {
        var k, y, len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          y = "2.3283064365386962890625e-10";
        }
        Ctor.precision += k;
        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
        for (var i = k; i--; ) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }
        Ctor.precision -= k;
        return x;
      }
      var divide = function() {
        function multiplyInteger(x, k, base) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry)
            x.unshift(carry);
          return x;
        }
        function compare(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; )
            a.shift();
        }
        return function(x, y, pr, rm, dp, base) {
          var cmp, e2, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign3 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0);
          }
          if (base) {
            logBase = 1;
            e2 = x.e - y.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e2 = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign3);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); i++)
            ;
          if (yd[i] > (xd[i] || 0))
            e2--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i = 0;
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;
              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }
              more = k || i < xL;
            } else {
              k = base / (yd[0] + 1) | 0;
              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; )
                rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2)
                ++yd0;
              do {
                k = 0;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  k = rem0 / yd0 | 0;
                  if (k > 1) {
                    if (k >= base)
                      k = base - 1;
                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length;
                    cmp = compare(prod, rem, prodL, remL);
                    if (cmp == 1) {
                      k--;
                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k == 0)
                      cmp = k = 1;
                    prod = yd.slice();
                  }
                  prodL = prod.length;
                  if (prodL < remL)
                    prod.unshift(0);
                  subtract(rem, prod, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k++;
                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }
                qd[i++] = k;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0])
              qd.shift();
          }
          if (logBase == 1) {
            q.e = e2;
            inexact = more;
          } else {
            for (i = 1, k = qd[0]; k >= 10; k /= 10)
              i++;
            q.e = i + e2 * logBase - 1;
            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
          }
          return q;
        };
      }();
      function finalise(x, sd, rm, isTruncated) {
        var digits2, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
        out:
          if (sd != null) {
            xd = x.d;
            if (!xd)
              return x;
            for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
              digits2++;
            i = sd - digits2;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              w = xd[xdi = 0];
              rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
            } else {
              xdi = Math.ceil((i + 1) / LOG_BASE);
              k = xd.length;
              if (xdi >= k) {
                if (isTruncated) {
                  for (; k++ <= xdi; )
                    xd.push(0);
                  w = rd = 0;
                  digits2 = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                w = k = xd[xdi];
                for (digits2 = 1; k >= 10; k /= 10)
                  digits2++;
                i %= LOG_BASE;
                j = i - LOG_BASE + digits2;
                rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
              }
            }
            isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
            roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xd[0]) {
              xd.length = 0;
              if (roundUp) {
                sd -= x.e + 1;
                xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
                x.e = -sd || 0;
              } else {
                xd[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xd.length = xdi;
              k = 1;
              xdi--;
            } else {
              xd.length = xdi + 1;
              k = mathpow(10, LOG_BASE - i);
              xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
            }
            if (roundUp) {
              for (; ; ) {
                if (xdi == 0) {
                  for (i = 1, j = xd[0]; j >= 10; j /= 10)
                    i++;
                  j = xd[0] += k;
                  for (k = 1; j >= 10; j /= 10)
                    k++;
                  if (i != k) {
                    x.e++;
                    if (xd[0] == BASE)
                      xd[0] = 1;
                  }
                  break;
                } else {
                  xd[xdi] += k;
                  if (xd[xdi] != BASE)
                    break;
                  xd[xdi--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xd.length; xd[--i] === 0; )
              xd.pop();
          }
        if (external) {
          if (x.e > Ctor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < Ctor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
        return x;
      }
      function finiteToString(x, isExp, sd) {
        if (!x.isFinite())
          return nonFiniteToString(x);
        var k, e2 = x.e, str = digitsToString(x.d), len = str.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + "." + str.slice(1);
          }
          str = str + (x.e < 0 ? "e" : "e+") + x.e;
        } else if (e2 < 0) {
          str = "0." + getZeroString(-e2 - 1) + str;
          if (sd && (k = sd - len) > 0)
            str += getZeroString(k);
        } else if (e2 >= len) {
          str += getZeroString(e2 + 1 - len);
          if (sd && (k = sd - e2 - 1) > 0)
            str = str + "." + getZeroString(k);
        } else {
          if ((k = e2 + 1) < len)
            str = str.slice(0, k) + "." + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e2 + 1 === len)
              str += ".";
            str += getZeroString(k);
          }
        }
        return str;
      }
      function getBase10Exponent(digits2, e2) {
        var w = digits2[0];
        for (e2 *= LOG_BASE; w >= 10; w /= 10)
          e2++;
        return e2;
      }
      function getLn10(Ctor, sd, pr) {
        if (sd > LN10_PRECISION) {
          external = true;
          if (pr)
            Ctor.precision = pr;
          throw Error(precisionLimitExceeded);
        }
        return finalise(new Ctor(LN10), sd, 1, true);
      }
      function getPi(Ctor, sd, rm) {
        if (sd > PI_PRECISION)
          throw Error(precisionLimitExceeded);
        return finalise(new Ctor(PI), sd, rm, true);
      }
      function getPrecision(digits2) {
        var w = digits2.length - 1, len = w * LOG_BASE + 1;
        w = digits2[w];
        if (w) {
          for (; w % 10 == 0; w /= 10)
            len--;
          for (w = digits2[0]; w >= 10; w /= 10)
            len++;
        }
        return len;
      }
      function getZeroString(k) {
        var zs = "";
        for (; k--; )
          zs += "0";
        return zs;
      }
      function intPow(Ctor, x, n, pr) {
        var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
        external = false;
        for (; ; ) {
          if (n % 2) {
            r = r.times(x);
            if (truncate(r.d, k))
              isTruncated = true;
          }
          n = mathfloor(n / 2);
          if (n === 0) {
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0)
              ++r.d[n];
            break;
          }
          x = x.times(x);
          truncate(x.d, k);
        }
        external = true;
        return r;
      }
      function isOdd(n) {
        return n.d[n.d.length - 1] & 1;
      }
      function maxOrMin(Ctor, args, ltgt) {
        var y, x = new Ctor(args[0]), i = 0;
        for (; ++i < args.length; ) {
          y = new Ctor(args[i]);
          if (!y.s) {
            x = y;
            break;
          } else if (x[ltgt](y)) {
            x = y;
          }
        }
        return x;
      }
      function naturalExponential(x, sd) {
        var denominator, guard, j, pow2, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.e > -2) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow2 = sum = new Ctor(1);
        Ctor.precision = wpr;
        for (; ; ) {
          pow2 = finalise(pow2.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum.plus(divide(pow2, denominator, wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            j = k;
            while (j--)
              sum = finalise(sum.times(sum), wpr, 1);
            if (sd == null) {
              if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow2 = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise(sum, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum;
            }
          }
          sum = t;
        }
      }
      function naturalLogarithm(y, sd) {
        var c, c0, denominator, e2, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        Ctor.precision = wpr += guard;
        c = digitsToString(xd);
        c0 = c.charAt(0);
        if (Math.abs(e2 = x.e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e2 = x.e;
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e2++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn10(Ctor, wpr + 2, pr).times(e2 + "");
          x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise(x, pr, rm, external = true) : x;
        }
        x1 = x;
        sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise(x.times(x), wpr, 1);
        denominator = 3;
        for (; ; ) {
          numerator = finalise(numerator.times(x2), wpr, 1);
          t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            sum = sum.times(2);
            if (e2 !== 0)
              sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e2 + ""));
            sum = divide(sum, new Ctor(n), wpr, 1);
            if (sd == null) {
              if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise(sum, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum;
            }
          }
          sum = t;
          denominator += 2;
        }
      }
      function nonFiniteToString(x) {
        return String(x.s * x.s / 0);
      }
      function parseDecimal(x, str) {
        var e2, i, len;
        if ((e2 = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e2 < 0)
            e2 = i;
          e2 += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e2 < 0) {
          e2 = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
          ;
        str = str.slice(i, len);
        if (str) {
          len -= i;
          x.e = e2 = e2 - i - 1;
          x.d = [];
          i = (e2 + 1) % LOG_BASE;
          if (e2 < 0)
            i += LOG_BASE;
          if (i < len) {
            if (i)
              x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; )
              x.d.push(+str.slice(i, i += LOG_BASE));
            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }
          for (; i--; )
            str += "0";
          x.d.push(+str);
          if (external) {
            if (x.e > x.constructor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < x.constructor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
        } else {
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function parseOther(x, str) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
        if (str === "Infinity" || str === "NaN") {
          if (!+str)
            x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }
        if (isHex.test(str)) {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary.test(str)) {
          base = 2;
        } else if (isOctal.test(str)) {
          base = 8;
        } else {
          throw Error(invalidArgument + str);
        }
        i = str.search(/p/i);
        if (i > 0) {
          p = +str.slice(i + 1);
          str = str.substring(2, i);
        } else {
          str = str.slice(2);
        }
        i = str.indexOf(".");
        isFloat = i >= 0;
        Ctor = x.constructor;
        if (isFloat) {
          str = str.replace(".", "");
          len = str.length;
          i = len - i;
          divisor = intPow(Ctor, new Ctor(base), i, i * 2);
        }
        xd = convertBase(str, base, BASE);
        xe = xd.length - 1;
        for (i = xe; xd[i] === 0; --i)
          xd.pop();
        if (i < 0)
          return new Ctor(x.s * 0);
        x.e = getBase10Exponent(xd, xe);
        x.d = xd;
        external = false;
        if (isFloat)
          x = divide(x, divisor, len * 4);
        if (p)
          x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal4.pow(2, p));
        external = true;
        return x;
      }
      function sine(Ctor, x) {
        var k, len = x.d.length;
        if (len < 3)
          return taylorSeries(Ctor, 2, x, x);
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x);
        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }
        return x;
      }
      function taylorSeries(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
        external = false;
        x2 = x.times(x);
        u = new Ctor(y);
        for (; ; ) {
          t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);
          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--; )
              ;
            if (j == -1)
              break;
          }
          j = u;
          u = y;
          y = t;
          t = j;
          i++;
        }
        external = true;
        t.d.length = k + 1;
        return t;
      }
      function tinyPow(b, e2) {
        var n = b;
        while (--e2)
          n *= b;
        return n;
      }
      function toLessThanHalfPi(Ctor, x) {
        var t, isNeg = x.s < 0, pi2 = getPi(Ctor, Ctor.precision, 1), halfPi = pi2.times(0.5);
        x = x.abs();
        if (x.lte(halfPi)) {
          quadrant = isNeg ? 4 : 1;
          return x;
        }
        t = x.divToInt(pi2);
        if (t.isZero()) {
          quadrant = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi2));
          if (x.lte(halfPi)) {
            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }
          quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }
        return x.minus(pi2).abs();
      }
      function toStringBinary(x, baseOut, sd, rm) {
        var base, e2, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
        if (isExp) {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }
        if (!x.isFinite()) {
          str = nonFiniteToString(x);
        } else {
          str = finiteToString(x);
          i = str.indexOf(".");
          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }
          if (i >= 0) {
            str = str.replace(".", "");
            y = new Ctor(1);
            y.e = str.length - i;
            y.d = convertBase(finiteToString(y), 10, base);
            y.e = y.d.length;
          }
          xd = convertBase(str, 10, base);
          e2 = len = xd.length;
          for (; xd[--len] == 0; )
            xd.pop();
          if (!xd[0]) {
            str = isExp ? "0p+0" : "0";
          } else {
            if (i < 0) {
              e2--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e2;
              x = divide(x, y, sd, rm, 0, base);
              xd = x.d;
              e2 = x.e;
              roundUp = inexact;
            }
            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;
            if (roundUp) {
              for (; ++xd[--sd] > base - 1; ) {
                xd[sd] = 0;
                if (!sd) {
                  ++e2;
                  xd.unshift(1);
                }
              }
            }
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 0, str = ""; i < len; i++)
              str += NUMERALS.charAt(xd[i]);
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;
                  for (--len; len % i; len++)
                    str += "0";
                  xd = convertBase(str, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len)
                    ;
                  for (i = 1, str = "1."; i < len; i++)
                    str += NUMERALS.charAt(xd[i]);
                } else {
                  str = str.charAt(0) + "." + str.slice(1);
                }
              }
              str = str + (e2 < 0 ? "p" : "p+") + e2;
            } else if (e2 < 0) {
              for (; ++e2; )
                str = "0" + str;
              str = "0." + str;
            } else {
              if (++e2 > len)
                for (e2 -= len; e2--; )
                  str += "0";
              else if (e2 < len)
                str = str.slice(0, e2) + "." + str.slice(e2);
            }
          }
          str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
        }
        return x.s < 0 ? "-" + str : str;
      }
      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function abs(x) {
        return new this(x).abs();
      }
      function acos(x) {
        return new this(x).acos();
      }
      function acosh2(x) {
        return new this(x).acosh();
      }
      function add(x, y) {
        return new this(x).plus(y);
      }
      function asin(x) {
        return new this(x).asin();
      }
      function asinh2(x) {
        return new this(x).asinh();
      }
      function atan(x) {
        return new this(x).atan();
      }
      function atanh2(x) {
        return new this(x).atanh();
      }
      function atan2(y, x) {
        y = new this(y);
        x = new this(x);
        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
        if (!y.s || !x.s) {
          r = new this(NaN);
        } else if (!y.d && !x.d) {
          r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
          r.s = y.s;
        } else if (!y.d || x.isZero()) {
          r = getPi(this, wpr, 1).times(0.5);
          r.s = y.s;
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide(y, x, wpr, 1));
          x = getPi(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide(y, x, wpr, 1));
        }
        return r;
      }
      function cbrt3(x) {
        return new this(x).cbrt();
      }
      function ceil(x) {
        return finalise(x = new this(x), x.e + 1, 2);
      }
      function config(obj) {
        if (!obj || typeof obj !== "object")
          throw Error(decimalError + "Object expected");
        var i, p, v, useDefaults = obj.defaults === true, ps = [
          "precision",
          1,
          MAX_DIGITS,
          "rounding",
          0,
          8,
          "toExpNeg",
          -EXP_LIMIT,
          0,
          "toExpPos",
          0,
          EXP_LIMIT,
          "maxE",
          0,
          EXP_LIMIT,
          "minE",
          -EXP_LIMIT,
          0,
          "modulo",
          0,
          9
        ];
        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults)
            this[p] = DEFAULTS[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
              this[p] = v;
            else
              throw Error(invalidArgument + p + ": " + v);
          }
        }
        if (p = "crypto", useDefaults)
          this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument + p + ": " + v);
          }
        }
        return this;
      }
      function cos(x) {
        return new this(x).cos();
      }
      function cosh2(x) {
        return new this(x).cosh();
      }
      function clone2(obj) {
        var i, p, ps;
        function Decimal5(v) {
          var e2, i2, t, x = this;
          if (!(x instanceof Decimal5))
            return new Decimal5(v);
          x.constructor = Decimal5;
          if (v instanceof Decimal5) {
            x.s = v.s;
            if (external) {
              if (!v.d || v.e > Decimal5.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal5.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }
            return;
          }
          t = typeof v;
          if (t === "number") {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            if (v === ~~v && v < 1e7) {
              for (e2 = 0, i2 = v; i2 >= 10; i2 /= 10)
                e2++;
              if (external) {
                if (e2 > Decimal5.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e2 < Decimal5.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e2;
                  x.d = [v];
                }
              } else {
                x.e = e2;
                x.d = [v];
              }
              return;
            } else if (v * 0 !== 0) {
              if (!v)
                x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }
            return parseDecimal(x, v.toString());
          } else if (t !== "string") {
            throw Error(invalidArgument + v);
          }
          if ((i2 = v.charCodeAt(0)) === 45) {
            v = v.slice(1);
            x.s = -1;
          } else {
            if (i2 === 43)
              v = v.slice(1);
            x.s = 1;
          }
          return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
        }
        Decimal5.prototype = P2;
        Decimal5.ROUND_UP = 0;
        Decimal5.ROUND_DOWN = 1;
        Decimal5.ROUND_CEIL = 2;
        Decimal5.ROUND_FLOOR = 3;
        Decimal5.ROUND_HALF_UP = 4;
        Decimal5.ROUND_HALF_DOWN = 5;
        Decimal5.ROUND_HALF_EVEN = 6;
        Decimal5.ROUND_HALF_CEIL = 7;
        Decimal5.ROUND_HALF_FLOOR = 8;
        Decimal5.EUCLID = 9;
        Decimal5.config = Decimal5.set = config;
        Decimal5.clone = clone2;
        Decimal5.isDecimal = isDecimalInstance;
        Decimal5.abs = abs;
        Decimal5.acos = acos;
        Decimal5.acosh = acosh2;
        Decimal5.add = add;
        Decimal5.asin = asin;
        Decimal5.asinh = asinh2;
        Decimal5.atan = atan;
        Decimal5.atanh = atanh2;
        Decimal5.atan2 = atan2;
        Decimal5.cbrt = cbrt3;
        Decimal5.ceil = ceil;
        Decimal5.cos = cos;
        Decimal5.cosh = cosh2;
        Decimal5.div = div;
        Decimal5.exp = exp;
        Decimal5.floor = floor;
        Decimal5.hypot = hypot;
        Decimal5.ln = ln;
        Decimal5.log = log;
        Decimal5.log10 = log103;
        Decimal5.log2 = log23;
        Decimal5.max = max;
        Decimal5.min = min;
        Decimal5.mod = mod;
        Decimal5.mul = mul;
        Decimal5.pow = pow;
        Decimal5.random = random;
        Decimal5.round = round;
        Decimal5.sign = sign2;
        Decimal5.sin = sin;
        Decimal5.sinh = sinh2;
        Decimal5.sqrt = sqrt;
        Decimal5.sub = sub;
        Decimal5.tan = tan;
        Decimal5.tanh = tanh2;
        Decimal5.trunc = trunc;
        if (obj === void 0)
          obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
            for (i = 0; i < ps.length; )
              if (!obj.hasOwnProperty(p = ps[i++]))
                obj[p] = this[p];
          }
        }
        Decimal5.config(obj);
        return Decimal5;
      }
      function div(x, y) {
        return new this(x).div(y);
      }
      function exp(x) {
        return new this(x).exp();
      }
      function floor(x) {
        return finalise(x = new this(x), x.e + 1, 3);
      }
      function hypot() {
        var i, n, t = new this(0);
        external = false;
        for (i = 0; i < arguments.length; ) {
          n = new this(arguments[i++]);
          if (!n.d) {
            if (n.s) {
              external = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }
        external = true;
        return t.sqrt();
      }
      function isDecimalInstance(obj) {
        return obj instanceof Decimal4 || obj && obj.name === "[object Decimal]" || false;
      }
      function ln(x) {
        return new this(x).ln();
      }
      function log(x, y) {
        return new this(x).log(y);
      }
      function log23(x) {
        return new this(x).log(2);
      }
      function log103(x) {
        return new this(x).log(10);
      }
      function max() {
        return maxOrMin(this, arguments, "lt");
      }
      function min() {
        return maxOrMin(this, arguments, "gt");
      }
      function mod(x, y) {
        return new this(x).mod(y);
      }
      function mul(x, y) {
        return new this(x).mul(y);
      }
      function pow(x, y) {
        return new this(x).pow(y);
      }
      function random(sd) {
        var d, e2, k, n, i = 0, r = new this(1), rd = [];
        if (sd === void 0)
          sd = this.precision;
        else
          checkInt32(sd, 1, MAX_DIGITS);
        k = Math.ceil(sd / LOG_BASE);
        if (!this.crypto) {
          for (; i < k; )
            rd[i++] = Math.random() * 1e7 | 0;
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));
          for (; i < k; ) {
            n = d[i];
            if (n >= 429e7) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              rd[i++] = n % 1e7;
            }
          }
        } else if (crypto.randomBytes) {
          d = crypto.randomBytes(k *= 4);
          for (; i < k; ) {
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
            if (n >= 214e7) {
              crypto.randomBytes(4).copy(d, i);
            } else {
              rd.push(n % 1e7);
              i += 4;
            }
          }
          i = k / 4;
        } else {
          throw Error(cryptoUnavailable);
        }
        k = rd[--i];
        sd %= LOG_BASE;
        if (k && sd) {
          n = mathpow(10, LOG_BASE - sd);
          rd[i] = (k / n | 0) * n;
        }
        for (; rd[i] === 0; i--)
          rd.pop();
        if (i < 0) {
          e2 = 0;
          rd = [0];
        } else {
          e2 = -1;
          for (; rd[0] === 0; e2 -= LOG_BASE)
            rd.shift();
          for (k = 1, n = rd[0]; n >= 10; n /= 10)
            k++;
          if (k < LOG_BASE)
            e2 -= LOG_BASE - k;
        }
        r.e = e2;
        r.d = rd;
        return r;
      }
      function round(x) {
        return finalise(x = new this(x), x.e + 1, this.rounding);
      }
      function sign2(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      function sin(x) {
        return new this(x).sin();
      }
      function sinh2(x) {
        return new this(x).sinh();
      }
      function sqrt(x) {
        return new this(x).sqrt();
      }
      function sub(x, y) {
        return new this(x).sub(y);
      }
      function tan(x) {
        return new this(x).tan();
      }
      function tanh2(x) {
        return new this(x).tanh();
      }
      function trunc(x) {
        return finalise(x = new this(x), x.e + 1, 1);
      }
      Decimal4 = clone2(DEFAULTS);
      Decimal4["default"] = Decimal4.Decimal = Decimal4;
      LN10 = new Decimal4(LN10);
      PI = new Decimal4(PI);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal4;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
          P2[Symbol.for("nodejs.util.inspect.custom")] = P2.toString;
          P2[Symbol.toStringTag] = "Decimal";
        }
        module2.exports = Decimal4;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
        }
        noConflict = globalScope.Decimal;
        Decimal4.noConflict = function() {
          globalScope.Decimal = noConflict;
          return Decimal4;
        };
        globalScope.Decimal = Decimal4;
      }
    })(exports2);
  });

  // node_modules/complex.js/complex.js
  var require_complex = __commonJS((exports2, module2) => {
    /**
     * @license Complex.js v2.0.12 11/02/2016
     *
     * Copyright (c) 2016, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **/
    (function(root) {
      "use strict";
      var cosh2 = function(x) {
        return (Math.exp(x) + Math.exp(-x)) * 0.5;
      };
      var sinh2 = function(x) {
        return (Math.exp(x) - Math.exp(-x)) * 0.5;
      };
      var cosm1 = function(x) {
        var limit = Math.PI / 4;
        if (x < -limit || x > limit) {
          return Math.cos(x) - 1;
        }
        var xx = x * x;
        return xx * (-0.5 + xx * (1 / 24 + xx * (-1 / 720 + xx * (1 / 40320 + xx * (-1 / 3628800 + xx * (1 / 4790014600 + xx * (-1 / 87178291200 + xx * (1 / 20922789888e3))))))));
      };
      var hypot = function(x, y) {
        var a = Math.abs(x);
        var b = Math.abs(y);
        if (a < 3e3 && b < 3e3) {
          return Math.sqrt(a * a + b * b);
        }
        if (a < b) {
          a = b;
          b = x / y;
        } else {
          b = y / x;
        }
        return a * Math.sqrt(1 + b * b);
      };
      var parser_exit = function() {
        throw SyntaxError("Invalid Param");
      };
      function logHypot(a, b) {
        var _a = Math.abs(a);
        var _b = Math.abs(b);
        if (a === 0) {
          return Math.log(_b);
        }
        if (b === 0) {
          return Math.log(_a);
        }
        if (_a < 3e3 && _b < 3e3) {
          return Math.log(a * a + b * b) * 0.5;
        }
        return Math.log(a / Math.cos(Math.atan2(b, a)));
      }
      var parse = function(a, b) {
        var z = {re: 0, im: 0};
        if (a === void 0 || a === null) {
          z["re"] = z["im"] = 0;
        } else if (b !== void 0) {
          z["re"] = a;
          z["im"] = b;
        } else
          switch (typeof a) {
            case "object":
              if ("im" in a && "re" in a) {
                z["re"] = a["re"];
                z["im"] = a["im"];
              } else if ("abs" in a && "arg" in a) {
                if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                  return Complex2["INFINITY"];
                }
                z["re"] = a["abs"] * Math.cos(a["arg"]);
                z["im"] = a["abs"] * Math.sin(a["arg"]);
              } else if ("r" in a && "phi" in a) {
                if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                  return Complex2["INFINITY"];
                }
                z["re"] = a["r"] * Math.cos(a["phi"]);
                z["im"] = a["r"] * Math.sin(a["phi"]);
              } else if (a.length === 2) {
                z["re"] = a[0];
                z["im"] = a[1];
              } else {
                parser_exit();
              }
              break;
            case "string":
              z["im"] = z["re"] = 0;
              var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
              var plus = 1;
              var minus = 0;
              if (tokens === null) {
                parser_exit();
              }
              for (var i = 0; i < tokens.length; i++) {
                var c = tokens[i];
                if (c === " " || c === "	" || c === "\n") {
                } else if (c === "+") {
                  plus++;
                } else if (c === "-") {
                  minus++;
                } else if (c === "i" || c === "I") {
                  if (plus + minus === 0) {
                    parser_exit();
                  }
                  if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
                    i++;
                  } else {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                  }
                  plus = minus = 0;
                } else {
                  if (plus + minus === 0 || isNaN(c)) {
                    parser_exit();
                  }
                  if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                    i++;
                  } else {
                    z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                  }
                  plus = minus = 0;
                }
              }
              if (plus + minus > 0) {
                parser_exit();
              }
              break;
            case "number":
              z["im"] = 0;
              z["re"] = a;
              break;
            default:
              parser_exit();
          }
        if (isNaN(z["re"]) || isNaN(z["im"])) {
        }
        return z;
      };
      function Complex2(a, b) {
        if (!(this instanceof Complex2)) {
          return new Complex2(a, b);
        }
        var z = parse(a, b);
        this["re"] = z["re"];
        this["im"] = z["im"];
      }
      Complex2.prototype = {
        re: 0,
        im: 0,
        sign: function() {
          var abs = this["abs"]();
          return new Complex2(this["re"] / abs, this["im"] / abs);
        },
        add: function(a, b) {
          var z = new Complex2(a, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex2["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex2["INFINITY"];
          }
          return new Complex2(this["re"] + z["re"], this["im"] + z["im"]);
        },
        sub: function(a, b) {
          var z = new Complex2(a, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex2["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex2["INFINITY"];
          }
          return new Complex2(this["re"] - z["re"], this["im"] - z["im"]);
        },
        mul: function(a, b) {
          var z = new Complex2(a, b);
          if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
            return Complex2["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex2["INFINITY"];
          }
          if (z["im"] === 0 && this["im"] === 0) {
            return new Complex2(this["re"] * z["re"], 0);
          }
          return new Complex2(this["re"] * z["re"] - this["im"] * z["im"], this["re"] * z["im"] + this["im"] * z["re"]);
        },
        div: function(a, b) {
          var z = new Complex2(a, b);
          if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
            return Complex2["NAN"];
          }
          if (this["isInfinite"]() || z["isZero"]()) {
            return Complex2["INFINITY"];
          }
          if (this["isZero"]() || z["isInfinite"]()) {
            return Complex2["ZERO"];
          }
          a = this["re"];
          b = this["im"];
          var c = z["re"];
          var d = z["im"];
          var t, x;
          if (d === 0) {
            return new Complex2(a / c, b / c);
          }
          if (Math.abs(c) < Math.abs(d)) {
            x = c / d;
            t = c * x + d;
            return new Complex2((a * x + b) / t, (b * x - a) / t);
          } else {
            x = d / c;
            t = d * x + c;
            return new Complex2((a + b * x) / t, (b - a * x) / t);
          }
        },
        pow: function(a, b) {
          var z = new Complex2(a, b);
          a = this["re"];
          b = this["im"];
          if (z["isZero"]()) {
            return Complex2["ONE"];
          }
          if (z["im"] === 0) {
            if (b === 0) {
              return new Complex2(Math.pow(a, z["re"]), 0);
            } else if (a === 0) {
              switch ((z["re"] % 4 + 4) % 4) {
                case 0:
                  return new Complex2(Math.pow(b, z["re"]), 0);
                case 1:
                  return new Complex2(0, Math.pow(b, z["re"]));
                case 2:
                  return new Complex2(-Math.pow(b, z["re"]), 0);
                case 3:
                  return new Complex2(0, -Math.pow(b, z["re"]));
              }
            }
          }
          if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
            return Complex2["ZERO"];
          }
          var arg = Math.atan2(b, a);
          var loh = logHypot(a, b);
          a = Math.exp(z["re"] * loh - z["im"] * arg);
          b = z["im"] * loh + z["re"] * arg;
          return new Complex2(a * Math.cos(b), a * Math.sin(b));
        },
        sqrt: function() {
          var a = this["re"];
          var b = this["im"];
          var r = this["abs"]();
          var re, im;
          if (a >= 0) {
            if (b === 0) {
              return new Complex2(Math.sqrt(a), 0);
            }
            re = 0.5 * Math.sqrt(2 * (r + a));
          } else {
            re = Math.abs(b) / Math.sqrt(2 * (r - a));
          }
          if (a <= 0) {
            im = 0.5 * Math.sqrt(2 * (r - a));
          } else {
            im = Math.abs(b) / Math.sqrt(2 * (r + a));
          }
          return new Complex2(re, b < 0 ? -im : im);
        },
        exp: function() {
          var tmp = Math.exp(this["re"]);
          if (this["im"] === 0) {
          }
          return new Complex2(tmp * Math.cos(this["im"]), tmp * Math.sin(this["im"]));
        },
        expm1: function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex2(Math.expm1(a) * Math.cos(b) + cosm1(b), Math.exp(a) * Math.sin(b));
        },
        log: function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0 && a > 0) {
          }
          return new Complex2(logHypot(a, b), Math.atan2(b, a));
        },
        abs: function() {
          return hypot(this["re"], this["im"]);
        },
        arg: function() {
          return Math.atan2(this["im"], this["re"]);
        },
        sin: function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex2(Math.sin(a) * cosh2(b), Math.cos(a) * sinh2(b));
        },
        cos: function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex2(Math.cos(a) * cosh2(b), -Math.sin(a) * sinh2(b));
        },
        tan: function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a) + cosh2(b);
          return new Complex2(Math.sin(a) / d, sinh2(b) / d);
        },
        cot: function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a) - cosh2(b);
          return new Complex2(-Math.sin(a) / d, sinh2(b) / d);
        },
        sec: function() {
          var a = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh2(2 * b) + 0.5 * Math.cos(2 * a);
          return new Complex2(Math.cos(a) * cosh2(b) / d, Math.sin(a) * sinh2(b) / d);
        },
        csc: function() {
          var a = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh2(2 * b) - 0.5 * Math.cos(2 * a);
          return new Complex2(Math.sin(a) * cosh2(b) / d, -Math.cos(a) * sinh2(b) / d);
        },
        asin: function() {
          var a = this["re"];
          var b = this["im"];
          var t1 = new Complex2(b * b - a * a + 1, -2 * a * b)["sqrt"]();
          var t2 = new Complex2(t1["re"] - b, t1["im"] + a)["log"]();
          return new Complex2(t2["im"], -t2["re"]);
        },
        acos: function() {
          var a = this["re"];
          var b = this["im"];
          var t1 = new Complex2(b * b - a * a + 1, -2 * a * b)["sqrt"]();
          var t2 = new Complex2(t1["re"] - b, t1["im"] + a)["log"]();
          return new Complex2(Math.PI / 2 - t2["im"], t2["re"]);
        },
        atan: function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0) {
            if (b === 1) {
              return new Complex2(0, Infinity);
            }
            if (b === -1) {
              return new Complex2(0, -Infinity);
            }
          }
          var d = a * a + (1 - b) * (1 - b);
          var t1 = new Complex2((1 - b * b - a * a) / d, -2 * a / d).log();
          return new Complex2(-0.5 * t1["im"], 0.5 * t1["re"]);
        },
        acot: function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex2(Math.atan2(1, a), 0);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex2(a / d, -b / d).atan() : new Complex2(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atan();
        },
        asec: function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex2(0, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex2(a / d, -b / d).acos() : new Complex2(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acos();
        },
        acsc: function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex2(Math.PI / 2, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex2(a / d, -b / d).asin() : new Complex2(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asin();
        },
        sinh: function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex2(sinh2(a) * Math.cos(b), cosh2(a) * Math.sin(b));
        },
        cosh: function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex2(cosh2(a) * Math.cos(b), sinh2(a) * Math.sin(b));
        },
        tanh: function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh2(a) + Math.cos(b);
          return new Complex2(sinh2(a) / d, Math.sin(b) / d);
        },
        coth: function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh2(a) - Math.cos(b);
          return new Complex2(sinh2(a) / d, -Math.sin(b) / d);
        },
        csch: function() {
          var a = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) - cosh2(2 * a);
          return new Complex2(-2 * sinh2(a) * Math.cos(b) / d, 2 * cosh2(a) * Math.sin(b) / d);
        },
        sech: function() {
          var a = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) + cosh2(2 * a);
          return new Complex2(2 * cosh2(a) * Math.cos(b) / d, -2 * sinh2(a) * Math.sin(b) / d);
        },
        asinh: function() {
          var tmp = this["im"];
          this["im"] = -this["re"];
          this["re"] = tmp;
          var res = this["asin"]();
          this["re"] = -this["im"];
          this["im"] = tmp;
          tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
          return res;
        },
        acosh: function() {
          var res = this["acos"]();
          if (res["im"] <= 0) {
            var tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
          } else {
            var tmp = res["im"];
            res["im"] = -res["re"];
            res["re"] = tmp;
          }
          return res;
        },
        atanh: function() {
          var a = this["re"];
          var b = this["im"];
          var noIM = a > 1 && b === 0;
          var oneMinus = 1 - a;
          var onePlus = 1 + a;
          var d = oneMinus * oneMinus + b * b;
          var x = d !== 0 ? new Complex2((onePlus * oneMinus - b * b) / d, (b * oneMinus + onePlus * b) / d) : new Complex2(a !== -1 ? a / 0 : 0, b !== 0 ? b / 0 : 0);
          var temp = x["re"];
          x["re"] = logHypot(x["re"], x["im"]) / 2;
          x["im"] = Math.atan2(x["im"], temp) / 2;
          if (noIM) {
            x["im"] = -x["im"];
          }
          return x;
        },
        acoth: function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex2(0, Math.PI / 2);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex2(a / d, -b / d).atanh() : new Complex2(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atanh();
        },
        acsch: function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex2(a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity, 0);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex2(a / d, -b / d).asinh() : new Complex2(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asinh();
        },
        asech: function() {
          var a = this["re"];
          var b = this["im"];
          if (this["isZero"]()) {
            return Complex2["INFINITY"];
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex2(a / d, -b / d).acosh() : new Complex2(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acosh();
        },
        inverse: function() {
          if (this["isZero"]()) {
            return Complex2["INFINITY"];
          }
          if (this["isInfinite"]()) {
            return Complex2["ZERO"];
          }
          var a = this["re"];
          var b = this["im"];
          var d = a * a + b * b;
          return new Complex2(a / d, -b / d);
        },
        conjugate: function() {
          return new Complex2(this["re"], -this["im"]);
        },
        neg: function() {
          return new Complex2(-this["re"], -this["im"]);
        },
        ceil: function(places) {
          places = Math.pow(10, places || 0);
          return new Complex2(Math.ceil(this["re"] * places) / places, Math.ceil(this["im"] * places) / places);
        },
        floor: function(places) {
          places = Math.pow(10, places || 0);
          return new Complex2(Math.floor(this["re"] * places) / places, Math.floor(this["im"] * places) / places);
        },
        round: function(places) {
          places = Math.pow(10, places || 0);
          return new Complex2(Math.round(this["re"] * places) / places, Math.round(this["im"] * places) / places);
        },
        equals: function(a, b) {
          var z = new Complex2(a, b);
          return Math.abs(z["re"] - this["re"]) <= Complex2["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex2["EPSILON"];
        },
        clone: function() {
          return new Complex2(this["re"], this["im"]);
        },
        toString: function() {
          var a = this["re"];
          var b = this["im"];
          var ret = "";
          if (this["isNaN"]()) {
            return "NaN";
          }
          if (this["isInfinite"]()) {
            return "Infinity";
          }
          if (b === 0) {
            return ret + a;
          }
          if (a !== 0) {
            ret += a;
            ret += " ";
            if (b < 0) {
              b = -b;
              ret += "-";
            } else {
              ret += "+";
            }
            ret += " ";
          } else if (b < 0) {
            b = -b;
            ret += "-";
          }
          if (b !== 1) {
            ret += b;
          }
          return ret + "i";
        },
        toVector: function() {
          return [this["re"], this["im"]];
        },
        valueOf: function() {
          if (this["im"] === 0) {
            return this["re"];
          }
          return null;
        },
        isNaN: function() {
          return isNaN(this["re"]) || isNaN(this["im"]);
        },
        isZero: function() {
          return this["im"] === 0 && this["re"] === 0;
        },
        isFinite: function() {
          return isFinite(this["re"]) && isFinite(this["im"]);
        },
        isInfinite: function() {
          return !(this["isNaN"]() || this["isFinite"]());
        }
      };
      Complex2["ZERO"] = new Complex2(0, 0);
      Complex2["ONE"] = new Complex2(1, 0);
      Complex2["I"] = new Complex2(0, 1);
      Complex2["PI"] = new Complex2(Math.PI, 0);
      Complex2["E"] = new Complex2(Math.E, 0);
      Complex2["INFINITY"] = new Complex2(Infinity, Infinity);
      Complex2["NAN"] = new Complex2(NaN, NaN);
      Complex2["EPSILON"] = 1e-16;
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Complex2;
        });
      } else if (typeof exports2 === "object") {
        Object.defineProperty(Complex2, "__esModule", {value: true});
        Complex2["default"] = Complex2;
        Complex2["Complex"] = Complex2;
        module2["exports"] = Complex2;
      } else {
        root["Complex"] = Complex2;
      }
    })(exports2);
  });

  // node_modules/fraction.js/fraction.js
  var require_fraction = __commonJS((exports2, module2) => {
    /**
     * @license Fraction.js v4.0.12 09/09/2015
     * http://www.xarg.org/2014/03/rational-numbers-in-javascript/
     *
     * Copyright (c) 2015, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **/
    (function(root) {
      "use strict";
      var MAX_CYCLE_LEN = 2e3;
      var P2 = {
        s: 1,
        n: 0,
        d: 1
      };
      function createError(name284) {
        function errorConstructor() {
          var temp = Error.apply(this, arguments);
          temp["name"] = this["name"] = name284;
          this["stack"] = temp["stack"];
          this["message"] = temp["message"];
        }
        function IntermediateInheritor() {
        }
        IntermediateInheritor.prototype = Error.prototype;
        errorConstructor.prototype = new IntermediateInheritor();
        return errorConstructor;
      }
      var DivisionByZero = Fraction2["DivisionByZero"] = createError("DivisionByZero");
      var InvalidParameter = Fraction2["InvalidParameter"] = createError("InvalidParameter");
      function assign(n, s) {
        if (isNaN(n = parseInt(n, 10))) {
          throwInvalidParam();
        }
        return n * s;
      }
      function throwInvalidParam() {
        throw new InvalidParameter();
      }
      var parse = function(p1, p2) {
        var n = 0, d = 1, s = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;
        var A = 0, B = 1;
        var C = 1, D = 1;
        var N = 1e7;
        var M;
        if (p1 === void 0 || p1 === null) {
        } else if (p2 !== void 0) {
          n = p1;
          d = p2;
          s = n * d;
        } else
          switch (typeof p1) {
            case "object": {
              if ("d" in p1 && "n" in p1) {
                n = p1["n"];
                d = p1["d"];
                if ("s" in p1)
                  n *= p1["s"];
              } else if (0 in p1) {
                n = p1[0];
                if (1 in p1)
                  d = p1[1];
              } else {
                throwInvalidParam();
              }
              s = n * d;
              break;
            }
            case "number": {
              if (p1 < 0) {
                s = p1;
                p1 = -p1;
              }
              if (p1 % 1 === 0) {
                n = p1;
              } else if (p1 > 0) {
                if (p1 >= 1) {
                  z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                  p1 /= z;
                }
                while (B <= N && D <= N) {
                  M = (A + C) / (B + D);
                  if (p1 === M) {
                    if (B + D <= N) {
                      n = A + C;
                      d = B + D;
                    } else if (D > B) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                    break;
                  } else {
                    if (p1 > M) {
                      A += C;
                      B += D;
                    } else {
                      C += A;
                      D += B;
                    }
                    if (B > N) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                  }
                }
                n *= z;
              } else if (isNaN(p1) || isNaN(p2)) {
                d = n = NaN;
              }
              break;
            }
            case "string": {
              B = p1.match(/\d+|./g);
              if (B === null)
                throwInvalidParam();
              if (B[A] === "-") {
                s = -1;
                A++;
              } else if (B[A] === "+") {
                A++;
              }
              if (B.length === A + 1) {
                w = assign(B[A++], s);
              } else if (B[A + 1] === "." || B[A] === ".") {
                if (B[A] !== ".") {
                  v = assign(B[A++], s);
                }
                A++;
                if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                  w = assign(B[A], s);
                  y = Math.pow(10, B[A].length);
                  A++;
                }
                if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                  x = assign(B[A + 1], s);
                  z = Math.pow(10, B[A + 1].length) - 1;
                  A += 3;
                }
              } else if (B[A + 1] === "/" || B[A + 1] === ":") {
                w = assign(B[A], s);
                y = assign(B[A + 2], 1);
                A += 3;
              } else if (B[A + 3] === "/" && B[A + 1] === " ") {
                v = assign(B[A], s);
                w = assign(B[A + 2], s);
                y = assign(B[A + 4], 1);
                A += 5;
              }
              if (B.length <= A) {
                d = y * z;
                s = n = x + d * v + z * w;
                break;
              }
            }
            default:
              throwInvalidParam();
          }
        if (d === 0) {
          throw new DivisionByZero();
        }
        P2["s"] = s < 0 ? -1 : 1;
        P2["n"] = Math.abs(n);
        P2["d"] = Math.abs(d);
      };
      function modpow(b, e2, m) {
        var r = 1;
        for (; e2 > 0; b = b * b % m, e2 >>= 1) {
          if (e2 & 1) {
            r = r * b % m;
          }
        }
        return r;
      }
      function cycleLen(n, d) {
        for (; d % 2 === 0; d /= 2) {
        }
        for (; d % 5 === 0; d /= 5) {
        }
        if (d === 1)
          return 0;
        var rem = 10 % d;
        var t = 1;
        for (; rem !== 1; t++) {
          rem = rem * 10 % d;
          if (t > MAX_CYCLE_LEN)
            return 0;
        }
        return t;
      }
      function cycleStart(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for (var t = 0; t < 300; t++) {
          if (rem1 === rem2)
            return t;
          rem1 = rem1 * 10 % d;
          rem2 = rem2 * 10 % d;
        }
        return 0;
      }
      function gcd(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        while (1) {
          a %= b;
          if (!a)
            return b;
          b %= a;
          if (!b)
            return a;
        }
      }
      ;
      function Fraction2(a, b) {
        if (!(this instanceof Fraction2)) {
          return new Fraction2(a, b);
        }
        parse(a, b);
        if (Fraction2["REDUCE"]) {
          a = gcd(P2["d"], P2["n"]);
        } else {
          a = 1;
        }
        this["s"] = P2["s"];
        this["n"] = P2["n"] / a;
        this["d"] = P2["d"] / a;
      }
      Fraction2["REDUCE"] = 1;
      Fraction2.prototype = {
        s: 1,
        n: 0,
        d: 1,
        abs: function() {
          return new Fraction2(this["n"], this["d"]);
        },
        neg: function() {
          return new Fraction2(-this["s"] * this["n"], this["d"]);
        },
        add: function(a, b) {
          parse(a, b);
          return new Fraction2(this["s"] * this["n"] * P2["d"] + P2["s"] * this["d"] * P2["n"], this["d"] * P2["d"]);
        },
        sub: function(a, b) {
          parse(a, b);
          return new Fraction2(this["s"] * this["n"] * P2["d"] - P2["s"] * this["d"] * P2["n"], this["d"] * P2["d"]);
        },
        mul: function(a, b) {
          parse(a, b);
          return new Fraction2(this["s"] * P2["s"] * this["n"] * P2["n"], this["d"] * P2["d"]);
        },
        div: function(a, b) {
          parse(a, b);
          return new Fraction2(this["s"] * P2["s"] * this["n"] * P2["d"], this["d"] * P2["n"]);
        },
        clone: function() {
          return new Fraction2(this);
        },
        mod: function(a, b) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction2(NaN);
          }
          if (a === void 0) {
            return new Fraction2(this["s"] * this["n"] % this["d"], 1);
          }
          parse(a, b);
          if (P2["n"] === 0 && this["d"] === 0) {
            Fraction2(0, 0);
          }
          return new Fraction2(this["s"] * (P2["d"] * this["n"]) % (P2["n"] * this["d"]), P2["d"] * this["d"]);
        },
        gcd: function(a, b) {
          parse(a, b);
          return new Fraction2(gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]), P2["d"] * this["d"]);
        },
        lcm: function(a, b) {
          parse(a, b);
          if (P2["n"] === 0 && this["n"] === 0) {
            return new Fraction2();
          }
          return new Fraction2(P2["n"] * this["n"], gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]));
        },
        ceil: function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction2(NaN);
          }
          return new Fraction2(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        floor: function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction2(NaN);
          }
          return new Fraction2(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        round: function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction2(NaN);
          }
          return new Fraction2(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        inverse: function() {
          return new Fraction2(this["s"] * this["d"], this["n"]);
        },
        pow: function(m) {
          if (m < 0) {
            return new Fraction2(Math.pow(this["s"] * this["d"], -m), Math.pow(this["n"], -m));
          } else {
            return new Fraction2(Math.pow(this["s"] * this["n"], m), Math.pow(this["d"], m));
          }
        },
        equals: function(a, b) {
          parse(a, b);
          return this["s"] * this["n"] * P2["d"] === P2["s"] * P2["n"] * this["d"];
        },
        compare: function(a, b) {
          parse(a, b);
          var t = this["s"] * this["n"] * P2["d"] - P2["s"] * P2["n"] * this["d"];
          return (0 < t) - (t < 0);
        },
        simplify: function(eps) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return this;
          }
          var cont = this["abs"]()["toContinued"]();
          eps = eps || 1e-3;
          function rec(a) {
            if (a.length === 1)
              return new Fraction2(a[0]);
            return rec(a.slice(1))["inverse"]()["add"](a[0]);
          }
          for (var i = 0; i < cont.length; i++) {
            var tmp = rec(cont.slice(0, i + 1));
            if (tmp["sub"](this["abs"]())["abs"]().valueOf() < eps) {
              return tmp["mul"](this["s"]);
            }
          }
          return this;
        },
        divisible: function(a, b) {
          parse(a, b);
          return !(!(P2["n"] * this["d"]) || this["n"] * P2["d"] % (P2["n"] * this["d"]));
        },
        valueOf: function() {
          return this["s"] * this["n"] / this["d"];
        },
        toFraction: function(excludeWhole) {
          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += "-";
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              str += " ";
              n %= d;
            }
            str += n;
            str += "/";
            str += d;
          }
          return str;
        },
        toLatex: function(excludeWhole) {
          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += "-";
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              n %= d;
            }
            str += "\\frac{";
            str += n;
            str += "}{";
            str += d;
            str += "}";
          }
          return str;
        },
        toContinued: function() {
          var t;
          var a = this["n"];
          var b = this["d"];
          var res = [];
          if (isNaN(a) || isNaN(b)) {
            return res;
          }
          do {
            res.push(Math.floor(a / b));
            t = a % b;
            a = b;
            b = t;
          } while (a !== 1);
          return res;
        },
        toString: function(dec) {
          var g;
          var N = this["n"];
          var D = this["d"];
          if (isNaN(N) || isNaN(D)) {
            return "NaN";
          }
          if (!Fraction2["REDUCE"]) {
            g = gcd(N, D);
            N /= g;
            D /= g;
          }
          dec = dec || 15;
          var cycLen = cycleLen(N, D);
          var cycOff = cycleStart(N, D, cycLen);
          var str = this["s"] === -1 ? "-" : "";
          str += N / D | 0;
          N %= D;
          N *= 10;
          if (N)
            str += ".";
          if (cycLen) {
            for (var i = cycOff; i--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += "(";
            for (var i = cycLen; i--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += ")";
          } else {
            for (var i = dec; N && i--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
          }
          return str;
        }
      };
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Fraction2;
        });
      } else if (typeof exports2 === "object") {
        Object.defineProperty(Fraction2, "__esModule", {value: true});
        Fraction2["default"] = Fraction2;
        Fraction2["Fraction"] = Fraction2;
        module2["exports"] = Fraction2;
      } else {
        root["Fraction"] = Fraction2;
      }
    })(exports2);
  });

  // node_modules/javascript-natural-sort/naturalSort.js
  var require_naturalSort = __commonJS((exports2, module2) => {
    module2.exports = function naturalSort2(a, b) {
      "use strict";
      var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i = function(s) {
        return naturalSort2.insensitive && ("" + s).toLowerCase() || "" + s;
      }, x = i(a).replace(sre, "") || "", y = i(b).replace(sre, "") || "", xN = x.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
      if (yD) {
        if (xD < yD) {
          return -1;
        } else if (xD > yD) {
          return 1;
        }
      }
      for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
        oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
        oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
        if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
          return isNaN(oFxNcL) ? 1 : -1;
        } else if (typeof oFxNcL !== typeof oFyNcL) {
          oFxNcL += "";
          oFyNcL += "";
        }
        if (oFxNcL < oFyNcL) {
          return -1;
        }
        if (oFxNcL > oFyNcL) {
          return 1;
        }
      }
      return 0;
    };
  });

  // node_modules/escape-latex/dist/index.js
  var require_dist = __commonJS((exports2, module2) => {
    "use strict";
    var _extends6 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var defaultEscapes = {
      "{": "\\{",
      "}": "\\}",
      "\\": "\\textbackslash{}",
      "#": "\\#",
      $: "\\$",
      "%": "\\%",
      "&": "\\&",
      "^": "\\textasciicircum{}",
      _: "\\_",
      "~": "\\textasciitilde{}"
    };
    var formatEscapes = {
      "\u2013": "\\--",
      "\u2014": "\\---",
      " ": "~",
      "	": "\\qquad{}",
      "\r\n": "\\newline{}",
      "\n": "\\newline{}"
    };
    var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
      return _extends6({}, defaultEscapes2, formatEscapes2);
    };
    module2.exports = function(str) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
      var runningStr = String(str);
      var result = "";
      var escapes = escapeMapFn(_extends6({}, defaultEscapes), preserveFormatting ? _extends6({}, formatEscapes) : {});
      var escapeKeys = Object.keys(escapes);
      var _loop = function _loop2() {
        var specialCharFound = false;
        escapeKeys.forEach(function(key, index) {
          if (specialCharFound) {
            return;
          }
          if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
            result += escapes[escapeKeys[index]];
            runningStr = runningStr.slice(key.length, runningStr.length);
            specialCharFound = true;
          }
        });
        if (!specialCharFound) {
          result += runningStr.slice(0, 1);
          runningStr = runningStr.slice(1, runningStr.length);
        }
      };
      while (runningStr) {
        _loop();
      }
      return result;
    };
  });

  // node_modules/seedrandom/lib/alea.js
  var require_alea = __commonJS((exports2, module2) => {
    (function(global2, module3, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(exports2, typeof module2 == "object" && module2, typeof define == "function" && define);
  });

  // node_modules/seedrandom/lib/xor128.js
  var require_xor128 = __commonJS((exports2, module2) => {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(exports2, typeof module2 == "object" && module2, typeof define == "function" && define);
  });

  // node_modules/seedrandom/lib/xorwow.js
  var require_xorwow = __commonJS((exports2, module2) => {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(exports2, typeof module2 == "object" && module2, typeof define == "function" && define);
  });

  // node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift7 = __commonJS((exports2, module2) => {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i = me.i, t, v, w;
          t = X[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init2(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8)
            X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j)
            ;
          if (j == 8)
            w = X[7] = -1;
          else
            w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init2(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(exports2, typeof module2 == "object" && module2, typeof define == "function" && define);
  });

  // node_modules/seedrandom/lib/xor4096.js
  var require_xor4096 = __commonJS((exports2, module2) => {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init2(me2, seed2) {
          var t, v, i, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2)
              v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i = t == 0 ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i;
        }
        init2(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(exports2, typeof module2 == "object" && module2, typeof define == "function" && define);
  });

  // node_modules/seedrandom/lib/tychei.js
  var require_tychei = __commonJS((exports2, module2) => {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(exports2, typeof module2 == "object" && module2, typeof define == "function" && define);
  });

  // (disabled):crypto
  var require_crypto = __commonJS(() => {
  });

  // node_modules/seedrandom/seedrandom.js
  var require_seedrandom = __commonJS((exports2, module2) => {
    (function(global2, pool, math2) {
      var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? {entropy: true} : options || {};
        var shortseed = mixkey(flatten2(options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed, 3), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math2[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(prng, shortseed, "global" in options ? options.global : this == math2, options.state);
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        (me.g = function(count) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten2(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten2(obj[prop], depth - 1));
            } catch (e2) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e2) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+new Date(), global2, plugins, global2.screen, tostring(pool)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math2.random(), pool);
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = seedrandom2;
        try {
          nodecrypto = require_crypto();
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math2["seed" + rngname] = seedrandom2;
      }
    })(typeof self !== "undefined" ? self : exports2, [], Math);
  });

  // node_modules/seedrandom/index.js
  var require_seedrandom2 = __commonJS((exports2, module2) => {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module2.exports = sr;
  });

  // node_modules/tiny-emitter/index.js
  var require_tiny_emitter = __commonJS((exports2, module2) => {
    function E() {
    }
    E.prototype = {
      on: function(name284, callback, ctx) {
        var e2 = this.e || (this.e = {});
        (e2[name284] || (e2[name284] = [])).push({
          fn: callback,
          ctx
        });
        return this;
      },
      once: function(name284, callback, ctx) {
        var self2 = this;
        function listener() {
          self2.off(name284, listener);
          callback.apply(ctx, arguments);
        }
        ;
        listener._ = callback;
        return this.on(name284, listener, ctx);
      },
      emit: function(name284) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name284] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function(name284, callback) {
        var e2 = this.e || (this.e = {});
        var evts = e2[name284];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback)
              liveEvents.push(evts[i]);
          }
        }
        liveEvents.length ? e2[name284] = liveEvents : delete e2[name284];
        return this;
      }
    };
    module2.exports = E;
    module2.exports.TinyEmitter = E;
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS((exports2, module2) => {
    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        \u00C0: "A",
        \u00C1: "A",
        \u00C2: "A",
        \u00C3: "A",
        \u00C4: "A",
        \u00C5: "A",
        \u00E0: "a",
        \u00E1: "a",
        \u00E2: "a",
        \u00E3: "a",
        \u00E4: "a",
        \u00E5: "a",
        \u00C7: "C",
        \u00E7: "c",
        \u00D0: "D",
        \u00F0: "d",
        \u00C8: "E",
        \u00C9: "E",
        \u00CA: "E",
        \u00CB: "E",
        \u00E8: "e",
        \u00E9: "e",
        \u00EA: "e",
        \u00EB: "e",
        \u00CC: "I",
        \u00CD: "I",
        \u00CE: "I",
        \u00CF: "I",
        \u00EC: "i",
        \u00ED: "i",
        \u00EE: "i",
        \u00EF: "i",
        \u00D1: "N",
        \u00F1: "n",
        \u00D2: "O",
        \u00D3: "O",
        \u00D4: "O",
        \u00D5: "O",
        \u00D6: "O",
        \u00D8: "O",
        \u00F2: "o",
        \u00F3: "o",
        \u00F4: "o",
        \u00F5: "o",
        \u00F6: "o",
        \u00F8: "o",
        \u00D9: "U",
        \u00DA: "U",
        \u00DB: "U",
        \u00DC: "U",
        \u00F9: "u",
        \u00FA: "u",
        \u00FB: "u",
        \u00FC: "u",
        \u00DD: "Y",
        \u00FD: "y",
        \u00FF: "y",
        \u00C6: "Ae",
        \u00E6: "ae",
        \u00DE: "Th",
        \u00FE: "th",
        \u00DF: "ss",
        \u0100: "A",
        \u0102: "A",
        \u0104: "A",
        \u0101: "a",
        \u0103: "a",
        \u0105: "a",
        \u0106: "C",
        \u0108: "C",
        \u010A: "C",
        \u010C: "C",
        \u0107: "c",
        \u0109: "c",
        \u010B: "c",
        \u010D: "c",
        \u010E: "D",
        \u0110: "D",
        \u010F: "d",
        \u0111: "d",
        \u0112: "E",
        \u0114: "E",
        \u0116: "E",
        \u0118: "E",
        \u011A: "E",
        \u0113: "e",
        \u0115: "e",
        \u0117: "e",
        \u0119: "e",
        \u011B: "e",
        \u011C: "G",
        \u011E: "G",
        \u0120: "G",
        \u0122: "G",
        \u011D: "g",
        \u011F: "g",
        \u0121: "g",
        \u0123: "g",
        \u0124: "H",
        \u0126: "H",
        \u0125: "h",
        \u0127: "h",
        \u0128: "I",
        \u012A: "I",
        \u012C: "I",
        \u012E: "I",
        \u0130: "I",
        \u0129: "i",
        \u012B: "i",
        \u012D: "i",
        \u012F: "i",
        \u0131: "i",
        \u0134: "J",
        \u0135: "j",
        \u0136: "K",
        \u0137: "k",
        \u0138: "k",
        \u0139: "L",
        \u013B: "L",
        \u013D: "L",
        \u013F: "L",
        \u0141: "L",
        \u013A: "l",
        \u013C: "l",
        \u013E: "l",
        \u0140: "l",
        \u0142: "l",
        \u0143: "N",
        \u0145: "N",
        \u0147: "N",
        \u014A: "N",
        \u0144: "n",
        \u0146: "n",
        \u0148: "n",
        \u014B: "n",
        \u014C: "O",
        \u014E: "O",
        \u0150: "O",
        \u014D: "o",
        \u014F: "o",
        \u0151: "o",
        \u0154: "R",
        \u0156: "R",
        \u0158: "R",
        \u0155: "r",
        \u0157: "r",
        \u0159: "r",
        \u015A: "S",
        \u015C: "S",
        \u015E: "S",
        \u0160: "S",
        \u015B: "s",
        \u015D: "s",
        \u015F: "s",
        \u0161: "s",
        \u0162: "T",
        \u0164: "T",
        \u0166: "T",
        \u0163: "t",
        \u0165: "t",
        \u0167: "t",
        \u0168: "U",
        \u016A: "U",
        \u016C: "U",
        \u016E: "U",
        \u0170: "U",
        \u0172: "U",
        \u0169: "u",
        \u016B: "u",
        \u016D: "u",
        \u016F: "u",
        \u0171: "u",
        \u0173: "u",
        \u0174: "W",
        \u0175: "w",
        \u0176: "Y",
        \u0177: "y",
        \u0178: "Y",
        \u0179: "Z",
        \u017B: "Z",
        \u017D: "Z",
        \u017A: "z",
        \u017C: "z",
        \u017E: "z",
        \u0132: "IJ",
        \u0133: "ij",
        \u0152: "Oe",
        \u0153: "oe",
        \u0149: "'n",
        \u017F: "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values2) {
        var index = -1, length = values2.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values2[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _4.defaults(root.Object(), context, _4.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty3 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty3.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          escape: reEscape,
          evaluate: reEvaluate,
          interpolate: reInterpolate,
          variable: "",
          imports: {
            _: lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty3.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty3.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            hash: new Hash(),
            map: new (Map2 || ListCache)(),
            string: new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values3) {
          var index = -1, length = values3 == null ? 0 : values3.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values3[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty3.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values3, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values3 = arrayMap(values3, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values3.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values3 = new SetCache(values3);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values3[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values3, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty3.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty3.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty3.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex2(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return {criteria, index: ++index, value};
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values3, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values3.length, seen = array;
          if (array === values3) {
            values3 = copyArray(values3);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values3[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex2(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values2(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values2(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex2(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            configurable: true,
            enumerable: false,
            value: constant(string),
            writable: true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values2(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values3, assignFunc) {
          var index = -1, length = props.length, valsLength = values3.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values3[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange2(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound2(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values3) {
          return new Set(values3);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty3.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten2), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty3.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty3.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return {start, end};
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex2(key, length) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty3.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex2(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex2(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize2(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex2(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values3) {
          var iteratee2 = last(values3);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values3) {
          var comparator = last(values3);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join2(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values3) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
        }
        function pullAllBy(array, values3, iteratee2) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values3, comparator) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex2(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values3) {
          return baseZipObject(props || [], values3 || [], assignValue);
        }
        function zipObjectDeep(props, values3) {
          return baseZipObject(props || [], values3 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            func: thru,
            args: [interceptor],
            thisArg: undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return {done, value};
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              func: thru,
              args: [reverse],
              thisArg: undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty3.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty3.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values2(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce2(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            leading,
            maxWait: wait,
            trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty3.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull2(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty3.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties2) {
          var result2 = baseCreate(prototype);
          return properties2 == null ? result2 : baseAssign(result2, properties2);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty3.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty3.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values2(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith2(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape3(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty3.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty3.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp2(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin2(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({func, args: arguments, thisArg: object});
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange2();
        var rangeRight = createRange2(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound2("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound2("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound2("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create2;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize2;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin2;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values2;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin2(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith2;
        lodash.eq = eq;
        lodash.escape = escape3;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach2;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean2;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate2;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger2;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp2;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join2;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce2;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach2;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin2(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty3.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), {chain: false});
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                size: nativeMin(n, MAX_ARRAY_LENGTH),
                type: methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              iteratee: getIteratee(iteratee2, 3),
              type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined2});
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty3.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({name: methodName, func: lodashFunc});
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          name: "wrapper",
          func: undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _4 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _4;
        define(function() {
          return _4;
        });
      } else if (freeModule) {
        (freeModule.exports = _4)._ = _4;
        freeExports._ = _4;
      } else {
        root._ = _4;
      }
    }).call(exports2);
  });

  // node_modules/canvas/lib/parse-font.js
  var require_parse_font = __commonJS((exports2, module2) => {
    "use strict";
    var weights = "bold|bolder|lighter|[1-9]00";
    var styles = "italic|oblique";
    var variants = "small-caps";
    var stretches = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded";
    var units = "px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q";
    var string = `'([^']+)'|"([^"]+)"|[\\w\\s-]+`;
    var weightRe = new RegExp("(" + weights + ") +", "i");
    var styleRe = new RegExp("(" + styles + ") +", "i");
    var variantRe = new RegExp("(" + variants + ") +", "i");
    var stretchRe = new RegExp("(" + stretches + ") +", "i");
    var sizeFamilyRe = new RegExp("([\\d\\.]+)(" + units + ") *((?:" + string + ")( *, *(?:" + string + "))*)");
    var cache = {};
    var defaultHeight = 16;
    module2.exports = function(str) {
      if (cache[str])
        return cache[str];
      const sizeFamily = sizeFamilyRe.exec(str);
      if (!sizeFamily)
        return;
      const font = {
        weight: "normal",
        style: "normal",
        stretch: "normal",
        variant: "normal",
        size: parseFloat(sizeFamily[1]),
        unit: sizeFamily[2],
        family: sizeFamily[3].replace(/["']/g, "").replace(/ *, */g, ",")
      };
      let weight, style, variant, stretch;
      let substr = str.substring(0, sizeFamily.index);
      if (weight = weightRe.exec(substr))
        font.weight = weight[1];
      if (style = styleRe.exec(substr))
        font.style = style[1];
      if (variant = variantRe.exec(substr))
        font.variant = variant[1];
      if (stretch = stretchRe.exec(substr))
        font.stretch = stretch[1];
      switch (font.unit) {
        case "pt":
          font.size /= 0.75;
          break;
        case "pc":
          font.size *= 16;
          break;
        case "in":
          font.size *= 96;
          break;
        case "cm":
          font.size *= 96 / 2.54;
          break;
        case "mm":
          font.size *= 96 / 25.4;
          break;
        case "%":
          break;
        case "em":
        case "rem":
          font.size *= defaultHeight / 0.75;
          break;
        case "q":
          font.size *= 96 / 25.4 / 4;
          break;
      }
      return cache[str] = font;
    };
  });

  // node_modules/canvas/browser.js
  var require_browser = __commonJS((exports2) => {
    var parseFont = require_parse_font();
    exports2.parseFont = parseFont;
    exports2.createCanvas = function(width, height) {
      return Object.assign(document.createElement("canvas"), {width, height});
    };
    exports2.createImageData = function(array, width, height) {
      switch (arguments.length) {
        case 0:
          return new ImageData();
        case 1:
          return new ImageData(array);
        case 2:
          return new ImageData(array, width);
        default:
          return new ImageData(array, width, height);
      }
    };
    exports2.loadImage = function(src, options) {
      return new Promise(function(resolve, reject) {
        const image = Object.assign(document.createElement("img"), options);
        function cleanup() {
          image.onload = null;
          image.onerror = null;
        }
        image.onload = function() {
          cleanup();
          resolve(image);
        };
        image.onerror = function() {
          cleanup();
          reject(new Error('Failed to load the image "' + src + '"'));
        };
        image.src = src;
      });
    };
  });

  // node_modules/jsxgraph/distrib/jsxgraphcore.js
  var require_jsxgraphcore = __commonJS((exports, module) => {
    !function(t, e2) {
      typeof define == "function" && define.amd ? define("jsxgraphcore", [], e2) : typeof module == "object" && module.exports ? module.exports = e2() : t.returnExports = e2();
    }(exports, function() {
      var requirejs, require, define;
      return function(t) {
        function e2(t2, e3) {
          return v.call(t2, e3);
        }
        function i(t2, e3) {
          var i2, r2, s2, o2, n3, a2, h2, l2, c2, d2, u2, p2, f2 = e3 && e3.split("/"), m2 = g.map, b2 = m2 && m2["*"] || {};
          if (t2) {
            for (t2 = t2.split("/"), n3 = t2.length - 1, g.nodeIdCompat && C.test(t2[n3]) && (t2[n3] = t2[n3].replace(C, "")), t2[0].charAt(0) === "." && f2 && (p2 = f2.slice(0, f2.length - 1), t2 = p2.concat(t2)), c2 = 0; c2 < t2.length; c2++)
              if ((u2 = t2[c2]) === ".")
                t2.splice(c2, 1), c2 -= 1;
              else if (u2 === "..") {
                if (c2 === 0 || c2 === 1 && t2[2] === ".." || t2[c2 - 1] === "..")
                  continue;
                c2 > 0 && (t2.splice(c2 - 1, 2), c2 -= 2);
              }
            t2 = t2.join("/");
          }
          if ((f2 || b2) && m2) {
            for (i2 = t2.split("/"), c2 = i2.length; c2 > 0; c2 -= 1) {
              if (r2 = i2.slice(0, c2).join("/"), f2) {
                for (d2 = f2.length; d2 > 0; d2 -= 1)
                  if ((s2 = m2[f2.slice(0, d2).join("/")]) && (s2 = s2[r2])) {
                    o2 = s2, a2 = c2;
                    break;
                  }
              }
              if (o2)
                break;
              !h2 && b2 && b2[r2] && (h2 = b2[r2], l2 = c2);
            }
            !o2 && h2 && (o2 = h2, a2 = l2), o2 && (i2.splice(0, a2, o2), t2 = i2.join("/"));
          }
          return t2;
        }
        function r(e3, i2) {
          return function() {
            var r2 = y.call(arguments, 0);
            return typeof r2[0] != "string" && r2.length === 1 && r2.push(null), d.apply(t, r2.concat([e3, i2]));
          };
        }
        function s(t2) {
          return function(e3) {
            return i(e3, t2);
          };
        }
        function o(t2) {
          return function(e3) {
            f[t2] = e3;
          };
        }
        function n(i2) {
          if (e2(m, i2)) {
            var r2 = m[i2];
            delete m[i2], b[i2] = true, c.apply(t, r2);
          }
          if (!e2(f, i2) && !e2(b, i2))
            throw new Error("No " + i2);
          return f[i2];
        }
        function a(t2) {
          var e3, i2 = t2 ? t2.indexOf("!") : -1;
          return i2 > -1 && (e3 = t2.substring(0, i2), t2 = t2.substring(i2 + 1, t2.length)), [e3, t2];
        }
        function h(t2) {
          return t2 ? a(t2) : [];
        }
        function l(t2) {
          return function() {
            return g && g.config && g.config[t2] || {};
          };
        }
        var c, d, u, p, f = {}, m = {}, g = {}, b = {}, v = Object.prototype.hasOwnProperty, y = [].slice, C = /\.js$/;
        u = function(t2, e3) {
          var r2, o2 = a(t2), h2 = o2[0], l2 = e3[1];
          return t2 = o2[1], h2 && (h2 = i(h2, l2), r2 = n(h2)), h2 ? t2 = r2 && r2.normalize ? r2.normalize(t2, s(l2)) : i(t2, l2) : (t2 = i(t2, l2), o2 = a(t2), h2 = o2[0], t2 = o2[1], h2 && (r2 = n(h2))), {f: h2 ? h2 + "!" + t2 : t2, n: t2, pr: h2, p: r2};
        }, p = {require: function(t2) {
          return r(t2);
        }, exports: function(t2) {
          var e3 = f[t2];
          return e3 !== void 0 ? e3 : f[t2] = {};
        }, module: function(t2) {
          return {id: t2, uri: "", exports: f[t2], config: l(t2)};
        }}, c = function(i2, s2, a2, l2) {
          var c2, d2, g2, v2, y2, C2, _4, P2 = [], E = typeof a2;
          if (l2 = l2 || i2, C2 = h(l2), E === "undefined" || E === "function") {
            for (s2 = !s2.length && a2.length ? ["require", "exports", "module"] : s2, y2 = 0; y2 < s2.length; y2 += 1)
              if (v2 = u(s2[y2], C2), (d2 = v2.f) === "require")
                P2[y2] = p.require(i2);
              else if (d2 === "exports")
                P2[y2] = p.exports(i2), _4 = true;
              else if (d2 === "module")
                c2 = P2[y2] = p.module(i2);
              else if (e2(f, d2) || e2(m, d2) || e2(b, d2))
                P2[y2] = n(d2);
              else {
                if (!v2.p)
                  throw new Error(i2 + " missing " + d2);
                v2.p.load(v2.n, r(l2, true), o(d2), {}), P2[y2] = f[d2];
              }
            g2 = a2 ? a2.apply(f[i2], P2) : void 0, i2 && (c2 && c2.exports !== t && c2.exports !== f[i2] ? f[i2] = c2.exports : g2 === t && _4 || (f[i2] = g2));
          } else
            i2 && (f[i2] = a2);
        }, requirejs = require = d = function(e3, i2, r2, s2, o2) {
          if (typeof e3 == "string")
            return p[e3] ? p[e3](i2) : n(u(e3, h(i2)).f);
          if (!e3.splice) {
            if (g = e3, g.deps && d(g.deps, g.callback), !i2)
              return;
            i2.splice ? (e3 = i2, i2 = r2, r2 = null) : e3 = t;
          }
          return i2 = i2 || function() {
          }, typeof r2 == "function" && (r2 = s2, s2 = o2), s2 ? c(t, e3, i2, r2) : setTimeout(function() {
            c(t, e3, i2, r2);
          }, 4), d;
        }, d.config = function(t2) {
          return d(t2);
        }, requirejs._defined = f, define = function(t2, i2, r2) {
          if (typeof t2 != "string")
            throw new Error("See almond README: incorrect module build, no module name");
          i2.splice || (r2 = i2, i2 = []), e2(f, t2) || e2(m, t2) || (m[t2] = [t2, i2, r2]);
        }, define.amd = {jQuery: true};
      }(), define("../node_modules/almond/almond", function() {
      }), define("jxg", [], function() {
        "use strict";
        var t = {};
        return typeof JXG != "object" || JXG.extend || (t = JXG), t.extend = function(t2, e2, i, r) {
          var s, o;
          i = i || false, r = r || false;
          for (s in e2)
            (!i || i && e2.hasOwnProperty(s)) && (o = r ? s.toLowerCase() : s, t2[o] = e2[s]);
        }, t.defineConstant = function(e2, i, r, s) {
          (s = s || false) && t.exists(e2[i]) || Object.defineProperty(e2, i, {value: r, writable: false, enumerable: true, configurable: false});
        }, t.extendConstants = function(t2, e2, i, r) {
          var s, o;
          i = i || false, r = r || false;
          for (s in e2)
            (!i || i && extension.hasOwnProperty(s)) && (o = r ? s.toUpperCase() : s, this.defineConstant(t2, o, e2[s]));
        }, t.extend(t, {boards: {}, readers: {}, elements: {}, registerElement: function(t2, e2) {
          t2 = t2.toLowerCase(), this.elements[t2] = e2;
        }, registerReader: function(t2, e2) {
          var i, r;
          for (i = 0; i < e2.length; i++)
            r = e2[i].toLowerCase(), typeof this.readers[r] != "function" && (this.readers[r] = t2);
        }, shortcut: function(t2, e2) {
          return function() {
            return t2[e2].apply(this, arguments);
          };
        }, getRef: function(e2, i) {
          return t.deprecated("JXG.getRef()", "Board.select()"), e2.select(i);
        }, getReference: function(e2, i) {
          return t.deprecated("JXG.getReference()", "Board.select()"), e2.select(i);
        }, getBoardByContainerId: function(t2) {
          var e2;
          for (e2 in JXG.boards)
            if (JXG.boards.hasOwnProperty(e2) && JXG.boards[e2].container === t2)
              return JXG.boards[e2];
          return null;
        }, deprecated: function(e2, i) {
          var r = e2 + " is deprecated.";
          i && (r += " Please use " + i + " instead."), t.warn(r);
        }, warn: function(t2) {
          typeof window == "object" && window.console && console.warn ? console.warn("WARNING:", t2) : typeof document == "object" && document.getElementById("warning") && (document.getElementById("debug").innerHTML += "WARNING: " + t2 + "<br />");
        }, debugInt: function(t2) {
          var e2, i;
          for (e2 = 0; e2 < arguments.length; e2++)
            i = arguments[e2], typeof window == "object" && window.console && console.log ? console.log(i) : typeof document == "object" && document.getElementById("debug") && (document.getElementById("debug").innerHTML += i + "<br/>");
        }, debugWST: function(e2) {
          var i = new Error();
          t.debugInt.apply(this, arguments), i && i.stack && (t.debugInt("stacktrace"), t.debugInt(i.stack.split("\n").slice(1).join("\n")));
        }, debugLine: function(e2) {
          var i = new Error();
          t.debugInt.apply(this, arguments), i && i.stack && t.debugInt("Called from", i.stack.split("\n").slice(2, 3).join("\n"));
        }, debug: function(e2) {
          t.debugInt.apply(this, arguments);
        }}), t;
      }), define("base/constants", ["jxg"], function(t) {
        "use strict";
        var e2;
        return e2 = {version: "1.2.2", licenseText: "JSXGraph v1.2.2 Copyright (C) see https://jsxgraph.org", COORDS_BY_USER: 1, COORDS_BY_SCREEN: 2, OBJECT_TYPE_ARC: 1, OBJECT_TYPE_ARROW: 2, OBJECT_TYPE_AXIS: 3, OBJECT_TYPE_AXISPOINT: 4, OBJECT_TYPE_TICKS: 5, OBJECT_TYPE_CIRCLE: 6, OBJECT_TYPE_CONIC: 7, OBJECT_TYPE_CURVE: 8, OBJECT_TYPE_GLIDER: 9, OBJECT_TYPE_IMAGE: 10, OBJECT_TYPE_LINE: 11, OBJECT_TYPE_POINT: 12, OBJECT_TYPE_SLIDER: 13, OBJECT_TYPE_CAS: 14, OBJECT_TYPE_GXTCAS: 15, OBJECT_TYPE_POLYGON: 16, OBJECT_TYPE_SECTOR: 17, OBJECT_TYPE_TEXT: 18, OBJECT_TYPE_ANGLE: 19, OBJECT_TYPE_INTERSECTION: 20, OBJECT_TYPE_TURTLE: 21, OBJECT_TYPE_VECTOR: 22, OBJECT_TYPE_OPROJECT: 23, OBJECT_TYPE_GRID: 24, OBJECT_TYPE_TANGENT: 25, OBJECT_TYPE_HTMLSLIDER: 26, OBJECT_TYPE_CHECKBOX: 27, OBJECT_TYPE_INPUT: 28, OBJECT_TYPE_BUTTON: 29, OBJECT_TYPE_TRANSFORMATION: 30, OBJECT_CLASS_POINT: 1, OBJECT_CLASS_LINE: 2, OBJECT_CLASS_CIRCLE: 3, OBJECT_CLASS_CURVE: 4, OBJECT_CLASS_AREA: 5, OBJECT_CLASS_OTHER: 6, OBJECT_CLASS_TEXT: 7, GENTYPE_ABC: 1, GENTYPE_AXIS: 2, GENTYPE_MID: 3, GENTYPE_REFLECTION: 4, GENTYPE_MIRRORELEMENT: 5, GENTYPE_REFLECTION_ON_LINE: 4, GENTYPE_REFLECTION_ON_POINT: 5, GENTYPE_TANGENT: 6, GENTYPE_PARALLEL: 7, GENTYPE_BISECTORLINES: 8, GENTYPE_BOARDIMG: 9, GENTYPE_BISECTOR: 10, GENTYPE_NORMAL: 11, GENTYPE_POINT: 12, GENTYPE_GLIDER: 13, GENTYPE_INTERSECTION: 14, GENTYPE_CIRCLE: 15, GENTYPE_CIRCLE2POINTS: 16, GENTYPE_LINE: 17, GENTYPE_TRIANGLE: 18, GENTYPE_QUADRILATERAL: 19, GENTYPE_TEXT: 20, GENTYPE_POLYGON: 21, GENTYPE_REGULARPOLYGON: 22, GENTYPE_SECTOR: 23, GENTYPE_ANGLE: 24, GENTYPE_PLOT: 25, GENTYPE_SLIDER: 26, GENTYPE_TRUNCATE: 27, GENTYPE_JCODE: 28, GENTYPE_MOVEMENT: 29, GENTYPE_COMBINED: 30, GENTYPE_RULER: 31, GENTYPE_SLOPETRIANGLE: 32, GENTYPE_PERPSEGMENT: 33, GENTYPE_LABELMOVEMENT: 34, GENTYPE_VECTOR: 35, GENTYPE_NONREFLEXANGLE: 36, GENTYPE_REFLEXANGLE: 37, GENTYPE_PATH: 38, GENTYPE_DERIVATIVE: 39, GENTYPE_DELETE: 41, GENTYPE_COPY: 42, GENTYPE_MIRROR: 43, GENTYPE_ROTATE: 44, GENTYPE_ABLATION: 45, GENTYPE_MIGRATE: 46, GENTYPE_VECTORCOPY: 47, GENTYPE_POLYGONCOPY: 48, GENTYPE_CTX_TYPE_G: 51, GENTYPE_CTX_TYPE_P: 52, GENTYPE_CTX_TRACE: 53, GENTYPE_CTX_VISIBILITY: 54, GENTYPE_CTX_CCVISIBILITY: 55, GENTYPE_CTX_MPVISIBILITY: 56, GENTYPE_CTX_WITHLABEL: 57, GENTYPE_CTX_LABEL: 58, GENTYPE_CTX_FIXED: 59, GENTYPE_CTX_STROKEWIDTH: 60, GENTYPE_CTX_LABELSIZE: 61, GENTYPE_CTX_SIZE: 62, GENTYPE_CTX_FACE: 63, GENTYPE_CTX_STRAIGHT: 64, GENTYPE_CTX_ARROW: 65, GENTYPE_CTX_COLOR: 66, GENTYPE_CTX_RADIUS: 67, GENTYPE_CTX_COORDS: 68, GENTYPE_CTX_TEXT: 69, GENTYPE_CTX_ANGLERADIUS: 70, GENTYPE_CTX_DOTVISIBILITY: 71, GENTYPE_CTX_FILLOPACITY: 72, GENTYPE_CTX_PLOT: 73, GENTYPE_CTX_SCALE: 74, GENTYPE_CTX_INTVAL: 75, GENTYPE_CTX_POINT1: 76, GENTYPE_CTX_POINT2: 77, GENTYPE_CTX_LABELSTICKY: 78, GENTYPE_CTX_TYPE_I: 79, GENTYPE_CTX_HASINNERPOINTS: 80, GENTYPE_CTX_SNAPWIDTH: 81, GENTYPE_CTX_SNAPTOGRID: 82}, t.extendConstants(t, e2), e2;
      }), define("utils/type", ["jxg", "base/constants"], function(t, e2) {
        "use strict";
        return t.extend(t, {isId: function(t2, e3) {
          return typeof e3 == "string" && !!t2.objects[e3];
        }, isName: function(t2, e3) {
          return typeof e3 == "string" && !!t2.elementsByName[e3];
        }, isGroup: function(t2, e3) {
          return typeof e3 == "string" && !!t2.groups[e3];
        }, isString: function(t2) {
          return typeof t2 == "string";
        }, isNumber: function(t2) {
          return typeof t2 == "number" || Object.prototype.toString.call(t2) === "[Object Number]";
        }, isFunction: function(t2) {
          return typeof t2 == "function";
        }, isArray: function(t2) {
          return Array.isArray ? Array.isArray(t2) : t2 !== null && typeof t2 == "object" && typeof t2.splice == "function" && typeof t2.join == "function";
        }, isObject: function(t2) {
          return typeof t2 == "object" && !this.isArray(t2);
        }, isPoint: function(t2) {
          return t2 !== null && typeof t2 == "object" && t2.elementClass === e2.OBJECT_CLASS_POINT;
        }, isPointType: function(t2, e3) {
          var i, r;
          return !!this.isArray(e3) || (!!(this.isFunction(e3) && (i = e3(), this.isArray(i) && i.length > 1)) || (r = t2.select(e3), this.isPoint(r)));
        }, isTransformationOrArray: function(t2) {
          if (t2 !== null) {
            if (this.isArray(t2) && t2.length > 0)
              return this.isTransformationOrArray(t2[0]);
            if (typeof t2 == "object")
              return t2.type === e2.OBJECT_TYPE_TRANSFORMATION;
          }
          return false;
        }, exists: function(t2) {
          return function(t3, e3) {
            var i = !(t3 === void 0 || t3 === null);
            return e3 = e3 || false, e3 ? i && t3 !== "" : i;
          };
        }(), isEmpty: function(t2) {
          return Object.keys(t2).length === 0;
        }, def: function(t2, e3) {
          return this.exists(t2) ? t2 : e3;
        }, str2Bool: function(t2) {
          return !this.exists(t2) || (typeof t2 == "boolean" ? t2 : !!this.isString(t2) && t2.toLowerCase() === "true");
        }, createEvalFunction: function(e3, i, r) {
          var s, o = [];
          for (s = 0; s < r; s++)
            o[s] = t.createFunction(i[s], e3, "", true);
          return function(t2) {
            return o[t2]();
          };
        }, createFunction: function(t2, e3, i, r) {
          var s = null;
          return this.exists(r) && !r || !this.isString(t2) ? this.isFunction(t2) ? s = t2 : this.isNumber(t2) ? s = function() {
            return t2;
          } : this.isString(t2) && (s = function() {
            return t2;
          }) : s = e3.jc.snippet(t2, true, i, true), s !== null && (s.origin = t2), s;
        }, providePoints: function(t2, e3, i, r, s) {
          var o, n, a, h, l, c = 0, d = [];
          for (this.isArray(e3) || (e3 = [e3]), a = e3.length, this.exists(s) && (c = s.length), c === 0 && (h = this.copyAttributes(i, t2.options, r)), o = 0; o < a; ++o)
            if (c > 0 && (n = Math.min(o, c - 1), h = this.copyAttributes(i, t2.options, r, s[n])), this.isArray(e3[o]) && e3[o].length > 1 ? d.push(t2.create("point", e3[o], h)) : this.isFunction(e3[o]) ? (l = e3[o](), this.isArray(l) && l.length > 1 && d.push(t2.create("point", [e3[o]], h))) : d.push(t2.select(e3[o])), !this.isPoint(d[o]))
              return false;
          return d;
        }, bind: function(t2, e3) {
          return function() {
            return t2.apply(e3, arguments);
          };
        }, evaluate: function(t2) {
          return this.isFunction(t2) ? t2() : t2;
        }, indexOf: function(t2, e3, i) {
          var r, s = this.exists(i);
          if (Array.indexOf && !s)
            return t2.indexOf(e3);
          for (r = 0; r < t2.length; r++)
            if (s && t2[r][i] === e3 || !s && t2[r] === e3)
              return r;
          return -1;
        }, eliminateDuplicates: function(t2) {
          var e3, i = t2.length, r = [], s = {};
          for (e3 = 0; e3 < i; e3++)
            s[t2[e3]] = 0;
          for (e3 in s)
            s.hasOwnProperty(e3) && r.push(e3);
          return r;
        }, swap: function(t2, e3, i) {
          var r;
          return r = t2[e3], t2[e3] = t2[i], t2[i] = r, t2;
        }, uniqueArray: function(e3) {
          var i, r, s, o = [];
          if (e3.length === 0)
            return [];
          for (i = 0; i < e3.length; i++)
            if (s = this.isArray(e3[i]), this.exists(e3[i]))
              for (r = i + 1; r < e3.length; r++)
                s && t.cmpArrays(e3[i], e3[r]) ? e3[i] = [] : s || e3[i] !== e3[r] || (e3[i] = "");
            else
              e3[i] = "";
          for (r = 0, i = 0; i < e3.length; i++)
            s = this.isArray(e3[i]), s || e3[i] === "" ? s && e3[i].length !== 0 && (o[r] = e3[i].slice(0), r++) : (o[r] = e3[i], r++);
          return e3 = o, o;
        }, isInArray: function(e3, i) {
          return t.indexOf(e3, i) > -1;
        }, coordsArrayToMatrix: function(t2, e3) {
          var i, r = [], s = [];
          for (i = 0; i < t2.length; i++)
            e3 ? (r.push(t2[i].usrCoords[1]), s.push(t2[i].usrCoords[2])) : s.push([t2[i].usrCoords[1], t2[i].usrCoords[2]]);
          return e3 && (s = [r, s]), s;
        }, cmpArrays: function(t2, e3) {
          var i;
          if (t2 === e3)
            return true;
          if (t2.length !== e3.length)
            return false;
          for (i = 0; i < t2.length; i++)
            if (this.isArray(t2[i]) && this.isArray(e3[i])) {
              if (!this.cmpArrays(t2[i], e3[i]))
                return false;
            } else if (t2[i] !== e3[i])
              return false;
          return true;
        }, removeElementFromArray: function(t2, e3) {
          var i;
          for (i = 0; i < t2.length; i++)
            if (t2[i] === e3)
              return t2.splice(i, 1), t2;
          return t2;
        }, trunc: function(e3, i) {
          return i = t.def(i, 0), this.toFixed(e3, i);
        }, _decimalAdjust: function(t2, e3, i) {
          return i === void 0 || +i == 0 ? Math[t2](e3) : (e3 = +e3, i = +i, isNaN(e3) || typeof i != "number" || i % 1 != 0 ? NaN : (e3 = e3.toString().split("e"), e3 = Math[t2](+(e3[0] + "e" + (e3[1] ? +e3[1] - i : -i))), e3 = e3.toString().split("e"), +(e3[0] + "e" + (e3[1] ? +e3[1] + i : i))));
        }, _round10: function(t2, e3) {
          return this._decimalAdjust("round", t2, e3);
        }, _floor10: function(t2, e3) {
          return this._decimalAdjust("floor", t2, e3);
        }, _ceil10: function(t2, e3) {
          return this._decimalAdjust("ceil", t2, e3);
        }, toFixed: function(t2, e3) {
          return this._round10(t2, -e3).toFixed(e3);
        }, autoDigits: function(t2) {
          var e3 = Math.abs(t2);
          return e3 > 0.1 ? this.toFixed(t2, 2) : e3 >= 0.01 ? this.toFixed(t2, 4) : e3 >= 1e-4 ? this.toFixed(t2, 6) : t2;
        }, keys: function(t2, e3) {
          var i, r = [];
          for (i in t2)
            e3 ? t2.hasOwnProperty(i) && r.push(i) : r.push(i);
          return r;
        }, clone: function(t2) {
          var e3 = {};
          return e3.prototype = t2, e3;
        }, cloneAndCopy: function(t2, e3) {
          var i, r = function() {
          };
          r.prototype = t2;
          for (i in e3)
            r[i] = e3[i];
          return r;
        }, merge: function(t2, e3) {
          var i, r;
          for (i in e3)
            if (e3.hasOwnProperty(i))
              if (this.isArray(e3[i]))
                for (t2[i] || (t2[i] = []), r = 0; r < e3[i].length; r++)
                  typeof e3[i][r] == "object" ? t2[i][r] = this.merge(t2[i][r], e3[i][r]) : t2[i][r] = e3[i][r];
              else
                typeof e3[i] == "object" ? (t2[i] || (t2[i] = {}), t2[i] = this.merge(t2[i], e3[i])) : t2[i] = e3[i];
          return t2;
        }, deepCopy: function(t2, e3, i) {
          var r, s, o, n;
          if (i = i || false, typeof t2 != "object" || t2 === null)
            return t2;
          if (this.isArray(t2))
            for (r = [], s = 0; s < t2.length; s++)
              o = t2[s], typeof o == "object" ? this.exists(o.board) ? r[s] = o.id : r[s] = this.deepCopy(o) : r[s] = o;
          else {
            r = {};
            for (s in t2)
              t2.hasOwnProperty(s) && (n = i ? s.toLowerCase() : s, o = t2[s], o !== null && typeof o == "object" ? this.exists(o.board) ? r[n] = o.id : r[n] = this.deepCopy(o) : r[n] = o);
            for (s in e3)
              e3.hasOwnProperty(s) && (n = i ? s.toLowerCase() : s, o = e3[s], typeof o == "object" ? this.isArray(o) || !this.exists(r[n]) ? r[n] = this.deepCopy(o) : r[n] = this.deepCopy(r[n], o, i) : r[n] = o);
          }
          return r;
        }, copyAttributes: function(e3, i, r) {
          var s, o, n, a, h, l = {circle: 1, curve: 1, image: 1, line: 1, point: 1, polygon: 1, text: 1, ticks: 1, integral: 1};
          for (n = arguments.length, s = n < 3 || l[r] ? t.deepCopy(i.elements, null, true) : {}, n < 4 && this.exists(r) && this.exists(i.layer[r]) && (s.layer = i.layer[r]), a = i, h = true, o = 2; o < n; o++) {
            if (!this.exists(a[arguments[o]])) {
              h = false;
              break;
            }
            a = a[arguments[o]];
          }
          for (h && (s = t.deepCopy(s, a, true)), a = e3, h = true, o = 3; o < n; o++) {
            if (!this.exists(a[arguments[o]])) {
              h = false;
              break;
            }
            a = a[arguments[o]];
          }
          if (h && this.extend(s, a, null, true), arguments[2] === "board")
            return s;
          for (a = i, h = true, o = 2; o < n; o++) {
            if (!this.exists(a[arguments[o]])) {
              h = false;
              break;
            }
            a = a[arguments[o]];
          }
          return h && this.exists(a.label) && (s.label = t.deepCopy(a.label, s.label)), s.label = t.deepCopy(i.label, s.label), s;
        }, copyPrototypeMethods: function(t2, e3, i) {
          var r;
          t2.prototype[i] = e3.prototype.constructor;
          for (r in e3.prototype)
            e3.prototype.hasOwnProperty(r) && (t2.prototype[r] = e3.prototype[r]);
        }, toJSON: function(e3, i) {
          var r, s, o, n;
          if (i = t.def(i, false), JSON.stringify && !i)
            try {
              return JSON.stringify(e3);
            } catch (t2) {
            }
          switch (typeof e3) {
            case "object":
              if (e3) {
                if (r = [], this.isArray(e3)) {
                  for (o = 0; o < e3.length; o++)
                    r.push(t.toJSON(e3[o], i));
                  return "[" + r.join(",") + "]";
                }
                for (s in e3)
                  if (e3.hasOwnProperty(s)) {
                    try {
                      n = t.toJSON(e3[s], i);
                    } catch (t2) {
                      n = "";
                    }
                    i ? r.push(s + ":" + n) : r.push('"' + s + '":' + n);
                  }
                return "{" + r.join(",") + "} ";
              }
              return "null";
            case "string":
              return "'" + e3.replace(/(["'])/g, "\\$1") + "'";
            case "number":
            case "boolean":
              return e3.toString();
          }
          return "0";
        }, clearVisPropOld: function(t2) {
          return t2.visPropOld = {cssclass: "", cssdefaultstyle: "", cssstyle: "", fillcolor: "", fillopacity: "", firstarrow: false, fontsize: -1, lastarrow: false, left: -1e5, linecap: "", shadow: false, strokecolor: "", strokeopacity: "", strokewidth: "", transitionduration: 0, top: -1e5, visible: null}, t2;
        }, isInObject: function(t2, e3) {
          var i;
          for (i in t2)
            if (t2.hasOwnProperty(i) && t2[i] === e3)
              return true;
          return false;
        }, escapeHTML: function(t2) {
          return t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }, unescapeHTML: function(t2) {
          return t2.replace(/<\/?[^>]+>/gi, "").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        }, capitalize: function(t2) {
          return t2.charAt(0).toUpperCase() + t2.substring(1).toLowerCase();
        }, trimNumber: function(t2) {
          return t2 = t2.replace(/^0+/, ""), t2 = t2.replace(/0+$/, ""), t2[t2.length - 1] !== "." && t2[t2.length - 1] !== "," || (t2 = t2.slice(0, -1)), t2[0] !== "." && t2[0] !== "," || (t2 = "0" + t2), t2;
        }, filterElements: function(t2, e3) {
          var i, r, s, o, n, a, h, l = t2.length, c = [];
          if (typeof e3 != "function" && typeof e3 != "object")
            return c;
          for (i = 0; i < l; i++) {
            if (h = true, s = t2[i], typeof e3 == "object") {
              for (r in e3)
                if (e3.hasOwnProperty(r) && (o = r.toLowerCase(), n = typeof s[r] == "function" ? s[r]() : s[r], a = s.visProp && typeof s.visProp[o] == "function" ? s.visProp[o]() : s.visProp && s.visProp[o], !(h = typeof e3[r] == "function" ? e3[r](n) || e3[r](a) : n === e3[r] || a === e3[r])))
                  break;
            } else
              typeof e3 == "function" && (h = e3(s));
            h && c.push(s);
          }
          return c;
        }, trim: function(t2) {
          return t2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        }, sanitizeHTML: function(t2, e3) {
          return typeof html_sanitize == "function" && e3 ? html_sanitize(t2, function() {
          }, function(t3) {
            return t3;
          }) : (t2 && (t2 = t2.replace(/</g, "&lt;").replace(/>/g, "&gt;")), t2);
        }, evalSlider: function(t2) {
          return t2 && t2.type === e2.OBJECT_TYPE_GLIDER && typeof t2.Value == "function" ? t2.Value() : t2;
        }}), t;
      }), define("utils/env", ["jxg", "utils/type"], function(t, e2) {
        "use strict";
        return t.extendConstants(t, {touchProperty: "touches"}), t.extend(t, {isTouchEvent: function(e3) {
          return t.exists(e3[t.touchProperty]);
        }, isPointerEvent: function(e3) {
          return t.exists(e3.pointerId);
        }, isMouseEvent: function(e3) {
          return !t.isTouchEvent(e3) && !t.isPointerEvent(e3);
        }, getNumberOfTouchPoints: function(e3) {
          var i = -1;
          return t.isTouchEvent(e3) && (i = e3[t.touchProperty].length), i;
        }, isFirstTouch: function(e3) {
          var i = t.getNumberOfTouchPoints(e3);
          return t.isPointerEvent(e3) ? e3.isPrimary : i === 1;
        }, isBrowser: typeof window == "object" && typeof document == "object", supportsES6: function() {
          try {
            return new Function("(a = 0) => a"), true;
          } catch (t2) {
            return false;
          }
        }, supportsVML: function() {
          return this.isBrowser && !!document.namespaces;
        }, supportsSVG: function() {
          return this.isBrowser && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
        }, supportsCanvas: function() {
          var t2, e3 = false;
          if (this.isNode())
            try {
              t2 = typeof module == "object" ? require_browser() : require("canvas"), e3 = !!t2;
            } catch (t3) {
            }
          return e3 || this.isBrowser && !!document.createElement("canvas").getContext;
        }, isNode: function() {
          return !this.isBrowser && (typeof module == "object" && !!module.exports || typeof global == "object" && global.requirejsVars && !global.requirejsVars.isBrowser);
        }, isWebWorker: function() {
          return !this.isBrowser && typeof self == "object" && typeof self.postMessage == "function";
        }, supportsPointerEvents: function() {
          return !!(this.isBrowser && window.navigator && (window.PointerEvent || window.navigator.pointerEnabled || window.navigator.msPointerEnabled));
        }, isTouchDevice: function() {
          return this.isBrowser && window.ontouchstart !== void 0;
        }, isAndroid: function() {
          return e2.exists(navigator) && navigator.userAgent.toLowerCase().indexOf("android") > -1;
        }, isWebkitAndroid: function() {
          return this.isAndroid() && navigator.userAgent.indexOf(" AppleWebKit/") > -1;
        }, isApple: function() {
          return e2.exists(navigator) && (navigator.userAgent.indexOf("iPad") > -1 || navigator.userAgent.indexOf("iPhone") > -1);
        }, isWebkitApple: function() {
          return this.isApple() && navigator.userAgent.search(/Mobile\/[0-9A-Za-z\.]*Safari/) > -1;
        }, isMetroApp: function() {
          return typeof window == "object" && window.clientInformation && window.clientInformation.appVersion && window.clientInformation.appVersion.indexOf("MSAppHost") > -1;
        }, isMozilla: function() {
          return e2.exists(navigator) && navigator.userAgent.toLowerCase().indexOf("mozilla") > -1 && navigator.userAgent.toLowerCase().indexOf("apple") === -1;
        }, isFirefoxOS: function() {
          return e2.exists(navigator) && navigator.userAgent.toLowerCase().indexOf("android") === -1 && navigator.userAgent.toLowerCase().indexOf("apple") === -1 && navigator.userAgent.toLowerCase().indexOf("mobile") > -1 && navigator.userAgent.toLowerCase().indexOf("mozilla") > -1;
        }, ieVersion: function() {
          var t2, e3, i = 3;
          if (typeof document != "object")
            return 0;
          t2 = document.createElement("div"), e3 = t2.getElementsByTagName("i");
          do {
            t2.innerHTML = "<!--[if gt IE " + ++i + "]><i></i><![endif]-->";
          } while (e3[0]);
          return i > 4 ? i : void 0;
        }(), getDimensions: function(t2, i) {
          var r, s, o, n, a, h, l, c, d, u = /\d+(\.\d*)?px/;
          if (!this.isBrowser || t2 === null)
            return {width: 500, height: 500};
          if (i = i || document, r = i.getElementById(t2), !e2.exists(r))
            throw new Error("\nJSXGraph: HTML container element '" + t2 + "' not found.");
          return (s = r.style.display) !== "none" && s !== null ? r.clientWidth > 0 && r.clientHeight > 0 ? {width: r.clientWidth, height: r.clientHeight} : (d = window.getComputedStyle ? window.getComputedStyle(r) : r.style, {width: u.test(d.width) ? parseFloat(d.width) : 0, height: u.test(d.height) ? parseFloat(d.height) : 0}) : (o = r.style, n = o.visibility, a = o.position, h = o.display, o.visibility = "hidden", o.position = "absolute", o.display = "block", l = r.clientWidth, c = r.clientHeight, o.display = h, o.position = a, o.visibility = n, {width: l, height: c});
        }, addEvent: function(t2, i, r, s) {
          var o = function() {
            return r.apply(s, arguments);
          };
          o.origin = r, s["x_internal" + i] = s["x_internal" + i] || [], s["x_internal" + i].push(o), e2.exists(t2) && e2.exists(t2.addEventListener) && t2.addEventListener(i, o, false), e2.exists(t2) && e2.exists(t2.attachEvent) && t2.attachEvent("on" + i, o);
        }, removeEvent: function(i, r, s, o) {
          var n;
          if (!e2.exists(o))
            return void t.debug("no such owner");
          if (!e2.exists(o["x_internal" + r]))
            return void t.debug("no such type: " + r);
          if (!e2.isArray(o["x_internal" + r]))
            return void t.debug("owner[x_internal + " + r + "] is not an array");
          if ((n = e2.indexOf(o["x_internal" + r], s, "origin")) === -1)
            return void t.debug("removeEvent: no such event function in internal list: " + s);
          try {
            e2.exists(i) && e2.exists(i.removeEventListener) && i.removeEventListener(r, o["x_internal" + r][n], false), e2.exists(i) && e2.exists(i.detachEvent) && i.detachEvent("on" + r, o["x_internal" + r][n]);
          } catch (e3) {
            t.debug("event not registered in browser: (" + r + " -- " + s + ")");
          }
          o["x_internal" + r].splice(n, 1);
        }, removeAllEvents: function(e3, i, r) {
          var s, o;
          if (r["x_internal" + i]) {
            for (o = r["x_internal" + i].length, s = o - 1; s >= 0; s--)
              t.removeEvent(e3, i, r["x_internal" + i][s].origin, r);
            r["x_internal" + i].length > 0 && t.debug("removeAllEvents: Not all events could be removed.");
          }
        }, getPosition: function(i, r, s) {
          var o, n, a, h = 0, l = 0;
          if (i || (i = window.event), s = s || document, a = i[t.touchProperty], e2.exists(a) && a.length === 0 && (a = i.changedTouches), e2.exists(r) && e2.exists(a))
            if (r === -1) {
              for (n = a.length, o = 0; o < n; o++)
                if (a[o]) {
                  i = a[o];
                  break;
                }
            } else
              i = a[r];
          return i.clientX && (h = i.clientX, l = i.clientY), [h, l];
        }, getOffset: function(t2) {
          var e3, i = t2, r = t2, s = i.offsetLeft - i.scrollLeft, o = i.offsetTop - i.scrollTop;
          for (e3 = this.getCSSTransform([s, o], i), s = e3[0], o = e3[1], i = i.offsetParent; i; ) {
            for (s += i.offsetLeft, o += i.offsetTop, i.offsetParent && (s += i.clientLeft - i.scrollLeft, o += i.clientTop - i.scrollTop), e3 = this.getCSSTransform([s, o], i), s = e3[0], o = e3[1], r = r.parentNode; r !== i; )
              s += r.clientLeft - r.scrollLeft, o += r.clientTop - r.scrollTop, e3 = this.getCSSTransform([s, o], r), s = e3[0], o = e3[1], r = r.parentNode;
            i = i.offsetParent;
          }
          return [s, o];
        }, getStyle: function(e3, i) {
          var r, s = e3.ownerDocument;
          return s.defaultView && s.defaultView.getComputedStyle ? r = s.defaultView.getComputedStyle(e3, null).getPropertyValue(i) : e3.currentStyle && t.ieVersion >= 9 ? r = e3.currentStyle[i] : e3.style && (i = i.replace(/-([a-z]|[0-9])/gi, function(t2, e4) {
            return e4.toUpperCase();
          }), r = e3.style[i]), r;
        }, getProp: function(t2, e3) {
          var i = parseInt(this.getStyle(t2, e3), 10);
          return isNaN(i) ? 0 : i;
        }, getCSSTransform: function(t2, i) {
          var r, s, o, n, a, h, l, c, d = ["transform", "webkitTransform", "MozTransform", "msTransform", "oTransform"];
          for (h = d.length, r = 0, o = ""; r < h; r++)
            if (e2.exists(i.style[d[r]])) {
              o = i.style[d[r]];
              break;
            }
          if (o !== "" && (a = o.indexOf("(")) > 0) {
            for (h = o.length, n = o.substring(a + 1, h - 1), c = n.split(","), s = 0, l = c.length; s < l; s++)
              c[s] = parseFloat(c[s]);
            o.indexOf("matrix") === 0 ? (t2[0] += c[4], t2[1] += c[5]) : o.indexOf("translateX") === 0 ? t2[0] += c[0] : o.indexOf("translateY") === 0 ? t2[1] += c[0] : o.indexOf("translate") === 0 && (t2[0] += c[0], t2[1] += c[1]);
          }
          return e2.exists(i.style.zoom) && (o = i.style.zoom) !== "" && (t2[0] *= parseFloat(o), t2[1] *= parseFloat(o)), t2;
        }, getCSSTransformMatrix: function(t2) {
          var i, r, s, o, n, a, h, l, c, d = t2.ownerDocument, u = ["transform", "webkitTransform", "MozTransform", "msTransform", "oTransform"], p = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
          if (d.defaultView && d.defaultView.getComputedStyle)
            c = d.defaultView.getComputedStyle(t2, null), s = c.getPropertyValue("-webkit-transform") || c.getPropertyValue("-moz-transform") || c.getPropertyValue("-ms-transform") || c.getPropertyValue("-o-transform") || c.getPropertyValue("transform");
          else
            for (a = u.length, i = 0, s = ""; i < a; i++)
              if (e2.exists(t2.style[u[i]])) {
                s = t2.style[u[i]];
                break;
              }
          if (s !== "" && (n = s.indexOf("(")) > 0) {
            for (a = s.length, o = s.substring(n + 1, a - 1), l = o.split(","), r = 0, h = l.length; r < h; r++)
              l[r] = parseFloat(l[r]);
            s.indexOf("matrix") === 0 ? p = [[1, 0, 0], [0, l[0], l[1]], [0, l[2], l[3]]] : s.indexOf("scaleX") === 0 ? p[1][1] = l[0] : s.indexOf("scaleY") === 0 ? p[2][2] = l[0] : s.indexOf("scale") === 0 && (p[1][1] = l[0], p[2][2] = l[1]);
          }
          return e2.exists(t2.style.zoom) && (s = t2.style.zoom) !== "" && (p[1][1] *= parseFloat(s), p[2][2] *= parseFloat(s)), p;
        }, timedChunk: function(t2, e3, i, r) {
          var s = t2.concat(), o = function() {
            var n = +new Date();
            do {
              e3.call(i, s.shift());
            } while (s.length > 0 && +new Date() - n < 300);
            s.length > 0 ? window.setTimeout(o, 1) : r(t2);
          };
          window.setTimeout(o, 1);
        }, scaleJSXGraphDiv: function(t2, e3, i, r) {
          var s, o, n = document.styleSheets.length, a = [":-webkit-full-screen", ":-moz-full-screen", ":fullscreen", ":-ms-fullscreen"], h = a.length, l = "{margin:0 auto;transform:matrix(" + i + ",0,0," + i + ",0," + r + ");}", c = new RegExp(".*" + t2 + ":.*full.*screen.*" + e3 + ".*auto;.*transform:.*matrix");
          for (n === 0 && (s = document.createElement("style"), s.appendChild(document.createTextNode("")), document.body.appendChild(s), n = document.styleSheets.length), document.styleSheets[n - 1].cssRules.length > 0 && c.test(document.styleSheets[n - 1].cssRules[0].cssText) && document.styleSheets[n - 1].deleteRule && document.styleSheets[n - 1].deleteRule(0), o = 0; o < h; o++)
            try {
              document.styleSheets[n - 1].insertRule(t2 + a[o] + " " + e3 + l, 0);
              break;
            } catch (t3) {
              console.log('JXG.scaleJSXGraphDiv: Could not add CSS rule "' + a[o] + '".'), console.log("One possible reason could be that the id of the JSXGraph container does not start with a letter.");
            }
        }, toFullscreen: function(t2, e3, i) {
          var r = document.getElementById(t2), s = document.getElementById(e3), o = parseInt(s.style.height, 10), n = window.screen.width / parseInt(s.style.width, 10), a = window.screen.height / parseInt(s.style.height, 10), h = 0.5 * (window.screen.height - o);
          i = i || Math.min(n, a), window.matchMedia && window.matchMedia("(orientation:landscape)").matches && window.screen.width < window.screen.height && (n = window.screen.height / parseInt(s.style.width, 10), a = window.screen.width / parseInt(s.style.height, 10), i = Math.min(n, a), h = 0.5 * (window.screen.width - o)), i *= 0.85, this.scaleJSXGraphDiv("#" + t2, "#" + e3, i, h), r.requestFullscreen = r.requestFullscreen || r.webkitRequestFullscreen || r.mozRequestFullScreen || r.msRequestFullscreen, r.requestFullscreen && r.requestFullscreen();
        }}), t;
      }), define("utils/xml", ["jxg", "utils/type"], function(t, e2) {
        "use strict";
        return t.XML = {cleanWhitespace: function(t2) {
          for (var i = t2.firstChild; e2.exists(i); )
            i.nodeType !== 3 || /\S/.test(i.nodeValue) ? i.nodeType === 1 && this.cleanWhitespace(i) : t2.removeChild(i), i = i.nextSibling;
        }, parse: function(t2) {
          var e3, i, r;
          return r = typeof DOMParser == "function" || typeof DOMParser == "object" ? DOMParser : function() {
            this.parseFromString = function(t3) {
              var e4;
              return typeof ActiveXObject == "function" && (e4 = new ActiveXObject("MSXML.DomDocument"), e4.loadXML(t3)), e4;
            };
          }, e3 = new r(), i = e3.parseFromString(t2, "text/xml"), this.cleanWhitespace(i), i;
        }}, t.XML;
      }), define("utils/event", ["jxg", "utils/type"], function(t, e2) {
        "use strict";
        return t.EventEmitter = {eventHandlers: {}, suspended: {}, trigger: function(t2, e3) {
          var i, r, s, o, n, a;
          for (n = t2.length, r = 0; r < n; r++)
            if (o = this.eventHandlers[t2[r]], !this.suspended[t2[r]]) {
              if (this.suspended[t2[r]] = true, o)
                for (a = o.length, i = 0; i < a; i++)
                  s = o[i], s.handler.apply(s.context, e3);
              this.suspended[t2[r]] = false;
            }
          return this;
        }, on: function(t2, i, r) {
          return e2.isArray(this.eventHandlers[t2]) || (this.eventHandlers[t2] = []), r = e2.def(r, this), this.eventHandlers[t2].push({handler: i, context: r}), this;
        }, off: function(t2, i) {
          var r;
          return t2 && e2.isArray(this.eventHandlers[t2]) ? (i ? (r = e2.indexOf(this.eventHandlers[t2], i, "handler"), r > -1 && this.eventHandlers[t2].splice(r, 1), this.eventHandlers[t2].length === 0 && delete this.eventHandlers[t2]) : delete this.eventHandlers[t2], this) : this;
        }, eventify: function(t2) {
          t2.eventHandlers = {}, t2.on = this.on, t2.off = this.off, t2.triggerEventHandlers = this.trigger, t2.trigger = this.trigger, t2.suspended = {};
        }}, t.EventEmitter;
      }), define("math/math", ["jxg", "utils/type"], function(t, e2) {
        "use strict";
        var i = function(t2) {
          var e3, i2;
          return t2.memo ? t2.memo : (e3 = {}, i2 = Array.prototype.join, t2.memo = function() {
            var r = i2.call(arguments);
            return e3[r] !== void 0 ? e3[r] : e3[r] = t2.apply(this, arguments);
          }, t2.memo);
        };
        return t.Math = {eps: 1e-6, relDif: function(t2, e3) {
          var i2 = Math.abs(t2), r = Math.abs(e3);
          return r = Math.max(i2, r), r === 0 ? 0 : Math.abs(t2 - e3) / r;
        }, mod: function(t2, e3) {
          return t2 - Math.floor(t2 / e3) * e3;
        }, vector: function(t2, e3) {
          var i2, r;
          for (e3 = e3 || 0, i2 = [], r = 0; r < t2; r++)
            i2[r] = e3;
          return i2;
        }, matrix: function(t2, e3, i2) {
          var r, s, o;
          for (i2 = i2 || 0, e3 = e3 || t2, r = [], s = 0; s < t2; s++)
            for (r[s] = [], o = 0; o < e3; o++)
              r[s][o] = i2;
          return r;
        }, identity: function(t2, e3) {
          var i2, r;
          for (e3 === void 0 && typeof e3 != "number" && (e3 = t2), i2 = this.matrix(t2, e3), r = 0; r < Math.min(t2, e3); r++)
            i2[r][r] = 1;
          return i2;
        }, frustum: function(t2, e3, i2, r, s, o) {
          var n = this.matrix(4, 4);
          return n[0][0] = 2 * s / (e3 - t2), n[0][1] = 0, n[0][2] = (e3 + t2) / (e3 - t2), n[0][3] = 0, n[1][0] = 0, n[1][1] = 2 * s / (r - i2), n[1][2] = (r + i2) / (r - i2), n[1][3] = 0, n[2][0] = 0, n[2][1] = 0, n[2][2] = -(o + s) / (o - s), n[2][3] = -o * s * 2 / (o - s), n[3][0] = 0, n[3][1] = 0, n[3][2] = -1, n[3][3] = 0, n;
        }, projection: function(t2, e3, i2, r) {
          var s = i2 * Math.tan(t2 / 2), o = s * e3;
          return this.frustum(-o, o, -s, s, i2, r);
        }, matVecMult: function(t2, e3) {
          var i2, r, s, o = t2.length, n = e3.length, a = [];
          if (n === 3)
            for (i2 = 0; i2 < o; i2++)
              a[i2] = t2[i2][0] * e3[0] + t2[i2][1] * e3[1] + t2[i2][2] * e3[2];
          else
            for (i2 = 0; i2 < o; i2++) {
              for (r = 0, s = 0; s < n; s++)
                r += t2[i2][s] * e3[s];
              a[i2] = r;
            }
          return a;
        }, matMatMult: function(t2, e3) {
          var i2, r, s, o, n = t2.length, a = n > 0 ? e3[0].length : 0, h = e3.length, l = this.matrix(n, a);
          for (i2 = 0; i2 < n; i2++)
            for (r = 0; r < a; r++) {
              for (s = 0, o = 0; o < h; o++)
                s += t2[i2][o] * e3[o][r];
              l[i2][r] = s;
            }
          return l;
        }, transpose: function(t2) {
          var e3, i2, r, s, o;
          for (s = t2.length, o = t2.length > 0 ? t2[0].length : 0, e3 = this.matrix(o, s), i2 = 0; i2 < o; i2++)
            for (r = 0; r < s; r++)
              e3[i2][r] = t2[r][i2];
          return e3;
        }, inverse: function(t2) {
          var e3, i2, r, s, o, n, a, h = t2.length, l = [], c = [], d = [];
          for (e3 = 0; e3 < h; e3++) {
            for (l[e3] = [], i2 = 0; i2 < h; i2++)
              l[e3][i2] = t2[e3][i2];
            c[e3] = e3;
          }
          for (i2 = 0; i2 < h; i2++) {
            for (o = Math.abs(l[i2][i2]), n = i2, e3 = i2 + 1; e3 < h; e3++)
              Math.abs(l[e3][i2]) > o && (o = Math.abs(l[e3][i2]), n = e3);
            if (o <= this.eps)
              return [];
            if (n > i2) {
              for (r = 0; r < h; r++)
                a = l[i2][r], l[i2][r] = l[n][r], l[n][r] = a;
              a = c[i2], c[i2] = c[n], c[n] = a;
            }
            for (s = 1 / l[i2][i2], e3 = 0; e3 < h; e3++)
              l[e3][i2] *= s;
            for (l[i2][i2] = s, r = 0; r < h; r++)
              if (r !== i2) {
                for (e3 = 0; e3 < h; e3++)
                  e3 !== i2 && (l[e3][r] -= l[e3][i2] * l[i2][r]);
                l[i2][r] = -s * l[i2][r];
              }
          }
          for (e3 = 0; e3 < h; e3++) {
            for (r = 0; r < h; r++)
              d[c[r]] = l[e3][r];
            for (r = 0; r < h; r++)
              l[e3][r] = d[r];
          }
          return l;
        }, innerProduct: function(t2, i2, r) {
          var s, o = 0;
          for (r !== void 0 && e2.isNumber(r) || (r = t2.length), s = 0; s < r; s++)
            o += t2[s] * i2[s];
          return o;
        }, crossProduct: function(t2, e3) {
          return [t2[1] * e3[2] - t2[2] * e3[1], t2[2] * e3[0] - t2[0] * e3[2], t2[0] * e3[1] - t2[1] * e3[0]];
        }, norm: function(t2, i2) {
          var r, s = 0;
          for (i2 !== void 0 && e2.isNumber(i2) || (i2 = t2.length), r = 0; r < i2; r++)
            s += t2[r] * t2[r];
          return Math.sqrt(s);
        }, factorial: i(function(t2) {
          return t2 < 0 ? NaN : (t2 = Math.floor(t2), t2 === 0 || t2 === 1 ? 1 : t2 * this.factorial(t2 - 1));
        }), binomial: i(function(t2, e3) {
          var i2, r;
          if (e3 > t2 || e3 < 0)
            return NaN;
          if (e3 = Math.round(e3), t2 = Math.round(t2), e3 === 0 || e3 === t2)
            return 1;
          for (i2 = 1, r = 0; r < e3; r++)
            i2 *= t2 - r, i2 /= r + 1;
          return i2;
        }), cosh: Math.cosh || function(t2) {
          return 0.5 * (Math.exp(t2) + Math.exp(-t2));
        }, sinh: Math.sinh || function(t2) {
          return 0.5 * (Math.exp(t2) - Math.exp(-t2));
        }, cot: function(t2) {
          return 1 / Math.tan(t2);
        }, acot: function(t2) {
          return (t2 >= 0 ? 0.5 : -0.5) * Math.PI - Math.atan(t2);
        }, nthroot: function(t2, e3) {
          var i2 = 1 / e3;
          return e3 <= 0 || Math.floor(e3) !== e3 ? NaN : t2 === 0 ? 0 : t2 > 0 ? Math.exp(i2 * Math.log(t2)) : e3 % 2 == 1 ? -Math.exp(i2 * Math.log(-t2)) : NaN;
        }, cbrt: Math.cbrt || function(t2) {
          return this.nthroot(t2, 3);
        }, pow: function(t2, e3) {
          return t2 === 0 ? e3 === 0 ? 1 : 0 : Math.floor(e3) === e3 ? Math.pow(t2, e3) : t2 > 0 ? Math.exp(e3 * Math.log(t2)) : NaN;
        }, ratpow: function(t2, e3, i2) {
          var r;
          return e3 === 0 ? 1 : i2 === 0 ? NaN : (r = this.gcd(e3, i2), this.nthroot(this.pow(t2, e3 / r), i2 / r));
        }, log10: function(t2) {
          return Math.log(t2) / Math.log(10);
        }, log2: function(t2) {
          return Math.log(t2) / Math.log(2);
        }, log: function(t2, i2) {
          return i2 !== void 0 && e2.isNumber(i2) ? Math.log(t2) / Math.log(i2) : Math.log(t2);
        }, sign: Math.sign || function(t2) {
          return t2 = +t2, t2 === 0 || isNaN(t2) ? t2 : t2 > 0 ? 1 : -1;
        }, squampow: function(t2, e3) {
          var i2;
          if (Math.floor(e3) === e3) {
            for (i2 = 1, e3 < 0 && (t2 = 1 / t2, e3 *= -1); e3 !== 0; )
              1 & e3 && (i2 *= t2), e3 >>= 1, t2 *= t2;
            return i2;
          }
          return this.pow(t2, e3);
        }, gcd: function(t2, i2) {
          if (t2 = Math.abs(t2), i2 = Math.abs(i2), !e2.isNumber(t2) || !e2.isNumber(i2))
            return NaN;
          if (i2 > t2) {
            var r = t2;
            t2 = i2, i2 = r;
          }
          for (; ; ) {
            if ((t2 %= i2) === 0)
              return i2;
            if ((i2 %= t2) === 0)
              return t2;
          }
        }, lcm: function(t2, i2) {
          var r;
          return e2.isNumber(t2) && e2.isNumber(i2) ? (r = t2 * i2, r !== 0 ? r / this.gcd(t2, i2) : 0) : NaN;
        }, normalize: function(t2) {
          var e3, i2, r = 2 * t2[3], s = t2[4] / r;
          return t2[5] = s, t2[6] = -t2[1] / r, t2[7] = -t2[2] / r, isFinite(s) ? Math.abs(s) >= 1 ? (t2[0] = (t2[6] * t2[6] + t2[7] * t2[7] - s * s) / (2 * s), t2[1] = -t2[6] / s, t2[2] = -t2[7] / s, t2[3] = 1 / (2 * s), t2[4] = 1) : (i2 = s <= 0 ? -1 : 1, t2[0] = i2 * (t2[6] * t2[6] + t2[7] * t2[7] - s * s) * 0.5, t2[1] = -i2 * t2[6], t2[2] = -i2 * t2[7], t2[3] = i2 / 2, t2[4] = i2 * s) : (e3 = Math.sqrt(t2[1] * t2[1] + t2[2] * t2[2]), t2[0] /= e3, t2[1] /= e3, t2[2] /= e3, t2[3] = 0, t2[4] = 1), t2;
        }, toGL: function(t2) {
          var e3, i2, r;
          if (e3 = typeof Float32Array == "function" ? new Float32Array(16) : new Array(16), t2.length !== 4 && t2[0].length !== 4)
            return e3;
          for (i2 = 0; i2 < 4; i2++)
            for (r = 0; r < 4; r++)
              e3[i2 + 4 * r] = t2[i2][r];
          return e3;
        }}, t.Math;
      }), define("base/coords", ["jxg", "base/constants", "utils/event", "utils/type", "math/math"], function(t, e2, i, r, s) {
        "use strict";
        return t.Coords = function(t2, e3, s2, o) {
          this.board = s2, this.usrCoords = [], this.scrCoords = [], this.emitter = !r.exists(o) || o, this.emitter && i.eventify(this), this.setCoordinates(t2, e3, false, true);
        }, t.extend(t.Coords.prototype, {normalizeUsrCoords: function() {
          Math.abs(this.usrCoords[0]) > s.eps && (this.usrCoords[1] /= this.usrCoords[0], this.usrCoords[2] /= this.usrCoords[0], this.usrCoords[0] = 1);
        }, usr2screen: function(t2) {
          var e3 = Math.round, i2 = this.board, r2 = this.usrCoords, s2 = i2.origin.scrCoords;
          t2 === true ? (this.scrCoords[0] = e3(r2[0]), this.scrCoords[1] = e3(r2[0] * s2[1] + r2[1] * i2.unitX), this.scrCoords[2] = e3(r2[0] * s2[2] - r2[2] * i2.unitY)) : (this.scrCoords[0] = r2[0], this.scrCoords[1] = r2[0] * s2[1] + r2[1] * i2.unitX, this.scrCoords[2] = r2[0] * s2[2] - r2[2] * i2.unitY);
        }, screen2usr: function() {
          var t2 = this.board.origin.scrCoords, e3 = this.scrCoords, i2 = this.board;
          this.usrCoords[0] = 1, this.usrCoords[1] = (e3[1] - t2[1]) / i2.unitX, this.usrCoords[2] = (t2[2] - e3[2]) / i2.unitY;
        }, distance: function(t2, i2) {
          var r2, o, n = 0, a = this.usrCoords, h = this.scrCoords;
          if (t2 === e2.COORDS_BY_USER) {
            if (r2 = i2.usrCoords, o = a[0] - r2[0], (n = o * o) > s.eps * s.eps)
              return Number.POSITIVE_INFINITY;
            o = a[1] - r2[1], n += o * o, o = a[2] - r2[2], n += o * o;
          } else
            r2 = i2.scrCoords, o = h[1] - r2[1], n += o * o, o = h[2] - r2[2], n += o * o;
          return Math.sqrt(n);
        }, setCoordinates: function(t2, i2, r2, s2) {
          var o = this.usrCoords, n = this.scrCoords, a = [o[0], o[1], o[2]], h = [n[0], n[1], n[2]];
          return t2 === e2.COORDS_BY_USER ? (i2.length === 2 ? (o[0] = 1, o[1] = i2[0], o[2] = i2[1]) : (o[0] = i2[0], o[1] = i2[1], o[2] = i2[2], this.normalizeUsrCoords()), this.usr2screen(r2)) : (i2.length === 2 ? (n[1] = i2[0], n[2] = i2[1]) : (n[1] = i2[1], n[2] = i2[2]), this.screen2usr()), !this.emitter || s2 || h[1] === n[1] && h[2] === n[2] || this.triggerEventHandlers(["update"], [a, h]), this;
        }, copy: function(t2, e3) {
          return e3 === void 0 && (e3 = 0), this[t2].slice(e3);
        }, isReal: function() {
          return !isNaN(this.usrCoords[1] + this.usrCoords[2]) && Math.abs(this.usrCoords[0]) > s.eps;
        }, __evt__update: function(t2, e3) {
        }, __evt: function() {
        }}), t.Coords;
      }), define("utils/expect", ["jxg", "utils/type", "base/constants", "base/coords"], function(t, e2, i, r) {
        "use strict";
        var s = {each: function(t2, i2, r2) {
          var s2, o, n = [];
          if (e2.exists(t2.length))
            for (o = t2.length, s2 = 0; s2 < o; s2++)
              n.push(i2.call(this, t2[s2], r2));
          return n;
        }, coords: function(t2, e3) {
          var s2 = t2;
          return t2 && t2.elementClass === i.OBJECT_CLASS_POINT ? s2 = t2.coords : t2.usrCoords && t2.scrCoords && t2.usr2screen && (s2 = t2), e3 && (s2 = new r(i.COORDS_BY_USER, s2.usrCoords, s2.board)), s2;
        }, coordsArray: function(t2, i2) {
          var r2;
          return r2 = e2.isArray(t2) ? t2 : this.coords(t2).usrCoords, r2.length < 3 && r2.unshift(1), i2 && (r2 = [r2[0], r2[1], r2[2]]), r2;
        }};
        return t.Expect = s, s;
      }), define("math/ia", ["jxg", "math/math", "utils/type"], function(t, e2, i) {
        "use strict";
        t.Math.DoubleBits = function() {
          var t2, e3, i2, r2, s2, o, n, a, h = new Float64Array(1), l = new Uint32Array(h.buffer);
          Float64Array !== void 0 && (h[0] = 1, true, l[1] === 1072693248 ? (t2 = function(t3) {
            return h[0] = t3, [l[0], l[1]];
          }, e3 = function(t3, e4) {
            return l[0] = t3, l[1] = e4, h[0];
          }, i2 = function(t3) {
            return h[0] = t3, l[0];
          }, r2 = function(t3) {
            return h[0] = t3, l[1];
          }, this.doubleBits = t2, this.pack = e3, this.lo = i2, this.hi = r2) : l[0] === 1072693248 && (s2 = function(t3) {
            return h[0] = t3, [l[1], l[0]];
          }, o = function(t3, e4) {
            return l[1] = t3, l[0] = e4, h[0];
          }, n = function(t3) {
            return h[0] = t3, l[1];
          }, a = function(t3) {
            return h[0] = t3, l[0];
          }, this.doubleBits = s2, this.pack = o, this.lo = n, this.hi = a));
        }, t.extend(t.Math.DoubleBits.prototype, {sign: function(t2) {
          return this.hi(t2) >>> 31;
        }, exponent: function(t2) {
          return (this.hi(t2) << 1 >>> 21) - 1023;
        }, fraction: function(t2) {
          var e3 = this.lo(t2), i2 = this.hi(t2), r2 = 1048575 & i2;
          return 2146435072 & i2 && (r2 += 1 << 20), [e3, r2];
        }, denormalized: function(t2) {
          return !(2146435072 & this.hi(t2));
        }});
        var r = new t.Math.DoubleBits(), s = function(t2, i2) {
          if (t2 !== void 0 && i2 !== void 0) {
            if (e2.IntervalArithmetic.isInterval(t2)) {
              if (!e2.IntervalArithmetic.isSingleton(t2))
                throw new TypeError("JXG.Math.IntervalArithmetic: interval `lo` must be a singleton");
              this.lo = t2.lo;
            } else
              this.lo = t2;
            if (e2.IntervalArithmetic.isInterval(i2)) {
              if (!e2.IntervalArithmetic.isSingleton(i2))
                throw new TypeError("JXG.Math.IntervalArithmetic: interval `hi` must be a singleton");
              this.hi = i2.hi;
            } else
              this.hi = i2;
          } else {
            if (t2 !== void 0)
              return Array.isArray(t2) ? new s(t2[0], t2[1]) : new s(t2, t2);
            this.lo = this.hi = 0;
          }
        };
        return t.extend(s.prototype, {print: function() {
          console.log("[", this.lo, this.hi, "]");
        }, set: function(t2, e3) {
          return this.lo = t2, this.hi = e3, this;
        }, bounded: function(t2, i2) {
          return this.set(e2.IntervalArithmetic.prev(t2), e2.IntervalArithmetic.next(i2));
        }, boundedSingleton: function(t2) {
          return this.bounded(t2, t2);
        }, assign: function(t2, e3) {
          if (typeof t2 != "number" || typeof e3 != "number")
            throw new TypeError("JXG.Math.Interval#assign: arguments must be numbers");
          return isNaN(t2) || isNaN(e3) || t2 > e3 ? this.setEmpty() : this.set(t2, e3);
        }, setEmpty: function() {
          return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
        }, setWhole: function() {
          return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
        }, open: function(t2, i2) {
          return this.assign(e2.IntervalArithmetic.next(t2), e2.IntervalArithmetic.prev(i2));
        }, halfOpenLeft: function(t2, i2) {
          return this.assign(e2.IntervalArithmetic.next(t2), i2);
        }, halfOpenRight: function(t2, i2) {
          return this.assign(t2, e2.IntervalArithmetic.prev(i2));
        }, toArray: function() {
          return [this.lo, this.hi];
        }, clone: function() {
          return new s().set(this.lo, this.hi);
        }}), t.Math.IntervalArithmetic = {Interval: function(t2, e3) {
          return new s(t2, e3);
        }, isInterval: function(t2) {
          return t2 !== null && typeof t2 == "object" && typeof t2.lo == "number" && typeof t2.hi == "number";
        }, isSingleton: function(t2) {
          return t2.lo === t2.hi;
        }, add: function(t2, e3) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), new s(this.addLo(t2.lo, e3.lo), this.addHi(t2.hi, e3.hi));
        }, sub: function(t2, e3) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), new s(this.subLo(t2.lo, e3.hi), this.subHi(t2.hi, e3.lo));
        }, mul: function(t2, e3) {
          var r2, o, n, a, h;
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), this.isEmpty(t2) || this.isEmpty(e3) ? this.EMPTY.clone() : (r2 = t2.lo, o = t2.hi, n = e3.lo, a = e3.hi, h = new s(), r2 < 0 ? o > 0 ? n < 0 ? a > 0 ? (h.lo = Math.min(this.mulLo(r2, a), this.mulLo(o, n)), h.hi = Math.max(this.mulHi(r2, n), this.mulHi(o, a))) : (h.lo = this.mulLo(o, n), h.hi = this.mulHi(r2, n)) : a > 0 ? (h.lo = this.mulLo(r2, a), h.hi = this.mulHi(o, a)) : (h.lo = 0, h.hi = 0) : n < 0 ? a > 0 ? (h.lo = this.mulLo(r2, a), h.hi = this.mulHi(r2, n)) : (h.lo = this.mulLo(o, a), h.hi = this.mulHi(r2, n)) : a > 0 ? (h.lo = this.mulLo(r2, a), h.hi = this.mulHi(o, n)) : (h.lo = 0, h.hi = 0) : o > 0 ? n < 0 ? a > 0 ? (h.lo = this.mulLo(o, n), h.hi = this.mulHi(o, a)) : (h.lo = this.mulLo(o, n), h.hi = this.mulHi(r2, a)) : a > 0 ? (h.lo = this.mulLo(r2, n), h.hi = this.mulHi(o, a)) : (h.lo = 0, h.hi = 0) : (h.lo = 0, h.hi = 0), h);
        }, div: function(t2, e3) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), this.isEmpty(t2) || this.isEmpty(e3) ? this.EMPTY.clone() : this.zeroIn(e3) ? e3.lo !== 0 ? e3.hi !== 0 ? this.divZero(t2) : this.divNegative(t2, e3.lo) : e3.hi !== 0 ? this.divPositive(t2, e3.hi) : this.EMPTY.clone() : this.divNonZero(t2, e3);
        }, positive: function(t2) {
          return new s(t2.lo, t2.hi);
        }, negative: function(t2) {
          return i.isNumber(t2) ? new s(-t2) : new s(-t2.hi, -t2.lo);
        }, isEmpty: function(t2) {
          return t2.lo > t2.hi;
        }, isWhole: function(t2) {
          return t2.lo === -1 / 0 && t2.hi === 1 / 0;
        }, zeroIn: function(t2) {
          return this.hasValue(t2, 0);
        }, hasValue: function(t2, e3) {
          return !this.isEmpty(t2) && (t2.lo <= e3 && e3 <= t2.hi);
        }, hasInterval: function(t2, e3) {
          return !!this.isEmpty(t2) || !this.isEmpty(e3) && e3.lo <= t2.lo && t2.hi <= e3.hi;
        }, intervalsOverlap: function(t2, e3) {
          return !this.isEmpty(t2) && !this.isEmpty(e3) && (t2.lo <= e3.lo && e3.lo <= t2.hi || e3.lo <= t2.lo && t2.lo <= e3.hi);
        }, divNonZero: function(t2, e3) {
          var i2 = t2.lo, r2 = t2.hi, o = e3.lo, n = e3.hi, a = new s();
          return r2 < 0 ? n < 0 ? (a.lo = this.divLo(r2, o), a.hi = this.divHi(i2, n)) : (a.lo = this.divLo(i2, o), a.hi = this.divHi(r2, n)) : i2 < 0 ? n < 0 ? (a.lo = this.divLo(r2, n), a.hi = this.divHi(i2, n)) : (a.lo = this.divLo(i2, o), a.hi = this.divHi(r2, o)) : n < 0 ? (a.lo = this.divLo(r2, n), a.hi = this.divHi(i2, o)) : (a.lo = this.divLo(i2, n), a.hi = this.divHi(r2, o)), a;
        }, divPositive: function(t2, e3) {
          return t2.lo === 0 && t2.hi === 0 ? t2 : this.zeroIn(t2) ? this.WHOLE : t2.hi < 0 ? new s(Number.NEGATIVE_INFINITY, this.divHi(t2.hi, e3)) : new s(this.divLo(t2.lo, e3), Number.POSITIVE_INFINITY);
        }, divNegative: function(t2, e3) {
          return t2.lo === 0 && t2.hi === 0 ? t2 : this.zeroIn(t2) ? this.WHOLE : t2.hi < 0 ? new s(this.divLo(t2.hi, e3), Number.POSITIVE_INFINITY) : new s(Number.NEGATIVE_INFINITY, this.divHi(t2.lo, e3));
        }, divZero: function(t2) {
          return t2.lo === 0 && t2.hi === 0 ? t2 : this.WHOLE;
        }, fmod: function(t2, e3) {
          var r2, o;
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), this.isEmpty(t2) || this.isEmpty(e3) ? this.EMPTY.clone() : (r2 = t2.lo < 0 ? e3.lo : e3.hi, o = t2.lo / r2, o = o < 0 ? Math.ceil(o) : Math.floor(o), this.sub(t2, this.mul(e3, new s(o))));
        }, multiplicativeInverse: function(t2) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) ? this.EMPTY.clone() : this.zeroIn(t2) ? t2.lo !== 0 ? t2.hi !== 0 ? this.WHOLE : new s(Number.NEGATIVE_INFINITY, this.divHi(1, t2.lo)) : t2.hi !== 0 ? new s(this.divLo(1, t2.hi), Number.POSITIVE_INFINITY) : this.EMPTY.clone() : new s(this.divLo(1, t2.hi), this.divHi(1, t2.lo));
        }, pow: function(t2, e3) {
          var r2, o;
          if (i.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2))
            return this.EMPTY.clone();
          if (this.isInterval(e3)) {
            if (!this.isSingleton(e3))
              return this.EMPTY.clone();
            e3 = e3.lo;
          }
          return e3 === 0 ? t2.lo === 0 && t2.hi === 0 ? this.EMPTY.clone() : this.ONE.clone() : e3 < 0 ? this.pow(this.multiplicativeInverse(t2), -e3) : e3 % 1 == 0 ? t2.hi < 0 ? (r2 = this.powLo(-t2.hi, e3), o = this.powHi(-t2.lo, e3), (1 & e3) == 1 ? new s(-o, -r2) : new s(r2, o)) : t2.lo < 0 ? (1 & e3) == 1 ? new s(-this.powLo(-t2.lo, e3), this.powHi(t2.hi, e3)) : new s(0, this.powHi(Math.max(-t2.lo, t2.hi), e3)) : new s(this.powLo(t2.lo, e3), this.powHi(t2.hi, e3)) : (console.warn("power is not an integer, you should use nth-root instead, returning an empty interval"), this.EMPTY.clone());
        }, sqrt: function(t2) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), this.nthRoot(t2, 2);
        }, nthRoot: function(t2, e3) {
          var r2, o, n, a, h;
          if (i.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) || e3 < 0)
            return this.EMPTY.clone();
          if (this.isInterval(e3)) {
            if (!this.isSingleton(e3))
              return this.EMPTY.clone();
            e3 = e3.lo;
          }
          return r2 = 1 / e3, t2.hi < 0 ? e3 % 1 == 0 && (1 & e3) == 1 ? (o = this.powHi(-t2.lo, r2), n = this.powLo(-t2.hi, r2), new s(-o, -n)) : this.EMPTY.clone() : t2.lo < 0 ? (a = this.powHi(t2.hi, r2), e3 % 1 == 0 && (1 & e3) == 1 ? (h = -this.powHi(-t2.lo, r2), new s(h, a)) : new s(0, a)) : new s(this.powLo(t2.lo, r2), this.powHi(t2.hi, r2));
        }, exp: function(t2) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) ? this.EMPTY.clone() : new s(this.expLo(t2.lo), this.expHi(t2.hi));
        }, log: function(t2) {
          var e3;
          return i.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) ? this.EMPTY.clone() : (e3 = t2.lo <= 0 ? Number.NEGATIVE_INFINITY : this.logLo(t2.lo), new s(e3, this.logHi(t2.hi)));
        }, ln: function(t2) {
          return this.log(t2);
        }, log10: function(t2) {
          return this.isEmpty(t2) ? this.EMPTY.clone() : this.div(this.log(t2), this.log(new s(10, 10)));
        }, log2: function(t2) {
          return this.isEmpty(t2) ? this.EMPTY.clone() : this.div(this.log(t2), this.log(new s(2, 2)));
        }, hull: function(t2, e3) {
          var i2 = this.isEmpty(t2), r2 = this.isEmpty(e3);
          return i2 && r2 ? this.EMPTY.clone() : i2 ? e3.clone() : r2 ? t2.clone() : new s(Math.min(t2.lo, e3.lo), Math.max(t2.hi, e3.hi));
        }, intersection: function(t2, e3) {
          var i2, r2;
          return this.isEmpty(t2) || this.isEmpty(e3) ? this.EMPTY.clone() : (i2 = Math.max(t2.lo, e3.lo), r2 = Math.min(t2.hi, e3.hi), i2 <= r2 ? new s(i2, r2) : this.EMPTY.clone());
        }, union: function(t2, e3) {
          if (!this.intervalsOverlap(t2, e3))
            throw new Error("Interval#unions do not overlap");
          return new s(Math.min(t2.lo, e3.lo), Math.max(t2.hi, e3.hi));
        }, difference: function(t2, e3) {
          if (this.isEmpty(t2) || this.isWhole(e3))
            return this.EMPTY.clone();
          if (this.intervalsOverlap(t2, e3)) {
            if (t2.lo < e3.lo && e3.hi < t2.hi)
              throw new Error("Interval.difference: difference creates multiple intervals");
            return e3.lo <= t2.lo && e3.hi === 1 / 0 || e3.hi >= t2.hi && e3.lo === -1 / 0 ? this.EMPTY.clone() : e3.lo <= t2.lo ? new s().halfOpenLeft(e3.hi, t2.hi) : new s().halfOpenRight(t2.lo, e3.lo);
          }
          return t2.clone();
        }, width: function(t2) {
          return this.isEmpty(t2) ? 0 : this.subHi(t2.hi, t2.lo);
        }, abs: function(t2) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), this.isEmpty(t2) ? this.EMPTY.clone() : t2.lo >= 0 ? t2.clone() : t2.hi <= 0 ? this.negative(t2) : new s(0, Math.max(-t2.lo, t2.hi));
        }, max: function(t2, e3) {
          var i2 = this.isEmpty(t2), r2 = this.isEmpty(e3);
          return i2 && r2 ? this.EMPTY.clone() : i2 ? e3.clone() : r2 ? t2.clone() : new s(Math.max(t2.lo, e3.lo), Math.max(t2.hi, e3.hi));
        }, min: function(t2, e3) {
          var i2 = this.isEmpty(t2), r2 = this.isEmpty(e3);
          return i2 && r2 ? this.EMPTY.clone() : i2 ? e3.clone() : r2 ? t2.clone() : new s(Math.min(t2.lo, e3.lo), Math.min(t2.hi, e3.hi));
        }, onlyInfinity: function(t2) {
          return !isFinite(t2.lo) && t2.lo === t2.hi;
        }, _handleNegative: function(t2) {
          var e3;
          return t2.lo < 0 && (t2.lo === -1 / 0 ? (t2.lo = 0, t2.hi = 1 / 0) : (e3 = Math.ceil(-t2.lo / this.piTwiceLow), t2.lo += this.piTwiceLow * e3, t2.hi += this.piTwiceLow * e3)), t2;
        }, cos: function(t2) {
          var e3, i2, r2, o, n, a, h, l;
          return this.isEmpty(t2) || this.onlyInfinity(t2) ? this.EMPTY.clone() : (e3 = new s().set(t2.lo, t2.hi), this._handleNegative(e3), i2 = this.PI_TWICE, r2 = this.fmod(e3, i2), this.width(r2) >= i2.lo ? new s(-1, 1) : r2.lo >= this.piHigh ? (o = this.cos(this.sub(r2, this.PI)), this.negative(o)) : (n = r2.lo, a = r2.hi, h = this.cosLo(a), l = this.cosHi(n), a <= this.piLow ? new s(h, l) : a <= i2.lo ? new s(-1, Math.max(h, l)) : new s(-1, 1)));
        }, sin: function(t2) {
          return this.isEmpty(t2) || this.onlyInfinity(t2) ? this.EMPTY.clone() : this.cos(this.sub(t2, this.PI_HALF));
        }, tan: function(t2) {
          var e3, i2, r2;
          return this.isEmpty(t2) || this.onlyInfinity(t2) ? this.EMPTY.clone() : (e3 = new s().set(t2.lo, t2.hi), this._handleNegative(e3), r2 = this.PI, i2 = this.fmod(e3, r2), i2.lo >= this.piHalfLow && (i2 = this.sub(i2, r2)), i2.lo <= -this.piHalfLow || i2.hi >= this.piHalfLow ? this.WHOLE.clone() : new s(this.tanLo(i2.lo), this.tanHi(i2.hi)));
        }, asin: function(t2) {
          var e3, i2;
          return this.isEmpty(t2) || t2.hi < -1 || t2.lo > 1 ? this.EMPTY.clone() : (e3 = t2.lo <= -1 ? -this.piHalfHigh : this.asinLo(t2.lo), i2 = t2.hi >= 1 ? this.piHalfHigh : this.asinHi(t2.hi), new s(e3, i2));
        }, acos: function(t2) {
          var e3, i2;
          return this.isEmpty(t2) || t2.hi < -1 || t2.lo > 1 ? this.EMPTY.clone() : (e3 = t2.hi >= 1 ? 0 : this.acosLo(t2.hi), i2 = t2.lo <= -1 ? this.piHigh : this.acosHi(t2.lo), new s(e3, i2));
        }, atan: function(t2) {
          return this.isEmpty(t2) ? this.EMPTY.clone() : new s(this.atanLo(t2.lo), this.atanHi(t2.hi));
        }, sinh: function(t2) {
          return this.isEmpty(t2) ? this.EMPTY.clone() : new s(this.sinhLo(t2.lo), this.sinhHi(t2.hi));
        }, cosh: function(t2) {
          return this.isEmpty(t2) ? this.EMPTY.clone() : t2.hi < 0 ? new s(this.coshLo(t2.hi), this.coshHi(t2.lo)) : t2.lo >= 0 ? new s(this.coshLo(t2.lo), this.coshHi(t2.hi)) : new s(1, this.coshHi(-t2.lo > t2.hi ? t2.lo : t2.hi));
        }, tanh: function(t2) {
          return this.isEmpty(t2) ? this.EMPTY.clone() : new s(this.tanhLo(t2.lo), this.tanhHi(t2.hi));
        }, equal: function(t2, e3) {
          return this.isEmpty(t2) ? this.isEmpty(e3) : !this.isEmpty(e3) && t2.lo === e3.lo && t2.hi === e3.hi;
        }, notEqual: function(t2, e3) {
          return this.isEmpty(t2) ? !this.isEmpty(e3) : this.isEmpty(e3) || t2.hi < e3.lo || t2.lo > e3.hi;
        }, lt: function(t2, e3) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), !this.isEmpty(t2) && !this.isEmpty(e3) && t2.hi < e3.lo;
        }, gt: function(t2, e3) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), !this.isEmpty(t2) && !this.isEmpty(e3) && t2.lo > e3.hi;
        }, leq: function(t2, e3) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), !this.isEmpty(t2) && !this.isEmpty(e3) && t2.hi <= e3.lo;
        }, geq: function(t2, e3) {
          return i.isNumber(t2) && (t2 = this.Interval(t2)), i.isNumber(e3) && (e3 = this.Interval(e3)), !this.isEmpty(t2) && !this.isEmpty(e3) && t2.lo >= e3.hi;
        }, piLow: 3.141592653589793, piHigh: 3.1415926535897936, piHalfLow: 1.5707963267948966, piHalfHigh: 1.5707963267948968, piTwiceLow: 6.283185307179586, piTwiceHigh: 6.283185307179587, identity: function(t2) {
          return t2;
        }, _prev: function(t2) {
          return t2 === 1 / 0 ? t2 : this.nextafter(t2, -1 / 0);
        }, _next: function(t2) {
          return t2 === -1 / 0 ? t2 : this.nextafter(t2, 1 / 0);
        }, prev: function(t2) {
          return this._prev(t2);
        }, next: function(t2) {
          return this._next(t2);
        }, toInteger: function(t2) {
          return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
        }, addLo: function(t2, e3) {
          return this.prev(t2 + e3);
        }, addHi: function(t2, e3) {
          return this.next(t2 + e3);
        }, subLo: function(t2, e3) {
          return this.prev(t2 - e3);
        }, subHi: function(t2, e3) {
          return this.next(t2 - e3);
        }, mulLo: function(t2, e3) {
          return this.prev(t2 * e3);
        }, mulHi: function(t2, e3) {
          return this.next(t2 * e3);
        }, divLo: function(t2, e3) {
          return this.prev(t2 / e3);
        }, divHi: function(t2, e3) {
          return this.next(t2 / e3);
        }, intLo: function(t2) {
          return this.toInteger(this.prev(t2));
        }, intHi: function(t2) {
          return this.toInteger(this.next(t2));
        }, logLo: function(t2) {
          return this.prev(Math.log(t2));
        }, logHi: function(t2) {
          return this.next(Math.log(t2));
        }, expLo: function(t2) {
          return this.prev(Math.exp(t2));
        }, expHi: function(t2) {
          return this.next(Math.exp(t2));
        }, sinLo: function(t2) {
          return this.prev(Math.sin(t2));
        }, sinHi: function(t2) {
          return this.next(Math.sin(t2));
        }, cosLo: function(t2) {
          return this.prev(Math.cos(t2));
        }, cosHi: function(t2) {
          return this.next(Math.cos(t2));
        }, tanLo: function(t2) {
          return this.prev(Math.tan(t2));
        }, tanHi: function(t2) {
          return this.next(Math.tan(t2));
        }, asinLo: function(t2) {
          return this.prev(Math.asin(t2));
        }, asinHi: function(t2) {
          return this.next(Math.asin(t2));
        }, acosLo: function(t2) {
          return this.prev(Math.acos(t2));
        }, acosHi: function(t2) {
          return this.next(Math.acos(t2));
        }, atanLo: function(t2) {
          return this.prev(Math.atan(t2));
        }, atanHi: function(t2) {
          return this.next(Math.atan(t2));
        }, sinhLo: function(t2) {
          return this.prev(e2.sinh(t2));
        }, sinhHi: function(t2) {
          return this.next(e2.sinh(t2));
        }, coshLo: function(t2) {
          return this.prev(e2.cosh(t2));
        }, coshHi: function(t2) {
          return this.next(e2.cosh(t2));
        }, tanhLo: function(t2) {
          return this.prev(e2.tanh(t2));
        }, tanhHi: function(t2) {
          return this.next(e2.tanh(t2));
        }, sqrtLo: function(t2) {
          return this.prev(Math.sqrt(t2));
        }, sqrtHi: function(t2) {
          return this.next(Math.sqrt(t2));
        }, powLo: function(t2, e3) {
          var i2;
          if (e3 % 1 != 0)
            return this.prev(Math.pow(t2, e3));
          for (i2 = (1 & e3) == 1 ? t2 : 1, e3 >>= 1; e3 > 0; )
            t2 = this.mulLo(t2, t2), (1 & e3) == 1 && (i2 = this.mulLo(t2, i2)), e3 >>= 1;
          return i2;
        }, powHi: function(t2, e3) {
          var i2;
          if (e3 % 1 != 0)
            return this.next(Math.pow(t2, e3));
          for (i2 = (1 & e3) == 1 ? t2 : 1, e3 >>= 1; e3 > 0; )
            t2 = this.mulHi(t2, t2), (1 & e3) == 1 && (i2 = this.mulHi(t2, i2)), e3 >>= 1;
          return i2;
        }, disable: function() {
          this.next = this.prev = this.identity;
        }, enable: function() {
          this.prev = function(t2) {
            return this._prev(t2);
          }, this.next = function(t2) {
            return this._next(t2);
          };
        }, SMALLEST_DENORM: Math.pow(2, -1074), UINT_MAX: -1 >>> 0, nextafter: function(t2, e3) {
          var i2, s2;
          return isNaN(t2) || isNaN(e3) ? NaN : t2 === e3 ? t2 : t2 === 0 ? e3 < 0 ? -this.SMALLEST_DENORM : this.SMALLEST_DENORM : (s2 = r.hi(t2), i2 = r.lo(t2), e3 > t2 == t2 > 0 ? i2 === this.UINT_MAX ? (s2 += 1, i2 = 0) : i2 += 1 : i2 === 0 ? (i2 = this.UINT_MAX, s2 -= 1) : i2 -= 1, r.pack(i2, s2));
        }}, t.Math.IntervalArithmetic.PI = new s(e2.IntervalArithmetic.piLow, e2.IntervalArithmetic.piHigh), t.Math.IntervalArithmetic.PI_HALF = new s(e2.IntervalArithmetic.piHalfLow, e2.IntervalArithmetic.piHalfHigh), t.Math.IntervalArithmetic.PI_TWICE = new s(e2.IntervalArithmetic.piTwiceLow, e2.IntervalArithmetic.piTwiceHigh), t.Math.IntervalArithmetic.ZERO = new s(0), t.Math.IntervalArithmetic.ONE = new s(1), t.Math.IntervalArithmetic.WHOLE = new s().setWhole(), t.Math.IntervalArithmetic.EMPTY = new s().setEmpty(), t.Math.IntervalArithmetic;
      }), define("math/extrapolate", ["math/math"], function(t) {
        "use strict";
        return t.Extrapolate = {upper: 15, infty: 1e4, wynnEps: function(t2, e2, i) {
          var r, s, o, n, a, h;
          if (i[e2] = t2, e2 === 0)
            h = t2;
          else {
            for (n = 0, s = e2; s > 0; s--)
              o = n, n = i[s - 1], a = i[s] - n, Math.abs(a) <= 1e-15 ? i[s - 1] = 1e20 : (r = 1, i[s - 1] = o * r + 1 / a);
            h = i[e2 % 2];
          }
          return h;
        }, aitken: function(t2, e2, i) {
          var r, s, o, n, a, h;
          if (i[e2] = t2, e2 < 2)
            r = t2;
          else {
            for (n = e2 / 2, a = 1; a <= n; a++)
              h = e2 - 2 * a, s = i[h + 2] - 2 * i[h + 1] + i[h], Math.abs(s) < 1e-15 ? i[h] = 1e20 : (o = i[h] - i[h + 1], i[h] -= o * o / s);
            r = i[e2 % 2];
          }
          return r;
        }, brezinski: function(t2, e2, i) {
          var r, s, o, n, a, h, l, c;
          if (i[e2] = t2, e2 < 3)
            r = t2;
          else {
            for (h = e2 / 3, c = e2, l = 1; l <= h; l++)
              c -= 3, o = i[c + 1] - i[c], n = i[c + 2] - i[c + 1], a = i[c + 3] - i[c + 2], s = a * (n - o) - o * (a - n), Math.abs(s) < 1e-15 ? i[c] = 1e20 : i[c] = i[c + 1] - o * n * (a - n) / s;
            r = i[e2 % 3];
          }
          return r;
        }, iteration: function(t2, e2, i, r, s) {
          var o, n, a, h, l = NaN, c = [], d = "finite", u = e2;
          for (s = s || 0, o = 1; o <= this.upper; o++) {
            if (u = s === 0 ? e2 / (o + 1) : 0.5 * u, n = i(t2 + u, true), a = this[r](n, o - 1, c), isNaN(a)) {
              d = "NaN";
              break;
            }
            if (n !== 0 && a / n > this.infty) {
              l = a, d = "infinite";
              break;
            }
            if (h = a - l, Math.abs(h) < 1e-7)
              break;
            l = a;
          }
          return [l, d, 1 - (o - 1) / this.upper];
        }, levin: function(t2, e2, i, r, s, o) {
          var n, a, h, l;
          if (l = 1 / (r + e2), s[e2] = t2 / i, o[e2] = 1 / i, e2 > 0 && (s[e2 - 1] = s[e2] - s[e2 - 1], o[e2 - 1] = o[e2] - o[e2 - 1], e2 > 1))
            for (h = (r + e2 - 1) * l, n = 2; n <= e2; n++)
              a = (r + e2 - n) * Math.pow(h, n - 2) * l, s[e2 - n] = s[e2 - n + 1] - a * s[e2 - n], o[e2 - n] = o[e2 - n + 1] - a * o[e2 - n], l *= h;
          return Math.abs(o[0]) < 1e-15 ? 1e20 : s[0] / o[0];
        }, iteration_levin: function(t2, e2, i, r) {
          var s, o, n, a, h, l, c, d = NaN, u = [], p = [], f = "finite", m = e2, g = "u";
          for (r = r || 0, a = i(t2 + e2, true), s = 1; s <= this.upper; s++) {
            if (m = r === 0 ? e2 / (s + 1) : 0.5 * m, o = i(t2 + m, true), h = o - a, g = Math.abs(h) < 1 ? "u" : "t", c = g === "u" ? (1 + s) * h : h, a = o, n = this.levin(o, s - 1, c, 1, u, p), l = n - d, isNaN(n)) {
              f = "NaN";
              break;
            }
            if (o !== 0 && n / o > this.infty) {
              d = n, f = "infinite";
              break;
            }
            if (Math.abs(l) < 1e-7)
              break;
            d = n;
          }
          return [d, f, 1 - (s - 1) / this.upper];
        }, limit: function(t2, e2, i) {
          return this.iteration_levin(t2, e2, i, 0);
        }}, t.Extrapolate;
      }), define("math/qdt", ["math/math", "utils/type"], function(t, e2) {
        "use strict";
        var i = function(t2) {
          this.capacity = 10, this.points = [], this.xlb = t2[0], this.xub = t2[2], this.ylb = t2[3], this.yub = t2[1], this.northWest = null, this.northEast = null, this.southEast = null, this.southWest = null;
        };
        return e2.extend(i.prototype, {contains: function(t2, e3) {
          return this.xlb < t2 && t2 <= this.xub && this.ylb < e3 && e3 <= this.yub;
        }, insert: function(t2) {
          return !!this.contains(t2.usrCoords[1], t2.usrCoords[2]) && (this.points.length < this.capacity ? (this.points.push(t2), true) : (this.northWest === null && this.subdivide(), !!this.northWest.insert(t2) || (!!this.northEast.insert(t2) || (!!this.southEast.insert(t2) || !!this.southWest.insert(t2)))));
        }, subdivide: function() {
          var t2, e3 = this.points.length, r = this.xlb + (this.xub - this.xlb) / 2, s = this.ylb + (this.yub - this.ylb) / 2;
          for (this.northWest = new i([this.xlb, this.yub, r, s]), this.northEast = new i([r, this.yub, this.xub, s]), this.southEast = new i([this.xlb, s, r, this.ylb]), this.southWest = new i([r, s, this.xub, this.ylb]), t2 = 0; t2 < e3; t2 += 1)
            this.northWest.insert(this.points[t2]), this.northEast.insert(this.points[t2]), this.southEast.insert(this.points[t2]), this.southWest.insert(this.points[t2]);
        }, _query: function(t2, e3) {
          var i2;
          if (this.contains(t2, e3)) {
            if (this.northWest === null)
              return this;
            if (i2 = this.northWest._query(t2, e3))
              return i2;
            if (i2 = this.northEast._query(t2, e3))
              return i2;
            if (i2 = this.southEast._query(t2, e3))
              return i2;
            if (i2 = this.southWest._query(t2, e3))
              return i2;
          }
          return false;
        }, query: function(t2, i2) {
          var r, s;
          return e2.exists(i2) ? (r = t2, s = i2) : (r = t2.usrCoords[1], s = t2.usrCoords[2]), this._query(r, s);
        }}), t.Quadtree = i, i;
      }), define("math/numerics", ["jxg", "utils/type", "math/math"], function(t, e2, i) {
        "use strict";
        var r = {rk4: {s: 4, A: [[0, 0, 0, 0], [0.5, 0, 0, 0], [0, 0.5, 0, 0], [0, 0, 1, 0]], b: [1 / 6, 1 / 3, 1 / 3, 1 / 6], c: [0, 0.5, 0.5, 1]}, heun: {s: 2, A: [[0, 0], [1, 0]], b: [0.5, 0.5], c: [0, 1]}, euler: {s: 1, A: [[0]], b: [1], c: [0]}};
        return i.Numerics = {Gauss: function(t2, r2) {
          var s, o, n, a, h, l = i.eps, c = t2.length > 0 ? t2[0].length : 0;
          if (c !== r2.length || c !== t2.length)
            throw new Error("JXG.Math.Numerics.Gauss: Dimensions don't match. A must be a square matrix and b must be of the same length as A.");
          for (a = [], h = r2.slice(0, c), s = 0; s < c; s++)
            a[s] = t2[s].slice(0, c);
          for (o = 0; o < c; o++) {
            for (s = c - 1; s > o; s--)
              if (Math.abs(a[s][o]) > l)
                if (Math.abs(a[o][o]) < l)
                  e2.swap(a, s, o), e2.swap(h, s, o);
                else
                  for (a[s][o] /= a[o][o], h[s] -= a[s][o] * h[o], n = o + 1; n < c; n++)
                    a[s][n] -= a[s][o] * a[o][n];
            if (Math.abs(a[o][o]) < l)
              throw new Error("JXG.Math.Numerics.Gauss(): The given matrix seems to be singular.");
          }
          return this.backwardSolve(a, h, true), h;
        }, backwardSolve: function(t2, e3, i2) {
          var r2, s, o, n, a;
          for (r2 = i2 ? e3 : e3.slice(0, e3.length), s = t2.length, o = t2.length > 0 ? t2[0].length : 0, n = s - 1; n >= 0; n--) {
            for (a = o - 1; a > n; a--)
              r2[n] -= t2[n][a] * r2[a];
            r2[n] /= t2[n][n];
          }
          return r2;
        }, gaussBareiss: function(t2) {
          var e3, r2, s, o, n, a, h, l, c, d = i.eps;
          if ((h = t2.length) <= 0)
            return 0;
          for (t2[0].length < h && (h = t2[0].length), l = [], o = 0; o < h; o++)
            l[o] = t2[o].slice(0, h);
          for (r2 = 1, s = 1, e3 = 0; e3 < h - 1; e3++) {
            if (a = l[e3][e3], Math.abs(a) < d) {
              for (o = e3 + 1; o < h && !(Math.abs(l[o][e3]) >= d); o++)
                ;
              if (o === h)
                return 0;
              for (n = e3; n < h; n++)
                c = l[o][n], l[o][n] = l[e3][n], l[e3][n] = c;
              s = -s, a = l[e3][e3];
            }
            for (o = e3 + 1; o < h; o++)
              for (n = e3 + 1; n < h; n++)
                c = a * l[o][n] - l[o][e3] * l[e3][n], l[o][n] = c / r2;
            r2 = a;
          }
          return s * l[h - 1][h - 1];
        }, det: function(t2) {
          return t2.length === 2 && t2[0].length === 2 ? t2[0][0] * t2[1][1] - t2[1][0] * t2[0][1] : this.gaussBareiss(t2);
        }, Jacobi: function(t2) {
          var e3, r2, s, o, n, a, h, l, c, d = i.eps * i.eps, u = 0, p = t2.length, f = [[0, 0, 0], [0, 0, 0], [0, 0, 0]], m = [[0, 0, 0], [0, 0, 0], [0, 0, 0]], g = 0;
          for (e3 = 0; e3 < p; e3++) {
            for (r2 = 0; r2 < p; r2++)
              f[e3][r2] = 0, m[e3][r2] = t2[e3][r2], u += Math.abs(m[e3][r2]);
            f[e3][e3] = 1;
          }
          if (p === 1)
            return [m, f];
          if (u <= 0)
            return [m, f];
          u /= p * p;
          do {
            for (l = 0, c = 0, r2 = 1; r2 < p; r2++)
              for (e3 = 0; e3 < r2; e3++)
                if (o = Math.abs(m[e3][r2]), o > c && (c = o), l += o, o >= d) {
                  for (o = 0.5 * Math.atan2(2 * m[e3][r2], m[e3][e3] - m[r2][r2]), n = Math.sin(o), a = Math.cos(o), s = 0; s < p; s++)
                    h = m[s][e3], m[s][e3] = a * h + n * m[s][r2], m[s][r2] = -n * h + a * m[s][r2], h = f[s][e3], f[s][e3] = a * h + n * f[s][r2], f[s][r2] = -n * h + a * f[s][r2];
                  for (m[e3][e3] = a * m[e3][e3] + n * m[r2][e3], m[r2][r2] = -n * m[e3][r2] + a * m[r2][r2], m[e3][r2] = 0, s = 0; s < p; s++)
                    m[e3][s] = m[s][e3], m[r2][s] = m[s][r2];
                }
            g += 1;
          } while (Math.abs(l) / u > d && g < 2e3);
          return [m, f];
        }, NewtonCotes: function(t2, i2, r2) {
          var s, o, n, a = 0, h = r2 && e2.isNumber(r2.number_of_nodes) ? r2.number_of_nodes : 28, l = {trapez: true, simpson: true, milne: true}, c = r2 && r2.integration_type && l.hasOwnProperty(r2.integration_type) && l[r2.integration_type] ? r2.integration_type : "milne", d = (t2[1] - t2[0]) / h;
          switch (c) {
            case "trapez":
              for (a = 0.5 * (i2(t2[0]) + i2(t2[1])), s = t2[0], o = 0; o < h - 1; o++)
                s += d, a += i2(s);
              a *= d;
              break;
            case "simpson":
              if (h % 2 > 0)
                throw new Error("JSXGraph:  INT_SIMPSON requires config.number_of_nodes dividable by 2.");
              for (n = h / 2, a = i2(t2[0]) + i2(t2[1]), s = t2[0], o = 0; o < n - 1; o++)
                s += 2 * d, a += 2 * i2(s);
              for (s = t2[0] - d, o = 0; o < n; o++)
                s += 2 * d, a += 4 * i2(s);
              a *= d / 3;
              break;
            default:
              if (h % 4 > 0)
                throw new Error("JSXGraph: Error in INT_MILNE: config.number_of_nodes must be a multiple of 4");
              for (n = 0.25 * h, a = 7 * (i2(t2[0]) + i2(t2[1])), s = t2[0], o = 0; o < n - 1; o++)
                s += 4 * d, a += 14 * i2(s);
              for (s = t2[0] - 3 * d, o = 0; o < n; o++)
                s += 4 * d, a += 32 * (i2(s) + i2(s + 2 * d));
              for (s = t2[0] - 2 * d, o = 0; o < n; o++)
                s += 4 * d, a += 12 * i2(s);
              a *= 2 * d / 45;
          }
          return a;
        }, Romberg: function(t2, i2, r2) {
          var s, o, n, a, h, l, c, d, u = [], p = 0, f = 1 / 0, m = r2 && e2.isNumber(r2.max_iterations) ? r2.max_iterations : 20, g = r2 && e2.isNumber(r2.eps) ? r2.eps : r2.eps || 1e-7;
          for (s = t2[0], o = t2[1], n = o - s, h = 1, u[0] = 0.5 * n * (i2(s) + i2(o)), l = 0; l < m; ++l) {
            for (a = 0, n *= 0.5, h *= 2, d = 1, c = 1; c < h; c += 2)
              a += i2(s + c * n);
            for (u[l + 1] = 0.5 * u[l] + a * n, p = u[l + 1], c = l - 1; c >= 0; --c)
              d *= 4, u[c] = u[c + 1] + (u[c + 1] - u[c]) / (d - 1), p = u[c];
            if (Math.abs(p - f) < g * Math.abs(p))
              break;
            f = p;
          }
          return p;
        }, GaussLegendre: function(t2, i2, r2) {
          var s, o, n, a, h, l, c, d, u = 0, p = [], f = [], m = r2 && e2.isNumber(r2.n) ? r2.n : 12;
          if (m > 18 && (m = 18), p[2] = [0.5773502691896257], f[2] = [1], p[4] = [0.33998104358485626, 0.8611363115940526], f[4] = [0.6521451548625461, 0.34785484513745385], p[6] = [0.2386191860831969, 0.6612093864662645, 0.932469514203152], f[6] = [0.46791393457269104, 0.3607615730481386, 0.17132449237917036], p[8] = [0.1834346424956498, 0.525532409916329, 0.7966664774136267, 0.9602898564975363], f[8] = [0.362683783378362, 0.31370664587788727, 0.22238103445337448, 0.10122853629037626], p[10] = [0.14887433898163122, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717], f[10] = [0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814], p[12] = [0.1252334085114689, 0.3678314989981802, 0.5873179542866175, 0.7699026741943047, 0.9041172563704749, 0.9815606342467192], f[12] = [0.24914704581340277, 0.2334925365383548, 0.20316742672306592, 0.16007832854334622, 0.10693932599531843, 0.04717533638651183], p[14] = [0.10805494870734367, 0.31911236892788974, 0.5152486363581541, 0.6872929048116855, 0.827201315069765, 0.9284348836635735, 0.9862838086968123], f[14] = [0.2152638534631578, 0.2051984637212956, 0.18553839747793782, 0.15720316715819355, 0.12151857068790319, 0.08015808715976021, 0.03511946033175186], p[16] = [0.09501250983763744, 0.2816035507792589, 0.45801677765722737, 0.6178762444026438, 0.755404408355003, 0.8656312023878318, 0.9445750230732326, 0.9894009349916499], f[16] = [0.1894506104550685, 0.18260341504492358, 0.16915651939500254, 0.14959598881657674, 0.12462897125553388, 0.09515851168249279, 0.062253523938647894, 0.027152459411754096], p[18] = [0.0847750130417353, 0.2518862256915055, 0.41175116146284263, 0.5597708310739475, 0.6916870430603532, 0.8037049589725231, 0.8926024664975557, 0.9558239495713977, 0.9915651684209309], f[18] = [0.1691423829631436, 0.16427648374583273, 0.15468467512626524, 0.14064291467065065, 0.12255520671147846, 0.10094204410628717, 0.07642573025488905, 0.0497145488949698, 0.02161601352648331], p[3] = [0, 0.7745966692414834], f[3] = [0.8888888888888888, 0.5555555555555556], p[5] = [0, 0.5384693101056831, 0.906179845938664], f[5] = [0.5688888888888889, 0.47862867049936647, 0.23692688505618908], p[7] = [0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585], f[7] = [0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697], p[9] = [0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261], f[9] = [0.3302393550012598, 0.31234707704000286, 0.26061069640293544, 0.1806481606948574, 0.08127438836157441], p[11] = [0, 0.26954315595234496, 0.5190961292068118, 0.7301520055740494, 0.8870625997680953, 0.978228658146057], f[11] = [0.2729250867779006, 0.26280454451024665, 0.23319376459199048, 0.18629021092773426, 0.1255803694649046, 0.05566856711617366], p[13] = [0, 0.2304583159551348, 0.44849275103644687, 0.6423493394403402, 0.8015780907333099, 0.9175983992229779, 0.9841830547185881], f[13] = [0.2325515532308739, 0.22628318026289723, 0.2078160475368885, 0.17814598076194574, 0.13887351021978725, 0.09212149983772845, 0.04048400476531588], p[15] = [0, 0.20119409399743451, 0.3941513470775634, 0.5709721726085388, 0.7244177313601701, 0.8482065834104272, 0.937273392400706, 0.9879925180204854], f[15] = [0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727], p[17] = [0, 0.17848418149584785, 0.3512317634538763, 0.5126905370864769, 0.6576711592166907, 0.7815140038968014, 0.8802391537269859, 0.9506755217687678, 0.9905754753144174], f[17] = [0.17944647035620653, 0.17656270536699264, 0.16800410215645004, 0.15404576107681028, 0.13513636846852548, 0.11188384719340397, 0.08503614831717918, 0.0554595293739872, 0.02414830286854793], s = t2[0], o = t2[1], a = m + 1 >> 1, c = p[m], d = f[m], l = 0.5 * (o - s), h = 0.5 * (o + s), true & m)
            for (u = d[0] * i2(h), n = 1; n < a; ++n)
              u += d[n] * (i2(h + l * c[n]) + i2(h - l * c[n]));
          else
            for (u = 0, n = 0; n < a; ++n)
              u += d[n] * (i2(h + l * c[n]) + i2(h - l * c[n]));
          return l * u;
        }, _rescale_error: function(t2, e3, i2) {
          var r2, s;
          return t2 = Math.abs(t2), i2 !== 0 && t2 !== 0 && (r2 = Math.pow(200 * t2 / i2, 1.5), t2 = r2 < 1 ? i2 * r2 : i2), e3 > 20041683600089728e-310 && (s = 11102230246251565e-30 * e3) > t2 && (t2 = s), t2;
        }, _gaussKronrod: function(t2, e3, i2, r2, s, o, n) {
          var a, h, l, c, d, u, p, f, m, g = t2[0], b = t2[1], v = 0.5 * (g + b), y = 0.5 * (b - g), C = Math.abs(y), _4 = e3(v), P2 = 0, E = _4 * o[i2 - 1], x = Math.abs(E), S = 0, O = 0, w = 0, T = [], N = [];
          for (i2 % 2 == 0 && (P2 = _4 * s[i2 / 2 - 1]), a = Math.floor((i2 - 1) / 2), l = 0; l < a; l++)
            c = 2 * l + 1, d = y * r2[c], u = e3(v - d), p = e3(v + d), f = u + p, T[c] = u, N[c] = p, P2 += s[l] * f, E += o[c] * f, x += o[c] * (Math.abs(u) + Math.abs(p));
          for (a = Math.floor(i2 / 2), l = 0; l < a; l++)
            m = 2 * l, d = y * r2[m], u = e3(v - d), p = e3(v + d), T[m] = u, N[m] = p, E += o[m] * (u + p), x += o[m] * (Math.abs(u) + Math.abs(p));
          for (O = 0.5 * E, S = o[i2 - 1] * Math.abs(_4 - O), l = 0; l < i2 - 1; l++)
            S += o[l] * (Math.abs(T[l] - O) + Math.abs(N[l] - O));
          return w = (E - P2) * y, E *= y, x *= C, S *= C, h = E, n.abserr = this._rescale_error(w, x, S), n.resabs = x, n.resasc = S, h;
        }, GaussKronrod15: function(t2, e3, i2) {
          var r2 = [0.9914553711208126, 0.9491079123427585, 0.8648644233597691, 0.7415311855993945, 0.5860872354676911, 0.4058451513773972, 0.20778495500789848, 0], s = [0.1294849661688697, 0.27970539148927664, 0.3818300505051189, 0.4179591836734694], o = [0.022935322010529224, 0.06309209262997856, 0.10479001032225019, 0.14065325971552592, 0.1690047266392679, 0.19035057806478542, 0.20443294007529889, 0.20948214108472782];
          return this._gaussKronrod(t2, e3, 8, r2, s, o, i2);
        }, GaussKronrod21: function(t2, e3, i2) {
          var r2 = [0.9956571630258081, 0.9739065285171717, 0.9301574913557082, 0.8650633666889845, 0.7808177265864169, 0.6794095682990244, 0.5627571346686047, 0.4333953941292472, 0.2943928627014602, 0.14887433898163122, 0], s = [0.06667134430868814, 0.1494513491505806, 0.21908636251598204, 0.26926671930999635, 0.29552422471475287], o = [0.011694638867371874, 0.032558162307964725, 0.054755896574351995, 0.07503967481091996, 0.0931254545836976, 0.10938715880229764, 0.12349197626206584, 0.13470921731147334, 0.14277593857706009, 0.14773910490133849, 0.1494455540029169];
          return this._gaussKronrod(t2, e3, 11, r2, s, o, i2);
        }, GaussKronrod31: function(t2, e3, i2) {
          var r2 = [0.9980022986933971, 0.9879925180204854, 0.9677390756791391, 0.937273392400706, 0.8972645323440819, 0.8482065834104272, 0.790418501442466, 0.7244177313601701, 0.650996741297417, 0.5709721726085388, 0.4850818636402397, 0.3941513470775634, 0.29918000715316884, 0.20119409399743451, 0.1011420669187175, 0], s = [0.03075324199611727, 0.07036604748810812, 0.10715922046717194, 0.13957067792615432, 0.16626920581699392, 0.1861610000155622, 0.19843148532711158, 0.2025782419255613], o = [0.005377479872923349, 0.015007947329316122, 0.02546084732671532, 0.03534636079137585, 0.04458975132476488, 0.05348152469092809, 0.06200956780067064, 0.06985412131872826, 0.07684968075772038, 0.08308050282313302, 0.08856444305621176, 0.09312659817082532, 0.09664272698362368, 0.09917359872179196, 0.10076984552387559, 0.10133000701479154];
          return this._gaussKronrod(t2, e3, 16, r2, s, o, i2);
        }, _workspace: function(t2, e3) {
          return {limit: e3, size: 0, nrmax: 0, i: 0, alist: [t2[0]], blist: [t2[1]], rlist: [0], elist: [0], order: [0], level: [0], qpsrt: function() {
            var t3, e4, i2, r2, s, o = this.size - 1, n = this.limit, a = this.nrmax, h = this.order[a];
            if (o < 2)
              return this.order[0] = 0, this.order[1] = 1, void (this.i = h);
            for (t3 = this.elist[h]; a > 0 && t3 > this.elist[this.order[a - 1]]; )
              this.order[a] = this.order[a - 1], a--;
            for (s = o < n / 2 + 2 ? o : n - o + 1, i2 = a + 1; i2 < s && t3 < this.elist[this.order[i2]]; )
              this.order[i2 - 1] = this.order[i2], i2++;
            for (this.order[i2 - 1] = h, e4 = this.elist[o], r2 = s - 1; r2 > i2 - 2 && e4 >= this.elist[this.order[r2]]; )
              this.order[r2 + 1] = this.order[r2], r2--;
            this.order[r2 + 1] = o, h = this.order[a], this.i = h, this.nrmax = a;
          }, set_initial_result: function(t3, e4) {
            this.size = 1, this.rlist[0] = t3, this.elist[0] = e4;
          }, update: function(t3, e4, i2, r2, s, o, n, a) {
            var h = this.i, l = this.size, c = this.level[this.i] + 1;
            a > r2 ? (this.alist[h] = s, this.rlist[h] = n, this.elist[h] = a, this.level[h] = c, this.alist[l] = t3, this.blist[l] = e4, this.rlist[l] = i2, this.elist[l] = r2, this.level[l] = c) : (this.blist[h] = e4, this.rlist[h] = i2, this.elist[h] = r2, this.level[h] = c, this.alist[l] = s, this.blist[l] = o, this.rlist[l] = n, this.elist[l] = a, this.level[l] = c), this.size++, c > this.maximum_level && (this.maximum_level = c), this.qpsrt();
          }, retrieve: function() {
            var t3 = this.i;
            return {a: this.alist[t3], b: this.blist[t3], r: this.rlist[t3], e: this.elist[t3]};
          }, sum_results: function() {
            var t3, e4 = this.size, i2 = 0;
            for (t3 = 0; t3 < e4; t3++)
              i2 += this.rlist[t3];
            return i2;
          }, subinterval_too_small: function(t3, e4, i2) {
            var r2 = 1.0000000000000222 * (Math.abs(e4) + 22250738585072014e-321);
            return Math.abs(t3) <= r2 && Math.abs(i2) <= r2;
          }};
        }, Qag: function(r2, s, o) {
          var n, a, h, l, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S, O = this._workspace(r2, 1e3), w = o && e2.isNumber(o.limit) ? o.limit : 15, T = o && e2.isNumber(o.epsrel) ? o.epsrel : 1e-7, N = o && e2.isNumber(o.epsabs) ? o.epsabs : 1e-7, M = o && e2.isFunction(o.q) ? o.q : this.GaussKronrod15, A = {}, R = 0, L = 0, k = 0, B = 0, I = 0, Y = 0, D = 0, j = 0, X = 0, U = 0;
          if (w > O.limit && t.warn("iteration limit exceeds available workspace"), N <= 0 && (T < 50 * i.eps || T < 5e-29) && t.warn("tolerance cannot be acheived with given epsabs and epsrel"), h = M.apply(this, [r2, s, A]), l = A.abserr, c = A.resabs, d = A.resasc, O.set_initial_result(h, l), u = Math.max(N, T * Math.abs(h)), p = 11102230246251565e-30 * c, l <= p && l > u)
            return h, t.warn("cannot reach tolerance because of roundoff error on first attempt"), -1 / 0;
          if (l <= u && l !== d || l === 0)
            return h;
          if (w === 1)
            return h, t.warn("a maximum of one iteration was insufficient"), -1 / 0;
          n = h, a = l, R = 1;
          do {
            I = 0, Y = 0, D = 0, j = 0, X = 0, U = 0, x = O.retrieve(), v = x.a, y = x.b, C = x.r, _4 = x.e, f = v, m = 0.5 * (v + y), g = m, b = y, I = M.apply(this, [[f, m], s, A]), j = A.abserr, P2 = A.resasc, Y = M.apply(this, [[g, b], s, A]), X = A.abserr, E = A.resasc, D = I + Y, U = j + X, a += U - _4, n += D - C, P2 !== j && E !== X && (S = C - D, Math.abs(S) <= 1e-5 * Math.abs(D) && U >= 0.99 * _4 && L++, R >= 10 && U > _4 && k++), u = Math.max(N, T * Math.abs(n)), a > u && ((L >= 6 || k >= 20) && (B = 2), O.subinterval_too_small(f, g, b) && (B = 3)), O.update(f, m, I, j, g, b, Y, X), x = O.retrieve(), v = x.a_i, y = x.b_i, C = x.r_i, _4 = x.e_i, R++;
          } while (R < w && !B && a > u);
          return O.sum_results();
        }, I: function(t2, e3) {
          return this.Qag(t2, e3, {q: this.GaussKronrod15, limit: 15, epsrel: 1e-7, epsabs: 1e-7});
        }, Newton: function(t2, r2, s) {
          var o, n = 0, a = i.eps, h = t2.apply(s, [r2]);
          for (e2.isArray(r2) && (r2 = r2[0]); n < 50 && Math.abs(h) > a; )
            o = this.D(t2, s)(r2), Math.abs(o) > a ? r2 -= h / o : r2 += 0.2 * Math.random() - 1, h = t2.apply(s, [r2]), n += 1;
          return r2;
        }, root: function(t2, e3, i2) {
          return this.chandrupatla(t2, e3, i2);
        }, generalizedNewton: function(t2, e3, r2, s) {
          var o, n, a, h, l, c, d, u, p, f, m, g, b, v, y = 0;
          for (this.generalizedNewton.t1memo ? (o = this.generalizedNewton.t1memo, n = this.generalizedNewton.t2memo) : (o = r2, n = s), u = t2.X(o) - e3.X(n), p = t2.Y(o) - e3.Y(n), f = u * u + p * p, m = this.D(t2.X, t2), g = this.D(e3.X, e3), b = this.D(t2.Y, t2), v = this.D(e3.Y, e3); f > i.eps && y < 10; )
            a = m(o), h = -g(n), l = b(o), c = -v(n), d = a * c - h * l, o -= (c * u - h * p) / d, n -= (a * p - l * u) / d, u = t2.X(o) - e3.X(n), p = t2.Y(o) - e3.Y(n), f = u * u + p * p, y += 1;
          return this.generalizedNewton.t1memo = o, this.generalizedNewton.t2memo = n, Math.abs(o) < Math.abs(n) ? [t2.X(o), t2.Y(o)] : [e3.X(n), e3.Y(n)];
        }, Neville: function(t2) {
          var e3 = [], r2 = function(r3) {
            return function(s, o) {
              var n, a, h, l = i.binomial, c = t2.length, d = c - 1, u = 0, p = 0;
              if (!o)
                for (h = 1, n = 0; n < c; n++)
                  e3[n] = l(d, n) * h, h *= -1;
              for (a = s, n = 0; n < c; n++) {
                if (a === 0)
                  return t2[n][r3]();
                h = e3[n] / a, a -= 1, u += t2[n][r3]() * h, p += h;
              }
              return u / p;
            };
          };
          return [r2("X"), r2("Y"), 0, function() {
            return t2.length - 1;
          }];
        }, splineDef: function(t2, e3) {
          var i2, r2, s, o = Math.min(t2.length, e3.length), n = [], a = [], h = [], l = [], c = [], d = [];
          if (o === 2)
            return [0, 0];
          for (r2 = 0; r2 < o; r2++)
            i2 = {X: t2[r2], Y: e3[r2]}, h.push(i2);
          for (h.sort(function(t3, e4) {
            return t3.X - e4.X;
          }), r2 = 0; r2 < o; r2++)
            t2[r2] = h[r2].X, e3[r2] = h[r2].Y;
          for (r2 = 0; r2 < o - 1; r2++)
            l.push(t2[r2 + 1] - t2[r2]);
          for (r2 = 0; r2 < o - 2; r2++)
            c.push(6 * (e3[r2 + 2] - e3[r2 + 1]) / l[r2 + 1] - 6 * (e3[r2 + 1] - e3[r2]) / l[r2]);
          for (n.push(2 * (l[0] + l[1])), a.push(c[0]), r2 = 0; r2 < o - 3; r2++)
            s = l[r2 + 1] / n[r2], n.push(2 * (l[r2 + 1] + l[r2 + 2]) - s * l[r2 + 1]), a.push(c[r2 + 1] - s * a[r2]);
          for (d[o - 3] = a[o - 3] / n[o - 3], r2 = o - 4; r2 >= 0; r2--)
            d[r2] = (a[r2] - l[r2 + 1] * d[r2 + 1]) / n[r2];
          for (r2 = o - 3; r2 >= 0; r2--)
            d[r2 + 1] = d[r2];
          return d[0] = 0, d[o - 1] = 0, d;
        }, splineEval: function(t2, i2, r2, s) {
          var o, n, a, h, l, c, d, u = Math.min(i2.length, r2.length), p = 1, f = false, m = [];
          for (e2.isArray(t2) ? (p = t2.length, f = true) : t2 = [t2], o = 0; o < p; o++) {
            if (t2[o] < i2[0] || i2[o] > i2[u - 1])
              return NaN;
            for (n = 1; n < u && !(t2[o] <= i2[n]); n++)
              ;
            n -= 1, a = r2[n], h = (r2[n + 1] - r2[n]) / (i2[n + 1] - i2[n]) - (i2[n + 1] - i2[n]) / 6 * (s[n + 1] + 2 * s[n]), l = s[n] / 2, c = (s[n + 1] - s[n]) / (6 * (i2[n + 1] - i2[n])), d = t2[o] - i2[n], m.push(a + (h + (l + c * d) * d) * d);
          }
          return f ? m : m[0];
        }, generatePolynomialTerm: function(t2, e3, i2, r2) {
          var s, o = [];
          for (s = e3; s >= 0; s--)
            o = o.concat(["(", t2[s].toPrecision(r2), ")"]), s > 1 ? o = o.concat(["*", i2, "<sup>", s, "<", "/sup> + "]) : s === 1 && (o = o.concat(["*", i2, " + "]));
          return o.join("");
        }, lagrangePolynomial: function(t2) {
          var e3 = [], i2 = function(i3, r2) {
            var s, o, n, a, h = t2.length, l = 0, c = 0;
            if (!r2)
              for (s = 0; s < h; s++) {
                for (e3[s] = 1, n = t2[s].X(), o = 0; o < h; o++)
                  o !== s && (e3[s] *= n - t2[o].X());
                e3[s] = 1 / e3[s];
              }
            for (s = 0; s < h; s++) {
              if (n = t2[s].X(), i3 === n)
                return t2[s].Y();
              a = e3[s] / (i3 - n), c += a, l += a * t2[s].Y();
            }
            return l / c;
          };
          return i2.getTerm = function() {
            return "";
          }, i2;
        }, _initCubicPoly: function(t2, e3, i2, r2) {
          return [t2, i2, -3 * t2 + 3 * e3 - 2 * i2 - r2, 2 * t2 - 2 * e3 + i2 + r2];
        }, CardinalSpline: function(t2, r2, s) {
          var o, n, a, h, l = [], c = this;
          return h = e2.isFunction(r2) ? r2 : function() {
            return r2;
          }, s === void 0 && (s = "uniform"), n = function(e3) {
            return function(r3, n3) {
              var d, u, p, f, m, g, b, v, y, C;
              if (t2.length < 2)
                return NaN;
              if (!n3)
                for (a = h(), p = {X: function() {
                  return 2 * t2[0].X() - t2[1].X();
                }, Y: function() {
                  return 2 * t2[0].Y() - t2[1].Y();
                }, Dist: function(t3) {
                  var e4 = this.X() - t3.X(), i2 = this.Y() - t3.Y();
                  return Math.sqrt(e4 * e4 + i2 * i2);
                }}, f = {X: function() {
                  return 2 * t2[t2.length - 1].X() - t2[t2.length - 2].X();
                }, Y: function() {
                  return 2 * t2[t2.length - 1].Y() - t2[t2.length - 2].Y();
                }, Dist: function(t3) {
                  var e4 = this.X() - t3.X(), i2 = this.Y() - t3.Y();
                  return Math.sqrt(e4 * e4 + i2 * i2);
                }}, o = [p].concat(t2, [f]), C = o.length, l[e3] = [], d = 0; d < C - 3; d++)
                  s === "centripetal" ? (b = o[d].Dist(o[d + 1]), v = o[d + 2].Dist(o[d + 1]), y = o[d + 3].Dist(o[d + 2]), b = Math.sqrt(b), v = Math.sqrt(v), y = Math.sqrt(y), v < i.eps && (v = 1), b < i.eps && (b = v), y < i.eps && (y = v), m = (o[d + 1][e3]() - o[d][e3]()) / b - (o[d + 2][e3]() - o[d][e3]()) / (v + b) + (o[d + 2][e3]() - o[d + 1][e3]()) / v, g = (o[d + 2][e3]() - o[d + 1][e3]()) / v - (o[d + 3][e3]() - o[d + 1][e3]()) / (y + v) + (o[d + 3][e3]() - o[d + 2][e3]()) / y, m *= v, g *= v, l[e3][d] = c._initCubicPoly(o[d + 1][e3](), o[d + 2][e3](), a * m, a * g)) : l[e3][d] = c._initCubicPoly(o[d + 1][e3](), o[d + 2][e3](), a * (o[d + 2][e3]() - o[d][e3]()), a * (o[d + 3][e3]() - o[d + 1][e3]()));
              return isNaN(r3) ? NaN : (C = t2.length, r3 <= 0 ? t2[0][e3]() : r3 >= C ? t2[C - 1][e3]() : (d = Math.floor(r3)) === r3 ? t2[d][e3]() : (r3 -= d, u = l[e3][d], u === void 0 ? NaN : ((u[3] * r3 + u[2]) * r3 + u[1]) * r3 + u[0]));
            };
          }, [n("X"), n("Y"), 0, function() {
            return t2.length - 1;
          }];
        }, CatmullRomSpline: function(t2, e3) {
          return this.CardinalSpline(t2, 0.5, e3);
        }, regressionPolynomial: function(t2, r2, s) {
          var o, n, a, h, l, c, d = "";
          if (e2.isPoint(t2) && e2.isFunction(t2.Value))
            n = function() {
              return t2.Value();
            };
          else if (e2.isFunction(t2))
            n = t2;
          else {
            if (!e2.isNumber(t2))
              throw new Error("JSXGraph: Can't create regressionPolynomial from degree of type'" + typeof t2 + "'.");
            n = function() {
              return t2;
            };
          }
          if (arguments.length === 3 && e2.isArray(r2) && e2.isArray(s))
            l = 0;
          else if (arguments.length === 2 && e2.isArray(r2) && r2.length > 0 && e2.isPoint(r2[0]))
            l = 1;
          else {
            if (!(arguments.length === 2 && e2.isArray(r2) && r2.length > 0 && r2[0].usrCoords && r2[0].scrCoords))
              throw new Error("JSXGraph: Can't create regressionPolynomial. Wrong parameters.");
            l = 2;
          }
          return c = function(t3, c2) {
            var u, p, f, m, g, b, v, y, C, _4 = r2.length;
            if (C = Math.floor(n()), !c2) {
              if (l === 1)
                for (a = [], h = [], u = 0; u < _4; u++)
                  a[u] = r2[u].X(), h[u] = r2[u].Y();
              if (l === 2)
                for (a = [], h = [], u = 0; u < _4; u++)
                  a[u] = r2[u].usrCoords[1], h[u] = r2[u].usrCoords[2];
              if (l === 0)
                for (a = [], h = [], u = 0; u < _4; u++)
                  e2.isFunction(r2[u]) ? a.push(r2[u]()) : a.push(r2[u]), e2.isFunction(s[u]) ? h.push(s[u]()) : h.push(s[u]);
              for (f = [], p = 0; p < _4; p++)
                f.push([1]);
              for (u = 1; u <= C; u++)
                for (p = 0; p < _4; p++)
                  f[p][u] = f[p][u - 1] * a[p];
              g = h, m = i.transpose(f), b = i.matMatMult(m, f), v = i.matVecMult(m, g), o = i.Numerics.Gauss(b, v), d = i.Numerics.generatePolynomialTerm(o, C, "x", 3);
            }
            for (y = o[C], u = C - 1; u >= 0; u--)
              y = y * t3 + o[u];
            return y;
          }, c.getTerm = function() {
            return d;
          }, c;
        }, bezier: function(t2) {
          var e3, i2, r2 = function(r3) {
            return function(s, o) {
              var n = 3 * Math.floor(s), a = s % 1, h = 1 - a;
              return o || (i2 = 3 * Math.floor((t2.length - 1) / 3), e3 = Math.floor(i2 / 3)), s < 0 ? t2[0][r3]() : s >= e3 ? t2[i2][r3]() : isNaN(s) ? NaN : h * h * (h * t2[n][r3]() + 3 * a * t2[n + 1][r3]()) + (3 * h * t2[n + 2][r3]() + a * t2[n + 3][r3]()) * a * a;
            };
          };
          return [r2("X"), r2("Y"), 0, function() {
            return Math.floor(t2.length / 3);
          }];
        }, bspline: function(t2, e3) {
          var i2, r2 = function(t3, e4) {
            var i3, r3 = [];
            for (i3 = 0; i3 < t3 + e4 + 1; i3++)
              r3[i3] = i3 < e4 ? 0 : i3 <= t3 ? i3 - e4 + 1 : t3 - e4 + 2;
            return r3;
          }, s = function(t3, e4, i3, r3) {
            var s2, o2, n, a, h, l = [];
            for (e4[r3] <= t3 && t3 < e4[r3 + 1] ? l[r3] = 1 : l[r3] = 0, s2 = 2; s2 <= i3; s2++)
              for (o2 = r3 - s2 + 1; o2 <= r3; o2++)
                n = o2 <= r3 - s2 + 1 || o2 < 0 ? 0 : l[o2], a = o2 >= r3 ? 0 : l[o2 + 1], h = e4[o2 + s2 - 1] - e4[o2], l[o2] = h === 0 ? 0 : (t3 - e4[o2]) / h * n, (h = e4[o2 + s2] - e4[o2 + 1]) !== 0 && (l[o2] += (e4[o2 + s2] - t3) / h * a);
            return l;
          }, o = function(o2) {
            return function(n, a) {
              var h, l, c, d = [], u = t2.length, p = u - 1, f = e3;
              if (p <= 0)
                return NaN;
              if (p + 2 <= f && (f = p + 1), n <= 0)
                return t2[0][o2]();
              if (n >= p - f + 2)
                return t2[p][o2]();
              for (c = Math.floor(n) + f - 1, i2 = r2(p, f), d = s(n, i2, f, c), h = 0, l = c - f + 1; l <= c; l++)
                l < u && l >= 0 && (h += t2[l][o2]() * d[l]);
              return h;
            };
          };
          return [o("X"), o("Y"), 0, function() {
            return t2.length - 1;
          }];
        }, D: function(t2, i2) {
          return e2.exists(i2) ? function(e3, r2) {
            var s = 1e-5;
            return (t2.apply(i2, [e3 + s, r2]) - t2.apply(i2, [e3 - s, r2])) / 2e-5;
          } : function(e3, i3) {
            var r2 = 1e-5;
            return (t2(e3 + r2, i3) - t2(e3 - r2, i3)) / 2e-5;
          };
        }, _riemannValue: function(t2, e3, i2, r2) {
          var s, o, n, a;
          if (r2 < 0 && (i2 !== "trapezoidal" && (t2 += r2), r2 *= -1, i2 === "lower" ? i2 = "upper" : i2 === "upper" && (i2 = "lower")), a = 0.01 * r2, i2 === "right")
            s = e3(t2 + r2);
          else if (i2 === "middle")
            s = e3(t2 + 0.5 * r2);
          else if (i2 === "left" || i2 === "trapezoidal")
            s = e3(t2);
          else if (i2 === "lower") {
            for (s = e3(t2), n = t2 + a; n <= t2 + r2; n += a)
              (o = e3(n)) < s && (s = o);
            o = e3(t2 + r2), o < s && (s = o);
          } else if (i2 === "upper") {
            for (s = e3(t2), n = t2 + a; n <= t2 + r2; n += a)
              (o = e3(n)) > s && (s = o);
            o = e3(t2 + r2), o > s && (s = o);
          } else
            s = i2 === "random" ? e3(t2 + r2 * Math.random()) : i2 === "simpson" ? (e3(t2) + 4 * e3(t2 + 0.5 * r2) + e3(t2 + r2)) / 6 : e3(t2);
          return s;
        }, riemann: function(t2, i2, r2, s, o) {
          var n, a, h, l, c, d, u, p = [], f = [], m = 0, g = s, b = 0;
          if (e2.isArray(t2) ? (c = t2[0], l = t2[1]) : l = t2, (i2 = Math.floor(i2)) <= 0)
            return [p, f, b];
          for (a = (o - s) / i2, n = 0; n < i2; n++)
            h = this._riemannValue(g, l, r2, a), p[m] = g, f[m] = h, m += 1, g += a, r2 === "trapezoidal" && (h = l(g)), p[m] = g, f[m] = h, m += 1;
          for (n = 0; n < i2; n++)
            h = c ? this._riemannValue(g, c, r2, -a) : 0, p[m] = g, f[m] = h, m += 1, g -= a, r2 === "trapezoidal" && c && (h = c(g)), p[m] = g, f[m] = h, r2 !== "trapezoidal" ? (d = h, u = f[2 * (i2 - 1) - 2 * n]) : (u = 0.5 * (l(g + a) + l(g)), d = c ? 0.5 * (c(g + a) + c(g)) : 0), b += (u - d) * a, m += 1, p[m] = g, f[m] = f[2 * (i2 - 1) - 2 * n], m += 1;
          return [p, f, b];
        }, riemannsum: function(e3, i2, r2, s, o) {
          return t.deprecated("Numerics.riemannsum()", "Numerics.riemann()"), this.riemann(e3, i2, r2, s, o)[2];
        }, rungeKutta: function(t2, i2, s, o, n) {
          var a, h, l, c, d, u, p = [], f = [], m = (s[1] - s[0]) / o, g = s[0], b = i2.length, v = [], y = 0;
          for (e2.isString(t2) && (t2 = r[t2] || r.euler), u = t2.s, a = 0; a < b; a++)
            p[a] = i2[a];
          for (h = 0; h < o; h++) {
            for (v[y] = [], a = 0; a < b; a++)
              v[y][a] = p[a];
            for (y += 1, c = [], l = 0; l < u; l++) {
              for (a = 0; a < b; a++)
                f[a] = 0;
              for (d = 0; d < l; d++)
                for (a = 0; a < b; a++)
                  f[a] += t2.A[l][d] * m * c[d][a];
              for (a = 0; a < b; a++)
                f[a] += p[a];
              c.push(n(g + t2.c[l] * m, f));
            }
            for (a = 0; a < b; a++)
              f[a] = 0;
            for (d = 0; d < u; d++)
              for (a = 0; a < b; a++)
                f[a] += t2.b[d] * c[d][a];
            for (a = 0; a < b; a++)
              p[a] = p[a] + m * f[a];
            g += m;
          }
          return v;
        }, maxIterationsRoot: 80, maxIterationsMinimize: 500, findBracket: function(t2, i2, r2) {
          var s, o, n, a, h, l, c, d, u, p;
          if (e2.isArray(i2))
            return i2;
          for (s = i2, n = t2.call(r2, s), o = s === 0 ? 1 : s, a = [s - 0.1 * o, s + 0.1 * o, s - 1, s + 1, s - 0.5 * o, s + 0.5 * o, s - 0.6 * o, s + 0.6 * o, s - 1 * o, s + 1 * o, s - 2 * o, s + 2 * o, s - 5 * o, s + 5 * o, s - 10 * o, s + 10 * o, s - 50 * o, s + 50 * o, s - 100 * o, s + 100 * o], p = a.length, u = 0; u < p && (h = a[u], l = t2.call(r2, h), !(n * l <= 0)); u++)
            ;
          return h < s && (c = s, s = h, h = c, d = n, n = l, l = d), [s, n, h, l];
        }, fzero: function(t2, r2, s) {
          var o, n, a, h, l, c, d, u, p, f, m, g, b, v, y, C = i.eps, _4 = this.maxIterationsRoot, P2 = 0;
          if (e2.isArray(r2)) {
            if (r2.length < 2)
              throw new Error("JXG.Math.Numerics.fzero: length of array x0 has to be at least two.");
            o = r2[0], h = t2.call(s, o), n = r2[1], l = t2.call(s, n);
          } else
            d = this.findBracket(t2, r2, s), o = d[0], h = d[1], n = d[2], l = d[3];
          if (Math.abs(h) <= C)
            return o;
          if (Math.abs(l) <= C)
            return n;
          if (h * l > 0)
            return e2.isArray(r2) ? this.fminbr(t2, [o, n], s) : this.Newton(t2, o, s);
          for (a = o, c = h; P2 < _4; ) {
            if (u = n - o, Math.abs(c) < Math.abs(l) && (o = n, n = a, a = o, h = l, l = c, c = h), g = 2 * C * Math.abs(n) + 0.5 * C, y = 0.5 * (a - n), Math.abs(y) <= g || Math.abs(l) <= C)
              return n;
            Math.abs(u) >= g && Math.abs(h) > Math.abs(l) && (f = a - n, o === a ? (p = l / h, b = f * p, v = 1 - p) : (v = h / c, p = l / c, m = l / h, b = m * (f * v * (v - p) - (n - o) * (p - 1)), v = (v - 1) * (p - 1) * (m - 1)), b > 0 ? v = -v : b = -b, b < 0.75 * f * v - 0.5 * Math.abs(g * v) && b < Math.abs(u * v * 0.5) && (y = b / v)), Math.abs(y) < g && (y = y > 0 ? g : -g), o = n, h = l, n += y, l = t2.call(s, n), (l > 0 && c > 0 || l < 0 && c < 0) && (a = o, c = h), P2++;
          }
          return n;
        }, chandrupatla: function(t2, r2, s) {
          var o, n, a, h, l, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S, O, w, T, N, M, A = 0, R = this.maxIterationsRoot, L = 1 + 1e-3 * Math.random(), k = 0.5 * L, B = i.eps;
          if (e2.isArray(r2)) {
            if (r2.length < 2)
              throw new Error("JXG.Math.Numerics.fzero: length of array x0 has to be at least two.");
            o = r2[0], n = t2.call(s, o), a = r2[1], h = t2.call(s, a);
          } else
            l = this.findBracket(t2, r2, s), o = l[0], n = l[1], a = l[2], h = l[3];
          if (n * h > 0)
            return e2.isArray(r2) ? this.fminbr(t2, [o, a], s) : this.Newton(t2, o, s);
          c = o, d = a, f = n, m = h;
          do {
            if (p = c + k * (d - c), b = t2.call(s, p), Math.sign(b) === Math.sign(f) ? (u = c, c = p, g = f, f = b) : (u = d, d = c, g = m, m = f), c = p, f = b, v = c, y = f, Math.abs(m) < Math.abs(f) && (v = d, y = m), C = 2 * B * Math.abs(v) + 5e-6, (_4 = C / Math.abs(d - c)) > 0.5 || y === 0)
              break;
            P2 = (c - d) / (u - d), E = (f - m) / (g - m), x = 1 - Math.sqrt(1 - P2), S = Math.sqrt(P2), x < E && E < S ? (O = (u - c) / (d - c), w = f / (m - f), T = g / (m - g), N = f / (g - f), M = m / (g - m), k = w * T + N * M * O) : k = 0.5 * L, k < _4 && (k = _4), k > 1 - _4 && (k = 1 - _4), A++;
          } while (A <= R);
          return v;
        }, fminbr: function(t2, r2, s) {
          var o, n, a, h, l, c, d, u, p, f, m, g, b, v, y, C, _4 = 0.5 * (3 - Math.sqrt(5)), P2 = i.eps, E = i.eps, x = this.maxIterationsMinimize, S = 0;
          if (!e2.isArray(r2) || r2.length < 2)
            throw new Error("JXG.Math.Numerics.fminbr: length of array x0 has to be at least two.");
          for (o = r2[0], n = r2[1], h = o + _4 * (n - o), d = t2.call(s, h), a = h, l = h, c = d, u = d; S < x; ) {
            if (p = n - o, f = 0.5 * (o + n), m = E * Math.abs(a) + P2 / 3, Math.abs(a - f) + 0.5 * p <= 2 * m)
              return a;
            g = _4 * (a < f ? n - a : o - a), Math.abs(a - l) >= m && (y = (a - l) * (c - d), v = (a - h) * (c - u), b = (a - h) * v - (a - l) * y, v = 2 * (v - y), v > 0 ? b = -b : v = -v, Math.abs(b) < Math.abs(g * v) && b > v * (o - a + 2 * m) && b < v * (n - a - 2 * m) && (g = b / v)), Math.abs(g) < m && (g = g > 0 ? m : -m), y = a + g, C = t2.call(s, y), C <= c ? (y < a ? n = a : o = a, h = l, l = a, a = y, d = u, u = c, c = C) : (y < a ? o = y : n = y, C <= u || l === a ? (h = l, l = y, d = u, u = C) : (C <= d || h === a || h === l) && (h = y, d = C)), S += 1;
          }
          return a;
        }, RamerDouglasPeucker: function(t2, e3) {
          var r2, s, o, n = [], a = [], h = function(t3, e4, r3) {
            var s2, o2, n3, a2, h2, l2, c, d, u, p, f, m = 0, g = e4;
            if (r3 - e4 < 2)
              return [-1, 0];
            if (n3 = t3[e4].scrCoords, a2 = t3[r3].scrCoords, isNaN(n3[1]) || isNaN(n3[2]))
              return [NaN, e4];
            if (isNaN(a2[1]) || isNaN(a2[2]))
              return [NaN, r3];
            for (o2 = e4 + 1; o2 < r3; o2++) {
              if (h2 = t3[o2].scrCoords, isNaN(h2[1]) || isNaN(h2[2]))
                return [NaN, o2];
              l2 = h2[1] - n3[1], c = h2[2] - n3[2], d = a2[1] - n3[1], u = a2[2] - n3[2], l2 = l2 === 1 / 0 ? 1e4 : l2, c = c === 1 / 0 ? 1e4 : c, d = d === 1 / 0 ? 1e4 : d, u = u === 1 / 0 ? 1e4 : u, l2 = l2 === -1 / 0 ? -1e4 : l2, c = c === -1 / 0 ? -1e4 : c, d = d === -1 / 0 ? -1e4 : d, u = u === -1 / 0 ? -1e4 : u, p = d * d + u * u, p >= i.eps ? (f = (l2 * d + c * u) / p, f < 0 ? f = 0 : f > 1 && (f = 1), l2 -= f * d, c -= f * u, s2 = l2 * l2 + c * c) : (f = 0, s2 = l2 * l2 + c * c), s2 > m && (m = s2, g = o2);
            }
            return [Math.sqrt(m), g];
          }, l = function(t3, e4, i2, r3, s2) {
            var o2 = h(t3, e4, i2), n3 = o2[1];
            if (isNaN(o2[0])) {
              l(t3, e4, n3 - 1, r3, s2), s2.push(t3[n3]);
              do {
                ++n3;
              } while (n3 <= i2 && isNaN(t3[n3].scrCoords[1] + t3[n3].scrCoords[2]));
              n3 <= i2 && s2.push(t3[n3]), l(t3, n3 + 1, i2, r3, s2);
            } else
              o2[0] > r3 ? (l(t3, e4, n3, r3, s2), l(t3, n3, i2, r3, s2)) : s2.push(t3[i2]);
          };
          for (o = t2.length, r2 = 0; ; ) {
            for (; r2 < o && isNaN(t2[r2].scrCoords[1] + t2[r2].scrCoords[2]); )
              r2 += 1;
            for (s = r2 + 1; s < o && !isNaN(t2[s].scrCoords[1] + t2[s].scrCoords[2]); )
              s += 1;
            if (s--, r2 < o && s > r2 && (a = [], a[0] = t2[r2], l(t2, r2, s, e3, a), n = n.concat(a)), r2 >= o)
              break;
            s < o - 1 && n.push(t2[s + 1]), r2 = s + 1;
          }
          return n;
        }, RamerDouglasPeuker: function(e3, i2) {
          return t.deprecated("Numerics.RamerDouglasPeuker()", "Numerics.RamerDouglasPeucker()"), this.RamerDouglasPeucker(e3, i2);
        }, Visvalingam: function(e3, i2) {
          var r2, s, o, n, a, h, l, c, d, u = [], p = [], f = [];
          if ((s = e3.length) <= 2)
            return e3;
          for (u[0] = {used: true, lft: null, node: null}, a = 0, r2 = 1; r2 < s - 1; r2++)
            o = Math.abs(t.Math.Numerics.det([e3[r2 - 1].usrCoords, e3[r2].usrCoords, e3[r2 + 1].usrCoords])), isNaN(o) || (d = {v: o, idx: r2}, p.push(d), u[r2] = {used: true, lft: a, node: d}, u[a].rt = r2, a = r2);
          for (u[s - 1] = {used: true, rt: null, lft: a, node: null}, u[a].rt = s - 1, n = -1 / 0; p.length > i2; )
            p.sort(function(t2, e4) {
              return e4.v - t2.v;
            }), r2 = p.pop().idx, u[r2].used = false, n = u[r2].node.v, a = u[r2].lft, h = u[r2].rt, u[a].rt = h, u[h].lft = a, l = u[a].lft, l !== null && (o = Math.abs(t.Math.Numerics.det([e3[l].usrCoords, e3[a].usrCoords, e3[h].usrCoords])), u[a].node.v = o >= n ? o : n), (c = u[h].rt) !== null && (o = Math.abs(t.Math.Numerics.det([e3[a].usrCoords, e3[h].usrCoords, e3[c].usrCoords])), u[h].node.v = o >= n ? o : n);
          r2 = 0, f = [e3[r2]];
          do {
            r2 = u[r2].rt, f.push(e3[r2]);
          } while (u[r2].rt !== null);
          return f;
        }}, i.Numerics;
      }), define("math/nlp", ["jxg", "math/math", "utils/type"], function(t, e2, i) {
        "use strict";
        return t.Math.Nlp = {arr: function(t2) {
          var e3, i2 = new Array(t2);
          for (e3 = 0; e3 < t2; e3++)
            i2[e3] = 0;
          return i2;
        }, arr2: function(t2, e3) {
          for (var i2 = 0, r = new Array(t2); i2 < t2; )
            r[i2] = this.arr(e3), i2++;
          return r;
        }, arraycopy: function(t2, e3, i2, r, s) {
          for (var o = 0; o < s; )
            i2[o + r] = t2[o + e3], o++;
        }, Normal: 0, MaxIterationsReached: 1, DivergingRoundingErrors: 2, FindMinimum: function(t2, e3, i2, r, s, o, n, a) {
          var h, l, c = i2 + 2, d = this.arr(e3 + 1), u = this;
          return d[0] = 0, this.arraycopy(r, 0, d, 1, e3), l = function(e4, i3, r2, s2) {
            var o2, n3, a2 = u.arr(e4);
            return u.arraycopy(r2, 1, a2, 0, e4), o2 = u.arr(i3), n3 = t2(e4, i3, a2, o2), u.arraycopy(o2, 0, s2, 1, i3), n3;
          }, h = this.cobylb(l, e3, i2, c, d, s, o, n, a), this.arraycopy(d, 1, r, 0, e3), h;
        }, cobylb: function(t2, e3, i2, r, s, o, n, a, h) {
          var l, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S, O, w, T, N, M, A, R, L, k, B, I, Y, D, j, X = -1, U = 0, F = 0, G = e3 + 1, J = i2 + 1, z = o, H = 0, V = false, $ = false, q = 0, W = 0, Z = 0, Q2 = this.arr(1 + r), K = this.arr2(1 + e3, 1 + G), tt = this.arr2(1 + e3, 1 + e3), et = this.arr2(1 + r, 1 + G), it = this.arr2(1 + e3, 1 + J), rt = this.arr(1 + e3), st = this.arr(1 + e3), ot = this.arr(1 + e3), nt = this.arr(1 + e3), at = this.arr(1 + e3);
          for (a >= 2 && console.log("The initial value of RHO is " + z + " and PARMU is set to zero."), g = 0, f = 1 / z, c = 1; c <= e3; ++c)
            K[c][G] = s[c], K[c][c] = z, tt[c][c] = f;
          b = G, v = false;
          t:
            for (; ; ) {
              if (g >= h && g > 0) {
                X = this.MaxIterationsReached;
                break t;
              }
              for (++g, U = t2(e3, i2, s, Q2), F = 0, u = 1; u <= i2; ++u)
                F = Math.max(F, -Q2[u]);
              if (g !== a - 1 && a !== 3 || this.PrintIterationResult(g, U, F, s, e3, a), Q2[J] = U, Q2[r] = F, y = true, !v) {
                for (y = false, c = 1; c <= r; ++c)
                  et[c][b] = Q2[c];
                if (g <= G) {
                  if (b <= e3)
                    if (et[J][G] <= U)
                      s[b] = K[b][G];
                    else {
                      for (K[b][G] = s[b], u = 1; u <= r; ++u)
                        et[u][b] = et[u][G], et[u][G] = Q2[u];
                      for (u = 1; u <= b; ++u) {
                        for (K[b][u] = -z, f = 0, c = u; c <= b; ++c)
                          f -= tt[c][u];
                        tt[b][u] = f;
                      }
                    }
                  if (g <= e3) {
                    b = g, s[b] += z;
                    continue t;
                  }
                }
                v = true;
              }
              e:
                for (; ; ) {
                  i:
                    do {
                      if (!y) {
                        for (C = et[J][G] + H * et[r][G], _4 = G, d = 1; d <= e3; ++d)
                          f = et[J][d] + H * et[r][d], f < C ? (_4 = d, C = f) : f === C && H === 0 && et[r][d] < et[r][_4] && (_4 = d);
                        if (_4 <= e3) {
                          for (c = 1; c <= r; ++c)
                            f = et[c][G], et[c][G] = et[c][_4], et[c][_4] = f;
                          for (c = 1; c <= e3; ++c) {
                            for (f = K[c][_4], K[c][_4] = 0, K[c][G] += f, m = 0, u = 1; u <= e3; ++u)
                              K[c][u] -= f, m -= tt[u][c];
                            tt[_4][c] = m;
                          }
                        }
                        for (P2 = 0, c = 1; c <= e3; ++c)
                          for (d = 1; d <= e3; ++d)
                            f = this.DOT_PRODUCT(this.PART(this.ROW(tt, c), 1, e3), this.PART(this.COL(K, d), 1, e3)) - (c === d ? 1 : 0), P2 = Math.max(P2, Math.abs(f));
                        if (P2 > 0.1) {
                          X = this.DivergingRoundingErrors;
                          break t;
                        }
                        for (u = 1; u <= J; ++u) {
                          for (Q2[u] = -et[u][G], d = 1; d <= e3; ++d)
                            at[d] = et[u][d] + Q2[u];
                          for (c = 1; c <= e3; ++c)
                            it[c][u] = (u === J ? -1 : 1) * this.DOT_PRODUCT(this.PART(at, 1, e3), this.PART(this.COL(tt, c), 1, e3));
                        }
                        for (V = true, q = 0.25 * z, E = 2.1 * z, d = 1; d <= e3; ++d) {
                          for (x = 0, u = 1; u <= e3; ++u)
                            x += tt[d][u] * tt[d][u];
                          for (S = 0, u = 1; u <= e3; ++u)
                            S += K[u][d] * K[u][d];
                          rt[d] = 1 / Math.sqrt(x), st[d] = Math.sqrt(S), (rt[d] < q || st[d] > E) && (V = false);
                        }
                        if (!v && !V) {
                          for (b = 0, f = E, d = 1; d <= e3; ++d)
                            st[d] > f && (b = d, f = st[d]);
                          if (b === 0)
                            for (d = 1; d <= e3; ++d)
                              rt[d] < f && (b = d, f = rt[d]);
                          for (f = 0.5 * z * rt[b], u = 1; u <= e3; ++u)
                            nt[u] = f * tt[b][u];
                          for (O = 0, w = 0, l = 0, u = 1; u <= J; ++u)
                            l = this.DOT_PRODUCT(this.PART(this.COL(it, u), 1, e3), this.PART(nt, 1, e3)), u < J && (f = et[u][G], O = Math.max(O, -l - f), w = Math.max(w, l - f));
                          for (T = H * (O - w) > 2 * l ? -1 : 1, f = 0, c = 1; c <= e3; ++c)
                            nt[c] = T * nt[c], K[c][b] = nt[c], f += tt[b][c] * nt[c];
                          for (u = 1; u <= e3; ++u)
                            tt[b][u] /= f;
                          for (d = 1; d <= e3; ++d) {
                            if (d !== b)
                              for (f = this.DOT_PRODUCT(this.PART(this.ROW(tt, d), 1, e3), this.PART(nt, 1, e3)), u = 1; u <= e3; ++u)
                                tt[d][u] -= f * tt[b][u];
                            s[d] = K[d][G] + nt[d];
                          }
                          continue t;
                        }
                        if (!($ = this.trstlp(e3, i2, it, Q2, z, nt))) {
                          for (f = 0, u = 1; u <= e3; ++u)
                            f += nt[u] * nt[u];
                          if (f < 0.25 * z * z) {
                            v = true;
                            break i;
                          }
                        }
                        for (l = 0, N = 0, Q2[J] = 0, u = 1; u <= J; ++u)
                          l = Q2[u] - this.DOT_PRODUCT(this.PART(this.COL(it, u), 1, e3), this.PART(nt, 1, e3)), u < J && (N = Math.max(N, l));
                        if (W = et[r][G] - N, M = W > 0 ? l / W : 0, H < 1.5 * M) {
                          for (H = 2 * M, a >= 2 && console.log("Increase in PARMU to " + H), A = et[J][G] + H * et[r][G], d = 1; d <= e3; ++d)
                            if ((f = et[J][d] + H * et[r][d]) < A || f === A && H === 0 && et[r][d] < et[r][G])
                              continue e;
                        }
                        for (Z = H * W - l, u = 1; u <= e3; ++u)
                          s[u] = K[u][G] + nt[u];
                        v = true;
                        continue t;
                      }
                      for (y = false, R = et[J][G] + H * et[r][G], L = U + H * F, k = R - L, H === 0 && U === et[J][G] && (Z = W, k = et[r][G] - F), B = k <= 0 ? 1 : 0, b = 0, d = 1; d <= e3; ++d)
                        f = Math.abs(this.DOT_PRODUCT(this.PART(this.ROW(tt, d), 1, e3), this.PART(nt, 1, e3))), f > B && (b = d, B = f), ot[d] = f * rt[d];
                      for (I = 1.1 * z, p = 0, d = 1; d <= e3; ++d)
                        if (ot[d] >= q || ot[d] >= rt[d]) {
                          if (f = st[d], k > 0) {
                            for (f = 0, u = 1; u <= e3; ++u)
                              f += Math.pow(nt[u] - K[u][d], 2);
                            f = Math.sqrt(f);
                          }
                          f > I && (p = d, I = f);
                        }
                      if (p > 0 && (b = p), b !== 0) {
                        for (f = 0, c = 1; c <= e3; ++c)
                          K[c][b] = nt[c], f += tt[b][c] * nt[c];
                        for (u = 1; u <= e3; ++u)
                          tt[b][u] /= f;
                        for (d = 1; d <= e3; ++d)
                          if (d !== b)
                            for (f = this.DOT_PRODUCT(this.PART(this.ROW(tt, d), 1, e3), this.PART(nt, 1, e3)), u = 1; u <= e3; ++u)
                              tt[d][u] -= f * tt[b][u];
                        for (u = 1; u <= r; ++u)
                          et[u][b] = Q2[u];
                        if (k > 0 && k >= 0.1 * Z)
                          continue e;
                      }
                    } while (false);
                  if (V) {
                    if (z <= n) {
                      X = this.Normal;
                      break t;
                    }
                    if (Y = 0, D = 0, z *= 0.5, z <= 1.5 * n && (z = n), H > 0) {
                      for (j = 0, u = 1; u <= J; ++u) {
                        for (Y = et[u][G], D = Y, c = 1; c <= e3; ++c)
                          Y = Math.min(Y, et[u][c]), D = Math.max(D, et[u][c]);
                        u <= i2 && Y < 0.5 * D && (f = Math.max(D, 0) - Y, j = j <= 0 ? f : Math.min(j, f));
                      }
                      j === 0 ? H = 0 : D - Y < H * j && (H = (D - Y) / j);
                    }
                    a >= 2 && console.log("Reduction in RHO to " + z + "  and PARMU = " + H), a === 2 && this.PrintIterationResult(g, et[J][G], et[r][G], this.COL(K, G), e3, a);
                  } else
                    v = false;
                }
            }
          switch (X) {
            case this.Normal:
              if (a >= 1 && console.log("%nNormal return from subroutine COBYLA%n"), $)
                return a >= 1 && this.PrintIterationResult(g, U, F, s, e3, a), X;
              break;
            case this.MaxIterationsReached:
              a >= 1 && console.log("%nReturn from subroutine COBYLA because the MAXFUN limit has been reached.%n");
              break;
            case this.DivergingRoundingErrors:
              a >= 1 && console.log("%nReturn from subroutine COBYLA because rounding errors are becoming damaging.%n");
          }
          for (u = 1; u <= e3; ++u)
            s[u] = K[u][G];
          return U = et[J][G], F = et[r][G], a >= 1 && this.PrintIterationResult(g, U, F, s, e3, a), X;
        }, trstlp: function(t2, e3, i2, r, s, o) {
          var n, a, h, l, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S, O, w, T, N, M, A, R, L, k, B, I, Y, D, j, X = 0, U = 0, F = 0, G = this.arr2(1 + t2, 1 + t2), J = this.arr(2 + e3), z = this.arr(2 + e3), H = this.arr(1 + t2), V = this.arr(1 + t2), $ = this.arr(2 + e3), q = this.arr(2 + e3), W = e3, Z = 0;
          for (h = 1; h <= t2; ++h)
            G[h][h] = 1, o[h] = 0;
          if (n = 0, a = 0, e3 >= 1) {
            for (l = 1; l <= e3; ++l)
              r[l] > a && (a = r[l], n = l);
            for (l = 1; l <= e3; ++l)
              q[l] = l, z[l] = a - r[l];
          }
          c = true;
          do {
            t:
              for (; ; ) {
                (!c || c && a === 0) && (W = e3 + 1, n = W, q[W] = W, z[W] = 0), c = false, d = 0, u = 0, p = 0, f = 0;
                e:
                  do {
                    if (m = W === e3 ? a : -this.DOT_PRODUCT(this.PART(o, 1, t2), this.PART(this.COL(i2, W), 1, t2)), u === 0 || m < d ? (d = m, U = Z, u = 3) : Z > U ? (U = Z, u = 3) : --u, u === 0)
                      break t;
                    if (g = 0, n <= Z) {
                      if (n < Z) {
                        b = q[n], v = z[n], l = n;
                        do {
                          for (C = l + 1, _4 = q[C], P2 = this.DOT_PRODUCT(this.PART(this.COL(G, l), 1, t2), this.PART(this.COL(i2, _4), 1, t2)), X = Math.sqrt(P2 * P2 + J[C] * J[C]), E = J[C] / X, x = P2 / X, J[C] = E * J[l], J[l] = X, h = 1; h <= t2; ++h)
                            X = E * G[h][C] + x * G[h][l], G[h][C] = E * G[h][l] - x * G[h][C], G[h][l] = X;
                          q[l] = _4, z[l] = z[C], l = C;
                        } while (l < Z);
                        q[l] = b, z[l] = v;
                      }
                      if (--Z, W > e3)
                        for (X = 1 / J[Z], l = 1; l <= t2; ++l)
                          H[l] = X * G[l][Z];
                      else
                        for (X = this.DOT_PRODUCT(this.PART(H, 1, t2), this.PART(this.COL(G, Z + 1), 1, t2)), l = 1; l <= t2; ++l)
                          H[l] -= X * G[l][Z + 1];
                    } else {
                      for (_4 = q[n], l = 1; l <= t2; ++l)
                        V[l] = i2[l][_4];
                      for (S = 0, l = t2; l > Z; ) {
                        for (P2 = 0, O = 0, h = 1; h <= t2; ++h)
                          X = G[h][l] * V[h], P2 += X, O += Math.abs(X);
                        if (w = O + 0.1 * Math.abs(P2), T = O + 0.2 * Math.abs(P2), (O >= w || w >= T) && (P2 = 0), S === 0)
                          S = P2;
                        else
                          for (C = l + 1, X = Math.sqrt(P2 * P2 + S * S), E = P2 / X, x = S / X, S = X, h = 1; h <= t2; ++h)
                            X = E * G[h][l] + x * G[h][C], G[h][C] = E * G[h][C] - x * G[h][l], G[h][l] = X;
                        --l;
                      }
                      if (S === 0) {
                        g = -1, l = Z;
                        do {
                          for (N = 0, M = 0, h = 1; h <= t2; ++h)
                            X = G[h][l] * V[h], N += X, M += Math.abs(X);
                          if (w = M + 0.1 * Math.abs(N), T = M + 0.2 * Math.abs(N), M < w && w < T) {
                            if (X = N / J[l], X > 0 && q[l] <= e3 && (j = z[l] / X, (g < 0 || j < g) && (g = j)), l >= 2)
                              for (A = q[l], h = 1; h <= t2; ++h)
                                V[h] -= X * i2[h][A];
                            $[l] = X;
                          } else
                            $[l] = 0;
                        } while (--l > 0);
                        if (g < 0)
                          break t;
                        for (l = 1; l <= Z; ++l)
                          z[l] = Math.max(0, z[l] - g * $[l]);
                        if (n < Z) {
                          b = q[n], v = z[n], l = n;
                          do {
                            for (C = l + 1, A = q[C], P2 = this.DOT_PRODUCT(this.PART(this.COL(G, l), 1, t2), this.PART(this.COL(i2, A), 1, t2)), X = Math.sqrt(P2 * P2 + J[C] * J[C]), E = J[C] / X, x = P2 / X, J[C] = E * J[l], J[l] = X, h = 1; h <= t2; ++h)
                              X = E * G[h][C] + x * G[h][l], G[h][C] = E * G[h][l] - x * G[h][C], G[h][l] = X;
                            q[l] = A, z[l] = z[C], l = C;
                          } while (l < Z);
                          q[l] = b, z[l] = v;
                        }
                        if ((X = this.DOT_PRODUCT(this.PART(this.COL(G, Z), 1, t2), this.PART(this.COL(i2, _4), 1, t2))) === 0)
                          break t;
                        J[Z] = X, z[n] = 0, z[Z] = g;
                      } else
                        ++Z, J[Z] = S, z[n] = z[Z], z[Z] = 0;
                      if (q[n] = q[Z], q[Z] = _4, W > e3 && _4 !== W) {
                        for (l = Z - 1, P2 = this.DOT_PRODUCT(this.PART(this.COL(G, l), 1, t2), this.PART(this.COL(i2, _4), 1, t2)), X = Math.sqrt(P2 * P2 + J[Z] * J[Z]), E = J[Z] / X, x = P2 / X, J[Z] = E * J[l], J[l] = X, h = 1; h <= t2; ++h)
                          X = E * G[h][Z] + x * G[h][l], G[h][Z] = E * G[h][l] - x * G[h][Z], G[h][l] = X;
                        q[Z] = q[l], q[l] = _4, X = z[l], z[l] = z[Z], z[Z] = X;
                      }
                      if (W > e3)
                        for (X = 1 / J[Z], l = 1; l <= t2; ++l)
                          H[l] = X * G[l][Z];
                      else
                        for (_4 = q[Z], X = (this.DOT_PRODUCT(this.PART(H, 1, t2), this.PART(this.COL(i2, _4), 1, t2)) - 1) / J[Z], l = 1; l <= t2; ++l)
                          H[l] -= X * G[l][Z];
                    }
                    for (R = s * s, k = 0, L = 0, h = 1; h <= t2; ++h)
                      Math.abs(o[h]) >= 1e-6 * s && (R -= o[h] * o[h]), k += o[h] * H[h], L += H[h] * H[h];
                    if (R <= 0)
                      break t;
                    if (X = Math.sqrt(L * R), Math.abs(k) >= 1e-6 * X && (X = Math.sqrt(L * R + k * k)), f = R / (X + k), p = f, W === e3) {
                      if (w = p + 0.1 * a, T = p + 0.2 * a, p >= w || w >= T)
                        break e;
                      p = Math.min(p, a);
                    }
                    for (l = 1; l <= t2; ++l)
                      V[l] = o[l] + p * H[l];
                    if (W === e3)
                      for (F = a, a = 0, l = 1; l <= Z; ++l)
                        _4 = q[l], X = r[_4] - this.DOT_PRODUCT(this.PART(this.COL(i2, _4), 1, t2), this.PART(V, 1, t2)), a = Math.max(a, X);
                    l = Z;
                    do {
                      for (B = 0, I = 0, h = 1; h <= t2; ++h)
                        X = G[h][l] * V[h], B += X, I += Math.abs(X);
                      if (w = I + 0.1 * Math.abs(B), T = I + 0.2 * Math.abs(B), (I >= w || w >= T) && (B = 0), $[l] = B / J[l], l >= 2)
                        for (_4 = q[l], h = 1; h <= t2; ++h)
                          V[h] -= $[l] * i2[h][_4];
                    } while (l-- >= 2);
                    for (W > e3 && ($[Z] = Math.max(0, $[Z])), l = 1; l <= t2; ++l)
                      V[l] = o[l] + p * H[l];
                    if (W > Z)
                      for (Y = Z + 1, l = Y; l <= W; ++l) {
                        for (_4 = q[l], y = a - r[_4], D = a + Math.abs(r[_4]), h = 1; h <= t2; ++h)
                          X = i2[h][_4] * V[h], y += X, D += Math.abs(X);
                        w = D + 0.1 * Math.abs(y), T = D + 0.2 * Math.abs(y), (D >= w || w >= T) && (y = 0), $[l] = y;
                      }
                    for (g = 1, n = 0, l = 1; l <= W; ++l)
                      $[l] < 0 && (X = z[l] / (z[l] - $[l])) < g && (g = X, n = l);
                    for (X = 1 - g, l = 1; l <= t2; ++l)
                      o[l] = X * o[l] + g * V[l];
                    for (l = 1; l <= W; ++l)
                      z[l] = Math.max(0, X * z[l] + g * $[l]);
                    W === e3 && (a = F + g * (a - F));
                  } while (n > 0);
                if (p === f)
                  return true;
              }
          } while (W === e3);
          return false;
        }, PrintIterationResult: function(t2, e3, i2, r, s, o) {
          o > 1 && console.log("NFVALS = " + t2 + "  F = " + e3 + "  MAXCV = " + i2), o > 1 && console.log("X = " + this.PART(r, 1, s));
        }, ROW: function(t2, e3) {
          return t2[e3].slice();
        }, COL: function(t2, e3) {
          var i2, r = t2.length, s = this.arr(r);
          for (i2 = 0; i2 < r; ++i2)
            s[i2] = t2[i2][e3];
          return s;
        }, PART: function(t2, e3, i2) {
          return t2.slice(e3, i2 + 1);
        }, FORMAT: function(t2) {
          return t2.join(",");
        }, DOT_PRODUCT: function(t2, e3) {
          var i2, r = 0, s = t2.length;
          for (i2 = 0; i2 < s; ++i2)
            r += t2[i2] * e3[i2];
          return r;
        }}, t.Math.Nlp;
      }), define("math/statistics", ["jxg", "math/math", "utils/type"], function(t, e2, i) {
        "use strict";
        return e2.Statistics = {sum: function(t2) {
          var e3, i2 = t2.length, r = 0;
          for (e3 = 0; e3 < i2; e3++)
            r += t2[e3];
          return r;
        }, prod: function(t2) {
          var e3, i2 = t2.length, r = 1;
          for (e3 = 0; e3 < i2; e3++)
            r *= t2[e3];
          return r;
        }, mean: function(t2) {
          return t2.length > 0 ? this.sum(t2) / t2.length : 0;
        }, median: function(t2) {
          var e3, i2;
          return t2.length > 0 ? (ArrayBuffer.isView(t2) ? (e3 = new Float64Array(t2), e3.sort()) : (e3 = t2.slice(0), e3.sort(function(t3, e4) {
            return t3 - e4;
          })), i2 = e3.length, 1 & i2 ? e3[parseInt(0.5 * i2, 10)] : 0.5 * (e3[0.5 * i2 - 1] + e3[0.5 * i2])) : 0;
        }, variance: function(t2) {
          var e3, i2, r, s = t2.length;
          if (s > 1) {
            for (e3 = this.mean(t2), i2 = 0, r = 0; r < s; r++)
              i2 += (t2[r] - e3) * (t2[r] - e3);
            return i2 / (t2.length - 1);
          }
          return 0;
        }, sd: function(t2) {
          return Math.sqrt(this.variance(t2));
        }, weightedMean: function(t2, e3) {
          if (t2.length !== e3.length)
            throw new Error("JSXGraph error (Math.Statistics.weightedMean): Array dimension mismatch.");
          return t2.length > 0 ? this.mean(this.multiply(t2, e3)) : 0;
        }, max: function(t2) {
          return Math.max.apply(this, t2);
        }, min: function(t2) {
          return Math.min.apply(this, t2);
        }, range: function(t2) {
          return [this.min(t2), this.max(t2)];
        }, abs: function(t2) {
          var e3, r, s;
          if (i.isArray(t2))
            if (t2.map)
              s = t2.map(Math.abs);
            else
              for (r = t2.length, s = [], e3 = 0; e3 < r; e3++)
                s[e3] = Math.abs(t2[e3]);
          else
            s = ArrayBuffer.isView(t2) ? t2.map(Math.abs) : Math.abs(t2);
          return s;
        }, add: function(t2, e3) {
          var r, s, o = [];
          if (t2 = i.evalSlider(t2), e3 = i.evalSlider(e3), i.isArray(t2) && i.isNumber(e3))
            for (s = t2.length, r = 0; r < s; r++)
              o[r] = t2[r] + e3;
          else if (i.isNumber(t2) && i.isArray(e3))
            for (s = e3.length, r = 0; r < s; r++)
              o[r] = t2 + e3[r];
          else if (i.isArray(t2) && i.isArray(e3))
            for (s = Math.min(t2.length, e3.length), r = 0; r < s; r++)
              o[r] = t2[r] + e3[r];
          else
            o = t2 + e3;
          return o;
        }, div: function(t2, e3) {
          var r, s, o = [];
          if (t2 = i.evalSlider(t2), e3 = i.evalSlider(e3), i.isArray(t2) && i.isNumber(e3))
            for (s = t2.length, r = 0; r < s; r++)
              o[r] = t2[r] / e3;
          else if (i.isNumber(t2) && i.isArray(e3))
            for (s = e3.length, r = 0; r < s; r++)
              o[r] = t2 / e3[r];
          else if (i.isArray(t2) && i.isArray(e3))
            for (s = Math.min(t2.length, e3.length), r = 0; r < s; r++)
              o[r] = t2[r] / e3[r];
          else
            o = t2 / e3;
          return o;
        }, divide: function() {
          t.deprecated("Statistics.divide()", "Statistics.div()"), e2.Statistics.div.apply(e2.Statistics, arguments);
        }, mod: function(t2, r, s) {
          var o, n, a = [], h = function(t3, e3) {
            return t3 % e3;
          };
          if (s = i.def(s, false), s && (h = e2.mod), t2 = i.evalSlider(t2), r = i.evalSlider(r), i.isArray(t2) && i.isNumber(r))
            for (n = t2.length, o = 0; o < n; o++)
              a[o] = h(t2[o], r);
          else if (i.isNumber(t2) && i.isArray(r))
            for (n = r.length, o = 0; o < n; o++)
              a[o] = h(t2, r[o]);
          else if (i.isArray(t2) && i.isArray(r))
            for (n = Math.min(t2.length, r.length), o = 0; o < n; o++)
              a[o] = h(t2[o], r[o]);
          else
            a = h(t2, r);
          return a;
        }, multiply: function(t2, e3) {
          var r, s, o = [];
          if (t2 = i.evalSlider(t2), e3 = i.evalSlider(e3), i.isArray(t2) && i.isNumber(e3))
            for (s = t2.length, r = 0; r < s; r++)
              o[r] = t2[r] * e3;
          else if (i.isNumber(t2) && i.isArray(e3))
            for (s = e3.length, r = 0; r < s; r++)
              o[r] = t2 * e3[r];
          else if (i.isArray(t2) && i.isArray(e3))
            for (s = Math.min(t2.length, e3.length), r = 0; r < s; r++)
              o[r] = t2[r] * e3[r];
          else
            o = t2 * e3;
          return o;
        }, subtract: function(t2, e3) {
          var r, s, o = [];
          if (t2 = i.evalSlider(t2), e3 = i.evalSlider(e3), i.isArray(t2) && i.isNumber(e3))
            for (s = t2.length, r = 0; r < s; r++)
              o[r] = t2[r] - e3;
          else if (i.isNumber(t2) && i.isArray(e3))
            for (s = e3.length, r = 0; r < s; r++)
              o[r] = t2 - e3[r];
          else if (i.isArray(t2) && i.isArray(e3))
            for (s = Math.min(t2.length, e3.length), r = 0; r < s; r++)
              o[r] = t2[r] - e3[r];
          else
            o = t2 - e3;
          return o;
        }, TheilSenRegression: function(t2) {
          var i2, r, s = [], o = [], n = [];
          for (i2 = 0; i2 < t2.length; i2++) {
            for (o.length = 0, r = 0; r < t2.length; r++)
              Math.abs(t2[r].usrCoords[1] - t2[i2].usrCoords[1]) > e2.eps && (o[r] = (t2[r].usrCoords[2] - t2[i2].usrCoords[2]) / (t2[r].usrCoords[1] - t2[i2].usrCoords[1]));
            s[i2] = this.median(o), n.push(t2[i2].usrCoords[2] - s[i2] * t2[i2].usrCoords[1]);
          }
          return [this.median(n), this.median(s), -1];
        }, generateGaussian: function(t2, e3) {
          var i2, r, s;
          if (this.hasSpare)
            return this.hasSpare = false, this.spare * e3 + t2;
          do {
            i2 = 2 * Math.random() - 1, r = 2 * Math.random() - 1, s = i2 * i2 + r * r;
          } while (s >= 1 || s === 0);
          return s = Math.sqrt(-2 * Math.log(s) / s), this.spare = r * s, this.hasSpare = true, t2 + e3 * i2 * s;
        }}, e2.Statistics;
      }), define("math/geometry", ["jxg", "base/constants", "base/coords", "math/math", "math/numerics", "utils/type", "utils/expect"], function(t, e2, i, r, s, o, n) {
        "use strict";
        return r.Geometry = {}, t.extend(r.Geometry, {angle: function(e3, i2, r2) {
          var s2, o2, n3, a, h = [], l = [], c = [];
          return t.deprecated("Geometry.angle()", "Geometry.rad()"), e3.coords ? (h[0] = e3.coords.usrCoords[1], h[1] = e3.coords.usrCoords[2]) : (h[0] = e3[0], h[1] = e3[1]), i2.coords ? (l[0] = i2.coords.usrCoords[1], l[1] = i2.coords.usrCoords[2]) : (l[0] = i2[0], l[1] = i2[1]), r2.coords ? (c[0] = r2.coords.usrCoords[1], c[1] = r2.coords.usrCoords[2]) : (c[0] = r2[0], c[1] = r2[1]), s2 = h[0] - l[0], o2 = h[1] - l[1], n3 = c[0] - l[0], a = c[1] - l[1], Math.atan2(s2 * a - o2 * n3, s2 * n3 + o2 * a);
        }, trueAngle: function(t2, e3, i2) {
          return 57.29577951308232 * this.rad(t2, e3, i2);
        }, rad: function(t2, e3, i2) {
          var r2, s2, o2, n3, a, h, l;
          return t2.coords ? (r2 = t2.coords.usrCoords[1], s2 = t2.coords.usrCoords[2]) : (r2 = t2[0], s2 = t2[1]), e3.coords ? (o2 = e3.coords.usrCoords[1], n3 = e3.coords.usrCoords[2]) : (o2 = e3[0], n3 = e3[1]), i2.coords ? (a = i2.coords.usrCoords[1], h = i2.coords.usrCoords[2]) : (a = i2[0], h = i2[1]), l = Math.atan2(h - n3, a - o2) - Math.atan2(s2 - n3, r2 - o2), l < 0 && (l += 6.283185307179586), l;
        }, angleBisector: function(t2, r2, s2, n3) {
          var a, h, l, c, d, u = t2.coords.usrCoords, p = r2.coords.usrCoords, f = s2.coords.usrCoords;
          return o.exists(n3) || (n3 = t2.board), p[0] === 0 ? new i(e2.COORDS_BY_USER, [1, 0.5 * (u[1] + f[1]), 0.5 * (u[2] + f[2])], n3) : (c = u[1] - p[1], d = u[2] - p[2], a = Math.atan2(d, c), c = f[1] - p[1], d = f[2] - p[2], h = Math.atan2(d, c), l = 0.5 * (a + h), a > h && (l += Math.PI), c = Math.cos(l) + p[1], d = Math.sin(l) + p[2], new i(e2.COORDS_BY_USER, [1, c, d], n3));
        }, reflection: function(t2, r2, s2) {
          var n3, a, h, l, c, d, u, p = r2.coords.usrCoords, f = t2.point1.coords.usrCoords, m = t2.point2.coords.usrCoords;
          return o.exists(s2) || (s2 = r2.board), c = m[1] - f[1], d = m[2] - f[2], n3 = p[1] - f[1], a = p[2] - f[2], u = (c * a - d * n3) / (c * c + d * d), h = p[1] + 2 * u * d, l = p[2] - 2 * u * c, new i(e2.COORDS_BY_USER, [h, l], s2);
        }, rotation: function(t2, r2, s2, n3) {
          var a, h, l, c, d, u, p = r2.coords.usrCoords, f = t2.coords.usrCoords;
          return o.exists(n3) || (n3 = r2.board), a = p[1] - f[1], h = p[2] - f[2], l = Math.cos(s2), c = Math.sin(s2), d = a * l - h * c + f[1], u = a * c + h * l + f[2], new i(e2.COORDS_BY_USER, [d, u], n3);
        }, perpendicular: function(t2, s2, n3) {
          var a, h, l, c, d, u = t2.point1.coords.usrCoords, p = t2.point2.coords.usrCoords, f = s2.coords.usrCoords;
          return o.exists(n3) || (n3 = s2.board), s2 === t2.point1 ? (a = u[1] + p[2] - u[2], h = u[2] - p[1] + u[1], d = u[0] * p[0], Math.abs(d) < r.eps && (a = p[2], h = -p[1]), c = [d, a, h], l = true) : s2 === t2.point2 ? (a = p[1] + u[2] - p[2], h = p[2] - u[1] + p[1], d = u[0] * p[0], Math.abs(d) < r.eps && (a = u[2], h = -u[1]), c = [d, a, h], l = false) : Math.abs(r.innerProduct(f, t2.stdform, 3)) < r.eps ? (a = f[1] + p[2] - f[2], h = f[2] - p[1] + f[1], d = p[0], Math.abs(d) < r.eps && (a = p[2], h = -p[1]), l = true, Math.abs(d) > r.eps && Math.abs(a - f[1]) < r.eps && Math.abs(h - f[2]) < r.eps && (a = f[1] + u[2] - f[2], h = f[2] - u[1] + f[1], l = false), c = [d, a, h]) : (c = [0, t2.stdform[1], t2.stdform[2]], c = r.crossProduct(c, f), c = r.crossProduct(c, t2.stdform), l = true), [new i(e2.COORDS_BY_USER, c, n3), l];
        }, circumcenterMidpoint: function() {
          t.deprecated("Geometry.circumcenterMidpoint()", "Geometry.circumcenter()"), this.circumcenter.apply(this, arguments);
        }, circumcenter: function(t2, s2, n3, a) {
          var h, l, c, d, u = t2.coords.usrCoords, p = s2.coords.usrCoords, f = n3.coords.usrCoords;
          return o.exists(a) || (a = t2.board), h = [p[0] - u[0], -p[2] + u[2], p[1] - u[1]], l = [0.5 * (u[0] + p[0]), 0.5 * (u[1] + p[1]), 0.5 * (u[2] + p[2])], c = r.crossProduct(h, l), h = [f[0] - p[0], -f[2] + p[2], f[1] - p[1]], l = [0.5 * (p[0] + f[0]), 0.5 * (p[1] + f[1]), 0.5 * (p[2] + f[2])], d = r.crossProduct(h, l), new i(e2.COORDS_BY_USER, r.crossProduct(c, d), a);
        }, distance: function(t2, e3, i2) {
          var r2, s2 = 0;
          for (i2 || (i2 = Math.min(t2.length, e3.length)), r2 = 0; r2 < i2; r2++)
            s2 += (t2[r2] - e3[r2]) * (t2[r2] - e3[r2]);
          return Math.sqrt(s2);
        }, affineDistance: function(t2, e3, i2) {
          var s2;
          return s2 = this.distance(t2, e3, i2), s2 > r.eps && (Math.abs(t2[0]) < r.eps || Math.abs(e3[0]) < r.eps) ? 1 / 0 : s2;
        }, sortVertices: function(t2) {
          for (var e3, i2 = n.each(t2, n.coordsArray), r2 = i2.length, s2 = null; i2[0][0] === i2[r2 - 1][0] && i2[0][1] === i2[r2 - 1][1] && i2[0][2] === i2[r2 - 1][2]; )
            s2 = i2.pop(), r2--;
          return e3 = i2[0], i2.sort(function(t3, i3) {
            return (t3[2] === e3[2] && t3[1] === e3[1] ? -1 / 0 : Math.atan2(t3[2] - e3[2], t3[1] - e3[1])) - (i3[2] === e3[2] && i3[1] === e3[1] ? -1 / 0 : Math.atan2(i3[2] - e3[2], i3[1] - e3[1]));
          }), s2 !== null && i2.push(s2), i2;
        }, signedTriangle: function(t2, e3, i2) {
          var r2 = n.coordsArray(t2), s2 = n.coordsArray(e3), o2 = n.coordsArray(i2);
          return 0.5 * ((s2[1] - r2[1]) * (o2[2] - r2[2]) - (s2[2] - r2[2]) * (o2[1] - r2[1]));
        }, signedPolygon: function(t2, e3) {
          var i2, r2, s2 = 0, o2 = n.each(t2, n.coordsArray);
          for (e3 === void 0 && (e3 = true), e3 ? o2.unshift(o2[o2.length - 1]) : o2 = this.sortVertices(o2), r2 = o2.length, i2 = 1; i2 < r2; i2++)
            s2 += o2[i2 - 1][1] * o2[i2][2] - o2[i2][1] * o2[i2 - 1][2];
          return 0.5 * s2;
        }, GrahamScan: function(t2) {
          var e3, i2 = 1, r2 = n.each(t2, n.coordsArray), s2 = r2.length;
          for (r2 = this.sortVertices(r2), s2 = r2.length, e3 = 2; e3 < s2; e3++) {
            for (; this.signedTriangle(r2[i2 - 1], r2[i2], r2[e3]) <= 0; ) {
              if (i2 > 1)
                i2 -= 1;
              else if (e3 === s2 - 1)
                break;
              e3 += 1;
            }
            i2 += 1, r2 = o.swap(r2, i2, e3);
          }
          return r2.slice(0, i2);
        }, calcStraight: function(t2, i2, s2, n3) {
          var a, h, l, c, d, u, p, f, m, g;
          if (o.exists(n3) || (n3 = 10), u = o.evaluate(t2.visProp.straightfirst), p = o.evaluate(t2.visProp.straightlast), Math.abs(i2.scrCoords[0]) < r.eps && (u = true), Math.abs(s2.scrCoords[0]) < r.eps && (p = true), (u || p) && (f = [], f[0] = t2.stdform[0] - t2.stdform[1] * t2.board.origin.scrCoords[1] / t2.board.unitX + t2.stdform[2] * t2.board.origin.scrCoords[2] / t2.board.unitY, f[1] = t2.stdform[1] / t2.board.unitX, f[2] = -t2.stdform[2] / t2.board.unitY, !isNaN(f[0] + f[1] + f[2]))) {
            if (a = false, h = false, a = !u && Math.abs(i2.usrCoords[0]) >= r.eps && i2.scrCoords[1] >= 0 && i2.scrCoords[1] <= t2.board.canvasWidth && i2.scrCoords[2] >= 0 && i2.scrCoords[2] <= t2.board.canvasHeight, h = !p && Math.abs(s2.usrCoords[0]) >= r.eps && s2.scrCoords[1] >= 0 && s2.scrCoords[1] <= t2.board.canvasWidth && s2.scrCoords[2] >= 0 && s2.scrCoords[2] <= t2.board.canvasHeight, l = this.meetLineBoard(f, t2.board, n3), c = l[0], d = l[1], !a && !h) {
              if (!u && p && !this.isSameDirection(i2, s2, c) && !this.isSameDirection(i2, s2, d))
                return;
              if (u && !p && !this.isSameDirection(s2, i2, c) && !this.isSameDirection(s2, i2, d))
                return;
            }
            a ? h || (g = this.isSameDir(i2, s2, c, d) ? d : c) : h ? m = this.isSameDir(i2, s2, c, d) ? c : d : this.isSameDir(i2, s2, c, d) ? (m = c, g = d) : (g = c, m = d), m && i2.setCoordinates(e2.COORDS_BY_USER, m.usrCoords), g && s2.setCoordinates(e2.COORDS_BY_USER, g.usrCoords);
          }
        }, calcLineDelimitingPoints: function(t2, i2, s2) {
          var n3, a, h, l, c, d, u, p, f, m, g = false, b = false;
          if (d = o.evaluate(t2.visProp.straightfirst), u = o.evaluate(t2.visProp.straightlast), Math.abs(i2.scrCoords[0]) < r.eps && (d = true), Math.abs(s2.scrCoords[0]) < r.eps && (u = true), p = [], p[0] = t2.stdform[0] - t2.stdform[1] * t2.board.origin.scrCoords[1] / t2.board.unitX + t2.stdform[2] * t2.board.origin.scrCoords[2] / t2.board.unitY, p[1] = t2.stdform[1] / t2.board.unitX, p[2] = -t2.stdform[2] / t2.board.unitY, !isNaN(p[0] + p[1] + p[2])) {
            if (g = !d, b = !u, a = t2.board.getBoundingBox(), h = t2.getSlope(), h >= 0 ? (l = this.projectPointToLine({coords: {usrCoords: [1, a[2], a[1]]}}, t2, t2.board), c = this.projectPointToLine({coords: {usrCoords: [1, a[0], a[3]]}}, t2, t2.board)) : (l = this.projectPointToLine({coords: {usrCoords: [1, a[0], a[1]]}}, t2, t2.board), c = this.projectPointToLine({coords: {usrCoords: [1, a[2], a[3]]}}, t2, t2.board)), !g && !b) {
              if (!d && !u) {
                if (n3 = i2.distance(e2.COORDS_BY_USER, s2), Math.abs(i2.distance(e2.COORDS_BY_USER, l) + l.distance(e2.COORDS_BY_USER, s2) - n3) > r.eps)
                  return;
                if (Math.abs(i2.distance(e2.COORDS_BY_USER, c) + c.distance(e2.COORDS_BY_USER, s2) - n3) > r.eps)
                  return;
              }
              if (!d && u && !this.isSameDirection(i2, s2, l) && !this.isSameDirection(i2, s2, c))
                return;
              if (d && !u && !this.isSameDirection(s2, i2, l) && !this.isSameDirection(s2, i2, c))
                return;
            }
            g ? b || (m = this.isSameDir(i2, s2, l, c) ? c : l) : b ? f = this.isSameDir(i2, s2, l, c) ? l : c : this.isSameDir(i2, s2, l, c) ? (f = l, m = c) : (m = l, f = c), f && i2.setCoordinates(e2.COORDS_BY_USER, f.usrCoords), m && s2.setCoordinates(e2.COORDS_BY_USER, m.usrCoords);
          }
        }, calcLabelQuadrant: function(t2) {
          var e3;
          return t2 < 0 && (t2 += 2 * Math.PI), e3 = Math.floor((t2 + Math.PI / 8) / (Math.PI / 4)) % 8, ["rt", "urt", "top", "ulft", "lft", "llft", "lrt"][e3];
        }, isSameDir: function(t2, e3, i2, s2) {
          var o2 = e3.usrCoords[1] - t2.usrCoords[1], n3 = e3.usrCoords[2] - t2.usrCoords[2], a = s2.usrCoords[1] - i2.usrCoords[1], h = s2.usrCoords[2] - i2.usrCoords[2];
          return Math.abs(e3.usrCoords[0]) < r.eps && (o2 = e3.usrCoords[1], n3 = e3.usrCoords[2]), Math.abs(t2.usrCoords[0]) < r.eps && (o2 = -t2.usrCoords[1], n3 = -t2.usrCoords[2]), o2 * a + n3 * h >= 0;
        }, isSameDirection: function(t2, e3, i2) {
          var s2, o2, n3, a, h = false;
          return s2 = e3.usrCoords[1] - t2.usrCoords[1], o2 = e3.usrCoords[2] - t2.usrCoords[2], n3 = i2.usrCoords[1] - t2.usrCoords[1], a = i2.usrCoords[2] - t2.usrCoords[2], Math.abs(s2) < r.eps && (s2 = 0), Math.abs(o2) < r.eps && (o2 = 0), Math.abs(n3) < r.eps && (n3 = 0), Math.abs(a) < r.eps && (a = 0), s2 >= 0 && n3 >= 0 ? h = o2 >= 0 && a >= 0 || o2 <= 0 && a <= 0 : s2 <= 0 && n3 <= 0 && (h = o2 >= 0 && a >= 0 || o2 <= 0 && a <= 0), h;
        }, intersectionFunction: function(t2, r2, s2, n3, a, h) {
          var l = this;
          return r2.elementClass === e2.OBJECT_CLASS_CURVE && s2.elementClass === e2.OBJECT_CLASS_CURVE ? function() {
            return l.meetCurveCurve(r2, s2, n3, a, r2.board);
          } : r2.elementClass === e2.OBJECT_CLASS_CURVE && s2.elementClass === e2.OBJECT_CLASS_LINE || s2.elementClass === e2.OBJECT_CLASS_CURVE && r2.elementClass === e2.OBJECT_CLASS_LINE ? function() {
            return l.meetCurveLine(r2, s2, n3, r2.board, h);
          } : r2.elementClass === e2.OBJECT_CLASS_LINE && s2.elementClass === e2.OBJECT_CLASS_LINE ? function() {
            var t3, a2, c = o.evaluate(r2.visProp.straightfirst), d = o.evaluate(r2.visProp.straightlast), u = o.evaluate(s2.visProp.straightfirst), p = o.evaluate(s2.visProp.straightlast);
            return o.evaluate(h) || c && d && u && p ? l.meet(r2.stdform, s2.stdform, n3, r2.board) : (t3 = l.meetSegmentSegment(r2.point1.coords.usrCoords, r2.point2.coords.usrCoords, s2.point1.coords.usrCoords, s2.point2.coords.usrCoords, r2.board), a2 = !c && t3[1] < 0 || !d && t3[1] > 1 || !u && t3[2] < 0 || !p && t3[2] > 1 ? [0, NaN, NaN] : t3[0], new i(e2.COORDS_BY_USER, a2, r2.board));
          } : function() {
            return l.meet(r2.stdform, s2.stdform, n3, r2.board);
          };
        }, meet: function(t2, e3, i2, s2) {
          var o2 = r.eps;
          return Math.abs(t2[3]) < o2 && Math.abs(e3[3]) < o2 ? this.meetLineLine(t2, e3, i2, s2) : Math.abs(t2[3]) >= o2 && Math.abs(e3[3]) < o2 ? this.meetLineCircle(e3, t2, i2, s2) : Math.abs(t2[3]) < o2 && Math.abs(e3[3]) >= o2 ? this.meetLineCircle(t2, e3, i2, s2) : this.meetCircleCircle(t2, e3, i2, s2);
        }, meetLineBoard: function(t2, s2, n3) {
          var a, h, l, c, d = [];
          for (o.exists(n3) || (n3 = 0), d[0] = r.crossProduct(t2, [n3, 0, 1]), d[1] = r.crossProduct(t2, [n3, 1, 0]), d[2] = r.crossProduct(t2, [-n3 - s2.canvasHeight, 0, 1]), d[3] = r.crossProduct(t2, [-n3 - s2.canvasWidth, 1, 0]), l = 0; l < 4; l++)
            if (Math.abs(d[l][0]) > r.eps) {
              for (c = 2; c > 0; c--)
                d[l][c] /= d[l][0];
              d[l][0] = 1;
            }
          return Math.abs(d[1][0]) < r.eps ? (a = d[0], h = d[2]) : Math.abs(d[0][0]) < r.eps ? (a = d[1], h = d[3]) : d[1][2] < 0 ? (a = d[0], h = d[3][2] > s2.canvasHeight ? d[2] : d[3]) : d[1][2] > s2.canvasHeight ? (a = d[2], h = d[3][2] < 0 ? d[0] : d[3]) : (a = d[1], h = d[3][2] < 0 ? d[0] : d[3][2] > s2.canvasHeight ? d[2] : d[3]), a = new i(e2.COORDS_BY_SCREEN, a.slice(1), s2), h = new i(e2.COORDS_BY_SCREEN, h.slice(1), s2), [a, h];
        }, meetLineLine: function(t2, s2, o2, n3) {
          var a = isNaN(t2[5] + s2[5]) ? [0, 0, 0] : r.crossProduct(t2, s2);
          return new i(e2.COORDS_BY_USER, a, n3);
        }, meetLineCircle: function(t2, s2, o2, n3) {
          var a, h, l, c, d, u, p, f, m, g;
          return s2[4] < r.eps ? Math.abs(r.innerProduct([1, s2[6], s2[7]], t2, 3)) < r.eps ? new i(e2.COORDS_BY_USER, s2.slice(6, 8), n3) : new i(e2.COORDS_BY_USER, [NaN, NaN], n3) : (l = s2[0], h = s2.slice(1, 3), a = s2[3], c = t2[0], d = t2.slice(1, 3), u = a, p = h[0] * d[1] - h[1] * d[0], f = a * c * c - (h[0] * d[0] + h[1] * d[1]) * c + l, m = p * p - 4 * u * f, m > -r.eps * r.eps ? (m = Math.sqrt(Math.abs(m)), g = [(-p + m) / (2 * u), (-p - m) / (2 * u)], o2 === 0 ? new i(e2.COORDS_BY_USER, [-g[0] * -d[1] - c * d[0], -g[0] * d[0] - c * d[1]], n3) : new i(e2.COORDS_BY_USER, [-g[1] * -d[1] - c * d[0], -g[1] * d[0] - c * d[1]], n3)) : new i(e2.COORDS_BY_USER, [0, 0, 0], n3));
        }, meetCircleCircle: function(t2, s2, o2, n3) {
          var a;
          return t2[4] < r.eps ? Math.abs(this.distance(t2.slice(6, 2), s2.slice(6, 8)) - s2[4]) < r.eps ? new i(e2.COORDS_BY_USER, t2.slice(6, 8), n3) : new i(e2.COORDS_BY_USER, [0, 0, 0], n3) : s2[4] < r.eps ? Math.abs(this.distance(s2.slice(6, 2), t2.slice(6, 8)) - t2[4]) < r.eps ? new i(e2.COORDS_BY_USER, s2.slice(6, 8), n3) : new i(e2.COORDS_BY_USER, [0, 0, 0], n3) : (a = [s2[3] * t2[0] - t2[3] * s2[0], s2[3] * t2[1] - t2[3] * s2[1], s2[3] * t2[2] - t2[3] * s2[2], 0, 1, 1 / 0, 1 / 0, 1 / 0], a = r.normalize(a), this.meetLineCircle(a, t2, o2, n3));
        }, meetCurveCurve: function(t2, r2, n3, a, h, l) {
          var c;
          return c = o.exists(l) && l === "newton" ? s.generalizedNewton(t2, r2, n3, a) : t2.bezierDegree === 3 && r2.bezierDegree === 3 ? this.meetBezierCurveRedBlueSegments(t2, r2, n3) : this.meetCurveRedBlueSegments(t2, r2, n3), new i(e2.COORDS_BY_USER, c, h);
        }, meetCurveLine: function(t2, i2, r2, s2, n3) {
          var a, h;
          return o.exists(s2) || (s2 = t2.board), t2.elementClass === e2.OBJECT_CLASS_CURVE ? (a = t2, h = i2) : (a = i2, h = t2), this.meetCurveLineDiscrete(a, h, r2, s2, !n3);
        }, meetCurveLineContinuous: function(t2, o2, n3, a, h) {
          var l, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E = r.eps, x = r.eps;
          for (u = this.meetCurveLineDiscrete(t2, o2, n3, a, h), p = u.usrCoords[1], f = u.usrCoords[2], c = function(e3) {
            var i2, r2;
            return e3 > t2.maxX() || e3 < t2.minX() ? 1 / 0 : (i2 = p - t2.X(e3), r2 = f - t2.Y(e3), i2 * i2 + r2 * r2);
          }, d = function(e3) {
            var i2 = o2.stdform[0] + o2.stdform[1] * t2.X(e3) + o2.stdform[2] * t2.Y(e3);
            return i2 * i2;
          }, g = 50, b = (t2.maxX() - t2.minX()) / g, v = t2.minX(), _4 = 1e-4, C = NaN, y = 0; y < g && (l = s.root(c, [Math.max(v, t2.minX()), Math.min(v + b, t2.maxX())]), !((P2 = Math.abs(c(l))) <= _4 && (_4 = P2, C = l, _4 < E))); y++)
            v += b;
          return l = C, l = s.root(d, [Math.max(l - b, t2.minX()), Math.min(l + b, t2.maxX())]), P2 = d(l), m = isNaN(P2) || Math.abs(P2) > x ? 0 : 1, new i(e2.COORDS_BY_USER, [m, t2.X(l), t2.Y(l)], a);
        }, meetCurveLineContinuousOld: function(o2, n3, a, h) {
          var l, c, d, u, p, f, m, g, b, v, y, C, _4 = 10 * r.eps;
          if (t.deprecated("Geometry.meetCurveLineContinuousOld()", "Geometry.meetCurveLineContinuous()"), u = function(t2) {
            var e3 = n3.stdform[0] + n3.stdform[1] * o2.X(t2) + n3.stdform[2] * o2.Y(t2);
            return e3 * e3;
          }, this.meetCurveLineContinuous.t1memo ? (b = this.meetCurveLineContinuous.t1memo, l = s.root(u, b)) : (b = o2.minX(), v = o2.maxX(), l = s.root(u, [b, v])), this.meetCurveLineContinuous.t1memo = l, y = o2.X(l), C = o2.Y(l), a === 1) {
            if (this.meetCurveLineContinuous.t2memo && (b = this.meetCurveLineContinuous.t2memo), c = s.root(u, b), !(Math.abs(c - l) > 0.1 && Math.abs(y - o2.X(c)) > 0.1 && Math.abs(C - o2.Y(c)) > 0.1))
              for (m = 20, g = (o2.maxX() - o2.minX()) / m, f = o2.minX(), d = 0; d < m && (c = s.root(u, [f, f + g]), !(Math.abs(u(c)) <= _4 && Math.abs(c - l) > 0.1 && Math.abs(y - o2.X(c)) > 0.1 && Math.abs(C - o2.Y(c)) > 0.1)); d++)
                f += g;
            l = c, this.meetCurveLineContinuous.t2memo = l;
          }
          return p = Math.abs(u(l)) > _4 ? NaN : 1, new i(e2.COORDS_BY_USER, [p, o2.X(l), o2.Y(l)], h);
        }, meetCurveLineDiscrete: function(t2, s2, n3, a, h) {
          var l, c, d, u, p, f, m, g = s2.point1.coords.usrCoords, b = s2.point2.coords.usrCoords, v = 0, y = t2.numberPoints, C = o.evaluate(s2.visProp.straightfirst), _4 = o.evaluate(s2.visProp.straightlast);
          for (f = new i(e2.COORDS_BY_USER, [0, NaN, NaN], a), g[0] === 0 ? g = [1, b[1] + s2.stdform[2], b[2] - s2.stdform[1]] : b[0] === 0 && (b = [1, g[1] + s2.stdform[2], g[2] - s2.stdform[1]]), u = t2.points[0].usrCoords, l = 1; l < y; l++)
            if (d = u.slice(0), u = t2.points[l].usrCoords, this.distance(d, u) > r.eps) {
              for (t2.bezierDegree === 3 ? (m = this.meetBeziersegmentBeziersegment([t2.points[l - 1].usrCoords.slice(1), t2.points[l].usrCoords.slice(1), t2.points[l + 1].usrCoords.slice(1), t2.points[l + 2].usrCoords.slice(1)], [g.slice(1), b.slice(1)], h), l += 2) : m = [this.meetSegmentSegment(d, u, g, b)], c = 0; c < m.length; c++)
                if (p = m[c], 0 <= p[1] && p[1] <= 1) {
                  if (v === n3)
                    return h && (!C && p[2] < 0 || !_4 && p[2] > 1) ? f : f = new i(e2.COORDS_BY_USER, p[0], a);
                  v += 1;
                }
            }
          return f;
        }, meetCurveRedBlueSegments: function(t2, e3, i2) {
          var r2, s2, o2, n3, a, h, l, c, d, u = 0, p = e3.numberPoints, f = t2.numberPoints;
          if (p <= 1 || f <= 1)
            return [0, NaN, NaN];
          for (r2 = 1; r2 < f; r2++)
            for (o2 = t2.points[r2 - 1].usrCoords, n3 = t2.points[r2].usrCoords, c = Math.min(o2[1], n3[1]), d = Math.max(o2[1], n3[1]), h = e3.points[0].usrCoords, s2 = 1; s2 < p; s2++)
              if (a = h, h = e3.points[s2].usrCoords, Math.min(a[1], h[1]) < d && Math.max(a[1], h[1]) > c && (l = this.meetSegmentSegment(o2, n3, a, h), l[1] >= 0 && l[2] >= 0 && (l[1] < 1 && l[2] < 1 || r2 === f - 1 && l[1] === 1 || s2 === p - 1 && l[2] === 1))) {
                if (u === i2)
                  return l[0];
                u++;
              }
          return [0, NaN, NaN];
        }, meetSegmentSegment: function(t2, e3, i2, s2) {
          var o2, n3, a, h = r.crossProduct(t2, e3), l = r.crossProduct(i2, s2), c = r.crossProduct(h, l), d = c[0];
          return Math.abs(d) < r.eps ? [c, 1 / 0, 1 / 0] : (a = [i2[1] - t2[1], i2[2] - t2[2]], o2 = (a[0] * (s2[2] - i2[2]) - a[1] * (s2[1] - i2[1])) / d, n3 = (a[0] * (e3[2] - t2[2]) - a[1] * (e3[1] - t2[1])) / d, [c, o2, n3]);
        }, _bezierSplit: function(t2) {
          var e3, i2, r2, s2, o2, n3;
          return e3 = [0.5 * (t2[0][0] + t2[1][0]), 0.5 * (t2[0][1] + t2[1][1])], i2 = [0.5 * (t2[1][0] + t2[2][0]), 0.5 * (t2[1][1] + t2[2][1])], r2 = [0.5 * (t2[2][0] + t2[3][0]), 0.5 * (t2[2][1] + t2[3][1])], s2 = [0.5 * (e3[0] + i2[0]), 0.5 * (e3[1] + i2[1])], o2 = [0.5 * (i2[0] + r2[0]), 0.5 * (i2[1] + r2[1])], n3 = [0.5 * (s2[0] + o2[0]), 0.5 * (s2[1] + o2[1])], [[t2[0], e3, s2, n3], [n3, o2, r2, t2[3]]];
        }, _bezierBbox: function(t2) {
          var e3 = [];
          return t2.length === 4 ? (e3[0] = Math.min(t2[0][0], t2[1][0], t2[2][0], t2[3][0]), e3[1] = Math.max(t2[0][1], t2[1][1], t2[2][1], t2[3][1]), e3[2] = Math.max(t2[0][0], t2[1][0], t2[2][0], t2[3][0]), e3[3] = Math.min(t2[0][1], t2[1][1], t2[2][1], t2[3][1])) : (e3[0] = Math.min(t2[0][0], t2[1][0]), e3[1] = Math.max(t2[0][1], t2[1][1]), e3[2] = Math.max(t2[0][0], t2[1][0]), e3[3] = Math.min(t2[0][1], t2[1][1])), e3;
        }, _bezierOverlap: function(t2, e3) {
          return t2[2] >= e3[0] && t2[0] <= e3[2] && t2[1] >= e3[3] && t2[3] <= e3[1];
        }, _bezierListConcat: function(t2, e3, i2, r2) {
          var s2, n3 = o.exists(r2), a = 0, h = e3.length, l = t2.length;
          for (l > 0 && h > 0 && (t2[l - 1][1] === 1 && e3[0][1] === 0 || n3 && t2[l - 1][2] === 1 && e3[0][2] === 0) && (a = 1), s2 = a; s2 < h; s2++)
            n3 && (e3[s2][2] *= 0.5, e3[s2][2] += r2), e3[s2][1] *= 0.5, e3[s2][1] += i2, t2.push(e3[s2]);
        }, _bezierMeetSubdivision: function(t2, e3, i2) {
          var r2, s2, o2, n3, a, h, l, c, d, u, p, f, m = [];
          return s2 = this._bezierBbox(e3), r2 = this._bezierBbox(t2), this._bezierOverlap(s2, r2) ? i2 < 5 ? (o2 = this._bezierSplit(t2), h = o2[0], l = o2[1], o2 = this._bezierSplit(e3), n3 = o2[0], a = o2[1], this._bezierListConcat(m, this._bezierMeetSubdivision(h, n3, i2 + 1), 0, 0), this._bezierListConcat(m, this._bezierMeetSubdivision(h, a, i2 + 1), 0, 0.5), this._bezierListConcat(m, this._bezierMeetSubdivision(l, n3, i2 + 1), 0.5, 0), this._bezierListConcat(m, this._bezierMeetSubdivision(l, a, i2 + 1), 0.5, 0.5), m) : (p = [1].concat(t2[0]), f = [1].concat(t2[3]), d = [1].concat(e3[0]), u = [1].concat(e3[3]), c = this.meetSegmentSegment(p, f, d, u), c[1] >= 0 && c[2] >= 0 && c[1] <= 1 && c[2] <= 1 ? [c] : []) : [];
        }, _bezierLineMeetSubdivision: function(t2, e3, i2, r2) {
          var s2, o2, n3, a, h, l, c, d, u, p, f = [];
          return s2 = this._bezierBbox(e3), o2 = this._bezierBbox(t2), r2 && !this._bezierOverlap(o2, s2) ? [] : i2 < 5 ? (n3 = this._bezierSplit(t2), a = n3[0], h = n3[1], this._bezierListConcat(f, this._bezierLineMeetSubdivision(a, e3, i2 + 1), 0), this._bezierListConcat(f, this._bezierLineMeetSubdivision(h, e3, i2 + 1), 0.5), f) : (u = [1].concat(t2[0]), p = [1].concat(t2[3]), c = [1].concat(e3[0]), d = [1].concat(e3[1]), l = this.meetSegmentSegment(u, p, c, d), l[1] >= 0 && l[1] <= 1 && (!r2 || l[2] >= 0 && l[2] <= 1) ? [l] : []);
        }, meetBeziersegmentBeziersegment: function(t2, e3, i2) {
          var r2, s2, o2;
          for (r2 = t2.length === 4 && e3.length === 4 ? this._bezierMeetSubdivision(t2, e3, 0) : this._bezierLineMeetSubdivision(t2, e3, 0, i2), r2.sort(function(t3, e4) {
            return 1e7 * (t3[1] - e4[1]) + (t3[2] - e4[2]);
          }), s2 = [], o2 = 0; o2 < r2.length; o2++)
            o2 !== 0 && r2[o2][1] === r2[o2 - 1][1] && r2[o2][2] === r2[o2 - 1][2] || s2.push(r2[o2]);
          return s2;
        }, meetBezierCurveRedBlueSegments: function(t2, e3, i2) {
          var r2, s2, o2, n3, a, h, l, c = e3.numberPoints, d = t2.numberPoints, u = [];
          if (c < 4 || d < 4)
            return [0, NaN, NaN];
          for (s2 = 0; s2 < d - 3; s2 += 3)
            for (r2 = t2.points, n3 = [[r2[s2].usrCoords[1], r2[s2].usrCoords[2]], [r2[s2 + 1].usrCoords[1], r2[s2 + 1].usrCoords[2]], [r2[s2 + 2].usrCoords[1], r2[s2 + 2].usrCoords[2]], [r2[s2 + 3].usrCoords[1], r2[s2 + 3].usrCoords[2]]], h = this._bezierBbox(n3), o2 = 0; o2 < c - 3; o2 += 3)
              if (r2 = e3.points, a = [[r2[o2].usrCoords[1], r2[o2].usrCoords[2]], [r2[o2 + 1].usrCoords[1], r2[o2 + 1].usrCoords[2]], [r2[o2 + 2].usrCoords[1], r2[o2 + 2].usrCoords[2]], [r2[o2 + 3].usrCoords[1], r2[o2 + 3].usrCoords[2]]], l = this._bezierBbox(a), this._bezierOverlap(h, l) && (u = u.concat(this.meetBeziersegmentBeziersegment(n3, a)), u.length > i2))
                return u[i2][0];
          return u.length > i2 ? u[i2][0] : [0, NaN, NaN];
        }, bezierSegmentEval: function(t2, e3) {
          var i2, r2, s2, o2 = 1 - t2;
          return r2 = 0, s2 = 0, i2 = o2 * o2 * o2, r2 += i2 * e3[0][0], s2 += i2 * e3[0][1], i2 = 3 * t2 * o2 * o2, r2 += i2 * e3[1][0], s2 += i2 * e3[1][1], i2 = 3 * t2 * t2 * o2, r2 += i2 * e3[2][0], s2 += i2 * e3[2][1], i2 = t2 * t2 * t2, r2 += i2 * e3[3][0], s2 += i2 * e3[3][1], [1, r2, s2];
        }, bezierArc: function(t2, e3, i2, s2, o2) {
          var n3, a, h, l, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E = 0.5 * Math.PI, x = e3[1], S = e3[2], O = e3[0], w = [], T = [];
          for (c = this.distance(e3, t2), x /= O, S /= O, d = this.rad(t2.slice(1), e3.slice(1), i2.slice(1)), o2 === -1 && (d = 2 * Math.PI - d), n3 = t2, n3[1] /= n3[0], n3[2] /= n3[0], n3[0] /= n3[0], l = n3.slice(0), s2 ? (w = [x, x + 0.333 * (n3[1] - x), x + 0.666 * (n3[1] - x), n3[1]], T = [S, S + 0.333 * (n3[2] - S), S + 0.666 * (n3[2] - S), n3[2]]) : (w = [n3[1]], T = [n3[2]]); d > r.eps; )
            d > E ? (u = E, d -= E) : (u = d, d = 0), p = Math.cos(o2 * u), f = Math.sin(o2 * u), P2 = [[1, 0, 0], [x * (1 - p) + S * f, p, -f], [S * (1 - p) - x * f, f, p]], C = r.matVecMult(P2, n3), l = [C[0] / C[0], C[1] / C[0], C[2] / C[0]], m = n3[1] - x, g = n3[2] - S, b = l[1] - x, v = l[2] - S, _4 = Math.sqrt((m + b) * (m + b) + (g + v) * (g + v)), y = Math.abs(v - g) > r.eps ? (m + b) * (c / _4 - 0.5) / (v - g) * 8 / 3 : (g + v) * (c / _4 - 0.5) / (m - b) * 8 / 3, a = [1, n3[1] - y * g, n3[2] + y * m], h = [1, l[1] + y * v, l[2] - y * b], w = w.concat([a[1], h[1], l[1]]), T = T.concat([a[2], h[2], l[2]]), n3 = l.slice(0);
          return s2 && (w = w.concat([l[1] + 0.333 * (x - l[1]), l[1] + 0.666 * (x - l[1]), x]), T = T.concat([l[2] + 0.333 * (S - l[2]), l[2] + 0.666 * (S - l[2]), S])), [w, T];
        }, projectPointToCircle: function(t2, s2, n3) {
          var a, h, l, c, d, u = s2.center.coords.usrCoords;
          return o.exists(n3) || (n3 = t2.board), o.isPoint(t2) ? (a = t2.coords.distance(e2.COORDS_BY_USER, s2.center.coords), h = t2.coords.usrCoords) : (a = t2.distance(e2.COORDS_BY_USER, s2.center.coords), h = t2.usrCoords), Math.abs(a) < r.eps && (a = r.eps), d = s2.Radius() / a, l = u[1] + d * (h[1] - u[1]), c = u[2] + d * (h[2] - u[2]), new i(e2.COORDS_BY_USER, [l, c], n3);
        }, projectPointToLine: function(t2, s2, n3) {
          var a, h = [0, s2.stdform[1], s2.stdform[2]];
          return o.exists(n3) || (n3 = o.exists(t2.coords) ? t2.board : s2.board), a = o.exists(t2.coords) ? t2.coords.usrCoords : t2.usrCoords, h = r.crossProduct(h, a), new i(e2.COORDS_BY_USER, r.crossProduct(h, s2.stdform), n3);
        }, projectCoordsToSegment: function(t2, e3, i2) {
          var s2, o2, n3 = [i2[1] - e3[1], i2[2] - e3[2]], a = [t2[1] - e3[1], t2[2] - e3[2]];
          return Math.abs(n3[0]) < r.eps && Math.abs(n3[1]) < r.eps ? [e3, 0] : (s2 = r.innerProduct(a, n3), o2 = r.innerProduct(n3, n3), s2 /= o2, [[1, s2 * n3[0] + e3[1], s2 * n3[1] + e3[2]], s2]);
        }, projectCoordsToBeziersegment: function(e3, i2, r2) {
          var s2, o2 = function(t2) {
            var s3 = [1, i2.X(r2 + t2), i2.Y(r2 + t2)];
            return s3[1] -= e3[1], s3[2] -= e3[2], s3[1] * s3[1] + s3[2] * s3[2];
          };
          return s2 = t.Math.Numerics.fminbr(o2, [0, 1]), [[1, i2.X(s2 + r2), i2.Y(s2 + r2)], s2];
        }, projectPointToCurve: function(t2, e3, i2) {
          o.exists(i2) || (i2 = t2.board);
          var r2 = t2.X(), s2 = t2.Y(), n3 = t2.position || 0, a = this.projectCoordsToCurve(r2, s2, n3, e3, i2);
          return t2.position = a[1], a[0];
        }, projectCoordsToCurve: function(t2, r2, n3, a, h) {
          var l, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S, O, w, T, N, M = Number.POSITIVE_INFINITY;
          if (o.exists(h) || (h = a.board), o.evaluate(a.visProp.curvetype) === "plot") {
            if (n3 = 0, p = M, l = a.numberPoints === 0 ? [0, 1, 1] : [a.Z(0), a.X(0), a.Y(0)], a.numberPoints > 1)
              for (g = [1, t2, r2], a.bezierDegree === 3 ? u = 0 : y = [a.Z(0), a.X(0), a.Y(0)], d = 0; d < a.numberPoints - 1; d++)
                a.bezierDegree === 3 ? _4 = this.projectCoordsToBeziersegment(g, a, u) : (C = [a.Z(d + 1), a.X(d + 1), a.Y(d + 1)], _4 = this.projectCoordsToSegment(g, y, C)), m = _4[1], b = _4[0], 0 <= m && m <= 1 ? (f = this.distance(b, g), v = d + m) : m < 0 ? (b = y, f = this.distance(y, g), v = d) : m > 1 && d === a.numberPoints - 2 && (b = C, f = this.distance(b, g), v = a.numberPoints - 1), f < p && (p = f, n3 = v, l = b), a.bezierDegree === 3 ? (u++, d += 2) : y = C;
            c = new i(e2.COORDS_BY_USER, l, h);
          } else {
            for (P2 = function(e3) {
              var i2, s2;
              return e3 < a.minX() || e3 > a.maxX() ? NaN : (i2 = t2 - a.X(e3), s2 = r2 - a.Y(e3), i2 * i2 + s2 * s2);
            }, S = P2(n3), w = 50, O = (a.maxX() - a.minX()) / w, E = a.minX(), d = 0; d < w; d++)
              x = P2(E), (x < S || isNaN(S)) && (n3 = E, S = x), E += O;
            n3 = s.fminbr(P2, [n3 - O, n3 + O]), T = a.minX(), N = a.maxX(), n3 = n3 < T ? T : n3, n3 = n3 > N ? N : n3, c = new i(e2.COORDS_BY_USER, [a.X(n3), a.Y(n3)], h);
          }
          return [a.updateTransform(c), n3];
        }, projectCoordsToPolygon: function(e3, i2) {
          var r2, s2, o2, n3, a = i2.vertices.length, h = 1 / 0;
          for (r2 = 0; r2 < a; r2++)
            o2 = t.Math.Geometry.projectCoordsToSegment(e3, i2.vertices[r2].coords.usrCoords, i2.vertices[(r2 + 1) % a].coords.usrCoords), s2 = t.Math.Geometry.distance(o2[0], e3, 3), 0 <= o2[1] && o2[1] <= 1 && s2 < h && (n3 = o2[0].slice(0), h = s2);
          return n3;
        }, projectPointToTurtle: function(t2, r2, s2) {
          var n3, a, h, l, c, d, u, p, f = 0, m = 0, g = Number.POSITIVE_INFINITY, b = r2.objects.length;
          for (o.exists(s2) || (s2 = t2.board), c = 0; c < b; c++)
            u = r2.objects[c], u.elementClass === e2.OBJECT_CLASS_CURVE && (n3 = this.projectPointToCurve(t2, u), d = this.distance(n3.usrCoords, t2.coords.usrCoords), d < g && (h = n3.usrCoords[1], l = n3.usrCoords[2], a = t2.position, g = d, p = u, m = f), f += u.numberPoints);
          return n3 = new i(e2.COORDS_BY_USER, [h, l], s2), t2.position = a + m, p.updateTransform(n3);
        }, projectPointToPoint: function(t2, e3) {
          return e3.coords;
        }, projectPointToBoard: function(t2, e3) {
          var i2, s2, o2, n3 = e3 || t2.board, a = [[1, 1, 0, 0, 3, 0, 1], [-1, 2, 1, 0, 1, 2, 1], [-1, 1, 2, 2, 1, 2, 3], [1, 2, 3, 0, 3, 2, 3]], h = t2.coords || t2, l = n3.getBoundingBox();
          for (i2 = 0; i2 < 4; i2++)
            o2 = a[i2], o2[0] * h.usrCoords[o2[1]] < o2[0] * l[o2[2]] && (s2 = r.crossProduct([1, l[o2[3]], l[o2[4]]], [1, l[o2[5]], l[o2[6]]]), s2[3] = 0, s2 = r.normalize(s2), h = this.projectPointToLine({coords: h}, {stdform: s2}, n3));
          return h;
        }, distPointLine: function(t2, e3) {
          var i2, s2 = e3[1], o2 = e3[2], n3 = e3[0];
          return Math.abs(s2) + Math.abs(o2) < r.eps ? Number.POSITIVE_INFINITY : (i2 = s2 * t2[1] + o2 * t2[2] + n3, s2 *= s2, o2 *= o2, Math.abs(i2) / Math.sqrt(s2 + o2));
        }, reuleauxPolygon: function(t2, e3) {
          var i2, s2 = 2 * Math.PI, o2 = s2 / e3, n3 = (e3 - 1) / 2, a = 0, h = function(h2, l) {
            return function(c, d) {
              var u = (c % s2 + s2) % s2, p = Math.floor(u / o2) % e3;
              return d || (a = t2[0].Dist(t2[n3]), i2 = r.Geometry.rad([t2[0].X() + 1, t2[0].Y()], t2[0], t2[n3 % e3])), isNaN(p) ? p : (u = 0.5 * u + p * o2 * 0.5 + i2, t2[p][h2]() + a * Math[l](u));
            };
          };
          return [h("X", "cos"), h("Y", "sin"), 0, s2];
        }}), r.Geometry;
      }), define("math/plot", ["jxg", "base/constants", "base/coords", "math/math", "math/extrapolate", "math/numerics", "math/statistics", "math/geometry", "math/ia", "utils/type"], function(t, e2, i, r, s, o, n, a, h, l) {
        "use strict";
        return r.Plot = {checkReal: function(t2) {
          var e3, i2, s2 = false, o2 = t2.length;
          for (e3 = 0; e3 < o2; e3++)
            if (i2 = t2[e3].usrCoords, !isNaN(i2[1]) && !isNaN(i2[2]) && Math.abs(i2[0]) > r.eps) {
              s2 = true;
              break;
            }
          return s2;
        }, updateParametricCurveNaive: function(t2, i2, r2, s2) {
          var o2, n3, a2 = false, h2 = (r2 - i2) / s2;
          for (o2 = 0; o2 < s2; o2++)
            n3 = i2 + o2 * h2, t2.points[o2].setCoordinates(e2.COORDS_BY_USER, [t2.X(n3, a2), t2.Y(n3, a2)], false), t2.points[o2]._t = n3, a2 = true;
          return t2;
        }, isSegmentOutside: function(t2, e3, i2, r2, s2) {
          return e3 < 0 && r2 < 0 || e3 > s2.canvasHeight && r2 > s2.canvasHeight || t2 < 0 && i2 < 0 || t2 > s2.canvasWidth && i2 > s2.canvasWidth;
        }, isDistOK: function(t2, e3, i2, r2) {
          return Math.abs(t2) < i2 && Math.abs(e3) < r2 && !isNaN(t2 + e3);
        }, isSegmentDefined: function(t2, e3, i2, r2) {
          return !(isNaN(t2 + e3) && isNaN(i2 + r2));
        }, updateParametricCurveOld: function(s2, o2, n3) {
          var a2, h2, l2, c, d, u, p, f, m, g, b, v = false, y = new i(e2.COORDS_BY_USER, [0, 0], s2.board, false), C = [], _4 = [], P2 = [], E = [], x = false, S = 0;
          for (t.deprecated("Curve.updateParametricCurveOld()"), s2.board.updateQuality === s2.board.BOARD_QUALITY_LOW ? (m = 15, g = 10, b = 10) : (m = 21, g = 0.7, b = 0.7), E[0] = n3 - o2, a2 = 1; a2 < m; a2++)
            E[a2] = 0.5 * E[a2 - 1];
          a2 = 1, C[0] = 1, _4[0] = 0, h2 = o2, y.setCoordinates(e2.COORDS_BY_USER, [s2.X(h2, v), s2.Y(h2, v)], false), v = true, d = y.scrCoords[1], u = y.scrCoords[2], h2 = n3, y.setCoordinates(e2.COORDS_BY_USER, [s2.X(h2, v), s2.Y(h2, v)], false), l2 = y.scrCoords[1], c = y.scrCoords[2], P2[0] = [l2, c], p = 1, f = 0, s2.points = [], s2.points[S++] = new i(e2.COORDS_BY_SCREEN, [d, u], s2.board, false);
          do {
            for (x = this.isDistOK(l2 - d, c - u, g, b) || this.isSegmentOutside(d, u, l2, c, s2.board); f < m && (!x || f < 6) && (f <= 7 || this.isSegmentDefined(d, u, l2, c)); )
              C[p] = a2, _4[p] = f, P2[p] = [l2, c], p += 1, a2 = 2 * a2 - 1, f++, h2 = o2 + a2 * E[f], y.setCoordinates(e2.COORDS_BY_USER, [s2.X(h2, v), s2.Y(h2, v)], false, true), l2 = y.scrCoords[1], c = y.scrCoords[2], x = this.isDistOK(l2 - d, c - u, g, b) || this.isSegmentOutside(d, u, l2, c, s2.board);
            S > 1 && function(t2, e3, i2) {
              var s3, o3, n4 = i2[1] - t2[1], a3 = i2[2] - t2[2], h3 = e3[0] - t2[1], l3 = e3[1] - t2[2], c2 = h3 * h3 + l3 * l3;
              return c2 >= r.eps && (s3 = (n4 * h3 + a3 * l3) / c2) > 0 && (s3 <= 1 ? (n4 -= s3 * h3, a3 -= s3 * l3) : (n4 -= h3, a3 -= l3)), o3 = n4 * n4 + a3 * a3, Math.sqrt(o3);
            }(s2.points[S - 2].scrCoords, [l2, c], s2.points[S - 1].scrCoords) < 0.015 && (S -= 1), s2.points[S] = new i(e2.COORDS_BY_SCREEN, [l2, c], s2.board, false), s2.points[S]._t = h2, S += 1, d = l2, u = c, h2, p -= 1, l2 = P2[p][0], c = P2[p][1], f = _4[p] + 1, a2 = 2 * C[p];
          } while (p > 0 && S < 5e5);
          return s2.numberPoints = s2.points.length, s2;
        }, _insertPoint_v2: function(t2, e3, i2) {
          var r2 = !isNaN(this._lastCrds[1] + this._lastCrds[2]), s2 = !isNaN(e3.scrCoords[1] + e3.scrCoords[2]), o2 = t2.board.canvasWidth, n3 = t2.board.canvasHeight;
          (!(s2 = s2 && e3.scrCoords[1] > -500 && e3.scrCoords[2] > -500 && e3.scrCoords[1] < o2 + 500 && e3.scrCoords[2] < n3 + 500) && r2 || s2 && (!r2 || Math.abs(e3.scrCoords[1] - this._lastCrds[1]) > 0.7 || Math.abs(e3.scrCoords[2] - this._lastCrds[2]) > 0.7)) && (e3._t = i2, t2.points.push(e3), this._lastCrds = e3.copy("scrCoords"));
        }, neighborhood_isNaN_v2: function(t2, s2) {
          var o2, n3, a2 = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false);
          return o2 = s2 + r.eps, a2.setCoordinates(e2.COORDS_BY_USER, [t2.X(o2, true), t2.Y(o2, true)], false), n3 = a2.usrCoords, !!(isNaN(n3[1] + n3[2]) || (o2 = s2 - r.eps, a2.setCoordinates(e2.COORDS_BY_USER, [t2.X(o2, true), t2.Y(o2, true)], false), n3 = a2.usrCoords, isNaN(n3[1] + n3[2])));
        }, _borderCase: function(t2, r2, s2, o2, n3, a2, h2, l2) {
          var c, d, u, p, f, m, g, b, v, y, C, _4 = null, P2 = false;
          if (l2 <= 1) {
            if (d = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false), isNaN(r2[1] + r2[2]) && !isNaN(o2[1] + o2[2]) && !this.neighborhood_isNaN_v2(t2, n3))
              return false;
            if (isNaN(s2[1] + s2[2]) && !isNaN(o2[1] + o2[2]) && !this.neighborhood_isNaN_v2(t2, a2))
              return false;
            if (isNaN(o2[1] + o2[2]) && (!isNaN(r2[1] + r2[2]) || !isNaN(s2[1] + s2[2])) && !this.neighborhood_isNaN_v2(t2, h2))
              return false;
            p = 0;
            do {
              if (isNaN(r2[1] + r2[2]) && !isNaN(o2[1] + o2[2]))
                f = n3, m = h2, g = a2;
              else if (isNaN(s2[1] + s2[2]) && !isNaN(o2[1] + o2[2]))
                f = a2, m = h2, g = n3;
              else if (isNaN(o2[1] + o2[2]) && !isNaN(s2[1] + s2[2]))
                f = h2, m = a2, g = a2 + (a2 - h2);
              else {
                if (!isNaN(o2[1] + o2[2]) || isNaN(r2[1] + r2[2]))
                  return false;
                f = h2, m = n3, g = n3 - (h2 - n3);
              }
              c = 0.5 * (f + m), d.setCoordinates(e2.COORDS_BY_USER, [t2.X(c, true), t2.Y(c, true)], false), u = d.usrCoords, P2 = isNaN(u[1] + u[2]), P2 ? f = c : (g = m, m = c), ++p;
            } while (P2 && p < 30);
            if (p < 30 && (_4 = u.slice(), o2 = u.slice(), m = c), b = t2.X(m, true), y = t2.X(g, true), (b - y) / (m - g), v = t2.Y(m, true), C = t2.Y(g, true), (v - C) / (m - g), _4 !== null)
              return this._insertPoint_v2(t2, new i(e2.COORDS_BY_USER, _4, t2.board, false)), true;
          }
          return false;
        }, _plotRecursive_v2: function(t2, r2, s2, o2, n3, a2, h2) {
          var l2, c, d, u, p, f, m = 0, g = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false);
          if (!(t2.numberPoints > 65536))
            return a2 < this.nanLevel && this._isUndefined(t2, r2, s2, o2, n3) ? this : a2 < this.nanLevel && this._isOutside(r2, s2, o2, n3, t2.board) ? this : (l2 = 0.5 * (s2 + n3), g.setCoordinates(e2.COORDS_BY_USER, [t2.X(l2, true), t2.Y(l2, true)], false), c = g.scrCoords, this._borderCase(t2, r2, o2, c, s2, n3, l2, a2) ? this : (d = this._triangleDists(r2, o2, c), u = a2 < this.smoothLevel && d[3] < h2, p = a2 < this.jumpLevel && (d[2] > 0.99 * d[0] || d[1] > 0.99 * d[0] || d[0] === 1 / 0 || d[1] === 1 / 0 || d[2] === 1 / 0), f = a2 < this.smoothLevel + 2 && d[0] < 0.5 * (d[1] + d[2]), f && (m = 0, u = false), --a2, p ? this._insertPoint_v2(t2, new i(e2.COORDS_BY_SCREEN, [NaN, NaN], t2.board, false), l2) : a2 <= m || u ? this._insertPoint_v2(t2, g, l2) : (this._plotRecursive_v2(t2, r2, s2, c, l2, a2, h2), isNaN(g.scrCoords[1] + g.scrCoords[2]) || this._insertPoint_v2(t2, g, l2), this._plotRecursive_v2(t2, c, l2, o2, n3, a2, h2)), this));
        }, updateParametricCurve_v2: function(t2, r2, s2) {
          var o2, n3, a2, h2, c, d, u, p, f, m = false, g = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false), b = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false);
          return t2.board.updateQuality === t2.board.BOARD_QUALITY_LOW ? (c = l.evaluate(t2.visProp.recursiondepthlow) || 13, d = 2, this.smoothLevel = c - 6, this.jumpLevel = 3) : (c = l.evaluate(t2.visProp.recursiondepthhigh) || 17, d = 2, this.smoothLevel = c - 9, this.jumpLevel = 2), this.nanLevel = c - 4, t2.points = [], this.xterm === "x" ? (p = t2.board.getBoundingBox(), u = 0.3 * (p[2] - p[0]), 0.3 * (p[1] - p[3]), o2 = Math.max(r2, p[0] - u), n3 = Math.min(s2, p[2] + u)) : (o2 = r2, n3 = s2), g.setCoordinates(e2.COORDS_BY_USER, [t2.X(o2, m), t2.Y(o2, m)], false), m = true, b.setCoordinates(e2.COORDS_BY_USER, [t2.X(n3, m), t2.Y(n3, m)], false), f = this._findStartPoint(t2, g.scrCoords, o2, b.scrCoords, n3), g.setCoordinates(e2.COORDS_BY_SCREEN, f[0], false), o2 = f[1], f = this._findStartPoint(t2, b.scrCoords, n3, g.scrCoords, o2), b.setCoordinates(e2.COORDS_BY_SCREEN, f[0], false), n3 = f[1], this._visibleArea = [o2, n3], a2 = g.copy("scrCoords"), h2 = b.copy("scrCoords"), g._t = o2, t2.points.push(g), this._lastCrds = g.copy("scrCoords"), this._plotRecursive_v2(t2, a2, o2, h2, n3, c, d), b._t = n3, t2.points.push(b), t2.numberPoints = t2.points.length, t2;
        }, _insertLimesPoint: function(t2, s2, o2, n3, a2) {
          var h2, l2, c;
          Math.abs(this._lastUsrCrds[1]) === 1 / 0 && Math.abs(a2.left_x) === 1 / 0 || Math.abs(this._lastUsrCrds[2]) === 1 / 0 && Math.abs(a2.left_y) === 1 / 0 || (h2 = new i(e2.COORDS_BY_USER, [a2.left_x, a2.left_y], t2.board), h2._t = o2, t2.points.push(h2), isNaN(a2.left_x) || isNaN(a2.left_y) || isNaN(a2.right_x) || isNaN(a2.right_y) || !(Math.abs(a2.left_x - a2.right_x) > r.eps || Math.abs(a2.left_y - a2.right_y) > r.eps) || (l2 = new i(e2.COORDS_BY_SCREEN, s2, t2.board), l2._t = o2, t2.points.push(l2)), c = new i(e2.COORDS_BY_USER, [a2.right_x, a2.right_y], t2.board), c._t = o2, t2.points.push(c), this._lastScrCrds = c.copy("scrCoords"), this._lastUsrCrds = c.copy("usrCoords"));
        }, _insertPoint: function(t2, r2, s2, o2, n3) {
          var a2, h2 = !isNaN(this._lastScrCrds[1] + this._lastScrCrds[2]), c = !isNaN(r2[1] + r2[2]), d = t2.board.canvasWidth, u = t2.board.canvasHeight;
          if (l.exists(n3))
            return void this._insertLimesPoint(t2, r2, s2, o2, n3);
          c = c && r2[1] > -500 && r2[2] > -500 && r2[1] < d + 500 && r2[2] < u + 500, (h2 || c) && (c && h2 && Math.abs(r2[1] - this._lastScrCrds[1]) < 0.8 && Math.abs(r2[2] - this._lastScrCrds[2]) < 0.8 || Math.abs(r2[1]) === 1 / 0 && Math.abs(this._lastUsrCrds[1]) === 1 / 0 || Math.abs(r2[2]) === 1 / 0 && Math.abs(this._lastUsrCrds[2]) === 1 / 0 || (a2 = new i(e2.COORDS_BY_SCREEN, r2, t2.board), a2._t = s2, t2.points.push(a2), this._lastScrCrds = a2.copy("scrCoords"), this._lastUsrCrds = a2.copy("usrCoords")));
        }, _triangleDists: function(t2, e3, i2) {
          var r2, s2, o2, n3, h2;
          return r2 = [t2[0] * e3[0], 0.5 * (t2[1] + e3[1]), 0.5 * (t2[2] + e3[2])], s2 = a.distance(t2, e3, 3), o2 = a.distance(t2, i2, 3), n3 = a.distance(i2, e3, 3), h2 = a.distance(i2, r2, 3), [s2, o2, n3, h2];
        }, _isUndefined: function(t2, r2, s2, o2, n3) {
          var a2, h2, l2;
          if (!isNaN(r2[1] + r2[2]) || !isNaN(o2[1] + o2[2]))
            return false;
          for (l2 = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false), h2 = 0; h2 < 20; ++h2)
            if (a2 = s2 + Math.random() * (n3 - s2), l2.setCoordinates(e2.COORDS_BY_USER, [t2.X(a2, true), t2.Y(a2, true)], false), !isNaN(l2.scrCoords[0] + l2.scrCoords[1] + l2.scrCoords[2]))
              return false;
          return true;
        }, _isOutside: function(t2, e3, i2, r2, s2) {
          var o2 = s2.canvasWidth, n3 = s2.canvasHeight;
          return !!(t2[1] < -500 && i2[1] < -500 || t2[2] < -500 && i2[2] < -500 || t2[1] > o2 + 500 && i2[1] > o2 + 500 || t2[2] > n3 + 500 && i2[2] > n3 + 500);
        }, _isOutsidePoint: function(t2, e3) {
          var i2 = e3.canvasWidth, r2 = e3.canvasHeight;
          return !!(t2[1] < -500 || t2[2] < -500 || t2[1] > i2 + 500 || t2[2] > r2 + 500);
        }, _findStartPoint: function(t2, r2, s2, o2, n3) {
          new i(e2.COORDS_BY_USER, [0, 0], t2.board, false), t2.board.getBoundingBox();
          return [r2, s2];
        }, _getBorderPos: function(t2, s2, o2, n3, a2, h2, l2) {
          var c, d, u, p, f, m, g = false;
          if (d = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false), p = 0, isNaN(o2[1] + o2[2]) && !isNaN(a2[1] + a2[2]))
            m = s2, f = n3, h2;
          else if (isNaN(l2[1] + l2[2]) && !isNaN(a2[1] + a2[2]))
            m = h2, f = n3, s2;
          else if (isNaN(a2[1] + a2[2]) && !isNaN(l2[1] + l2[2]))
            m = n3, f = h2, h2 + (h2 - n3);
          else {
            if (!isNaN(a2[1] + a2[2]) || isNaN(o2[1] + o2[2]))
              return false;
            m = n3, f = s2, s2 - (n3 - s2);
          }
          do {
            c = 0.5 * (f + m), d.setCoordinates(e2.COORDS_BY_USER, [t2.X(c, true), t2.Y(c, true)], false), u = d.usrCoords, g = isNaN(u[1] + u[2]), g ? m = c : (f, f = c), ++p;
          } while (p < 30 && Math.abs(f - m) > r.eps);
          return c;
        }, _getCuspPos: function(t2, e3, i2) {
          var r2 = [t2.X(e3, true), t2.Y(e3, true)], s2 = [t2.X(i2, true), t2.Y(i2, true)], n3 = function(e4) {
            var i3 = [t2.X(e4, true), t2.Y(e4, true)];
            return -(Math.sqrt((r2[0] - i3[0]) * (r2[0] - i3[0]) + (r2[1] - i3[1]) * (r2[1] - i3[1])) + Math.sqrt((s2[0] - i3[0]) * (s2[0] - i3[0]) + (s2[1] - i3[1]) * (s2[1] - i3[1])));
          };
          return o.fminbr(n3, [e3, i2], t2);
        }, _getJumpPos: function(t2, e3, i2) {
          var s2 = function(e4) {
            var i3 = r.eps * r.eps, s3 = [t2.X(e4, true), t2.Y(e4, true)], o2 = [t2.X(e4 + i3, true), t2.Y(e4 + i3, true)];
            return -Math.abs((o2[1] - s3[1]) / (o2[0] - s3[0]));
          };
          return o.fminbr(s2, [e3, i2], t2);
        }, _getLimits: function(t2, e3) {
          var i2, r2, o2, n3, a2, h2 = 2 / (t2.maxX() - t2.minX());
          return i2 = s.limit(e3, -h2, t2.X), r2 = i2[0], i2[1] === "infinite" && (r2 = Math.sign(r2) * (1 / 0)), i2 = s.limit(e3, -h2, t2.Y), n3 = i2[0], i2[1] === "infinite" && (n3 = Math.sign(n3) * (1 / 0)), i2 = s.limit(e3, h2, t2.X), o2 = i2[0], i2[1] === "infinite" && (o2 = Math.sign(o2) * (1 / 0)), i2 = s.limit(e3, h2, t2.Y), a2 = i2[0], i2[1] === "infinite" && (a2 = Math.sign(a2) * (1 / 0)), {left_x: r2, left_y: n3, right_x: o2, right_y: a2, t: e3};
        }, _getLimes: function(t2, e3, i2, r2, s2, o2, n3, a2, h2) {
          var l2;
          return a2 === "border" ? l2 = this._getBorderPos(t2, e3, i2, r2, s2, o2, n3) : a2 === "cusp" ? l2 = this._getCuspPos(t2, e3, o2) : a2 === "jump" && (l2 = this._getJumpPos(t2, e3, o2)), this._getLimits(t2, l2);
        }, _plotNonRecursive: function(t2, e3, i2, r2, s2, o2) {
          var n3, a2, h2, l2, c, d, u, p, f, m, g, b = null, v = false, y = "", C = [], _4 = 0;
          for (p = t2.board.origin.scrCoords, C[_4++] = [e3, i2, r2, s2, o2, 1 / 0]; _4 > 0; ) {
            if (g = C[--_4], e3 = g[0], i2 = g[1], r2 = g[2], s2 = g[3], f = g[4], m = g[5], v = false, y = "", b = null, t2.points.length > 65536)
              return;
            if (f < this.nanLevel) {
              if (this._isUndefined(t2, e3, i2, r2, s2))
                continue;
              if (this._isOutside(e3, i2, r2, s2, t2.board))
                continue;
            }
            n3 = 0.5 * (i2 + s2), d = t2.X(n3, true), u = t2.Y(n3, true), a2 = [1, p[1] + d * t2.board.unitX, p[2] - u * t2.board.unitY], h2 = this._triangleDists(e3, r2, a2), l2 = isNaN(e3[1] + e3[2]), c = isNaN(r2[1] + r2[2]), l2 && !c || !l2 && c ? y = "border" : h2[0] > 0.66 * m || h2[0] < this.cusp_threshold * (h2[1] + h2[2]) || h2[1] > 5 * h2[2] || h2[2] > 5 * h2[1] ? y = "cusp" : (h2[2] > this.jump_threshold * h2[0] || h2[1] > this.jump_threshold * h2[0] || h2[0] === 1 / 0 || h2[1] === 1 / 0 || h2[2] === 1 / 0) && (y = "jump"), v = y === "" && f < this.smoothLevel && h2[3] < this.smooth_threshold, f < this.testLevel && !v && (y === "" ? v = true : b = this._getLimes(t2, i2, e3, n3, a2, s2, r2, y, f)), b !== null ? (a2 = [1, NaN, NaN], this._insertPoint(t2, a2, n3, f, b)) : f <= 0 || v ? this._insertPoint(t2, a2, n3, f, null) : (C[_4++] = [a2, n3, r2, s2, f - 1, h2[0]], C[_4++] = [e3, i2, a2, n3, f - 1, h2[0]]);
          }
          return this;
        }, updateParametricCurve_v3: function(t2, r2, s2) {
          var o2, n3, a2, h2, c, d, u, p, f = false, m = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false), g = new i(e2.COORDS_BY_USER, [0, 0], t2.board, false);
          return c = t2.board.updateQuality === t2.board.BOARD_QUALITY_LOW ? l.evaluate(t2.visProp.recursiondepthlow) || 14 : l.evaluate(t2.visProp.recursiondepthhigh) || 17, this.smoothLevel = 7, this.nanLevel = c - 4, this.testLevel = 4, this.cusp_threshold = 0.5, this.jump_threshold = 0.99, this.smooth_threshold = 2, t2.points = [], t2.xterm === "x" ? (u = t2.board.getBoundingBox(), d = 0.3 * (u[2] - u[0]), o2 = Math.max(r2, u[0] - d), n3 = Math.min(s2, u[2] + d)) : (o2 = r2, n3 = s2), m.setCoordinates(e2.COORDS_BY_USER, [t2.X(o2, f), t2.Y(o2, f)], false), f = true, g.setCoordinates(e2.COORDS_BY_USER, [t2.X(n3, f), t2.Y(n3, f)], false), p = this._findStartPoint(t2, m.scrCoords, o2, g.scrCoords, n3), m.setCoordinates(e2.COORDS_BY_SCREEN, p[0], false), o2 = p[1], p = this._findStartPoint(t2, g.scrCoords, n3, m.scrCoords, o2), g.setCoordinates(e2.COORDS_BY_SCREEN, p[0], false), n3 = p[1], this._visibleArea = [o2, n3], a2 = m.copy("scrCoords"), h2 = g.copy("scrCoords"), m._t = o2, t2.points.push(m), this._lastScrCrds = m.copy("scrCoords"), this._lastUsrCrds = m.copy("usrCoords"), this._plotNonRecursive(t2, a2, o2, h2, n3, c), g._t = n3, t2.points.push(g), t2.numberPoints = t2.points.length, t2;
        }, _criticalInterval: function(t2, e3, i2) {
          var r2, s2, o2, a2, h2, l2, c, d = false, u = -1 / 0, p = false, f = false, m = 0, g = [], b = [], v = [];
          for (c = n.abs(t2), a2 = n.median(c), a2 < 1e-7 ? (a2 = 1e-7, p = true) : a2 *= this.criticalThreshold, r2 = 0; r2 < e3; r2++)
            c[r2] > a2 ? (v.push({i: r2, v: t2[r2], group: m}), u = r2, d || (d = true)) : d && r2 > u + 4 && (v.length > 0 && g.push(v.slice(0)), v = [], d = false, m++);
          for (d && v.length > 1 && g.push(v.slice(0)), p && g.length === 0 && (f = true), s2 = 0; s2 < g.length; s2++)
            if (b[s2] = "point", !((o2 = g[s2].length) < 64)) {
              for (l2 = 0, h2 = Math.sign(g[s2][0].v), r2 = 1; r2 < o2; r2++)
                Math.sign(g[s2][r2].v) !== h2 && (l2++, h2 = Math.sign(g[s2][r2].v));
              6 * l2 > o2 && (b[s2] = "interval");
            }
          return {smooth: f, groups: g, types: b};
        }, Component: function() {
          this.left_isNaN = false, this.right_isNaN = false, this.left_t = null, this.right_t = null, this.t_values = [], this.x_values = [], this.y_values = [], this.len = 0;
        }, findComponents: function(t2, e3, i2, r2) {
          var s2, o2, n3, a2, h2, l2, c = [], d = 0, u = 0, p = 0, f = false, m = false;
          for (n3 = (i2 - e3) / r2, c[d] = new this.Component(), l2 = c[d], s2 = 0, o2 = e3; s2 <= r2; s2++, o2 += n3)
            a2 = t2.X(o2, m), h2 = t2.Y(o2, m), isNaN(a2) || isNaN(h2) ? ++p > 1 && f && (l2.right_isNaN = true, l2.right_t = o2 - n3, l2.len = u, f = false, d++, c[d] = new this.Component(), l2 = c[d], p = 0) : (f || (f = true, u = 0, p > 0 && (l2.left_t = o2 - n3, l2.left_isNaN = true)), p = 0, l2.t_values[u] = o2, l2.x_values[u] = a2, l2.y_values[u] = h2, u++), s2 === 0 && (m = true);
          return f ? l2.len = u : c.pop(), c;
        }, getPointType: function(t2, e3, i2, r2, s2, o2, n3) {
          var a2 = s2[0], h2 = o2[0], l2 = r2.length, c = {idx: e3, t: i2, x: a2[e3], y: h2[e3], type: "other"};
          return e3 < 5 ? (c.type = "borderleft", c.idx = 0, c.t = r2[0], c.x = a2[0], c.y = h2[0], c) : e3 > n3 - 6 ? (c.type = "borderright", c.idx = l2 - 1, c.t = r2[l2 - 1], c.x = a2[l2 - 1], c.y = h2[l2 - 1], c) : c;
        }, newtonApprox: function(t2, e3, i2, r2, s2) {
          var o2, n3 = 0;
          for (o2 = r2; o2 > 0; o2--)
            n3 = (n3 + s2[o2][t2]) * (e3 - (o2 - 1) * i2) / o2;
          return n3 + s2[0][t2];
        }, thiele: function(t2, e3, i2, r2, s2) {
          var o2, n3 = 0;
          for (o2 = s2; o2 > 1; o2--)
            n3 = (t2 - i2[r2 + o2]) / (e3[o2][r2 + 1] - e3[o2 - 2][r2 + 1] + n3);
          return e3[0][r2 + 1] + (t2 - i2[r2 + 1]) / (e3[1][r2 + 1] + n3);
        }, differenceMethodExperiments: function(t2, e3) {
          var i2, r2, s2, o2, n3, a2, h2, l2, c, d, u, p = t2.t_values, f = t2.x_values, m = t2.y_values, g = [], b = [], v = [], y = [], C = [], _4 = [], P2 = [], E = [], x = 0, S = [];
          for (n3 = p[1] - p[0], C.push([]), _4.push([]), P2.push([]), E.push([]), s2 = m.length, i2 = 0; i2 < s2; i2++)
            C[0][i2] = f[i2], _4[0][i2] = m[i2], P2[0][i2] = f[i2], E[0][i2] = m[i2];
          for (C.push([]), _4.push([]), P2.push([]), E.push([]), a2 = n3, s2 = m.length - 1, i2 = 0; i2 < s2; i2++)
            g[i2] = f[i2 + 1] - f[i2], b[i2] = m[i2 + 1] - m[i2], v[i2] = g[i2], y[i2] = b[i2], C[1][i2] = g[i2], _4[1][i2] = b[i2], P2[1][i2] = a2 / g[i2], E[1][i2] = a2 / b[i2];
          for (s2--, o2 = Math.min(8, m.length - 1), r2 = 1; r2 < o2; r2++) {
            for (C.push([]), _4.push([]), P2.push([]), E.push([]), a2 *= n3, i2 = 0; i2 < s2; i2++)
              g[i2] = g[i2 + 1] - g[i2], b[i2] = b[i2 + 1] - b[i2], C[r2 + 1][i2] = g[i2], _4[r2 + 1][i2] = b[i2], P2[r2 + 1][i2] = a2 / (P2[r2][i2 + 1] - P2[r2][i2]) + P2[r2 - 1][i2 + 1], E[r2 + 1][i2] = a2 / (E[r2][i2 + 1] - E[r2][i2]) + E[r2 - 1][i2 + 1];
            if ((u = this._criticalPoints(b, s2, r2)) === false) {
              console.log("Polynomial of degree", r2), u = [];
              break;
            }
            if (u.length > 0 && ++x > 1 && r2 % 2 == 0)
              break;
            s2--;
          }
          for (i2 = 0; i2 < u.length; i2++) {
            for (l2 = -1 / 0, c = 0; c < u[i2].length; c++)
              (d = Math.abs(u[i2][c].v)) > l2 && (l2 = d, h2 = c);
            h2 = Math.floor(u[i2][h2].i + r2 / 2), S.push(this.getPointType(e3, h2, p, f, m, v, y, s2 + 1));
          }
          return [S, C, _4, P2, E];
        }, getCenterOfCriticalInterval: function(t2, e3, i2) {
          var r2, s2, o2, n3, a2, h2 = 0, l2 = 0, c = i2[1] - i2[0], d = [];
          for (r2 = -1 / 0, d = [], s2 = 0; s2 < t2.length; s2++)
            n3 = Math.abs(t2[s2].v), n3 > r2 ? (d = [s2], r2 = n3, o2 = s2) : r2 === n3 && d.push(s2);
          if (d.length > 0 && (a2 = d.reduce(function(t3, e4) {
            return t3 + e4;
          }, 0) / d.length, o2 = Math.floor(a2), a2 += t2[0].i), r2 < 1 / 0) {
            for (s2 = 0; s2 < t2.length; s2++)
              h2 += Math.abs(t2[s2].v) * t2[s2].i, l2 += Math.abs(t2[s2].v);
            a2 = h2 / l2;
          }
          return a2 += e3 / 2, [t2[o2].i + e3 / 2, a2, i2[Math.floor(a2)] + c * (a2 - Math.floor(a2))];
        }, differenceMethod: function(t2, e3) {
          var i2, r2, s2, o2, n3, a2, h2, l2, c, d, u = t2.t_values, p = t2.x_values, f = t2.y_values, m = [], g = [], b = 0, v = -1, y = -1, C = [], _4 = [];
          for (s2 = f.length, m.push(new Float64Array(p)), g.push(new Float64Array(f)), s2--, o2 = Math.min(12, s2), r2 = 0; r2 < o2 && (m.push(new Float64Array(s2)), g.push(new Float64Array(s2)), m[r2 + 1] = m[r2].map(function(t3, e4, i3) {
            return i3[e4 + 1] - t3;
          }), g[r2 + 1] = g[r2].map(function(t3, e4, i3) {
            return i3[e4 + 1] - t3;
          }), l2 = this._criticalInterval(g[r2 + 1], s2, r2), l2.smooth === true && (y = r2, C = []), h2 = this._criticalInterval(m[r2 + 1], s2, r2), v === -1 && h2.smooth === true && (v = r2), !(y >= 0)); r2++) {
            if (l2.groups.length > 0 && ++b > 2 && (r2 + 1) % 2 == 0) {
              C = l2.groups, d = l2.types;
              break;
            }
            s2--;
          }
          for (i2 = 0; i2 < C.length; i2++)
            d[i2] !== "interval" && (a2 = this.getCenterOfCriticalInterval(C[i2], r2 + 1, u), n3 = l2[0], n3 = Math.floor(a2[1]), c = a2[2], _4.push(this.getPointType(e3, n3, c, u, m, g, s2 + 1)));
          return [_4, m, g, v, y];
        }, _insertPoint_v4: function(t2, r2, s2, o2) {
          var n3, a2, h2, l2 = null;
          t2.points.length > 0 && (l2 = t2.points[t2.points.length - 1].scrCoords), n3 = new i(e2.COORDS_BY_USER, r2, t2.board), l2 !== null && (a2 = n3.scrCoords[1] - l2[1], h2 = n3.scrCoords[2] - l2[2], a2 * a2 + h2 * h2 < 0.8 * 0.8) || (n3._t = s2, t2.points.push(n3));
        }, getInterval: function(e3, i2, r2) {
          var s2, o2;
          return h.disable(), s2 = h.Interval(i2, r2), e3.board.mathLib = h, e3.board.mathLibJXG = h, e3.X(s2, true), o2 = e3.Y(s2, true), e3.board.mathLib = Math, e3.board.mathLibJXG = t.Math, o2;
        }, sign: function(t2) {
          return t2 < 0 ? -1 : t2 > 0 ? 1 : 0;
        }, handleBorder: function(t2, e3, i2, r2, s2) {
          var o2, n3, a2, h2, c, d, u, p, f, m, g, b, v = i2.idx;
          if (b = e3.t_values[1] - e3.t_values[0], i2.type === "borderleft" ? (o2 = e3.left_isNaN ? e3.left_t : i2.t - b, n3 = o2, a2 = n3 + b) : i2.type === "borderright" ? (o2 = e3.right_isNaN ? e3.right_t : i2.t + b, a2 = o2, n3 = a2 - b) : console.log("No bordercase!!!"), m = this.findComponents(t2, n3, a2, 32), m.length !== 0) {
            for (i2.type === "borderleft" && (n3 = m[0].left_t, a2 = m[0].t_values[0], b = m[0].t_values[1] - m[0].t_values[0], n3 = n3 === null ? a2 - b : n3, o2 = n3, h2 = this.getInterval(t2, n3, a2), l.isObject(h2) && (u = h2.lo, p = h2.hi, c = t2.X(o2, true), d = s2[1][v] < 0 ? p : u, this._insertPoint_v4(t2, [1, c, d], o2))), g = m[0].t_values.length, f = 0; f < g; f++)
              o2 = m[0].t_values[f], c = m[0].x_values[f], d = m[0].y_values[f], this._insertPoint_v4(t2, [1, c, d], o2);
            i2.type === "borderright" && (n3 = m[0].t_values[g - 1], a2 = m[0].right_t, b = m[0].t_values[1] - m[0].t_values[0], a2 = a2 === null ? n3 + b : a2, o2 = a2, h2 = this.getInterval(t2, n3, a2), l.isObject(h2) && (u = h2.lo, p = h2.hi, c = t2.X(o2, true), d = s2[1][v] > 0 ? p : u, this._insertPoint_v4(t2, [1, c, d], o2)));
          }
        }, _seconditeration_v4: function(t2, e3, i2, r2, s2) {
          var o2, n3, a2, h2, l2, c, d, u, p, f, m, g, b;
          for (n3 = e3.t_values[i2.idx - 2], a2 = e3.t_values[i2.idx + 2], l2 = this.findComponents(t2, n3, a2, 64), d = 0; d < l2.length; d++) {
            for (c = l2[d], h2 = this.differenceMethod(c, t2), u = h2[0], f = h2[1], m = h2[2], g = 0, p = 0; p <= u.length; p++) {
              for (b = p === u.length ? c.len : u[p].idx, o2 = g; o2 < b; o2++)
                isNaN(c.x_values[o2]) || isNaN(c.y_values[o2]) || this._insertPoint_v4(t2, [1, c.x_values[o2], c.y_values[o2]], c.t_values[o2]);
              p < u.length && (this.handleSingularity(t2, c, u[p], f, m), g = u[p].idx + 1);
            }
            b = c.len, d < l2.length - 1 && this._insertPoint_v4(t2, [1, NaN, NaN], c.right_t);
          }
          return this;
        }, _recurse_v4: function(t2, e3, i2, r2, s2, o2, n3, a2) {
          var h2, l2, c = 0.5 * (e3 + i2), d = t2.X(c, true), u = t2.Y(c, true);
          if (a2 == 0)
            return void this._insertPoint_v4(t2, [1, NaN, NaN], c);
          h2 = (d - r2) * t2.board.unitX, l2 = (u - s2) * t2.board.unitY, Math.sqrt(h2 * h2 + l2 * l2) > 2 ? this._recurse_v4(t2, e3, c, r2, s2, d, u, a2 - 1) : this._insertPoint_v4(t2, [1, d, u], c), h2 = (d - o2) * t2.board.unitX, l2 = (u - n3) * t2.board.unitY, Math.sqrt(h2 * h2 + l2 * l2) > 2 ? this._recurse_v4(t2, c, i2, d, u, o2, n3, a2 - 1) : this._insertPoint_v4(t2, [1, d, u], c);
        }, handleSingularity: function(t2, e3, i2, r2, s2) {
          var o2, n3, a2, h2, c, d, u, p, f, m, g, b = i2.idx;
          o2 = i2.t, console.log("HandleSingularity at t =", o2), n3 = e3.t_values[b - 5], a2 = e3.t_values[b + 5], h2 = this.getInterval(t2, n3, a2), l.isObject(h2) ? (p = h2.lo, f = h2.hi) : s2[0][b - 1] < s2[0][b + 1] ? (p = s2[0][b - 1], f = s2[0][b + 1]) : (p = s2[0][b + 1], f = s2[0][b - 1]), u = t2.X(o2, true), m = (s2[0][b - 3] - s2[0][b - 5]) / (e3.t_values[b - 3] - e3.t_values[b - 5]), g = (s2[0][b + 3] - s2[0][b + 5]) / (e3.t_values[b + 3] - e3.t_values[b + 5]), console.log(":::", m, g), m < -100 ? (this._insertPoint_v4(t2, [1, u, p], o2, true), g <= 100 && this._insertPoint_v4(t2, [1, NaN, NaN], o2)) : m > 100 ? (this._insertPoint_v4(t2, [1, u, f], o2), g >= -100 && this._insertPoint_v4(t2, [1, NaN, NaN], o2)) : (p === -1 / 0 && (this._insertPoint_v4(t2, [1, u, p], o2, true), this._insertPoint_v4(t2, [1, NaN, NaN], o2)), f === 1 / 0 && (this._insertPoint_v4(t2, [1, NaN, NaN], o2), this._insertPoint_v4(t2, [1, u, f], o2, true)), i2.t < e3.t_values[b] ? (c = b - 1, d = b) : (c = b, d = b + 1), n3 = e3.t_values[c], a2 = e3.t_values[d], this._recurse_v4(t2, n3, a2, r2[0][c], s2[0][c], r2[0][d], s2[0][d], 10)), g < -100 ? this._insertPoint_v4(t2, [1, u, f], o2) : g > 100 && this._insertPoint_v4(t2, [1, u, p], o2);
        }, steps: 1021, criticalThreshold: 1e3, plot_v4: function(t2, e3, i2, r2) {
          var s2, n3, a2, h2, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E = (i2 - e3) / r2, x = function(e4) {
            return t2.Y(e4, true);
          }, S = function(e4) {
            return -t2.Y(e4, true);
          }, O = 0.5 * E;
          for (a2 = this.findComponents(t2, e3, i2, r2), h2 = 0; h2 < a2.length; h2++) {
            for (c = a2[h2], f = this.differenceMethod(c, t2), d = f[0], m = f[1], g = f[2], f[3], f[4], d.length !== 0 && d[0].type === "borderleft" || d.unshift({idx: 0, t: c.t_values[0], x: c.x_values[0], y: c.y_values[0], type: "borderleft"}), d[d.length - 1].type !== "borderright" && (n3 = c.t_values.length, d.push({idx: n3 - 1, t: c.t_values[n3 - 1], x: c.x_values[n3 - 1], y: c.y_values[n3 - 1], type: "borderright"})), p = 0, u = 0; u <= d.length; u++) {
              for (n3 = u === d.length ? c.len : d[u].idx - 1, C = 0, _4 = 0, s2 = p; s2 < n3 - 2; s2++)
                this._insertPoint_v4(t2, [1, c.x_values[s2], c.y_values[s2]], c.t_values[s2]), Math.max(0, s2 - 2), s2 >= p + 3 && s2 < n3 - 3 && g.length > 3 && Math.abs(g[2][s2]) > 0.2 * Math.abs(g[0][s2]) ? (b = c.t_values[s2], O = 0.25 * E, P2 = this.getInterval(t2, b, b + E), l.isObject(P2) ? g[2][s2] > 0 ? this._insertPoint_v4(t2, [1, b + O, P2.lo], b + O) : this._insertPoint_v4(t2, [1, b + E - O, P2.hi], b + E - O) : (v = o.fminbr(x, [b, b + E]), y = o.fminbr(S, [b, b + E]), v < y ? (this._insertPoint_v4(t2, [1, t2.X(v, true), t2.Y(v, true)], v), this._insertPoint_v4(t2, [1, t2.X(y, true), t2.Y(y, true)], y)) : (this._insertPoint_v4(t2, [1, t2.X(y, true), t2.Y(y, true)], y), this._insertPoint_v4(t2, [1, t2.X(v, true), t2.Y(v, true)], v))), _4++) : C++;
              u < d.length && (s2 = d[u].idx, d[u].type === "borderleft" || d[u].type === "borderright" ? this.handleBorder(t2, c, d[u], m, g) : this._seconditeration_v4(t2, c, d[u], m, g), p = d[u].idx + 1 + 1);
            }
            n3 = c.len, h2 < a2.length - 1 && this._insertPoint_v4(t2, [1, NaN, NaN], c.right_t);
          }
        }, updateParametricCurve_v4: function(t2, e3, i2) {
          var r2, s2, o2, n3;
          t2.xterm === "x" ? (n3 = t2.board.getBoundingBox(), o2 = 0.3 * (n3[2] - n3[0]), r2 = Math.max(e3, n3[0] - o2), s2 = Math.min(i2, n3[2] + o2)) : (r2 = e3, s2 = i2), t2.points = [], this.plot_v4(t2, r2, s2, this.steps), t2.numberPoints = t2.points.length;
        }, updateParametricCurve: function(t2, e3, i2) {
          return this.updateParametricCurve_v2(t2, e3, i2);
        }}, r.Plot;
      }), define("math/metapost", ["utils/type", "math/math"], function(t, e2) {
        "use strict";
        return e2.Metapost = {MP_ENDPOINT: 0, MP_EXPLICIT: 1, MP_GIVEN: 2, MP_CURL: 3, MP_OPEN: 4, MP_END_CYCLE: 5, UNITY: 1, FRACTION_ONE: 1, FRACTION_THREE: 3, ONE_EIGHTY_DEG: Math.PI, THREE_SIXTY_DEG: 2 * Math.PI, EPS_SQ: 1e-5 * 1e-5, make_choices: function(t2) {
          var e3, i, r, s, o, n, a, h, l, c, d, u, p, f, m;
          a = t2[0];
          do {
            if (!a)
              break;
            n = a.next, a.rtype > this.MP_EXPLICIT && (a.x - n.x) * (a.x - n.x) + (a.y - n.y) * (a.y - n.y) < this.EPS_SQ && (a.rtype = this.MP_EXPLICIT, a.ltype === this.MP_OPEN && (a.ltype = this.MP_CURL, a.set_left_curl(this.UNITY)), n.ltype = this.MP_EXPLICIT, n.rtype === this.MP_OPEN && (n.rtype = this.MP_CURL, n.set_right_curl(this.UNITY)), a.rx = a.x, n.lx = a.x, a.ry = a.y, n.ly = a.y), a = n;
          } while (a !== t2[0]);
          for (i = t2[0]; ; ) {
            if (i.ltype !== this.MP_OPEN || i.rtype !== this.MP_OPEN)
              break;
            if ((i = i.next) === t2[0]) {
              i.ltype = this.MP_END_CYCLE;
              break;
            }
          }
          for (a = i; ; ) {
            if (!a)
              break;
            if (n = a.next, a.rtype >= this.MP_GIVEN) {
              for (; n.ltype === this.MP_OPEN && n.rtype === this.MP_OPEN; )
                n = n.next;
              for (r = 0, h = a, o = t2.length, u = [], p = [], f = [], m = [null]; ; )
                if (c = h.next, u.push(c.x - h.x), p.push(c.y - h.y), f.push(this.mp_pyth_add(u[r], p[r])), r > 0 && (d = p[r - 1] / f[r - 1], l = u[r - 1] / f[r - 1], m.push(Math.atan2(p[r] * l - u[r] * d, u[r] * l + p[r] * d))), r++, h = c, h === n && (o = r), r >= o && h.ltype !== this.MP_END_CYCLE)
                  break;
              r === o ? m.push(0) : m.push(m[1]), n.ltype === this.MP_OPEN && (s = n.rx - n.x, e3 = n.ry - n.y, s * s + e3 * e3 < this.EPS_SQ ? (n.ltype = this.MP_CURL, n.set_left_curl(this.UNITY)) : (n.ltype = this.MP_GIVEN, n.set_left_given(Math.atan2(e3, s)))), a.rtype === this.MP_OPEN && a.ltype === this.MP_EXPLICIT && (s = a.x - a.lx, e3 = a.y - a.ly, s * s + e3 * e3 < this.EPS_SQ ? (a.rtype = this.MP_CURL, a.set_right_curl(this.UNITY)) : (a.rtype = this.MP_GIVEN, a.set_right_given(Math.atan2(e3, s)))), this.mp_solve_choices(a, n, o, u, p, f, m);
            } else
              a.rtype === this.MP_ENDPOINT && (a.rx = a.x, a.ry = a.y, n.lx = n.x, n.ly = n.y);
            if ((a = n) === i)
              break;
          }
        }, mp_solve_choices: function(t2, e3, i, r, s, o, n) {
          var a, h, l, c, d, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S, O, w, T, N, M, A, R;
          for (d = o.length + 1, g = new Array(d), m = new Array(d), l = new Array(d), _4 = new Array(d), A = 0; A < d; A++)
            _4[A] = l[A] = m[A] = g[A] = 0;
          for (p = 0, f = t2, v = 0; ; ) {
            if (y = f.next, p === 0)
              if (f.rtype === this.MP_GIVEN) {
                if (y.ltype === this.MP_GIVEN)
                  return a = Math.atan2(s[0], r[0]), S = this.mp_n_sin_cos(t2.right_given() - a), O = S[0], w = S[1], T = this.mp_n_sin_cos(e3.left_given() - a), N = T[0], M = T[1], void this.mp_set_controls(t2, e3, r[0], s[0], w, O, -M, N);
                l[0] = f.right_given() - Math.atan2(s[0], r[0]), l[0] = this.reduce_angle(l[0]), g[0] = 0, m[0] = 0;
              } else if (f.rtype === this.MP_CURL) {
                if (y.ltype === this.MP_CURL)
                  return t2.rtype = this.MP_EXPLICIT, e3.ltype = this.MP_EXPLICIT, b = Math.abs(e3.left_tension()), P2 = Math.abs(t2.right_tension()), C = this.UNITY / (3 * P2), t2.rx = t2.x + r[0] * C, t2.ry = t2.y + s[0] * C, C = this.UNITY / (3 * b), e3.lx = e3.x - r[0] * C, void (e3.ly = e3.y - s[0] * C);
                x = f.right_curl(), b = Math.abs(y.left_tension()), P2 = Math.abs(f.right_tension()), g[0] = this.mp_curl_ratio(x, P2, b), l[0] = -n[1] * g[0], m[0] = 0;
              } else
                f.rtype === this.MP_OPEN && (g[0] = 0, l[0] = 0, m[0] = this.FRACTION_ONE);
            else if (f.ltype === this.MP_END_CYCLE || f.ltype === this.MP_OPEN) {
              if (a = this.UNITY / (3 * Math.abs(v.right_tension()) - this.UNITY), E = o[p] * (this.FRACTION_THREE - this.UNITY / Math.abs(v.right_tension())), c = this.UNITY / (3 * Math.abs(y.left_tension()) - this.UNITY), u = o[p - 1] * (this.FRACTION_THREE - this.UNITY / Math.abs(y.left_tension())), x = this.FRACTION_ONE - g[p - 1] * a, E *= x, b = Math.abs(f.left_tension()), P2 = Math.abs(f.right_tension()), b < P2 ? E *= Math.pow(b / P2, 2) : b > P2 && (u *= Math.pow(P2 / b, 2)), C = u / (u + E), g[p] = C * c, h = -n[p + 1] * g[p], v.rtype === this.MP_CURL ? (m[p] = 0, l[p] = h - n[1] * (this.FRACTION_ONE - C)) : (C = (this.FRACTION_ONE - C) / x, h -= n[p] * C, C *= a, l[p] = h - l[p - 1] * C, m[p] = -m[p - 1] * C), f.ltype === this.MP_END_CYCLE) {
                for (a = 0, c = this.FRACTION_ONE; ; )
                  if (p -= 1, p === 0 && (p = i), a = l[p] - a * g[p], c = m[p] - c * g[p], p === i)
                    break;
                for (a /= this.FRACTION_ONE - c, _4[i] = a, l[0] = a, R = 1; R < i; R++)
                  l[R] = l[R] + a * m[R];
                break;
              }
            } else {
              if (f.ltype === this.MP_CURL) {
                x = f.left_curl(), b = Math.abs(f.left_tension()), P2 = Math.abs(v.right_tension()), C = this.mp_curl_ratio(x, b, P2), _4[i] = -l[i - 1] * C / (this.FRACTION_ONE - C * g[i - 1]);
                break;
              }
              if (f.ltype === this.MP_GIVEN) {
                _4[i] = f.left_given() - Math.atan2(s[i - 1], r[i - 1]), _4[i] = this.reduce_angle(_4[i]);
                break;
              }
            }
            v = f, f = y, p += 1;
          }
          for (p = i - 1; p > -1; p--)
            _4[p] = l[p] - _4[p + 1] * g[p];
          for (f = t2, p = 0; ; )
            if (y = f.next, S = this.mp_n_sin_cos(_4[p]), O = S[0], w = S[1], T = this.mp_n_sin_cos(-n[p + 1] - _4[p + 1]), N = T[0], M = T[1], this.mp_set_controls(f, y, r[p], s[p], w, O, M, N), p++, f = y, p === i)
              break;
        }, mp_n_sin_cos: function(t2) {
          return [Math.cos(t2), Math.sin(t2)];
        }, mp_set_controls: function(t2, e3, i, r, s, o, n, a) {
          var h, l, c, d, u;
          c = Math.abs(e3.left_tension()), h = Math.abs(t2.right_tension()), u = this.mp_velocity(s, o, n, a, h), l = this.mp_velocity(n, a, s, o, c), (t2.right_tension() < 0 || e3.left_tension() < 0) && (s >= 0 && n >= 0 || s <= 0 && n <= 0) && (d = Math.abs(s) * a + Math.abs(n) * o) > 0 && (d *= 1.00024414062, t2.right_tension() < 0 && this.mp_ab_vs_cd(Math.abs(n), this.FRACTION_ONE, u, d) < 0 && (u = Math.abs(n) / d), e3.left_tension() < 0 && this.mp_ab_vs_cd(Math.abs(s), this.FRACTION_ONE, l, d) < 0 && (l = Math.abs(s) / d)), t2.rx = t2.x + (i * o - r * s) * u, t2.ry = t2.y + (r * o + i * s) * u, e3.lx = e3.x - (i * a + r * n) * l, e3.ly = e3.y - (r * a - i * n) * l, t2.rtype = this.MP_EXPLICIT, e3.ltype = this.MP_EXPLICIT;
        }, mp_pyth_add: function(t2, e3) {
          return Math.sqrt(t2 * t2 + e3 * e3);
        }, mp_curl_ratio: function(t2, e3, i) {
          var r = 1 / e3, s = 1 / i;
          return Math.min(4, ((3 - r) * r * r * t2 + s * s * s) / (r * r * r * t2 + (3 - s) * s * s));
        }, mp_ab_vs_cd: function(t2, e3, i, r) {
          return t2 * e3 == i * r ? 0 : t2 * e3 > i * r ? 1 : -1;
        }, mp_velocity: function(t2, e3, i, r, s) {
          return Math.min(4, (2 + Math.sqrt(2) * (t2 - i / 16) * (i - t2 / 16) * (e3 - r)) / (1.5 * s * (2 + (Math.sqrt(5) - 1) * e3 + (3 - Math.sqrt(5)) * r)));
        }, reduce_angle: function(t2) {
          return Math.abs(t2) > this.ONE_EIGHTY_DEG && (t2 > 0 ? t2 -= this.THREE_SIXTY_DEG : t2 += this.THREE_SIXTY_DEG), t2;
        }, makeknots: function(t2, e3, i) {
          var r, s, o = [];
          for (e3 = e3 || 1, s = t2.length, r = 0; r < s; r++)
            o.push({x: t2[r][0], y: t2[r][1], ltype: this.MP_OPEN, rtype: this.MP_OPEN, ly: e3, ry: e3, lx: e3, rx: e3, left_curl: function() {
              return this.lx || 0;
            }, right_curl: function() {
              return this.rx || 0;
            }, left_tension: function() {
              return this.ly || (this.ly = 1), this.ly;
            }, right_tension: function() {
              return this.ry || (this.ry = 1), this.ry;
            }, set_right_curl: function(t3) {
              this.rx = t3 || 0;
            }, set_left_curl: function(t3) {
              this.lx = t3 || 0;
            }});
          for (s = o.length, r = 0; r < s; r++)
            o[r].next = o[r + 1] || o[r], o[r].set_right_given = o[r].set_right_curl, o[r].set_left_given = o[r].set_left_curl, o[r].right_given = o[r].right_curl, o[r].left_given = o[r].left_curl;
          return o[s - 1].next = o[0], i || (o[s - 1].rtype = this.MP_ENDPOINT, o[s - 1].ltype = this.MP_CURL, o[0].rtype = this.MP_CURL), o;
        }, curve: function(e3, i) {
          var r, s, o, n, a = [], h = [];
          i = i || {tension: 1, direction: {}, curl: {}, isClosed: false}, r = this.makeknots(e3, t.evaluate(i.tension), i.isClosed), s = r.length;
          for (o in i.direction)
            i.direction.hasOwnProperty(o) && (n = t.evaluate(i.direction[o]), t.isArray(n) ? (n[0] !== false && (r[o].lx = n[0] * Math.PI / 180, r[o].ltype = this.MP_GIVEN), n[1] !== false && (r[o].rx = n[1] * Math.PI / 180, r[o].rtype = this.MP_GIVEN)) : (r[o].lx = n * Math.PI / 180, r[o].rx = n * Math.PI / 180, r[o].ltype = r[o].rtype = this.MP_GIVEN));
          for (o in i.curl)
            i.curl.hasOwnProperty(o) && (n = t.evaluate(i.curl[o]), parseInt(o, 10) === 0 ? (r[o].rtype = this.MP_CURL, r[o].set_right_curl(n)) : parseInt(o, 10) === s - 1 && (r[o].ltype = this.MP_CURL, r[o].set_left_curl(n)));
          for (this.make_choices(r), o = 0; o < s - 1; o++)
            a.push(r[o].x), a.push(r[o].rx), a.push(r[o + 1].lx), h.push(r[o].y), h.push(r[o].ry), h.push(r[o + 1].ly);
          return a.push(r[s - 1].x), h.push(r[s - 1].y), i.isClosed && (a.push(r[s - 1].rx), h.push(r[s - 1].ry), a.push(r[0].lx), h.push(r[0].ly), a.push(r[0].x), h.push(r[0].y)), [a, h];
        }}, e2.Metapost;
      }), define("utils/zip", ["jxg"], function(t) {
        "use strict";
        var e2 = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255], i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], r = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99], s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], o = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], n = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], a = 256;
        return t.Util = t.Util || {}, t.Util.Unzip = function(h) {
          function l() {
            return Y += 8, B < k ? h[B++] : -1;
          }
          function c() {
            I = 1;
          }
          function d() {
            var t2;
            try {
              return Y++, t2 = 1 & I, I >>= 1, I === 0 && (I = l(), t2 = 1 & I, I = I >> 1 | 128), t2;
            } catch (t3) {
              throw t3;
            }
          }
          function u(t2) {
            var i2 = 0, r2 = t2;
            try {
              for (; r2--; )
                i2 = i2 << 1 | d();
              t2 && (i2 = e2[i2] >> 8 - t2);
            } catch (t3) {
              throw t3;
            }
            return i2;
          }
          function p() {
            R = 0;
          }
          function f(t2) {
            x++, A[R++] = t2, T.push(String.fromCharCode(t2)), R === 32768 && (R = 0);
          }
          function m() {
            this.b0 = 0, this.b1 = 0, this.jump = null, this.jumppos = -1;
          }
          function g() {
            for (; ; ) {
              if (G[F] >= w)
                return -1;
              if (O[G[F]] === F)
                return G[F]++;
              G[F]++;
            }
          }
          function b() {
            var t2, e3 = U[X];
            if (F === 17)
              return -1;
            if (X++, F++, (t2 = g()) >= 0)
              e3.b0 = t2;
            else if (e3.b0 = 32768, b())
              return -1;
            if ((t2 = g()) >= 0)
              e3.b1 = t2, e3.jump = null;
            else if (e3.b1 = 32768, e3.jump = U[X], e3.jumppos = X, b())
              return -1;
            return F--, 0;
          }
          function v(t2, e3, i2, r2) {
            var s2;
            for (U = t2, X = 0, O = i2, w = e3, s2 = 0; s2 < 17; s2++)
              G[s2] = 0;
            return F = 0, b() ? -1 : 0;
          }
          function y(t2) {
            for (var e3, i2, r2 = 0, s2 = t2[r2]; ; )
              if (d()) {
                if (!(32768 & s2.b1))
                  return s2.b1;
                for (s2 = s2.jump, e3 = t2.length, i2 = 0; i2 < e3; i2++)
                  if (t2[i2] === s2) {
                    r2 = i2;
                    break;
                  }
              } else {
                if (!(32768 & s2.b0))
                  return s2.b0;
                r2++, s2 = t2[r2];
              }
          }
          function C() {
            var a2, h2, g2, b2, C2, _5, P3, E2, x2, S2, O2, w2, T2, N2, M2, L2, k2;
            do {
              if (a2 = d(), (g2 = u(2)) === 0)
                for (c(), S2 = l(), S2 |= l() << 8, w2 = l(), w2 |= l() << 8, 65535 & (S2 ^ ~w2) && t.debug("BlockLen checksum mismatch\n"); S2--; )
                  h2 = l(), f(h2);
              else if (g2 === 1)
                for (; ; )
                  if (C2 = e2[u(7)] >> 1, C2 > 23 ? (C2 = C2 << 1 | d(), C2 > 199 ? (C2 -= 128, C2 = C2 << 1 | d()) : (C2 -= 48) > 143 && (C2 += 136)) : C2 += 256, C2 < 256)
                    f(C2);
                  else {
                    if (C2 === 256)
                      break;
                    for (C2 -= 257, x2 = u(r[C2]) + i[C2], C2 = e2[u(5)] >> 3, o[C2] > 8 ? (O2 = u(8), O2 |= u(o[C2] - 8) << 8) : O2 = u(o[C2]), O2 += s[C2], C2 = 0; C2 < x2; C2++)
                      h2 = A[R - O2 & 32767], f(h2);
                  }
              else if (g2 === 2) {
                for (P3 = new Array(320), N2 = 257 + u(5), M2 = 1 + u(5), L2 = 4 + u(4), C2 = 0; C2 < 19; C2++)
                  P3[C2] = 0;
                for (C2 = 0; C2 < L2; C2++)
                  P3[n[C2]] = u(3);
                for (x2 = j.length, b2 = 0; b2 < x2; b2++)
                  j[b2] = new m();
                if (v(j, 19, P3, 0))
                  return p(), 1;
                for (T2 = N2 + M2, b2 = 0, k2 = -1; b2 < T2; )
                  if (k2++, (C2 = y(j)) < 16)
                    P3[b2++] = C2;
                  else if (C2 === 16) {
                    if (C2 = 3 + u(2), b2 + C2 > T2)
                      return p(), 1;
                    for (_5 = b2 ? P3[b2 - 1] : 0; C2--; )
                      P3[b2++] = _5;
                  } else {
                    if (C2 = C2 === 17 ? 3 + u(3) : 11 + u(7), b2 + C2 > T2)
                      return p(), 1;
                    for (; C2--; )
                      P3[b2++] = 0;
                  }
                for (x2 = D.length, b2 = 0; b2 < x2; b2++)
                  D[b2] = new m();
                if (v(D, N2, P3, 0))
                  return p(), 1;
                for (x2 = D.length, b2 = 0; b2 < x2; b2++)
                  j[b2] = new m();
                for (E2 = [], b2 = N2; b2 < P3.length; b2++)
                  E2[b2 - N2] = P3[b2];
                if (v(j, M2, E2, 0))
                  return p(), 1;
                for (; ; )
                  if ((C2 = y(D)) >= 256) {
                    if ((C2 -= 256) === 0)
                      break;
                    for (C2 -= 1, x2 = u(r[C2]) + i[C2], C2 = y(j), o[C2] > 8 ? (O2 = u(8), O2 |= u(o[C2] - 8) << 8) : O2 = u(o[C2]), O2 += s[C2]; x2--; )
                      h2 = A[R - O2 & 32767], f(h2);
                  } else
                    f(C2);
              }
            } while (!a2);
            return p(), c(), 0;
          }
          function _4() {
            var t2, e3, i2, r2, s2, o2, n3, h2, c2 = [];
            try {
              if (T = [], L = false, c2[0] = l(), c2[1] = l(), c2[0] === 120 && c2[1] === 218 && (C(), M[N] = [T.join(""), "geonext.gxt"], N++), c2[0] === 31 && c2[1] === 139 && (P2(), M[N] = [T.join(""), "file"], N++), c2[0] === 80 && c2[1] === 75) {
                if (L = true, c2[2] = l(), c2[3] = l(), c2[2] === 3 && c2[3] === 4) {
                  for (c2[0] = l(), c2[1] = l(), E = l(), E |= l() << 8, h2 = l(), h2 |= l() << 8, l(), l(), l(), l(), n3 = l(), n3 |= l() << 8, n3 |= l() << 16, n3 |= l() << 24, o2 = l(), o2 |= l() << 8, o2 |= l() << 16, o2 |= l() << 24, s2 = l(), s2 |= l() << 8, s2 |= l() << 16, s2 |= l() << 24, r2 = l(), r2 |= l() << 8, i2 = l(), i2 |= l() << 8, t2 = 0, J = []; r2--; )
                    e3 = l(), e3 === "/" | e3 === ":" ? t2 = 0 : t2 < a - 1 && (J[t2++] = String.fromCharCode(e3));
                  for (S || (S = J), t2 = 0; t2 < i2; )
                    e3 = l(), t2++;
                  if (x = 0, h2 === 8 && (C(), M[N] = new Array(2), M[N][0] = T.join(""), M[N][1] = J.join(""), N++), P2())
                    return false;
                }
                return true;
              }
            } catch (t3) {
              throw t3;
            }
            return false;
          }
          function P2() {
            var t2, e3, i2, r2, s2, o2 = [];
            if (8 & E && (o2[0] = l(), o2[1] = l(), o2[2] = l(), o2[3] = l(), o2[0] === 80 && o2[1] === 75 && o2[2] === 7 && o2[3] === 8 ? (t2 = l(), t2 |= l() << 8, t2 |= l() << 16, t2 |= l() << 24) : t2 = o2[0] | o2[1] << 8 | o2[2] << 16 | o2[3] << 24, e3 = l(), e3 |= l() << 8, e3 |= l() << 16, e3 |= l() << 24, i2 = l(), i2 |= l() << 8, i2 |= l() << 16, i2 |= l() << 24), L && _4())
              return false;
            if (o2[0] = l(), o2[0] !== 8)
              return true;
            if (E = l(), l(), l(), l(), l(), l(), l(), 4 & E)
              for (o2[0] = l(), o2[2] = l(), F = o2[0] + 256 * o2[1], r2 = 0; r2 < F; r2++)
                l();
            if (8 & E)
              for (r2 = 0, J = [], s2 = l(); s2; )
                s2 !== "7" && s2 !== ":" || (r2 = 0), r2 < a - 1 && (J[r2++] = s2), s2 = l();
            if (16 & E)
              for (s2 = l(); s2; )
                s2 = l();
            return 2 & E && (l(), l()), C(), t2 = l(), t2 |= l() << 8, t2 |= l() << 16, t2 |= l() << 24, i2 = l(), i2 |= l() << 8, i2 |= l() << 16, i2 |= l() << 24, L && _4(), false;
          }
          var E, x, S, O, w, T = [], N = 0, M = [], A = new Array(32768), R = 0, L = false, k = h.length, B = 0, I = 1, Y = 0, D = new Array(288), j = new Array(32), X = 0, U = null, F = (new Array(64), new Array(64), 0), G = new Array(17), J = [];
          G[0] = 0, t.Util.Unzip.prototype.unzipFile = function(t2) {
            var e3;
            for (this.unzip(), e3 = 0; e3 < M.length; e3++)
              if (M[e3][1] === t2)
                return M[e3][0];
            return "";
          }, t.Util.Unzip.prototype.unzip = function() {
            return _4(), M;
          };
        }, t.Util;
      }), define("utils/encoding", ["jxg"], function(t) {
        "use strict";
        var e2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 11, 6, 6, 6, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 12, 24, 36, 60, 96, 84, 12, 12, 12, 48, 72, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 12, 12, 12, 12, 12, 0, 12, 0, 12, 12, 12, 24, 12, 12, 12, 12, 12, 24, 12, 24, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12, 12, 12, 12, 12, 36, 12, 36, 12, 12, 12, 36, 12, 12, 12, 12, 12, 36, 12, 36, 12, 12, 12, 36, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12];
        return t.Util = t.Util || {}, t.Util.UTF8 = {encode: function(t2) {
          var e3, i, r = "", s = t2.length;
          if (t2 = t2.replace(/\r\n/g, "\n"), typeof unescape == "function" && typeof encodeURIComponent == "function")
            return unescape(encodeURIComponent(t2));
          for (e3 = 0; e3 < s; e3++)
            i = t2.charCodeAt(e3), i < 128 ? r += String.fromCharCode(i) : i > 127 && i < 2048 ? (r += String.fromCharCode(i >> 6 | 192), r += String.fromCharCode(63 & i | 128)) : (r += String.fromCharCode(i >> 12 | 224), r += String.fromCharCode(i >> 6 & 63 | 128), r += String.fromCharCode(63 & i | 128));
          return r;
        }, decode: function(t2) {
          var i, r, s, o = 0, n = 0, a = 0, h = [], l = t2.length, c = [];
          for (i = 0; i < l; i++)
            r = t2.charCodeAt(i), s = e2[r], n = a !== 0 ? 63 & r | n << 6 : 255 >> s & r, (a = e2[256 + a + s]) === 0 && (n > 65535 ? h.push(55232 + (n >> 10), 56320 + (1023 & n)) : h.push(n), ++o % 1e4 == 0 && (c.push(String.fromCharCode.apply(null, h)), h = []));
          return c.push(String.fromCharCode.apply(null, h)), c.join("");
        }, asciiCharCodeAt: function(t2, e3) {
          var i = t2.charCodeAt(e3);
          if (i > 255)
            switch (i) {
              case 8364:
                i = 128;
                break;
              case 8218:
                i = 130;
                break;
              case 402:
                i = 131;
                break;
              case 8222:
                i = 132;
                break;
              case 8230:
                i = 133;
                break;
              case 8224:
                i = 134;
                break;
              case 8225:
                i = 135;
                break;
              case 710:
                i = 136;
                break;
              case 8240:
                i = 137;
                break;
              case 352:
                i = 138;
                break;
              case 8249:
                i = 139;
                break;
              case 338:
                i = 140;
                break;
              case 381:
                i = 142;
                break;
              case 8216:
                i = 145;
                break;
              case 8217:
                i = 146;
                break;
              case 8220:
                i = 147;
                break;
              case 8221:
                i = 148;
                break;
              case 8226:
                i = 149;
                break;
              case 8211:
                i = 150;
                break;
              case 8212:
                i = 151;
                break;
              case 732:
                i = 152;
                break;
              case 8482:
                i = 153;
                break;
              case 353:
                i = 154;
                break;
              case 8250:
                i = 155;
                break;
              case 339:
                i = 156;
                break;
              case 382:
                i = 158;
                break;
              case 376:
                i = 159;
            }
          return i;
        }}, t.Util.UTF8;
      }), define("utils/base64", ["jxg", "utils/encoding"], function(t, e2) {
        "use strict";
        function i(t2, e3) {
          return 255 & t2.charCodeAt(e3);
        }
        function r(t2, e3) {
          return s.indexOf(t2.charAt(e3));
        }
        var s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        return t.Util = t.Util || {}, t.Util.Base64 = {encode: function(t2) {
          var r2, o, n, a, h, l = [];
          for (h = e2.encode(t2), n = h.length, a = n % 3, r2 = 0; r2 < n - a; r2 += 3)
            o = i(h, r2) << 16 | i(h, r2 + 1) << 8 | i(h, r2 + 2), l.push(s.charAt(o >> 18), s.charAt(o >> 12 & 63), s.charAt(o >> 6 & 63), s.charAt(63 & o));
          switch (a) {
            case 1:
              o = i(h, n - 1), l.push(s.charAt(o >> 2), s.charAt(o << 4 & 63), "=", "=");
              break;
            case 2:
              o = i(h, n - 2) << 8 | i(h, n - 1), l.push(s.charAt(o >> 10), s.charAt(o >> 4 & 63), s.charAt(o << 2 & 63), "=");
          }
          return l.join("");
        }, decode: function(t2, i2) {
          var s2, o, n, a, h, l, c = [], d = [];
          if (s2 = t2.replace(/[^A-Za-z0-9\+\/=]/g, ""), (n = s2.length) % 4 != 0)
            throw new Error("JSXGraph/utils/base64: Can't decode string (invalid input length).");
          for (s2.charAt(n - 1) === "=" && (a = 1, s2.charAt(n - 2) === "=" && (a = 2), n -= 4), o = 0; o < n; o += 4)
            h = r(s2, o) << 18 | r(s2, o + 1) << 12 | r(s2, o + 2) << 6 | r(s2, o + 3), d.push(h >> 16, h >> 8 & 255, 255 & h), o % 1e4 == 0 && (c.push(String.fromCharCode.apply(null, d)), d = []);
          switch (a) {
            case 1:
              h = r(s2, n) << 12 | r(s2, n + 1) << 6 | r(s2, n + 2), d.push(h >> 10, h >> 2 & 255);
              break;
            case 2:
              h = r(s2, o) << 6 | r(s2, o + 1), d.push(h >> 4);
          }
          return c.push(String.fromCharCode.apply(null, d)), l = c.join(""), i2 && (l = e2.decode(l)), l;
        }, decodeAsArray: function(t2) {
          var e3, i2 = this.decode(t2), r2 = [], s2 = i2.length;
          for (e3 = 0; e3 < s2; e3++)
            r2[e3] = i2.charCodeAt(e3);
          return r2;
        }}, t.Util.Base64;
      }), define("server/server", ["jxg", "utils/zip", "utils/base64", "utils/type"], function(t, e2, i, r) {
        "use strict";
        return t.Server = {modules: {}, runningCalls: {}, handleError: function(e3) {
          t.debug("error occured, server says: " + e3.message);
        }, callServer: function(s, o, n, a) {
          var h, l, c, d, u, p, f;
          a = a || false, d = "";
          for (f in n)
            n.hasOwnProperty(f) && (d += "&" + escape(f) + "=" + escape(n[f]));
          p = r.toJSON(n);
          do {
            u = s + Math.floor(4096 * Math.random());
          } while (r.exists(this.runningCalls[u]));
          return this.runningCalls[u] = {action: s}, r.exists(n.module) && (this.runningCalls[u].module = n.module), h = t.serverBase + "JXGServer.py", l = "action=" + escape(s) + "&id=" + u + "&dataJSON=" + escape(i.encode(p)), this.cbp = function(t2) {
            var s2, n3, a2, h2, l2, c2, d2, u2;
            if (s2 = new e2.Unzip(i.decodeAsArray(t2)).unzip(), r.isArray(s2) && s2.length > 0 && (s2 = s2[0][0]), r.exists(s2)) {
              if (n3 = window.JSON && window.JSON.parse ? window.JSON.parse(s2) : new Function("return " + s2)(), n3.type === "error")
                this.handleError(n3);
              else if (n3.type === "response") {
                for (c2 = n3.id, d2 = 0; d2 < n3.fields.length; d2++)
                  a2 = n3.fields[d2], h2 = a2.namespace + (typeof new Function("return " + a2.namespace)() == "object" ? "." : ".prototype.") + a2.name + " = " + a2.value, new Function(h2)();
                for (d2 = 0; d2 < n3.handler.length; d2++) {
                  for (a2 = n3.handler[d2], l2 = [], u2 = 0; u2 < a2.parameters.length; u2++)
                    l2[u2] = '"' + a2.parameters[u2] + '": ' + a2.parameters[u2];
                  h2 = "if(typeof JXG.Server.modules." + this.runningCalls[c2].module + ' == "undefined")JXG.Server.modules.' + this.runningCalls[c2].module + " = {};", h2 += "JXG.Server.modules." + this.runningCalls[c2].module + "." + a2.name + "_cb = " + a2.callback + ";", h2 += "JXG.Server.modules." + this.runningCalls[c2].module + "." + a2.name + " = function (" + a2.parameters.join(",") + ', __JXGSERVER_CB__, __JXGSERVER_SYNC) {if(typeof __JXGSERVER_CB__ == "undefined") __JXGSERVER_CB__ = JXG.Server.modules.' + this.runningCalls[c2].module + "." + a2.name + "_cb;var __JXGSERVER_PAR__ = {" + l2.join(",") + ', "module": "' + this.runningCalls[c2].module + '", "handler": "' + a2.name + '" };JXG.Server.callServer("exec", __JXGSERVER_CB__, __JXGSERVER_PAR__, __JXGSERVER_SYNC);};', new Function(h2)();
                }
                delete this.runningCalls[c2], o(n3.data);
              }
            }
          }, this.cb = t.bind(this.cbp, this), window.XMLHttpRequest ? (c = new XMLHttpRequest(), c.overrideMimeType("text/plain; charset=iso-8859-1")) : c = new ActiveXObject("Microsoft.XMLHTTP"), !(!c || (c.open("POST", h, !a), c.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), a || (c.onreadystatechange = function(t2) {
            return function() {
              return c.readyState === 4 && c.status === 200 && (t2(c.responseText), true);
            };
          }(this.cb)), c.send(l), !a)) && (this.cb(c.responseText), true);
        }, loadModule_cb: function(e3) {
          var i2;
          for (i2 = 0; i2 < e3.length; i2++)
            t.debug(e3[i2].name + ": " + e3[i2].value);
        }, loadModule: function(e3) {
          return t.Server.callServer("load", t.Server.loadModule_cb, {module: e3}, true);
        }}, t.Server.load = t.Server.loadModule, t.Server;
      }), define("math/symbolic", ["base/constants", "base/coords", "math/math", "math/geometry", "server/server", "utils/type"], function(t, e2, i, r, s, o) {
        "use strict";
        return i.Symbolic = {generateSymbolicCoordinatesPartial: function(t2, e3, i2, r2) {
          var s2, n, a, h = e3.ancestors, l = 0, c = function(t3) {
            return r2 === "underscore" ? i2 + "_{" + t3 + "}" : r2 === "brace" ? i2 + "[" + t3 + "]" : i2 + t3;
          };
          t2.listOfFreePoints = [], t2.listOfDependantPoints = [];
          for (n in h)
            if (h.hasOwnProperty(n) && (s2 = 0, o.isPoint(h[n]))) {
              for (a in h[n].ancestors)
                h[n].ancestors.hasOwnProperty(a) && s2++;
              s2 === 0 ? (h[n].symbolic.x = h[n].coords.usrCoords[1], h[n].symbolic.y = h[n].coords.usrCoords[2], t2.listOfFreePoints.push(h[n])) : (l += 1, h[n].symbolic.x = c(l), l += 1, h[n].symbolic.y = c(l), t2.listOfDependantPoints.push(h[n]));
            }
          return o.isPoint(e3) && (e3.symbolic.x = "x", e3.symbolic.y = "y"), l;
        }, clearSymbolicCoordinates: function(t2) {
          var e3 = function(t3) {
            var e4, i2 = t3 && t3.length || 0;
            for (e4 = 0; e4 < i2; e4++)
              o.isPoint(t3[e4]) && (t3[e4].symbolic.x = "", t3[e4].symbolic.y = "");
          };
          e3(t2.listOfFreePoints), e3(t2.listOfDependantPoints), delete t2.listOfFreePoints, delete t2.listOfDependantPoints;
        }, generatePolynomials: function(t2, e3, i2) {
          var r2, s2, n, a, h = e3.ancestors, l = [], c = [];
          i2 && this.generateSymbolicCoordinatesPartial(t2, e3, "u", "brace"), h[e3.id] = e3;
          for (r2 in h)
            if (h.hasOwnProperty(r2) && (a = 0, l = [], o.isPoint(h[r2]))) {
              for (s2 in h[r2].ancestors)
                h[r2].ancestors.hasOwnProperty(s2) && a++;
              if (a > 0)
                for (l = h[r2].generatePolynomial(), n = 0; n < l.length; n++)
                  c.push(l[n]);
            }
          return i2 && this.clearSymbolicCoordinates(t2), c;
        }, geometricLocusByGroebnerBase: function(n, a) {
          var h, l, c, d, u, p, f, m, g, b, v, y, C, _4 = n.options.locus, P2 = {}, E = this.generateSymbolicCoordinatesPartial(n, a, "u", "brace"), x = new e2(t.COORDS_BY_USR, [0, 0], n), S = new e2(t.COORDS_BY_USR, [n.canvasWidth, n.canvasHeight], n), O = 1, w = 0, T = 0, N = 0;
          if (s.modules.geoloci === void 0 && s.loadModule("geoloci"), s.modules.geoloci === void 0)
            throw new Error("JSXGraph: Unable to load JXG.Server module 'geoloci.py'.");
          if (f = x.usrCoords[1], m = S.usrCoords[1], g = S.usrCoords[2], b = x.usrCoords[2], _4.translateToOrigin && n.listOfFreePoints.length > 0) {
            for (d = _4.toOrigin !== void 0 && _4.toOrigin !== null && o.isInArray(n.listOfFreePoints, _4.toOrigin.id) ? _4.toOrigin : n.listOfFreePoints[0], w = d.symbolic.x, T = d.symbolic.y, p = 0; p < n.listOfFreePoints.length; p++)
              n.listOfFreePoints[p].symbolic.x -= w, n.listOfFreePoints[p].symbolic.y -= T;
            if (f -= w, m -= w, g -= T, b -= T, _4.translateTo10 && n.listOfFreePoints.length > 1) {
              for (u = _4.to10 !== void 0 && _4.to10 !== null && _4.to10.id !== _4.toOrigin.id && o.isInArray(n.listOfFreePoints, _4.to10.id) ? _4.to10 : n.listOfFreePoints[0].id === d.id ? n.listOfFreePoints[1] : n.listOfFreePoints[0], N = r.rad([1, 0], [0, 0], [u.symbolic.x, u.symbolic.y]), v = Math.cos(-N), y = Math.sin(-N), p = 0; p < n.listOfFreePoints.length; p++)
                C = n.listOfFreePoints[p].symbolic.x, n.listOfFreePoints[p].symbolic.x = v * n.listOfFreePoints[p].symbolic.x - y * n.listOfFreePoints[p].symbolic.y, n.listOfFreePoints[p].symbolic.y = y * C + v * n.listOfFreePoints[p].symbolic.y;
              if (u.symbolic.y = 0, C = f, f = v * f - y * g, g = y * C + v * g, C = m, m = v * m - y * b, b = y * C + v * b, _4.stretch && Math.abs(u.symbolic.x) > i.eps) {
                for (O = u.symbolic.x, p = 0; p < n.listOfFreePoints.length; p++)
                  n.listOfFreePoints[p].symbolic.x /= O, n.listOfFreePoints[p].symbolic.y /= O;
                for (p = 0; p < n.objectsList.length; p++)
                  n.objectsList[p].elementClass === t.OBJECT_CLASS_CIRCLE && n.objectsList[p].method === "pointRadius" && (P2[p] = n.objectsList[p].radius, n.objectsList[p].radius /= O);
                f /= O, m /= O, g /= O, b /= O, u.symbolic.x = 1;
              }
            }
            for (p = 0; p < n.listOfFreePoints.length; p++)
              C = n.listOfFreePoints[p].symbolic.x, Math.abs(C) < i.eps && (n.listOfFreePoints[p].symbolic.x = 0), Math.abs(C - Math.round(C)) < i.eps && (n.listOfFreePoints[p].symbolic.x = Math.round(C)), C = n.listOfFreePoints[p].symbolic.y, Math.abs(C) < i.eps && (n.listOfFreePoints[p].symbolic.y = 0), Math.abs(C - Math.round(C)) < i.eps && (n.listOfFreePoints[p].symbolic.y = Math.round(C));
          }
          h = this.generatePolynomials(n, a), l = h.join(","), this.cbp = function(t2) {
            c = t2;
          }, this.cb = o.bind(this.cbp, this), s.modules.geoloci.lociCoCoA(f, m, g, b, E, l, O, N, w, T, this.cb, true), this.clearSymbolicCoordinates(n);
          for (p in P2)
            P2.hasOwnProperty(p) && (n.objects[p].radius = P2[p]);
          return c;
        }}, i.Symbolic;
      }), define("math/clip", ["jxg", "base/constants", "base/coords", "math/math", "math/geometry", "utils/type"], function(t, e2, i, r, s, o) {
        "use strict";
        return r.Clip = {_isSeparator: function(t2) {
          return isNaN(t2.coords.usrCoords[1]) && isNaN(t2.coords.usrCoords[2]);
        }, makeDoublyLinkedList: function(t2) {
          var e3, i2 = null, r2 = [], s2 = t2.length;
          if (s2 > 0)
            for (e3 = 0; e3 < s2; e3++)
              this._isSeparator(t2[e3]) ? (t2[e3]._next = t2[(e3 + 1) % s2], t2[e3]._prev = t2[(s2 + e3 - 1) % s2]) : (i2 === null && (i2 = e3, r2.push(i2)), this._isSeparator(t2[(e3 + 1) % s2]) || e3 == s2 - 1 ? (t2[e3]._next = t2[i2], t2[i2]._prev = t2[e3], t2[e3]._end = true, i2 = null) : (t2[e3]._next = t2[(e3 + 1) % s2], t2[i2]._prev = t2[e3]), this._isSeparator(t2[(s2 + e3 - 1) % s2]) || (t2[e3]._prev = t2[(s2 + e3 - 1) % s2]));
          return r2;
        }, det: function(t2, e3, i2) {
          return (t2[1] - i2[1]) * (e3[2] - i2[2]) - (e3[1] - i2[1]) * (t2[2] - i2[2]);
        }, windingNumber: function(t2, e3) {
          var i2, s2, o2, n, a, h = 0, l = e3.length, c = t2[1], d = t2[2];
          if (l === 0)
            return 0;
          if (isNaN(c) || isNaN(d))
            return 1;
          if (e3[0].coords.usrCoords[1] === c && e3[0].coords.usrCoords[2] === d)
            return 1;
          for (a = 0; a < l; a++)
            if (i2 = e3[a].coords.usrCoords, s2 = e3[(a + 1) % l].coords.usrCoords, !(i2[0] === 0 || s2[0] === 0 || isNaN(i2[1]) || isNaN(s2[1]) || isNaN(i2[2]) || isNaN(s2[2]))) {
              if (s2[2] === d) {
                if (s2[1] === c)
                  return 1;
                if (i2[2] === d && s2[1] > c == i2[1] < c)
                  return 0;
              }
              if (i2[2] < d != s2[2] < d)
                if (n = 2 * (s2[2] > i2[2] ? 1 : 0) - 1, i2[1] >= c)
                  if (s2[1] > c)
                    h += n;
                  else {
                    if ((o2 = this.det(i2, s2, t2)) === 0)
                      return 0;
                    o2 > 0 == s2[2] > i2[2] && (h += n);
                  }
                else
                  s2[1] > c && (o2 = this.det(i2, s2, t2)) > 0 + r.eps == s2[2] > i2[2] && (h += n);
            }
          return h;
        }, Vertex: function(t2, i2, r2, s2, o2, n) {
          this.pos = i2, this.intersection = true, this.coords = t2, this.elementClass = e2.OBJECT_CLASS_POINT, this.data = {alpha: r2, path: s2, pathname: o2, done: false, type: n, revtype: n, link: null, idx: 0}, this.neighbour = null, this.entry_exit = false;
        }, _addToList: function(t2, i2, s2) {
          var o2 = t2.length, n = r.eps * r.eps;
          o2 > 0 && Math.abs(t2[o2 - 1].coords.usrCoords[0] - i2.usrCoords[0]) < n && Math.abs(t2[o2 - 1].coords.usrCoords[1] - i2.usrCoords[1]) < n && Math.abs(t2[o2 - 1].coords.usrCoords[2] - i2.usrCoords[2]) < n || t2.push({pos: s2, intersection: false, coords: i2, elementClass: e2.OBJECT_CLASS_POINT});
        }, sortIntersections: function(t2) {
          var e3, i2, r2, s2, o2, n, a = [], h = t2.length;
          for (e3 = 0; e3 < h; e3++)
            if (t2[e3].sort(function(t3, e4) {
              return t3.data.alpha > e4.data.alpha ? 1 : -1;
            }), t2[e3].length > 0) {
              for (o2 = t2[e3].length - 1, r2 = t2[e3][0], s2 = r2.data.path[r2.pos], n = s2._next, e3 === h - 1 && (s2._end = false), r2.data.alpha === 0 && r2.data.type === "T" ? (s2.intersection = true, s2.data = r2.data, s2.neighbour = r2.neighbour, s2.neighbour.neighbour = s2, s2.entry_exit = false, t2[e3][0] = s2) : (r2._prev = s2, r2._prev._next = r2), i2 = 1; i2 <= o2; i2++)
                r2 = t2[e3][i2], r2._prev = t2[e3][i2 - 1], r2._prev._next = r2;
              r2 = t2[e3][o2], r2._next = n, r2._next._prev = r2, e3 === h - 1 && (r2._end = true), a = a.concat(t2[e3]);
            }
          return a;
        }, _inbetween: function(t2, e3, i2) {
          var s2, o2 = r.eps * r.eps, n = i2[1] - e3[1], a = i2[2] - e3[2], h = t2[1] - e3[1], l = t2[2] - e3[2];
          return n === 0 && a === 0 && h === 0 && l === 0 || (s2 = Math.abs(h) < o2 && Math.abs(n) < o2 ? l / a : h / n, Math.abs(s2) < o2 && (s2 = 0), s2);
        }, _print_array: function(t2) {
          var e3, i2;
          for (e3 = 0; e3 < t2.length; e3++)
            try {
              i2 = "", t2[e3]._end && (i2 = " end"), console.log(e3, t2[e3].coords.usrCoords, "prev", t2[e3]._prev.coords.usrCoords, "next", t2[e3]._next.coords.usrCoords + i2);
            } catch (i3) {
              console.log(e3, t2[e3].coords.usrCoords);
            }
        }, _print_list: function(t2) {
          for (var e3, i2 = 0; i2 < 100 && (e3 = t2.data ? t2.data.alpha : "-", console.log("	", t2.coords.usrCoords, "\n		is:", t2.intersection, "end:", t2._end, e3, "\n		-:", t2._prev.coords.usrCoords, "\n		+:", t2._next.coords.usrCoords, "\n		n:", t2.intersection ? t2.neighbour.coords.usrCoords : "-"), !t2._end); )
            t2 = t2._next, i2++;
        }, _noOverlap: function(t2, e3, i2, s2) {
          var o2, n, a, h, l, c = r.eps * r.eps, d = false;
          for (o2 = 0; o2 < 3; o2++)
            if (n = Math.min(t2[o2], e3[o2]), a = Math.max(t2[o2], e3[o2]), h = Math.min(i2[o2], s2[o2]), l = Math.max(i2[o2], s2[o2]), a < h - c || n > l + c) {
              d = true;
              break;
            }
          return d;
        }, findIntersections: function(t2, o2, n) {
          var a, h, l, c, d, u, p, f, m, g, b, v, y, C = [], _4 = r.eps, P2 = t2.length, E = o2.length, x = [], S = [], O = [], w = [], T = false, N = false;
          for (h = 0; h < E; h++)
            w.push([]);
          for (a = 0; a < P2; a++)
            if (O.push([]), this._isSeparator(t2[a]) || this._isSeparator(t2[(a + 1) % P2]))
              T = true;
            else {
              if (T && a === P2 - 1)
                break;
              for (c = t2[a].coords.usrCoords, d = t2[(a + 1) % P2].coords.usrCoords, h = 0; h < E; h++)
                if (this._isSeparator(o2[h]) || this._isSeparator(o2[(h + 1) % E]))
                  N = true;
                else {
                  if (N && h === E - 1)
                    break;
                  if (u = o2[h].coords.usrCoords, p = o2[(h + 1) % E].coords.usrCoords, !this._noOverlap(c, d, u, p) && (C = s.meetSegmentSegment(c, d, u, p), f = s.distance(c, d, 3), m = s.distance(u, p, 3), C[1] * f > -_4 && C[1] < 1 - _4 / f && C[2] * m > -_4 && C[2] < 1 - _4 / m || C[1] === 1 / 0 && C[2] === 1 / 0 && r.norm(C[0], 3) < _4)) {
                    if (l = new i(e2.COORDS_BY_USER, C[0], n), b = "X", Math.abs(C[1]) * f < _4 || Math.abs(C[2]) * m < _4)
                      b = "T", Math.abs(C[1]) * f < _4 && (C[1] = 0), Math.abs(C[2]) * m < _4 && (C[2] = 0), l = C[1] === 0 ? new i(e2.COORDS_BY_USER, c, n) : new i(e2.COORDS_BY_USER, u, n);
                    else if (C[1] === 1 / 0 && C[2] === 1 / 0 && r.norm(C[0], 3) < _4) {
                      g = this._inbetween(c, u, p), g >= 0 && g < 1 && (b = "T", l = new i(e2.COORDS_BY_USER, c, n), C[1] = 0, C[2] = g, v = new this.Vertex(l, a, C[1], t2, "S", b), y = new this.Vertex(l, h, C[2], o2, "C", b), v.neighbour = y, y.neighbour = v, O[a].push(v), w[h].push(y)), g = this._inbetween(u, c, d), s.distance(c, u, 3) > _4 && g >= 0 && g < 1 && (b = "T", l = new i(e2.COORDS_BY_USER, u, n), C[1] = g, C[2] = 0, v = new this.Vertex(l, a, C[1], t2, "S", b), y = new this.Vertex(l, h, C[2], o2, "C", b), v.neighbour = y, y.neighbour = v, O[a].push(v), w[h].push(y));
                      continue;
                    }
                    v = new this.Vertex(l, a, C[1], t2, "S", b), y = new this.Vertex(l, h, C[2], o2, "C", b), v.neighbour = y, y.neighbour = v, O[a].push(v), w[h].push(y);
                  }
                }
            }
          for (x = this.sortIntersections(O), a = 0; a < x.length; a++)
            x[a].data.idx = a, x[a].neighbour.data.idx = a;
          return S = this.sortIntersections(w), [x, S];
        }, _getPosition: function(t2, e3, i2, r2) {
          var s2 = this.det(t2, e3, i2), o2 = this.det(t2, i2, r2);
          return this.det(e3, i2, r2) >= 0 ? s2 > 0 && o2 > 0 ? "left" : "right" : s2 < 0 && o2 < 0 ? "right" : "left";
        }, _classifyDegenerateIntersections: function(t2) {
          var e3, i2, n, a, h, l, c;
          for (c = 0, t2._start = 0; ; ) {
            if (t2.intersection && t2.data.type === "T" && (e3 = t2._next.coords.usrCoords, i2 = t2._prev.coords.usrCoords, s.distance(t2.coords.usrCoords, e3, 3) < r.eps && (t2._next = t2._next._next, e3 = t2._next.coords.usrCoords), s.distance(t2.coords.usrCoords, i2, 3) < r.eps && (t2._prev = t2._prev._prev, i2 = t2._prev.coords.usrCoords), h = t2.neighbour, a = t2.neighbour._prev.coords.usrCoords, n = t2.neighbour._next.coords.usrCoords, t2._next.intersection && t2._next.neighbour === h._next ? t2._prev.intersection && t2._prev.neighbour === h._prev ? t2.delayedStatus = ["on", "on"] : (l = this._getPosition(a, i2, t2.coords.usrCoords, e3), t2.delayedStatus = l === "right" ? ["left", "on"] : ["right", "on"]) : t2._next.intersection && t2._next.neighbour === h._prev && (t2._prev.intersection && t2._prev.neighbour === h._next ? t2.delayedStatus = ["on", "on"] : (l = this._getPosition(n, i2, t2.coords.usrCoords, e3), t2.delayedStatus = l === "right" ? ["left", "on"] : ["right", "on"])), t2._prev.intersection && t2._prev.neighbour === h._prev ? t2._next.intersection && t2._next.neighbour === h._next || (l = this._getPosition(n, i2, t2.coords.usrCoords, e3), t2.delayedStatus = l === "right" ? ["on", "left"] : ["on", "right"]) : t2._prev.intersection && t2._prev.neighbour === h._next && (t2._next.intersection && t2._next.neighbour === h._prev || (l = this._getPosition(a, i2, t2.coords.usrCoords, e3), t2.delayedStatus = l === "right" ? ["on", "left"] : ["on", "right"])), t2._next.intersection && (t2._next.neighbour === h._prev || t2._next.neighbour === h._next) || t2._prev.intersection && (t2._prev.neighbour === h._prev || t2._prev.neighbour === h._next) || (l = this._getPosition(a, i2, t2.coords.usrCoords, e3), l !== this._getPosition(n, i2, t2.coords.usrCoords, e3) ? (t2.data.type = "X", t2.data.revtype = "X") : (t2.data.type = "B", t2.data.revtype = "B"))), o.exists(t2._start) && t2._start++, t2._start > 3 || t2._end || c > 1e3) {
              c > 1e3 && console.log("Clipping: _classifyDegenerateIntersections exit"), o.exists(t2._start) && delete t2._start;
              break;
            }
            t2.intersection && c++, t2 = t2._next;
          }
        }, _handleIntersectionChains: function(t2) {
          for (var e3, i2 = 0, r2 = "Null", s2 = false, o2 = false; ; ) {
            if (t2.intersection === true && (t2.data.type === "T" && (t2.delayedStatus[0] !== "on" && t2.delayedStatus[1] === "on" ? (s2 = true, e3 = t2, r2 = t2.delayedStatus[0]) : t2.delayedStatus[0] === "on" && t2.delayedStatus[1] === "on" ? (t2.data.type = "B", t2.data.revtype = "B") : t2.delayedStatus[0] === "on" && t2.delayedStatus[1] !== "on" && s2 && (s2 = false, r2 === t2.delayedStatus[1] ? (t2.data.type = "B", t2.data.revtype = "B", e3.data.type = "B", e3.data.revtype = "B") : (t2.data.type = "X", t2.data.revtype = "B", e3.data.type = "B", e3.data.revtype = "X"), e3.data.link = t2, t2.data.link = e3)), i2++), t2._end && (o2 = true), o2 && !s2)
              break;
            if (i2 > 1e3) {
              console.log("Clipping: Intersection chain - exit");
              break;
            }
            t2 = t2._next;
          }
        }, _handleFullyDegenerateCase: function(t2, s2, o2) {
          var n, a, h, l, c, d, u, p, f, m, g, b, v, y, C = [t2, s2];
          for (h = 0; h < 2; h++) {
            for (n = C[h], g = n.length, f = 0, y = true; f < g; f++)
              if (!n[f].intersection) {
                y = false;
                break;
              }
            if (y)
              for (a = C[(h + 1) % 2], b = a.length, f = 0; f < g; f++) {
                for (d = n[f].coords.usrCoords, u = n[(f + 1) % g].coords.usrCoords, l = [0.5 * (d[0] + u[0]), 0.5 * (d[1] + u[1]), 0.5 * (d[2] + u[2])], m = 0, v = false; m < b; m++)
                  if (Math.abs(this.det(a[m].coords.usrCoords, a[(m + 1) % b].coords.usrCoords, l)) < r.eps) {
                    v = true;
                    break;
                  }
                if (!v) {
                  c = new i(e2.COORDS_BY_USER, l, o2), p = {pos: f, intersection: false, coords: c, elementClass: e2.OBJECT_CLASS_POINT}, n[f]._next = p, p._prev = n[f], n[(f + 1) % g]._prev = p, p._next = n[(f + 1) % g], n[f]._end && (n[f]._end = false, p._end = true);
                  break;
                }
              }
          }
        }, _getStatus: function(t2, e3) {
          for (var i2; t2.intersection && !t2._end; )
            t2 = t2._next;
          return i2 = this.windingNumber(t2.coords.usrCoords, e3) % 2 == 0 ? "entry" : "exit", [t2, i2];
        }, markEntryExit: function(t2, e3, i2) {
          var r2, s2, n, a, h, l, c;
          for (l = i2.length, h = 0; h < l; h++)
            for (c = i2[h], this._classifyDegenerateIntersections(t2[c]), this._handleIntersectionChains(t2[c]), a = this._getStatus(t2[c], e3), s2 = a[0], r2 = a[1], s2._starter = true, n = 0; ; ) {
              if (s2.intersection === true && s2.data.type === "X" && (s2.entry_exit = r2, r2 = r2 === "entry" ? "exit" : "entry", s2.data.link === null || s2.data.link.entry_exit || (s2.data.link.entry_exit = s2.entry_exit)), s2.intersection === true && s2.data.type !== "X" && (s2.entry_exit || s2.data.link === null || (s2.entry_exit = s2.data.link.entry_exit)), s2 = s2._next, o.exists(s2._starter) || n > 1e4)
                break;
              n++;
            }
        }, _isCrossing: function(t2, e3) {
          return e3 = e3 || false, t2.intersection && (e3 ? t2.data.revtype : t2.data.type) === "X";
        }, tracing: function(t2, e3, i2) {
          var r2, s2, o2, n, a = 0, h = 0, l = [];
          for (n = i2 === "difference" || i2 === "union"; h < e3.length && a < 1e4; )
            if (s2 = e3[h], !s2.data.done && this._isCrossing(s2, n)) {
              l.length > 0 && l.push([NaN, NaN]), o2 = s2.data.idx, r2 = t2;
              do {
                if (l.push(s2), s2.data.done = true, i2 === "intersection" && s2.entry_exit === "entry" || i2 === "union" && s2.entry_exit === "exit" || i2 === "difference" && r2 === t2 == (s2.entry_exit === "exit")) {
                  s2 = s2._next;
                  do {
                    a++, this._isCrossing(s2, n) || (isNaN(s2.coords.usrCoords[1]) || isNaN(s2.coords.usrCoords[2]) || l.push(s2), s2 = s2._next);
                  } while (!this._isCrossing(s2, n) && a < 1e4);
                } else {
                  s2 = s2._prev;
                  do {
                    a++, this._isCrossing(s2, true) || (isNaN(s2.coords.usrCoords[1]) || isNaN(s2.coords.usrCoords[2]) || l.push(s2), s2 = s2._prev);
                  } while (!this._isCrossing(s2, true) && a < 1e4);
                }
                if (s2.data.done = true, !s2.neighbour)
                  return console.log("BREAK!!!!!!!!!!!!!!!!!", a), [[0], [0]];
                if (s2 = s2.neighbour, s2.data.done) {
                  l.push(s2);
                  break;
                }
                r2 = s2.data.path;
              } while ((s2.data.pathname !== "S" || s2.data.idx !== o2) && a < 1e4);
              h++;
            } else
              h++;
          return this._getCoordsArrays(l, false);
        }, isEmptyCase: function(t2, e3, i2, r2, s2) {
          return i2 === "intersection" && (t2.length === 0 || e3.length === 0) || (i2 === "union" && (t2.length === 0 || e3.length === 0) || i2 === "difference" && (t2.length === 0 || e3.length === 0));
        }, _getCoordsArrays: function(t2, e3) {
          var i2, r2 = [], s2 = [], o2 = t2.length;
          for (i2 = 0; i2 < o2; i2++)
            t2[i2].coords ? (r2.push(t2[i2].coords.usrCoords[1]), s2.push(t2[i2].coords.usrCoords[2])) : (r2.push(t2[i2][0]), s2.push(t2[i2][1]));
          return e3 && o2 > 0 && (t2[0].coords ? (r2.push(t2[0].coords.usrCoords[1]), s2.push(t2[0].coords.usrCoords[2])) : (r2.push(t2[0][0]), s2.push(t2[0][1]))), [r2, s2];
        }, handleEmptyIntersection: function(t2, e3, i2) {
          var r2, o2, n = false, a = [];
          if (t2.length === 0)
            return a = i2 === "union" ? e3 : [], this._getCoordsArrays(a, true);
          if (e3.length === 0)
            return a = i2 === "intersection" ? [] : t2, this._getCoordsArrays(a, true);
          if (i2 === "union")
            return a = a.concat(t2), a.push(t2[0]), a.push([NaN, NaN]), a = a.concat(e3), a.push(e3[0]), this._getCoordsArrays(a, false);
          if (t2.length > 0)
            for (r2 = t2[0]; r2.intersection && (r2 = r2._next, !r2._end); )
              ;
          if (e3.length > 0)
            for (o2 = e3[0]; o2.intersection && (o2 = o2._next, !o2._end); )
              ;
          return this.windingNumber(r2.coords.usrCoords, e3) === 0 ? this.windingNumber(o2.coords.usrCoords, t2) !== 0 ? (i2 === "difference" && (a = a.concat(t2), a.push(t2[0]), s.signedPolygon(t2) * s.signedPolygon(e3) > 0 && a.reverse(), a.push([NaN, NaN])), a = a.concat(e3), a.push(e3[0]), n = false) : i2 === "difference" && (a = a.concat(t2), n = true) : i2 === "intersection" && (a = a.concat(t2), n = true), this._getCoordsArrays(a, n);
        }, _countCrossingIntersections: function(t2) {
          var e3, i2 = t2.length, r2 = 0;
          for (e3 = 0; e3 < i2; e3++)
            t2[e3].data.type === "X" && r2++;
          return r2;
        }, _getPath: function(t2, r2) {
          var n, a, h, l, c, d, u, p = [];
          if (t2.elementClass !== e2.OBJECT_CLASS_CURVE || t2.type !== e2.OBJECT_TYPE_ARC && t2.type !== e2.OBJECT_TYPE_SECTOR) {
            if (t2.elementClass === e2.OBJECT_CLASS_CURVE && o.exists(t2.points))
              for (a = t2.numberPoints, n = 0; n < a; n++)
                this._addToList(p, t2.points[n], n);
            else if (t2.type === e2.OBJECT_TYPE_POLYGON)
              for (n = 0; n < t2.vertices.length; n++)
                this._addToList(p, t2.vertices[n].coords, n);
            else if (t2.elementClass === e2.OBJECT_CLASS_CIRCLE)
              for (u = 359, h = t2.Radius(), l = 2 * Math.PI / u, n = 0; n <= u; n++)
                this._addToList(p, new i(e2.COORDS_BY_USER, [t2.center.coords.usrCoords[0], t2.center.coords.usrCoords[1] + Math.cos(n * l) * h, t2.center.coords.usrCoords[2] + Math.sin(n * l) * h], r2), n);
            else if (o.isArray(t2))
              for (a = t2.length, n = 0; n < a; n++)
                o.exists(t2[n].coords) ? this._addToList(p, t2[n].coords, n) : o.isArray(t2[n]) ? this._addToList(p, new i(e2.COORDS_BY_USER, t2[n], r2), n) : o.exists(t2[n].usrCoords) && this._addToList(p, t2[n], n);
          } else {
            for (c = s.rad(t2.radiuspoint, t2.center, t2.anglepoint), u = Math.floor(180 * c / Math.PI), h = t2.Radius(), l = c / u, d = Math.atan2(t2.radiuspoint.coords.usrCoords[2] - t2.center.coords.usrCoords[2], t2.radiuspoint.coords.usrCoords[1] - t2.center.coords.usrCoords[1]), t2.type === e2.OBJECT_TYPE_SECTOR && this._addToList(p, t2.center.coords, 0), n = 0; n <= u; n++)
              this._addToList(p, new i(e2.COORDS_BY_USER, [t2.center.coords.usrCoords[0], t2.center.coords.usrCoords[1] + Math.cos(n * l + d) * h, t2.center.coords.usrCoords[2] + Math.sin(n * l + d) * h], r2), n + 1);
            t2.type === e2.OBJECT_TYPE_SECTOR && this._addToList(p, t2.center.coords, u + 2);
          }
          return p;
        }, greinerHormann: function(t2, e3, i2, o2) {
          var n, a, h, l = [], c = [], d = [], u = [], p = [], f = [];
          return l = this._getPath(t2, o2), n = l.length, n > 0 && s.distance(l[0].coords.usrCoords, l[n - 1].coords.usrCoords, 3) < r.eps && l.pop(), c = this._getPath(e3, o2), n = c.length, n > 0 && s.distance(c[0].coords.usrCoords, c[n - 1].coords.usrCoords, 3) < r.eps * r.eps && c.pop(), this.isEmptyCase(l, c, i2, p, f) ? [p, f] : (a = this.makeDoublyLinkedList(l), h = this.makeDoublyLinkedList(c), u = this.findIntersections(l, c, o2), d = u[0], this._handleFullyDegenerateCase(l, c, o2), this.markEntryExit(l, c, a), this.markEntryExit(c, l, h), this._countCrossingIntersections(d) === 0 ? this.handleEmptyIntersection(l, c, i2) : this.tracing(l, d, i2));
        }, union: function(t2, e3, i2) {
          return this.greinerHormann(t2, e3, "union", i2);
        }, intersection: function(t2, e3, i2) {
          return this.greinerHormann(t2, e3, "intersection", i2);
        }, difference: function(t2, e3, i2) {
          return this.greinerHormann(t2, e3, "difference", i2);
        }}, t.extend(r.Clip, {}), r.Clip;
      }), define("math/poly", ["jxg", "math/math", "utils/type"], function(t, e2, i) {
        "use strict";
        return e2.Poly = {}, e2.Poly.Ring = function(t2) {
          this.vars = t2;
        }, t.extend(e2.Poly.Ring.prototype, {}), e2.Poly.Monomial = function(t2, e3, r) {
          var s;
          if (!i.exists(t2))
            throw new Error("JSXGraph error: In JXG.Math.Poly.monomial missing parameter 'ring'.");
          for (i.isArray(r) || (r = []), r = r.slice(0, t2.vars.length), s = r.length; s < t2.vars.length; s++)
            r.push(0);
          this.ring = t2, this.coefficient = e3 || 0, this.exponents = i.deepCopy(r);
        }, t.extend(e2.Poly.Monomial.prototype, {copy: function() {
          return new e2.Poly.Monomial(this.ring, this.coefficient, this.exponents);
        }, print: function() {
          var t2, e3 = [];
          for (t2 = 0; t2 < this.ring.vars.length; t2++)
            e3.push(this.ring.vars[t2] + "^" + this.exponents[t2]);
          return this.coefficient + "*" + e3.join("*");
        }}), e2.Poly.Polynomial = function(t2, e3) {
          var r;
          if (!i.exists(t2))
            throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial missing parameter 'ring'.");
          r = i.exists(e3) && i.isString(e3) ? void 0 : [], this.ring = t2, this.monomials = r;
        }, t.extend(e2.Poly.Polynomial.prototype, {findSignature: function(t2) {
          var e3;
          for (e3 = 0; e3 < this.monomials.length; e3++)
            if (i.cmpArrays(this.monomials[e3].exponents, t2))
              return e3;
          return -1;
        }, addSubMonomial: function(t2, e3) {
          var i2;
          i2 = this.findSignature(t2.exponents), i2 > -1 ? this.monomials[i2].coefficient += e3 * t2.coefficient : (t2.coefficient *= e3, this.monomials.push(t2));
        }, add: function(t2) {
          var e3;
          if (!i.exists(t2) || t2.ring !== this.ring)
            throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial.add either summand is undefined or rings don't match.");
          if (i.isArray(t2.exponents))
            this.addSubMonomial(t2, 1);
          else
            for (e3 = 0; e3 < t2.monomials.length; e3++)
              this.addSubMonomial(t2.monomials[e3], 1);
        }, sub: function(t2) {
          var e3;
          if (!i.exists(t2) || t2.ring !== this.ring)
            throw new Error("JSXGraph error: In JXG.Math.Poly.polynomial.sub either summand is undefined or rings don't match.");
          if (i.isArray(t2.exponents))
            this.addSubMonomial(t2, -1);
          else
            for (e3 = 0; e3 < t2.monomials.length; e3++)
              this.addSubMonomial(t2.monomials[e3], -1);
        }, copy: function() {
          var t2, i2;
          for (i2 = new e2.Poly.Polynomial(this.ring), t2 = 0; t2 < this.monomials.length; t2++)
            i2.monomials.push(this.monomials[t2].copy());
          return i2;
        }, print: function() {
          var t2, e3 = [];
          for (t2 = 0; t2 < this.monomials.length; t2++)
            e3.push("(" + this.monomials[t2].print() + ")");
          return e3.join("+");
        }}), e2.Poly;
      }), define("math/complex", ["jxg", "utils/type"], function(t, e2) {
        "use strict";
        return t.Complex = function(t2, e3) {
          this.isComplex = true, t2 && t2.isComplex && (e3 = t2.imaginary, t2 = t2.real), this.real = t2 || 0, this.imaginary = e3 || 0, this.absval = 0, this.angle = 0;
        }, t.extend(t.Complex.prototype, {toString: function() {
          return this.real + " + " + this.imaginary + "i";
        }, add: function(t2) {
          return e2.isNumber(t2) ? this.real += t2 : (this.real += t2.real, this.imaginary += t2.imaginary), this;
        }, sub: function(t2) {
          return e2.isNumber(t2) ? this.real -= t2 : (this.real -= t2.real, this.imaginary -= t2.imaginary), this;
        }, mult: function(t2) {
          var i, r;
          return e2.isNumber(t2) ? (this.real *= t2, this.imaginary *= t2) : (i = this.real, r = this.imaginary, this.real = i * t2.real - r * t2.imaginary, this.imaginary = i * t2.imaginary + r * t2.real), this;
        }, div: function(t2) {
          var i, r, s;
          if (e2.isNumber(t2)) {
            if (Math.abs(t2) < Math.eps)
              return this.real = 1 / 0, this.imaginary = 1 / 0, this;
            this.real /= t2, this.imaginary /= t2;
          } else {
            if (Math.abs(t2.real) < Math.eps && Math.abs(t2.imaginary) < Math.eps)
              return this.real = 1 / 0, this.imaginary = 1 / 0, this;
            i = t2.real * t2.real + t2.imaginary * t2.imaginary, s = this.real, r = this.imaginary, this.real = (s * t2.real + r * t2.imaginary) / i, this.imaginary = (r * t2.real - s * t2.imaginary) / i;
          }
          return this;
        }, conj: function() {
          return this.imaginary *= -1, this;
        }}), t.C = {}, t.C.add = function(e3, i) {
          var r = new t.Complex(e3);
          return r.add(i), r;
        }, t.C.sub = function(e3, i) {
          var r = new t.Complex(e3);
          return r.sub(i), r;
        }, t.C.mult = function(e3, i) {
          var r = new t.Complex(e3);
          return r.mult(i), r;
        }, t.C.div = function(e3, i) {
          var r = new t.Complex(e3);
          return r.div(i), r;
        }, t.C.conj = function(e3) {
          var i = new t.Complex(e3);
          return i.conj(), i;
        }, t.C.abs = function(e3) {
          var i = new t.Complex(e3);
          return i.conj(), i.mult(e3), Math.sqrt(i.real);
        }, t.Complex.C = t.C, t.Complex;
      }), define("utils/color", ["jxg", "utils/type", "math/math"], function(t, e2, i) {
        "use strict";
        var r = {aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32"}, s = [{re: /^\s*rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([\d\.]{1,3})\s*\)\s*$/, example: ["rgba(123, 234, 45, 0.5)", "rgba(255,234,245,1.0)"], process: function(t2) {
          return [parseInt(t2[1], 10), parseInt(t2[2], 10), parseInt(t2[3], 10)];
        }}, {re: /^\s*rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)\s*$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t2) {
          return [parseInt(t2[1], 10), parseInt(t2[2], 10), parseInt(t2[3], 10)];
        }}, {re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t2) {
          return [parseInt(t2[1], 16), parseInt(t2[2], 16), parseInt(t2[3], 16)];
        }}, {re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t2) {
          return [parseInt(t2[1] + t2[1], 16), parseInt(t2[2] + t2[2], 16), parseInt(t2[3] + t2[3], 16)];
        }}];
        return t.rgbParser = function(t2, i2, o) {
          var n, a, h, l, c, d, u, p, f, m, g = t2;
          if (!e2.exists(t2))
            return [];
          if (e2.exists(i2) && e2.exists(o) && (g = [t2, i2, o]), n = g, m = false, e2.isArray(n)) {
            for (d = 0; d < 3; d++)
              m = m || /\./.test(g[d].toString());
            for (d = 0; d < 3; d++)
              m = m && g[d] >= 0 && g[d] <= 1;
            return m ? [Math.ceil(255 * g[0]), Math.ceil(255 * g[1]), Math.ceil(255 * g[2])] : g;
          }
          for (typeof g == "string" && (n = g), n.charAt(0) === "#" && (n = n.substr(1, 6)), n = n.replace(/ /g, "").toLowerCase(), n = r[n] || n, d = 0; d < s.length; d++)
            h = s[d].re, l = s[d].process, (c = h.exec(n)) && (a = l(c), u = a[0], p = a[1], f = a[2]);
          return isNaN(u) || isNaN(p) || isNaN(f) ? [] : (u = u < 0 || isNaN(u) ? 0 : u > 255 ? 255 : u, p = p < 0 || isNaN(p) ? 0 : p > 255 ? 255 : p, f = f < 0 || isNaN(f) ? 0 : f > 255 ? 255 : f, [u, p, f]);
        }, t.rgb2css = function(e3, i2, r2) {
          var s2;
          return s2 = t.rgbParser(e3, i2, r2), "rgb(" + s2[0] + ", " + s2[1] + ", " + s2[2] + ")";
        }, t.rgb2hex = function(e3, i2, r2) {
          var s2, o, n;
          return s2 = t.rgbParser(e3, i2, r2), o = s2[1], n = s2[2], s2 = s2[0], s2 = s2.toString(16), o = o.toString(16), n = n.toString(16), s2.length === 1 && (s2 = "0" + s2), o.length === 1 && (o = "0" + o), n.length === 1 && (n = "0" + n), "#" + s2 + o + n;
        }, t.hex2rgb = function(e3) {
          return t.deprecated("JXG.hex2rgb()", "JXG.rgb2css()"), t.rgb2css(e3);
        }, t.hsv2rgb = function(t2, e3, r2) {
          var s2, o, n, a, h, l, c, d, u;
          if (t2 = (t2 % 360 + 360) % 360, e3 === 0) {
            if (!(isNaN(t2) || t2 < i.eps))
              return "#ffffff";
            s2 = r2, o = r2, n = r2;
          } else
            switch (l = t2 >= 360 ? 0 : t2, l /= 60, h = Math.floor(l), a = l - h, c = r2 * (1 - e3), d = r2 * (1 - e3 * a), u = r2 * (1 - e3 * (1 - a)), h) {
              case 0:
                s2 = r2, o = u, n = c;
                break;
              case 1:
                s2 = d, o = r2, n = c;
                break;
              case 2:
                s2 = c, o = r2, n = u;
                break;
              case 3:
                s2 = c, o = d, n = r2;
                break;
              case 4:
                s2 = u, o = c, n = r2;
                break;
              case 5:
                s2 = r2, o = c, n = d;
            }
          return s2 = Math.round(255 * s2).toString(16), s2 = s2.length === 2 ? s2 : s2.length === 1 ? "0" + s2 : "00", o = Math.round(255 * o).toString(16), o = o.length === 2 ? o : o.length === 1 ? "0" + o : "00", n = Math.round(255 * n).toString(16), n = n.length === 2 ? n : n.length === 1 ? "0" + n : "00", ["#", s2, o, n].join("");
        }, t.rgb2hsv = function(e3, i2, r2) {
          var s2, o, n, a, h, l, c, d, u, p, f, m, g;
          return s2 = t.rgbParser(e3, i2, r2), o = s2[1], n = s2[2], s2 = s2[0], a = s2 / 255, h = o / 255, l = n / 255, m = Math.max(s2, o, n), g = Math.min(s2, o, n), c = m / 255, d = g / 255, f = c, p = 0, f > 0 && (p = (f - d) / f), u = 1 / (c - d), p > 0 && (m === s2 ? u *= h - l : u = m === o ? 2 + (l - a) * u : 4 + (a - h) * u), u *= 60, u < 0 && (u += 360), m === g && (u = 0), [u, p, f];
        }, t.rgb2LMS = function(e3, i2, r2) {
          var s2, o, n, a, h, l, c, d = [[0.05059983, 0.08585369, 95242e-7], [0.01893033, 0.08925308, 0.01370054], [292202e-8, 975732e-8, 0.07145979]];
          return s2 = t.rgbParser(e3, i2, r2), o = s2[1], n = s2[2], s2 = s2[0], s2 = Math.pow(s2, 0.476190476), o = Math.pow(o, 0.476190476), n = Math.pow(n, 0.476190476), a = s2 * d[0][0] + o * d[0][1] + n * d[0][2], h = s2 * d[1][0] + o * d[1][1] + n * d[1][2], l = s2 * d[2][0] + o * d[2][1] + n * d[2][2], c = [a, h, l], c.l = a, c.m = h, c.s = l, c;
        }, t.LMS2rgb = function(t2, e3, i2) {
          var r2, s2, o, n, a = [[30.830854, -29.832659, 1.610474], [-6.481468, 17.715578, -2.532642], [-0.37569, -1.199062, 14.273846]], h = function(t3) {
            for (var e4 = 127, i3 = 64; i3 > 0; ) {
              if (Math.pow(e4, 0.476190476) > t3)
                e4 -= i3;
              else {
                if (Math.pow(e4 + 1, 0.476190476) > t3)
                  return e4;
                e4 += i3;
              }
              i3 /= 2;
            }
            return e4 === 254 && 13.994955247 < t3 ? 255 : e4;
          };
          return r2 = t2 * a[0][0] + e3 * a[0][1] + i2 * a[0][2], s2 = t2 * a[1][0] + e3 * a[1][1] + i2 * a[1][2], o = t2 * a[2][0] + e3 * a[2][1] + i2 * a[2][2], r2 = h(r2), s2 = h(s2), o = h(o), n = [r2, s2, o], n.r = r2, n.g = s2, n.b = o, n;
        }, t.rgba2rgbo = function(t2) {
          var e3;
          return t2.length === 9 && t2.charAt(0) === "#" ? (e3 = parseInt(t2.substr(7, 2).toUpperCase(), 16) / 255, t2 = t2.substr(0, 7)) : e3 = 1, [t2, e3];
        }, t.rgbo2rgba = function(t2, e3) {
          var i2;
          return t2 === "none" ? t2 : (i2 = Math.round(255 * e3).toString(16), i2.length === 1 && (i2 = "0" + i2), t2 + i2);
        }, t.rgb2bw = function(e3) {
          var i2, r2, s2, o = "0123456789ABCDEF";
          return e3 === "none" ? e3 : (s2 = t.rgbParser(e3), i2 = Math.floor(0.3 * s2[0] + 0.59 * s2[1] + 0.11 * s2[2]), r2 = o.charAt(i2 >> 4 & 15) + o.charAt(15 & i2), e3 = "#" + r2 + r2 + r2);
        }, t.rgb2cb = function(e3, i2) {
          var r2, s2, o, n, a, h, l, c, d, u, p, f, m, g = "0123456789ABCDEF";
          if (e3 === "none")
            return e3;
          switch (a = t.rgb2LMS(e3), s2 = a[0], o = a[1], n = a[2], i2 = i2.toLowerCase()) {
            case "protanopia":
              l = -0.06150039994295001, c = 0.08277001656812001, d = -0.013200141220000003, u = 0.05858939668799999, p = -0.07934519995360001, f = 0.013289415272000003, m = 0.6903216543277437, h = n / o, s2 = h < m ? -(c * o + d * n) / l : -(p * o + f * n) / u;
              break;
            case "tritanopia":
              l = -58973116217e-14, c = 0.007690316482, d = -0.01011703519052, u = 0.025495080838999994, p = -0.0422740347, f = 0.017005316784, m = 0.8349489908460004, h = o / s2, n = h < m ? -(l * s2 + c * o) / d : -(u * s2 + p * o) / f;
              break;
            default:
              l = -0.06150039994295001, c = 0.08277001656812001, d = -0.013200141220000003, u = 0.05858939668799999, p = -0.07934519995360001, f = 0.013289415272000003, m = 0.5763833686400911, h = n / s2, o = h < m ? -(l * s2 + d * n) / c : -(u * s2 + f * n) / p;
          }
          return r2 = t.LMS2rgb(s2, o, n), h = g.charAt(r2[0] >> 4 & 15) + g.charAt(15 & r2[0]), e3 = "#" + h, h = g.charAt(r2[1] >> 4 & 15) + g.charAt(15 & r2[1]), e3 += h, h = g.charAt(r2[2] >> 4 & 15) + g.charAt(15 & r2[2]), e3 += h;
        }, t.autoHighlight = function(e3) {
          var i2 = t.rgba2rgbo(e3), r2 = i2[0], s2 = i2[1];
          return e3.charAt(0) === "#" ? (s2 *= s2 < 0.3 ? 1.8 : 0.4, t.rgbo2rgba(r2, s2)) : e3;
        }, t.contrast = function(e3, i2, r2, s2) {
          var o, n, a, h, l;
          return i2 = i2 || "#000000", r2 = r2 || "#ffffff", s2 = s2 || 7, o = t.rgbParser(e3), n = t.rgbParser("#000000"), a = 0.2126 * Math.pow(o[0] / 255, 2.2) + 0.7152 * Math.pow(o[1] / 255, 2.2) + 0.0722 * Math.pow(o[2] / 255, 2.2), h = 0.2126 * Math.pow(n[0] / 255, 2.2) + 0.7152 * Math.pow(n[1] / 255, 2.2) + 0.0722 * Math.pow(n[2] / 255, 2.2), l = a > h ? Math.floor((a + 0.05) / (h + 0.05)) : Math.floor((h + 0.05) / (a + 0.05)), l -= 1, l > s2 ? i2 : r2;
        }, t;
      }), define("options", ["jxg", "base/constants", "math/math", "utils/color", "utils/type"], function(t, e2, i, r, s) {
        "use strict";
        return t.Options = {jc: {enabled: true, compile: true}, board: {boundingBox: [-5, 5, 5, -5], maxBoundingBox: [-1 / 0, 1 / 0, 1 / 0, -1 / 0], zoomFactor: 1, zoomX: 1, zoomY: 1, title: "", description: "", showCopyright: true, axis: false, defaultAxes: {x: {name: "x", ticks: {label: {visible: "inherit", anchorX: "middle", anchorY: "top", fontSize: 12, offset: [0, -3]}, drawZero: false, visible: "inherit"}}, y: {name: "y", ticks: {label: {visible: "inherit", anchorX: "right", anchorY: "middle", fontSize: 12, offset: [-6, 0]}, tickEndings: [1, 0], drawZero: false, visible: "inherit"}}}, showNavigation: true, showZoom: true, showReload: false, showScreenshot: false, screenshot: {scale: 1, type: "png", symbol: "\u2318", css: "background-color:#eeeeee; opacity:1.0; border:2px solid black; border-radius:10px; text-align:center", cssButton: "padding: 4px 10px; border: solid #356AA0 1px; border-radius: 5px; position: absolute; right: 2ex; top: 2ex; background-color: rgba(255, 255, 255, 0.3);"}, showFullscreen: false, fullscreen: {symbol: "\u26F6"}, showClearTraces: false, keepAspectRatio: false, ignoreLabels: true, maxNameLength: 1, document: false, takeFirst: false, takeSizeFromFile: false, renderer: "auto", animationDelay: 35, maxFrameRate: 40, registerEvents: true, minimizeReflow: "svg", offsetX: 0, offsetY: 0, zoom: {enabled: true, factorX: 1.25, factorY: 1.25, wheel: true, needShift: true, min: 1e-4, max: 1e4, pinchHorizontal: true, pinchVertical: true, pinchSensitivity: 7}, pan: {needShift: true, needTwoFingers: false, enabled: true}, drag: {enabled: true}, selection: {enabled: false, name: "selectionPolygon", needShift: false, needCtrl: true, withLines: false, vertices: {visible: false}, fillColor: "#ffff00", visible: false}, showInfobox: true}, navbar: {strokeColor: "#333333", fillColor: "transparent", highlightFillColor: "#aaaaaa", padding: "2px", position: "absolute", fontSize: "14px", cursor: "pointer", zIndex: "100", right: "5px", bottom: "5px"}, elements: {strokeColor: "#0000ff", highlightStrokeColor: "#C3D9FF", fillColor: "red", highlightFillColor: "none", strokeOpacity: 1, highlightStrokeOpacity: 1, fillOpacity: 1, highlightFillOpacity: 1, gradient: null, gradientSecondColor: "#ffffff", gradientSecondOpacity: 1, gradientStartOffset: 0, gradientEndOffset: 1, gradientAngle: 0, gradientCX: 0.5, gradientCY: 0.5, gradientR: 0.5, gradientFX: 0.5, gradientFY: 0.5, gradientFR: 0, transitionDuration: 100, strokeWidth: 2, highlightStrokeWidth: 2, fixed: false, frozen: false, withLabel: false, visible: true, priv: false, layer: 0, dash: 0, shadow: false, trace: false, traceAttributes: {}, highlight: true, needsRegularUpdate: true, snapToGrid: false, scalable: true, dragToTopOfLayer: false, precision: "inherit", draft: {draft: false, strokeColor: "#565656", fillColor: "#565656", strokeOpacity: 0.8, fillOpacity: 0.8, strokeWidth: 1}, isLabel: false}, ticks: {generateLabelText: null, generateLabelValue: null, drawLabels: false, label: {}, beautifulScientificTickLabels: false, useUnicodeMinus: true, anchor: "left", drawZero: false, insertTicks: false, minTicksDistance: 10, minorHeight: 4, majorHeight: 10, tickEndings: [1, 1], minorTicks: 4, scale: 1, scaleSymbol: "", labels: [], maxLabelLength: 5, precision: 3, ticksDistance: 1, face: "|", strokeOpacity: 1, strokeWidth: 1, strokeColor: "black", highlightStrokeColor: "#888888", fillColor: "none", highlightFillColor: "none", visible: "inherit", includeBoundaries: false, type: "linear"}, hatch: {drawLabels: false, drawZero: true, majorHeight: 20, anchor: "middle", face: "|", strokeWidth: 2, strokeColor: "blue", ticksDistance: 0.2}, precision: {touch: 15, touchMax: 100, mouse: 4, pen: 4, epsilon: 1e-4, hasPoint: 4}, layer: {numlayers: 20, unused9: 19, unused8: 18, unused7: 17, unused6: 16, unused5: 15, unused4: 14, unused3: 13, unused2: 12, unused1: 11, unused0: 10, text: 9, point: 9, glider: 9, arc: 8, line: 7, circle: 6, curve: 5, turtle: 5, polygon: 3, sector: 3, angle: 3, integral: 3, axis: 2, ticks: 2, grid: 1, image: 0, trace: 0}, angle: {withLabel: true, radius: 0.5, type: "sector", orthoType: "square", orthoSensitivity: 1, fillColor: "#FF7F00", highlightFillColor: "#FF7F00", strokeColor: "#FF7F00", fillOpacity: 0.3, highlightFillOpacity: 0.3, radiuspoint: {withLabel: false, visible: false, name: ""}, pointsquare: {withLabel: false, visible: false, name: ""}, dot: {visible: false, strokeColor: "none", fillColor: "black", size: 2, face: "o", withLabel: false, name: ""}, label: {position: "top", offset: [0, 0], strokeColor: "#0000FF"}, arc: {visible: false, fillColor: "none"}}, arc: {selection: "auto", hasInnerPoints: false, label: {anchorX: "auto", anchorY: "auto"}, firstArrow: false, lastArrow: false, fillColor: "none", highlightFillColor: "none", strokeColor: "#0000ff", highlightStrokeColor: "#C3D9FF", useDirection: false, center: {}, radiusPoint: {}, anglePoint: {}}, arrow: {firstArrow: false, lastArrow: {type: 1, highlightSize: 6, size: 6}}, axis: {name: "", needsRegularUpdate: false, strokeWidth: 1, lastArrow: {type: 1, highlightSize: 8, size: 8}, strokeColor: "#666666", highlightStrokeWidth: 1, highlightStrokeColor: "#888888", withTicks: true, straightFirst: true, straightLast: true, margin: -4, withLabel: false, scalable: false, ticks: {label: {offset: [4, -9], parse: false, needsRegularUpdate: false, display: "internal", visible: "inherit", layer: 9}, visible: "inherit", needsRegularUpdate: false, strokeWidth: 1, strokeColor: "#666666", highlightStrokeColor: "#888888", drawLabels: true, drawZero: false, insertTicks: true, minTicksDistance: 5, minorHeight: 10, majorHeight: -1, tickEndings: [0, 1], minorTicks: 4, ticksDistance: 1, strokeOpacity: 0.25}, point1: {needsRegularUpdate: false, visible: false}, point2: {needsRegularUpdate: false, visible: false}, label: {position: "lft", offset: [10, 10]}}, bisector: {strokeColor: "#000000", point: {visible: false, fixed: false, withLabel: false, name: ""}}, bisectorlines: {line1: {strokeColor: "black"}, line2: {strokeColor: "black"}}, button: {disabled: false, display: "html"}, cardinalspline: {createPoints: true, isArrayOfCoordinates: false, points: {strokeOpacity: 0.05, fillOpacity: 0.05, highlightStrokeOpacity: 1, highlightFillOpacity: 1, withLabel: false, name: "", fixed: false}}, chart: {chartStyle: "line", colors: ["#B02B2C", "#3F4C6B", "#C79810", "#D15600", "#FFFF88", "#C3D9FF", "#4096EE", "#008C00"], highlightcolors: null, fillcolor: null, highlightonsector: false, highlightbysize: false, fillOpacity: 0.6, withLines: false, label: {}}, checkbox: {disabled: false, checked: false, display: "html"}, circle: {hasInnerPoints: false, fillColor: "none", highlightFillColor: "none", strokeColor: "#0000ff", highlightStrokeColor: "#C3D9FF", center: {visible: false, withLabel: false, fixed: false, name: ""}, label: {position: "urt"}}, circumcircle: {fillColor: "none", highlightFillColor: "none", strokeColor: "#0000ff", highlightStrokeColor: "#C3D9FF", center: {visible: false, fixed: false, withLabel: false, name: ""}}, circumcirclearc: {fillColor: "none", highlightFillColor: "none", strokeColor: "#0000ff", highlightStrokeColor: "#C3D9FF", center: {visible: false, withLabel: false, fixed: false, name: ""}}, circumcirclesector: {useDirection: true, fillColor: "#00FF00", highlightFillColor: "#00FF00", fillOpacity: 0.3, highlightFillOpacity: 0.3, strokeColor: "#0000ff", highlightStrokeColor: "#C3D9FF", point: {visible: false, fixed: false, withLabel: false, name: ""}}, conic: {fillColor: "none", highlightFillColor: "none", strokeColor: "#0000ff", highlightStrokeColor: "#C3D9FF", foci: {
          fixed: false,
          visible: false,
          withLabel: false,
          name: ""
        }, center: {visible: false, withLabel: false, name: ""}, point: {withLabel: false, name: ""}, line: {visible: false}}, curve: {strokeWidth: 1, strokeColor: "#0000ff", fillColor: "none", fixed: true, useQDT: false, handDrawing: false, curveType: null, RDPsmoothing: false, numberPointsHigh: 1600, numberPointsLow: 400, doAdvancedPlot: true, recursionDepthHigh: 17, recursionDepthLow: 15, doAdvancedPlotOld: false, plotVersion: 2, label: {position: "lft"}, firstArrow: false, lastArrow: false}, glider: {label: {}}, grid: {needsRegularUpdate: false, hasGrid: false, gridX: 1, gridY: 1, strokeColor: "#C0C0C0", strokeOpacity: 0.5, strokeWidth: 1, dash: 0, snapToGrid: false, snapSizeX: 10, snapSizeY: 10}, group: {needsRegularUpdate: true}, htmlslider: {widthRange: 100, widthOut: 34, step: 0.01, frozen: true, isLabel: false, strokeColor: "black", display: "html", anchorX: "left", anchorY: "middle", withLabel: false}, image: {imageString: null, fillOpacity: 1, highlightFillOpacity: 0.6, cssClass: "JXGimage", highlightCssClass: "JXGimageHighlight", rotate: 0, snapSizeX: 1, snapSizeY: 1, attractors: []}, incircle: {fillColor: "none", highlightFillColor: "none", strokeColor: "#0000ff", highlightStrokeColor: "#C3D9FF", center: {visible: false, fixed: false, withLabel: false, name: ""}}, inequality: {fillColor: "red", fillOpacity: 0.2, strokeColor: "none", inverse: false}, infobox: {fontSize: 12, isLabel: false, strokeColor: "#bbbbbb", display: "html", anchorX: "left", anchorY: "middle", cssClass: "JXGinfobox", rotate: 0, visible: true, parse: false, transitionDuration: 0, needsRegularUpdate: false}, integral: {axis: "x", withLabel: true, fixed: true, strokeWidth: 0, strokeOpacity: 0, fillColor: "red", fillOpacity: 0.4, highlightFillColor: "red", highlightFillOpacity: 0.2, curveLeft: {visible: true, withLabel: false, color: "red", fillOpacity: 0.8, layer: 9}, baseLeft: {visible: false, fixed: false, withLabel: false, name: ""}, curveRight: {visible: true, withLabel: false, color: "red", fillOpacity: 0.8, layer: 9}, baseRight: {visible: false, fixed: false, withLabel: false, name: ""}, label: {fontSize: 20}}, input: {disabled: false, maxlength: 524288, display: "html"}, intersection: {alwaysIntersect: true}, label: {visible: "inherit", strokeColor: "black", strokeOpacity: 1, highlightStrokeOpacity: 0.666666, highlightStrokeColor: "black", fixed: true, position: "urt", offset: [10, 10], autoPosition: false}, legend: {style: "vertical", labels: ["1", "2", "3", "4", "5", "6", "7", "8"], colors: ["#B02B2C", "#3F4C6B", "#C79810", "#D15600", "#FFFF88", "#C3D9FF", "#4096EE", "#008C00"], rowHeight: 20, strokeWidth: 5}, line: {firstArrow: false, lastArrow: false, margin: 0, straightFirst: true, straightLast: true, fillColor: "none", highlightFillColor: "none", strokeColor: "#0000ff", highlightStrokeColor: "#888888", withTicks: false, point1: {visible: false, withLabel: false, fixed: false, name: ""}, point2: {visible: false, withLabel: false, fixed: false, name: ""}, ticks: {drawLabels: true, label: {offset: [4, -9]}, drawZero: false, insertTicks: false, minTicksDistance: 50, minorHeight: 4, majorHeight: -1, minorTicks: 4, defaultDistance: 1, strokeOpacity: 0.3, visible: "inherit"}, label: {position: "llft"}, snapToGrid: false, snapSizeX: 1, snapSizeY: 1, touchFirstPoint: false, touchLastPoint: false, lineCap: "butt"}, locus: {translateToOrigin: false, translateTo10: false, stretch: false, toOrigin: null, to10: null}, metapostspline: {createPoints: true, isArrayOfCoordinates: false, points: {strokeOpacity: 0.05, fillOpacity: 0.05, highlightStrokeOpacity: 1, highlightFillOpacity: 1, withLabel: false, name: "", fixed: false}}, mirrorelement: {fixed: true, point: {}, center: {}, type: "Euclidean"}, normal: {strokeColor: "#000000", point: {visible: false, fixed: false, withLabel: false, name: ""}}, orthogonalprojection: {}, parallel: {strokeColor: "#000000", point: {visible: false, fixed: false, withLabel: false, name: ""}, label: {position: "llft"}}, perpendicular: {strokeColor: "#000000", straightFirst: true, straightLast: true}, perpendicularsegment: {strokeColor: "#000000", straightFirst: false, straightLast: false, point: {visible: false, fixed: true, withLabel: false, name: ""}}, point: {withLabel: true, label: {}, style: 5, face: "o", size: 3, sizeUnit: "screen", fillColor: "#ff0000", highlightFillColor: "#EEEEEE", strokeWidth: 2, strokeColor: "#ff0000", highlightStrokeColor: "#C3D9FF", zoom: false, showInfobox: "inherit", infoboxDigits: "auto", draft: false, attractors: [], attractorUnit: "user", attractorDistance: 0, snatchDistance: 0, snapToGrid: false, snapSizeX: 1, snapSizeY: 1, snapToPoints: false, ignoredSnapToPoints: []}, polygon: {hasInnerPoints: false, fillColor: "#00FF00", highlightFillColor: "#00FF00", fillOpacity: 0.3, highlightFillOpacity: 0.3, withLines: true, borders: {withLabel: false, strokeWidth: 1, highlightStrokeWidth: 1, layer: 5, label: {position: "top"}, visible: "inherit"}, vertices: {layer: 9, withLabel: false, name: "", strokeColor: "#ff0000", fillColor: "#ff0000", fixed: false, visible: "inherit"}, label: {offset: [0, 0]}}, polygonalchain: {fillColor: "none", highlightFillColor: "none"}, prescribedangle: {anglePoint: {size: 2, visible: false, withLabel: false}}, reflection: {fixed: true, center: {}, type: "Euclidean"}, regularpolygon: {hasInnerPoints: false, fillColor: "#00FF00", highlightFillColor: "#00FF00", fillOpacity: 0.3, highlightFillOpacity: 0.3, withLines: true, borders: {withLabel: false, strokeWidth: 1, highlightStrokeWidth: 1, layer: 5, label: {position: "top"}}, vertices: {layer: 9, withLabel: true, strokeColor: "#ff0000", fillColor: "#ff0000", fixed: false}, label: {offset: [0, 0]}}, riemannsum: {withLabel: false, fillOpacity: 0.3, fillColor: "#ffff00"}, sector: {fillColor: "#00FF00", highlightFillColor: "#00FF00", fillOpacity: 0.3, highlightFillOpacity: 0.3, highlightOnSector: false, highlightStrokeWidth: 0, selection: "auto", arc: {visible: false, fillColor: "none"}, radiusPoint: {visible: false, withLabel: false}, center: {visible: false, withLabel: false}, anglePoint: {visible: false, withLabel: false}, label: {offset: [0, 0], anchorX: "auto", anchorY: "auto"}}, segment: {label: {position: "top"}}, semicircle: {center: {visible: false, withLabel: false, fixed: false, name: ""}}, slider: {snapWidth: -1, precision: 2, firstArrow: false, lastArrow: false, withTicks: true, withLabel: true, suffixLabel: null, unitLabel: null, postLabel: null, layer: 9, showInfobox: false, name: "", visible: true, strokeColor: "#000000", highlightStrokeColor: "#888888", fillColor: "#ffffff", highlightFillColor: "none", size: 6, point1: {needsRegularUpdate: false, showInfobox: false, withLabel: false, visible: false, fixed: true, name: ""}, point2: {needsRegularUpdate: false, showInfobox: false, withLabel: false, visible: false, fixed: true, name: ""}, baseline: {needsRegularUpdate: false, visible: "inherit", fixed: true, scalable: false, name: "", strokeWidth: 1, strokeColor: "#000000", highlightStrokeColor: "#888888"}, ticks: {needsRegularUpdate: false, fixed: true, drawLabels: false, precision: 2, includeBoundaries: 1, drawZero: true, label: {offset: [-4, -14], display: "internal"}, minTicksDistance: 30, insertTicks: true, minorHeight: 4, majorHeight: 5, minorTicks: 0, defaultDistance: 1, strokeOpacity: 1, strokeWidth: 1, tickEndings: [0, 1], strokeColor: "#000000", visible: "inherit"}, highline: {strokeWidth: 3, visible: "inherit", fixed: true, name: "", strokeColor: "#000000", highlightStrokeColor: "#888888"}, label: {visible: "inherit", strokeColor: "#000000"}, moveOnUp: true}, comb: {frequency: 0.2, width: 0.4, angle: Math.PI / 3, reverse: false, point1: {visible: false, withLabel: false, fixed: false, name: ""}, point2: {visible: false, withLabel: false, fixed: false, name: ""}, curve: {strokeWidth: 1, strokeColor: "#000000", fillColor: "none"}}, slopetriangle: {fillColor: "red", fillOpacity: 0.4, highlightFillColor: "red", highlightFillOpacity: 0.3, borders: {lastArrow: {type: 1, size: 6}}, glider: {fixed: true, visible: false, withLabel: false}, baseline: {visible: false, withLabel: false, name: ""}, basepoint: {visible: false, withLabel: false, name: ""}, tangent: {visible: false, withLabel: false, name: ""}, topPoint: {visible: false, withLabel: false, name: ""}, label: {visible: true}}, stepfunction: {}, tapemeasure: {strokeColor: "#000000", strokeWidth: 2, highlightStrokeColor: "#000000", withTicks: true, withLabel: true, precision: 2, point1: {visible: "inherit", strokeColor: "#000000", fillColor: "#ffffff", fillOpacity: 0, highlightFillOpacity: 0.1, size: 6, snapToPoints: true, attractorUnit: "screen", attractorDistance: 20, showInfobox: false, withLabel: false, name: ""}, point2: {visible: "inherit", strokeColor: "#000000", fillColor: "#ffffff", fillOpacity: 0, highlightFillOpacity: 0.1, size: 6, snapToPoints: true, attractorUnit: "screen", attractorDistance: 20, showInfobox: false, withLabel: false, name: ""}, ticks: {drawLabels: false, drawZero: true, insertTicks: true, minorHeight: 8, majorHeight: 16, minorTicks: 4, tickEndings: [0, 1], defaultDistance: 0.1, strokeOpacity: 1, strokeWidth: 1, strokeColor: "#000000", visible: "inherit"}, label: {position: "top"}}, text: {fontSize: 12, digits: 2, parse: true, useCaja: false, isLabel: false, strokeColor: "black", highlightStrokeColor: "black", highlightStrokeOpacity: 0.666666, cssDefaultStyle: "font-family: Arial, Helvetica, Geneva, sans-serif;", highlightCssDefaultStyle: "font-family: Arial, Helvetica, Geneva, sans-serif;", cssStyle: "", highlightCssStyle: "", useASCIIMathML: false, useMathJax: false, display: "html", anchor: null, anchorX: "left", anchorY: "middle", cssClass: "JXGtext", highlightCssClass: "JXGtext", dragArea: "all", withLabel: false, rotate: 0, visible: true, snapSizeX: 1, snapSizeY: 1, attractors: []}, tracecurve: {strokeColor: "#000000", fillColor: "none", numberPoints: 100}, turtle: {strokeWidth: 1, fillColor: "none", strokeColor: "#000000", arrow: {strokeWidth: 2, withLabel: false, strokeColor: "#ff0000", lastArrow: true}}, shortcuts: {color: ["strokeColor", "fillColor"], opacity: ["strokeOpacity", "fillOpacity"], highlightColor: ["highlightStrokeColor", "highlightFillColor"], highlightOpacity: ["highlightStrokeOpacity", "highlightFillOpacity"], strokeWidth: ["strokeWidth", "highlightStrokeWidth"]}}, t.Validator = function() {
          var e3, r2 = function(t2) {
            return /^[0-9]+px$/.test(t2);
          }, o = function(t2) {
            return t2 === "html" || t2 === "internal";
          }, n = function(t2) {
            return s.isString(t2);
          }, a = function(e4) {
            return s.exists(t.normalizePointFace(e4));
          }, h = function(t2) {
            return Math.abs(t2 - Math.round(t2)) < i.eps;
          }, l = function(t2) {
            return h(t2) && t2 >= 0;
          }, c = function(t2) {
            return h(t2) && t2 > 0;
          }, d = function(t2) {
            return t2 === "vml" || t2 === "svg" || t2 === "canvas" || t2 === "no";
          }, u = function(t2) {
            return t2 > 0;
          }, p = function(t2) {
            return t2 >= 0;
          }, f = {}, m = {attractorDistance: p, color: n, defaultDistance: s.isNumber, display: o, doAdvancedPlot: false, draft: false, drawLabels: false, drawZero: false, face: a, factor: s.isNumber, fillColor: n, fillOpacity: s.isNumber, firstArrow: false, fontSize: h, dash: h, gridX: s.isNumber, gridY: s.isNumber, hasGrid: false, highlightFillColor: n, highlightFillOpacity: s.isNumber, highlightStrokeColor: n, highlightStrokeOpacity: s.isNumber, insertTicks: false, lastArrow: false, layer: l, majorHeight: h, minorHeight: h, minorTicks: p, minTicksDistance: c, numberPointsHigh: c, numberPointsLow: c, opacity: s.isNumber, radius: s.isNumber, RDPsmoothing: false, renderer: d, right: r2, showCopyright: false, showInfobox: false, showNavigation: false, size: p, snapSizeX: u, snapSizeY: u, snapWidth: s.isNumber, snapToGrid: false, snatchDistance: p, straightFirst: false, straightLast: false, stretch: false, strokeColor: n, strokeOpacity: s.isNumber, strokeWidth: p, takeFirst: false, takeSizeFromFile: false, to10: false, toOrigin: false, translateTo10: false, translateToOrigin: false, useASCIIMathML: false, useDirection: false, useMathJax: false, withLabel: false, withTicks: false, zoom: false};
          for (e3 in m)
            m.hasOwnProperty(e3) && (f[e3.toLowerCase()] = m[e3]);
          return f;
        }(), t.normalizePointFace = function(t2) {
          return {cross: "x", x: "x", circle: "o", o: "o", square: "[]", "[]": "[]", plus: "+", "+": "+", diamond: "<>", "<>": "<>", triangleup: "^", a: "^", "^": "^", triangledown: "v", v: "v", triangleleft: "<", "<": "<", triangleright: ">", ">": ">"}[t2];
        }, t.useStandardOptions = function(i2) {
          var r2, s2, o, n, a = t.Options, h = i2.hasGrid;
          i2.options.grid.hasGrid = a.grid.hasGrid, i2.options.grid.gridX = a.grid.gridX, i2.options.grid.gridY = a.grid.gridY, i2.options.grid.gridColor = a.grid.gridColor, i2.options.grid.gridOpacity = a.grid.gridOpacity, i2.options.grid.gridDash = a.grid.gridDash, i2.options.grid.snapToGrid = a.grid.snapToGrid, i2.options.grid.snapSizeX = a.grid.SnapSizeX, i2.options.grid.snapSizeY = a.grid.SnapSizeY, i2.takeSizeFromFile = a.takeSizeFromFile, n = function(t2, e3) {
            t2.visProp.fillcolor = e3.fillColor, t2.visProp.highlightfillcolor = e3.highlightFillColor, t2.visProp.strokecolor = e3.strokeColor, t2.visProp.highlightstrokecolor = e3.highlightStrokeColor;
          };
          for (r2 in i2.objects)
            if (i2.objects.hasOwnProperty(r2))
              if (o = i2.objects[r2], o.elementClass === e2.OBJECT_CLASS_POINT)
                n(o, a.point);
              else if (o.elementClass === e2.OBJECT_CLASS_LINE)
                for (n(o, a.line), s2 = 0; s2 < o.ticks.length; s2++)
                  o.ticks[s2].majorTicks = a.line.ticks.majorTicks, o.ticks[s2].minTicksDistance = a.line.ticks.minTicksDistance, o.ticks[s2].visProp.minorheight = a.line.ticks.minorHeight, o.ticks[s2].visProp.majorheight = a.line.ticks.majorHeight;
              else
                o.elementClass === e2.OBJECT_CLASS_CIRCLE ? n(o, a.circle) : o.type === e2.OBJECT_TYPE_ANGLE ? n(o, a.angle) : o.type === e2.OBJECT_TYPE_ARC ? n(o, a.arc) : o.type === e2.OBJECT_TYPE_POLYGON ? n(o, a.polygon) : o.type === e2.OBJECT_TYPE_CONIC ? n(o, a.conic) : o.type === e2.OBJECT_TYPE_CURVE ? n(o, a.curve) : o.type === e2.OBJECT_TYPE_SECTOR && (o.arc.visProp.fillcolor = a.sector.fillColor, o.arc.visProp.highlightfillcolor = a.sector.highlightFillColor, o.arc.visProp.fillopacity = a.sector.fillOpacity, o.arc.visProp.highlightfillopacity = a.sector.highlightFillOpacity);
          i2.fullUpdate(), h && !i2.hasGrid ? i2.removeGrids(i2) : !h && i2.hasGrid && i2.create("grid", []);
        }, t.useBlackWhiteOptions = function(e3) {
          var i2 = t.Options;
          i2.point.fillColor = r.rgb2bw(i2.point.fillColor), i2.point.highlightFillColor = r.rgb2bw(i2.point.highlightFillColor), i2.point.strokeColor = r.rgb2bw(i2.point.strokeColor), i2.point.highlightStrokeColor = r.rgb2bw(i2.point.highlightStrokeColor), i2.line.fillColor = r.rgb2bw(i2.line.fillColor), i2.line.highlightFillColor = r.rgb2bw(i2.line.highlightFillColor), i2.line.strokeColor = r.rgb2bw(i2.line.strokeColor), i2.line.highlightStrokeColor = r.rgb2bw(i2.line.highlightStrokeColor), i2.circle.fillColor = r.rgb2bw(i2.circle.fillColor), i2.circle.highlightFillColor = r.rgb2bw(i2.circle.highlightFillColor), i2.circle.strokeColor = r.rgb2bw(i2.circle.strokeColor), i2.circle.highlightStrokeColor = r.rgb2bw(i2.circle.highlightStrokeColor), i2.arc.fillColor = r.rgb2bw(i2.arc.fillColor), i2.arc.highlightFillColor = r.rgb2bw(i2.arc.highlightFillColor), i2.arc.strokeColor = r.rgb2bw(i2.arc.strokeColor), i2.arc.highlightStrokeColor = r.rgb2bw(i2.arc.highlightStrokeColor), i2.polygon.fillColor = r.rgb2bw(i2.polygon.fillColor), i2.polygon.highlightFillColor = r.rgb2bw(i2.polygon.highlightFillColor), i2.sector.fillColor = r.rgb2bw(i2.sector.fillColor), i2.sector.highlightFillColor = r.rgb2bw(i2.sector.highlightFillColor), i2.curve.strokeColor = r.rgb2bw(i2.curve.strokeColor), i2.grid.gridColor = r.rgb2bw(i2.grid.gridColor), t.useStandardOptions(e3);
        }, t.Options.normalizePointFace = t.normalizePointFace, t.Options;
      }), define("renderer/abstract", ["jxg", "options", "base/coords", "base/constants", "math/math", "math/geometry", "utils/type", "utils/env"], function(t, e2, i, r, s, o, n, a) {
        "use strict";
        return t.AbstractRenderer = function() {
          this.vOffsetText = 0, this.enhancedRendering = true, this.container = null, this.type = "", this.supportsForeignObject = false;
        }, t.extend(t.AbstractRenderer.prototype, {_updateVisual: function(t2, e3, i2) {
          (i2 || this.enhancedRendering) && (e3 = e3 || {}, this.setObjectTransition(t2), n.evaluate(t2.visProp.draft) ? this.setDraft(t2) : (e3.stroke || (t2.highlighted ? (this.setObjectStrokeColor(t2, t2.visProp.highlightstrokecolor, t2.visProp.highlightstrokeopacity), this.setObjectStrokeWidth(t2, t2.visProp.highlightstrokewidth)) : (this.setObjectStrokeColor(t2, t2.visProp.strokecolor, t2.visProp.strokeopacity), this.setObjectStrokeWidth(t2, t2.visProp.strokewidth))), e3.fill || (t2.highlighted ? this.setObjectFillColor(t2, t2.visProp.highlightfillcolor, t2.visProp.highlightfillopacity) : this.setObjectFillColor(t2, t2.visProp.fillcolor, t2.visProp.fillopacity)), e3.dash || this.setDashStyle(t2, t2.visProp), e3.shadow || this.setShadow(t2), e3.gradient || this.setShadow(t2)));
        }, _getHighlighted: function(t2) {
          var e3 = false;
          return n.exists(t2.board) && n.exists(t2.board.highlightedObjects) || (e3 = true), !e3 && n.exists(t2.board.highlightedObjects[t2.id]) ? "highlight" : "";
        }, drawPoint: function(t2) {
          var i2, r2 = e2.normalizePointFace(n.evaluate(t2.visProp.face));
          i2 = r2 === "o" ? "ellipse" : r2 === "[]" ? "rect" : "path", t2.rendNode = this.appendChildPrim(this.createPrim(i2, t2.id), n.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, i2), this._updateVisual(t2, {dash: true, shadow: true}, true), this.updatePoint(t2);
        }, updatePoint: function(t2) {
          var i2, r2 = n.evaluate(t2.visProp.size), s2 = e2.normalizePointFace(n.evaluate(t2.visProp.face)), o2 = n.evaluate(t2.visProp.sizeunit), a2 = n.evaluate(t2.visProp.zoom);
          isNaN(t2.coords.scrCoords[2] + t2.coords.scrCoords[1]) || (o2 === "user" && (r2 *= Math.sqrt(t2.board.unitX * t2.board.unitY)), r2 *= t2.board && a2 ? Math.sqrt(t2.board.zoomX * t2.board.zoomY) : 1, i2 = r2 === 0 ? 0 : r2 + 1, s2 === "o" ? this.updateEllipsePrim(t2.rendNode, t2.coords.scrCoords[1], t2.coords.scrCoords[2], i2, i2) : s2 === "[]" ? this.updateRectPrim(t2.rendNode, t2.coords.scrCoords[1] - r2, t2.coords.scrCoords[2] - r2, 2 * r2, 2 * r2) : this.updatePathPrim(t2.rendNode, this.updatePathStringPoint(t2, r2, s2), t2.board), this._updateVisual(t2, {dash: false, shadow: false}), this.setShadow(t2));
        }, changePointStyle: function(t2) {
          var e3 = this.getElementById(t2.id);
          n.exists(e3) && this.remove(e3), this.drawPoint(t2), n.clearVisPropOld(t2), t2.visPropCalc.visible || this.display(t2, false), n.evaluate(t2.visProp.draft) && this.setDraft(t2);
        }, drawLine: function(t2) {
          t2.rendNode = this.appendChildPrim(this.createPrim("line", t2.id), n.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "lines"), this.updateLine(t2);
        }, getArrowHeadData: function(t2, e3, i2) {
          var r2, o2, a2, h, l = s.eps, c = 0, d = 0, u = 0, p = 0, f = n.evaluate(t2.visProp.firstarrow), m = n.evaluate(t2.visProp.lastarrow);
          return (f || m) && (n.exists(f.type) && (r2 = n.evaluate(f.type)), n.exists(m.type) && (o2 = n.evaluate(m.type)), f && (h = 6, n.exists(f.size) && (h = n.evaluate(f.size)), i2 !== "" && n.exists(f[i2 + "size"]) && (h = n.evaluate(f[i2 + "size"])), a2 = e3 * h, r2 === 2 ? (a2 *= 0.5, l += e3 * h) : r2 === 3 ? (a2 = e3 * h / 3, l += e3) : r2 === 4 || r2 === 5 || r2 === 6 ? (a2 = e3 * h / 1.5, l += e3 * h) : l += e3 * h, c += a2, u = h), m && (h = 6, n.exists(m.size) && (h = n.evaluate(m.size)), i2 !== "" && n.exists(m[i2 + "size"]) && (h = n.evaluate(m[i2 + "size"])), a2 = e3 * h, o2 === 2 ? (a2 *= 0.5, l += e3 * h) : o2 === 3 ? (a2 = e3 * h / 3, l += e3) : o2 === 4 || o2 === 5 || o2 === 6 ? (a2 = e3 * h / 1.5, l += e3 * h) : l += e3 * h, d += a2, p = h)), {evFirst: f, evLast: m, offFirst: c, offLast: d, sizeFirst: u, sizeLast: p, showFirst: 1, showLast: 1, minLen: l, strokeWidth: e3};
        }, getPositionArrowHead: function(t2, e3, i2, s2) {
          var o2, n3, a2, h, l;
          return (s2.evFirst || s2.evLast) && (n3 = a2 = h = l = 0, o2 = e3.distance(r.COORDS_BY_SCREEN, i2), s2.evFirst && t2.board.renderer.type !== "vml" && (o2 >= s2.minLen ? (n3 = (i2.scrCoords[1] - e3.scrCoords[1]) * s2.offFirst / o2, a2 = (i2.scrCoords[2] - e3.scrCoords[2]) * s2.offFirst / o2) : s2.showFirst = 0), s2.evLast && t2.board.renderer.type !== "vml" && (o2 >= s2.minLen ? (h = (i2.scrCoords[1] - e3.scrCoords[1]) * s2.offLast / o2, l = (i2.scrCoords[2] - e3.scrCoords[2]) * s2.offLast / o2) : s2.showLast = 0), e3.setCoordinates(r.COORDS_BY_SCREEN, [e3.scrCoords[1] + n3, e3.scrCoords[2] + a2], false, true), i2.setCoordinates(r.COORDS_BY_SCREEN, [i2.scrCoords[1] - h, i2.scrCoords[2] - l], false, true)), this;
        }, handleTouchpoints: function(t2, e3, i2, s2) {
          var o2, a2, h, l, c, d, u;
          return (s2.evFirst || s2.evLast) && (h = l = c = d = u = 0, o2 = n.evaluate(t2.point1.visProp.size) + n.evaluate(t2.point1.visProp.strokewidth), a2 = n.evaluate(t2.point2.visProp.size) + n.evaluate(t2.point2.visProp.strokewidth), o2 + a2, s2.evFirst && n.evaluate(t2.visProp.touchfirstpoint) && (h = e3.distance(r.COORDS_BY_SCREEN, i2), l = (i2.scrCoords[1] - e3.scrCoords[1]) * o2 / h, c = (i2.scrCoords[2] - e3.scrCoords[2]) * o2 / h), s2.evLast && n.evaluate(t2.visProp.touchlastpoint) && (h = e3.distance(r.COORDS_BY_SCREEN, i2), d = (i2.scrCoords[1] - e3.scrCoords[1]) * a2 / h, u = (i2.scrCoords[2] - e3.scrCoords[2]) * a2 / h), e3.setCoordinates(r.COORDS_BY_SCREEN, [e3.scrCoords[1] + l, e3.scrCoords[2] + c], false, true), i2.setCoordinates(r.COORDS_BY_SCREEN, [i2.scrCoords[1] - d, i2.scrCoords[2] - u], false, true)), this;
        }, updateLineEndings: function(t2, e3) {
          var s2, a2, h = null;
          return s2 = new i(r.COORDS_BY_USER, t2.point1.coords.usrCoords, t2.board), a2 = new i(r.COORDS_BY_USER, t2.point2.coords.usrCoords, t2.board), h = n.evaluate(t2.visProp.margin), o.calcStraight(t2, s2, a2, h), this.handleTouchpoints(t2, s2, a2, e3), this.getPositionArrowHead(t2, s2, a2, e3), this.updateLinePrim(t2.rendNode, s2.scrCoords[1], s2.scrCoords[2], a2.scrCoords[1], a2.scrCoords[2], t2.board), this;
        }, updatePathEndings: function(t2, e3) {
          return n.evaluate(t2.visProp.handdrawing) ? this.updatePathPrim(t2.rendNode, this.updatePathStringBezierPrim(t2), t2.board) : this.updatePathPrim(t2.rendNode, this.updatePathStringPrim(t2), t2.board), this.shortenPath(t2.rendNode, e3.offFirst, e3.offLast), this;
        }, setArrowSize: function(t2, e3) {
          return e3.evFirst && this._setArrowWidth(t2.rendNodeTriangleStart, e3.showFirst * e3.strokeWidth, t2.rendNode, e3.sizeFirst), e3.evLast && this._setArrowWidth(t2.rendNodeTriangleEnd, e3.showLast * e3.strokeWidth, t2.rendNode, e3.sizeLast), this;
        }, updatePathWithArrowHeads: function(t2, e3) {
          var i2, s2, o2 = t2.visProp, a2 = e3 ? "highlight" : "";
          i2 = e3 && o2.highlightstrokewidth ? Math.max(n.evaluate(o2.highlightstrokewidth), n.evaluate(o2.strokewidth)) : n.evaluate(o2.strokewidth), s2 = this.getArrowHeadData(t2, i2, a2), this.makeArrows(t2), t2.elementClass === r.OBJECT_CLASS_LINE ? this.updateLineEndings(t2, s2) : t2.elementClass === r.OBJECT_CLASS_CURVE && this.updatePathEndings(t2, s2), this.setArrowSize(t2, s2);
        }, updateLine: function(t2) {
          this._updateVisual(t2), this.updatePathWithArrowHeads(t2), this.setLineCap(t2);
        }, setLineCap: function(t2) {
        }, drawTicks: function(t2) {
          t2.rendNode = this.appendChildPrim(this.createPrim("path", t2.id), n.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "path");
        }, updateTicks: function(t2) {
        }, drawCurve: function(t2) {
          t2.rendNode = this.appendChildPrim(this.createPrim("path", t2.id), n.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "path"), t2.numberPoints > 1 && this.makeArrows(t2), this._updateVisual(t2, {shadow: true}, true), this.updateCurve(t2);
        }, updateCurve: function(t2) {
          this.updatePathWithArrowHeads(t2), this._updateVisual(t2);
        }, drawEllipse: function(t2) {
          t2.rendNode = this.appendChildPrim(this.createPrim("ellipse", t2.id), n.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "ellipse"), this.updateEllipse(t2);
        }, updateEllipse: function(t2) {
          this._updateVisual(t2);
          var e3 = t2.Radius();
          e3 > 0 && Math.abs(t2.center.coords.usrCoords[0]) > s.eps && !isNaN(e3 + t2.center.coords.scrCoords[1] + t2.center.coords.scrCoords[2]) && e3 * t2.board.unitX < 2e6 && this.updateEllipsePrim(t2.rendNode, t2.center.coords.scrCoords[1], t2.center.coords.scrCoords[2], e3 * t2.board.unitX, e3 * t2.board.unitY);
        }, drawPolygon: function(t2) {
          t2.rendNode = this.appendChildPrim(this.createPrim("polygon", t2.id), n.evaluate(t2.visProp.layer)), this.appendNodesToElement(t2, "polygon"), this.updatePolygon(t2);
        }, updatePolygon: function(t2) {
          this._updateVisual(t2, {stroke: true, dash: true}), this.updatePolygonPrim(t2.rendNode, t2);
        }, displayCopyright: function(t2, e3) {
        }, drawInternalText: function(t2) {
        }, updateInternalText: function(t2) {
        }, drawText: function(t2) {
          var e3, i2, r2, s2;
          n.evaluate(t2.visProp.display) === "html" && a.isBrowser && this.type !== "no" ? (e3 = this.container.ownerDocument.createElement("div"), e3.style.position = "absolute", e3.className = n.evaluate(t2.visProp.cssclass), r2 = n.evaluate(t2.visProp.layer), n.exists(r2) || (r2 = 0), i2 = this.container.style.zIndex === "" ? 0 : parseInt(this.container.style.zIndex, 10), e3.style.zIndex = i2 + r2, this.container.appendChild(e3), e3.setAttribute("id", this.container.id + "_" + t2.id)) : e3 = this.drawInternalText(t2), t2.rendNode = e3, t2.htmlStr = "", t2.visProp.islabel && n.exists(t2.visProp.anchor) ? (s2 = n.evaluate(t2.visProp.anchor.visProp.visible), t2.prepareUpdate().updateVisibility(s2)) : t2.prepareUpdate().updateVisibility(), this.updateText(t2);
        }, updateText: function(e3) {
          var i2, r2, s2, o2, a2, h = e3.plaintext;
          if (e3.visPropCalc.visible)
            if (this.updateTextStyle(e3, false), n.evaluate(e3.visProp.display) === "html" && this.type !== "no") {
              if (isNaN(e3.coords.scrCoords[1] + e3.coords.scrCoords[2]) || (r2 = e3.coords.scrCoords[1], r2 = Math.abs(r2) < 1e6 ? r2 : 1e6, o2 = e3.getAnchorX(), i2 = o2 === "right" ? Math.floor(e3.board.canvasWidth - r2) : o2 === "middle" ? Math.floor(r2 - 0.5 * e3.size[0]) : Math.floor(r2), e3.visPropOld.left !== o2 + i2 && (o2 === "right" ? (e3.rendNode.style.right = i2 + "px", e3.rendNode.style.left = "auto") : (e3.rendNode.style.left = i2 + "px", e3.rendNode.style.right = "auto"), e3.visPropOld.left = o2 + i2), r2 = e3.coords.scrCoords[2] + this.vOffsetText, r2 = Math.abs(r2) < 1e6 ? r2 : 1e6, a2 = e3.getAnchorY(), i2 = a2 === "bottom" ? Math.floor(e3.board.canvasHeight - r2) : a2 === "middle" ? Math.floor(r2 - 0.5 * e3.size[1]) : Math.floor(r2), e3.visPropOld.top !== a2 + i2 && (a2 === "bottom" ? (e3.rendNode.style.top = "auto", e3.rendNode.style.bottom = i2 + "px") : (e3.rendNode.style.bottom = "auto", e3.rendNode.style.top = i2 + "px"), e3.visPropOld.top = a2 + i2)), e3.htmlStr !== h) {
                try {
                  e3.rendNode.innerHTML = h;
                } catch (t2) {
                  s2 = e3.rendNode.parentNode, e3.rendNode.parentNode.removeChild(e3.rendNode), e3.rendNode.innerHTML = h, s2.appendChild(e3.rendNode);
                }
                if (e3.htmlStr = h, n.evaluate(e3.visProp.usemathjax))
                  try {
                    MathJax.typeset ? MathJax.typeset([e3.rendNode]) : MathJax.Hub.Queue(["Typeset", MathJax.Hub, e3.rendNode]);
                  } catch (e4) {
                    t.debug("MathJax (not yet) loaded");
                  }
                else if (n.evaluate(e3.visProp.useasciimathml))
                  try {
                    AMprocessNode(e3.rendNode, false);
                  } catch (e4) {
                    t.debug("AsciiMathML (not yet) loaded");
                  }
              }
              this.transformImage(e3, e3.transformations);
            } else
              this.updateInternalText(e3);
        }, _css2js: function(t2) {
          var e3, i2, r2, s2, o2, a2 = [], h = n.trim(t2).replace(/;$/, "").split(";");
          for (i2 = h.length, e3 = 0; e3 < i2; ++e3)
            n.trim(h[e3]) !== "" && (o2 = h[e3].split(":"), r2 = n.trim(o2[0].replace(/-([a-z])/gi, function(t3, e4) {
              return e4.toUpperCase();
            })), s2 = n.trim(o2[1]), a2.push({key: r2, val: s2}));
          return a2;
        }, updateTextStyle: function(t2, e3) {
          var i2, r2, s2, o2, h, l, c, d, u, p = t2.visProp, f = a.isBrowser ? p.display : "internal", m = ["rendNode", "rendNodeTag", "rendNodeLabel"], g = m.length, b = ["cssdefaultstyle", "cssstyle"], v = b.length;
          if (e3 ? (s2 = p.highlightstrokecolor, r2 = p.highlightstrokeopacity, o2 = p.highlightcssclass) : (s2 = p.strokecolor, r2 = p.strokeopacity, o2 = p.cssclass), this.type !== "no" && (f === "html" || this.type !== "canvas")) {
            for (d = 0; d < v; d++)
              if ((u = n.evaluate(p[(e3 ? "highlight" : "") + b[d]])) !== "" && t2.visPropOld[b[d]] !== u) {
                for (l = this._css2js(u), h = 0; h < g; h++)
                  if (n.exists(t2[m[h]]))
                    for (c in l)
                      l.hasOwnProperty(c) && (t2[m[h]].style[l[c].key] = l[c].val);
                t2.visPropOld[b[d]] = u;
              }
            if (i2 = n.evaluate(p.fontsize), t2.visPropOld.fontsize !== i2) {
              t2.needsSizeUpdate = true;
              try {
                for (h = 0; h < g; h++)
                  n.exists(t2[m[h]]) && (t2[m[h]].style.fontSize = i2 + "px");
              } catch (e4) {
                for (h = 0; h < g; h++)
                  n.exists(t2[m[h]]) && (t2[m[h]].style.fontSize = i2);
              }
              t2.visPropOld.fontsize = i2;
            }
          }
          return this.setObjectTransition(t2), f === "html" && this.type !== "no" ? (t2.visPropOld.cssclass !== o2 && (t2.rendNode.className = o2, t2.visPropOld.cssclass = o2, t2.needsSizeUpdate = true), this.setObjectStrokeColor(t2, s2, r2)) : this.updateInternalTextStyle(t2, s2, r2), this;
        }, updateInternalTextStyle: function(t2, e3, i2) {
          this.setObjectStrokeColor(t2, e3, i2);
        }, drawImage: function(t2) {
        }, updateImage: function(t2) {
          this.updateRectPrim(t2.rendNode, t2.coords.scrCoords[1], t2.coords.scrCoords[2] - t2.size[1], t2.size[0], t2.size[1]), this.updateImageURL(t2), this.transformImage(t2, t2.transformations), this._updateVisual(t2, {stroke: true, dash: true}, true);
        }, joinTransforms: function(t2, e3) {
          var i2, r2 = t2.board.origin.scrCoords[1], o2 = t2.board.origin.scrCoords[2], n3 = t2.board.unitX, a2 = t2.board.unitY, h = e3.length, l = [[1, 0, 0], [-r2 / n3, 1 / n3, 0], [o2 / a2, 0, -1 / a2]];
          for (i2 = 0; i2 < h; i2++)
            l = s.matMatMult(e3[i2].matrix, l);
          return l = s.matMatMult([[1, 0, 0], [r2, n3, 0], [o2, 0, -a2]], l);
        }, transformImage: function(t2, e3) {
        }, updateImageURL: function(t2) {
        }, updateImageStyle: function(t2, e3) {
          t2.rendNode.className = n.evaluate(e3 ? t2.visProp.highlightcssclass : t2.visProp.cssclass);
        }, appendChildPrim: function(t2, e3) {
        }, appendNodesToElement: function(t2, e3) {
        }, createPrim: function(t2, e3) {
          return null;
        }, remove: function(t2) {
        }, makeArrows: function(t2) {
        }, _setArrowWidth: function(t2, e3, i2) {
        }, updateEllipsePrim: function(t2, e3, i2, r2, s2) {
        }, updateLinePrim: function(t2, e3, i2, r2, s2, o2) {
        }, updatePathPrim: function(t2, e3, i2) {
        }, updatePathStringPoint: function(t2, e3, i2) {
        }, updatePathStringPrim: function(t2) {
        }, updatePathStringBezierPrim: function(t2) {
        }, updatePolygonPrim: function(t2, e3) {
        }, updateRectPrim: function(t2, e3, i2, r2, s2) {
        }, setPropertyPrim: function(t2, e3, i2) {
        }, display: function(t2, e3) {
          t2 && (t2.visPropOld.visible = e3);
        }, show: function(t2) {
        }, hide: function(t2) {
        }, setBuffering: function(t2, e3) {
        }, setDashStyle: function(t2) {
        }, setDraft: function(t2) {
          if (n.evaluate(t2.visProp.draft)) {
            var e3 = t2.board.options.elements.draft.color, i2 = t2.board.options.elements.draft.opacity;
            this.setObjectTransition(t2), t2.type === r.OBJECT_TYPE_POLYGON ? this.setObjectFillColor(t2, e3, i2) : (t2.elementClass === r.OBJECT_CLASS_POINT ? this.setObjectFillColor(t2, e3, i2) : this.setObjectFillColor(t2, "none", 0), this.setObjectStrokeColor(t2, e3, i2), this.setObjectStrokeWidth(t2, t2.board.options.elements.draft.strokeWidth));
          }
        }, removeDraft: function(t2) {
          this.setObjectTransition(t2), t2.type === r.OBJECT_TYPE_POLYGON ? this.setObjectFillColor(t2, t2.visProp.fillcolor, t2.visProp.fillopacity) : (t2.type === r.OBJECT_CLASS_POINT && this.setObjectFillColor(t2, t2.visProp.fillcolor, t2.visProp.fillopacity), this.setObjectStrokeColor(t2, t2.visProp.strokecolor, t2.visProp.strokeopacity), this.setObjectStrokeWidth(t2, t2.visProp.strokewidth));
        }, setGradient: function(t2) {
        }, updateGradient: function(t2) {
        }, setObjectTransition: function(t2, e3) {
        }, setObjectFillColor: function(t2, e3, i2) {
        }, setObjectStrokeColor: function(t2, e3, i2) {
        }, setObjectStrokeWidth: function(t2, e3) {
        }, setShadow: function(t2) {
        }, highlight: function(t2) {
          var e3, i2, s2 = t2.visProp;
          if (this.setObjectTransition(t2), !s2.draft) {
            if (t2.type === r.OBJECT_TYPE_POLYGON)
              for (this.setObjectFillColor(t2, s2.highlightfillcolor, s2.highlightfillopacity), e3 = 0; e3 < t2.borders.length; e3++)
                this.setObjectStrokeColor(t2.borders[e3], t2.borders[e3].visProp.highlightstrokecolor, t2.borders[e3].visProp.highlightstrokeopacity);
            else
              t2.elementClass === r.OBJECT_CLASS_TEXT ? this.updateTextStyle(t2, true) : t2.type === r.OBJECT_TYPE_IMAGE ? (this.updateImageStyle(t2, true), this.setObjectFillColor(t2, s2.highlightfillcolor, s2.highlightfillopacity)) : (this.setObjectStrokeColor(t2, s2.highlightstrokecolor, s2.highlightstrokeopacity), this.setObjectFillColor(t2, s2.highlightfillcolor, s2.highlightfillopacity));
            s2.highlightstrokewidth && (i2 = Math.max(n.evaluate(s2.highlightstrokewidth), n.evaluate(s2.strokewidth)), this.setObjectStrokeWidth(t2, i2), t2.elementClass !== r.OBJECT_CLASS_LINE && t2.elementClass !== r.OBJECT_CLASS_CURVE || this.updatePathWithArrowHeads(t2, true));
          }
          return this;
        }, noHighlight: function(t2) {
          var e3, i2, s2 = t2.visProp;
          if (this.setObjectTransition(t2), !n.evaluate(t2.visProp.draft)) {
            if (t2.type === r.OBJECT_TYPE_POLYGON)
              for (this.setObjectFillColor(t2, s2.fillcolor, s2.fillopacity), e3 = 0; e3 < t2.borders.length; e3++)
                this.setObjectStrokeColor(t2.borders[e3], t2.borders[e3].visProp.strokecolor, t2.borders[e3].visProp.strokeopacity);
            else
              t2.elementClass === r.OBJECT_CLASS_TEXT ? this.updateTextStyle(t2, false) : t2.type === r.OBJECT_TYPE_IMAGE ? (this.updateImageStyle(t2, false), this.setObjectFillColor(t2, s2.fillcolor, s2.fillopacity)) : (this.setObjectStrokeColor(t2, s2.strokecolor, s2.strokeopacity), this.setObjectFillColor(t2, s2.fillcolor, s2.fillopacity));
            i2 = n.evaluate(s2.strokewidth), this.setObjectStrokeWidth(t2, i2), t2.elementClass !== r.OBJECT_CLASS_LINE && t2.elementClass !== r.OBJECT_CLASS_CURVE || this.updatePathWithArrowHeads(t2, false);
          }
          return this;
        }, suspendRedraw: function() {
        }, unsuspendRedraw: function() {
        }, drawZoomBar: function(t2, e3) {
          var i2, r2, s2 = function(t3) {
            t3 || (t3 = window.event), t3.stopPropagation ? t3.stopPropagation() : t3.cancelBubble = true;
          }, o2 = function(e4, o3) {
            var h;
            h = i2.createElement("span"), r2.appendChild(h), h.appendChild(i2.createTextNode(e4)), h.style.paddingLeft = "7px", h.style.paddingRight = "7px", h.classList !== void 0 && h.classList.add("JXG_navigation_button"), a.addEvent(h, "click", function(e5) {
              return n.bind(o3, t2)(), false;
            }, t2), a.addEvent(h, "mouseup", s2, t2), a.addEvent(h, "mousedown", s2, t2), a.addEvent(h, "touchend", s2, t2), a.addEvent(h, "touchstart", s2, t2);
          };
          a.isBrowser && this.type !== "no" && (i2 = t2.containerObj.ownerDocument, r2 = i2.createElement("div"), r2.setAttribute("id", t2.containerObj.id + "_navigationbar"), r2.style.color = e3.strokecolor, r2.style.backgroundColor = e3.fillcolor, r2.style.padding = e3.padding, r2.style.position = e3.position, r2.style.fontSize = e3.fontsize, r2.style.cursor = e3.cursor, r2.style.zIndex = e3.zindex, t2.containerObj.appendChild(r2), r2.style.right = e3.right, r2.style.bottom = e3.bottom, r2.classList !== void 0 && r2.classList.add("JXG_navigation"), t2.attr.showfullscreen && o2(t2.attr.fullscreen.symbol, function() {
            t2.toFullscreen();
          }), t2.attr.showscreenshot && o2(t2.attr.screenshot.symbol, function() {
            window.setTimeout(function() {
              t2.renderer.screenshot(t2, "", false);
            }, 330);
          }), t2.attr.showreload && o2("\u21BB", function() {
            t2.reload();
          }), t2.attr.showcleartraces && o2("\u2297", function() {
            t2.clearTraces();
          }), t2.attr.shownavigation && (t2.attr.showzoom && (o2("\u2013", t2.zoomOut), o2("o", t2.zoom100), o2("+", t2.zoomIn)), o2("\u2190", t2.clickLeftArrow), o2("\u2193", t2.clickUpArrow), o2("\u2191", t2.clickDownArrow), o2("\u2192", t2.clickRightArrow)));
        }, getElementById: function(t2) {
          return n.exists(this.container) ? this.container.ownerDocument.getElementById(this.container.id + "_" + t2) : "";
        }, removeToInsertLater: function(t2) {
          var e3 = t2.parentNode, i2 = t2.nextSibling;
          if (e3 !== null)
            return e3.removeChild(t2), function() {
              i2 ? e3.insertBefore(t2, i2) : e3.appendChild(t2);
            };
        }, resize: function(t2, e3) {
        }, createTouchpoints: function(t2) {
        }, showTouchpoint: function(t2) {
        }, hideTouchpoint: function(t2) {
        }, updateTouchpoint: function(t2, e3) {
        }, dumpToDataURI: function(t2) {
        }, dumpToCanvas: function(t2, e3, i2, r2) {
        }, screenshot: function(t2) {
        }, shortenPath: function(t2, e3, i2) {
        }, setLayer: function(t2, e3) {
        }}), t.AbstractRenderer;
      }), define("reader/file", ["jxg", "utils/env", "utils/type", "utils/encoding", "utils/base64"], function(t, e2, i, r, s) {
        "use strict";
        return t.FileReader = {handleRemoteFile: function(e3, o, n, a, h, l) {
          var c = false;
          try {
            c = new XMLHttpRequest(), n.toLowerCase() === "raw" ? c.overrideMimeType("text/plain; charset=" + h) : c.overrideMimeType("text/xml; charset=" + h);
          } catch (t2) {
            try {
              c = new ActiveXObject("Msxml2.XMLHTTP");
            } catch (t3) {
              try {
                c = new ActiveXObject("Microsoft.XMLHTTP");
              } catch (t4) {
                c = false;
              }
            }
          }
          if (!c)
            return void t.debug("AJAX not activated!");
          c.open("GET", e3, a), n.toLowerCase() === "raw" ? this.cbp = function() {
            var t2 = c;
            t2.readyState === 4 && o(t2.responseText);
          } : this.cbp = function() {
            var t2 = c, e4 = "";
            t2.readyState === 4 && (!i.exists(t2.responseStream) || t2.responseText.slice(0, 2) !== "PK" && r.asciiCharCodeAt(t2.responseText.slice(0, 1), 0) !== 31 ? (e4 = t2.responseText, console.log(e4)) : e4 = s.decode(jxgBinFileReader(t2)), this.parseString(e4, o, n, l));
          }, this.cb = i.bind(this.cbp, this), c.onreadystatechange = this.cb;
          try {
            c.send(null);
          } catch (t2) {
            throw new Error("JSXGraph: A problem occurred while trying to read remote file '" + e3 + "'.");
          }
        }, handleLocalFile: function(t2, e3, r2, s2, o, n) {
          i.exists(s2) || (s2 = true), r2.toLowerCase() === "raw" ? this.cbp = function(t3) {
            e3(t3.target.result);
          } : this.cbp = function(t3) {
            var i2 = t3.target.result;
            this.parseString(i2, e3, r2, n);
          }, this.cb = i.bind(this.cbp, this);
          var a = new FileReader();
          a.onload = this.cb, r2.toLowerCase() === "raw" ? a.readAsText(t2) : a.readAsText(t2, o);
        }, parseFileContent: function(t2, e3, r2, s2, o, n) {
          i.isString(t2) || FileReader === void 0 ? this.handleRemoteFile(t2, e3, r2, s2, o, n) : this.handleLocalFile(t2, e3, r2, s2, o, n);
        }, parseString: function(e3, r2, s2, o) {
          var n, a;
          if (s2 = s2.toLowerCase(), n = t.readers[s2], !i.exists(n))
            throw new Error("JSXGraph: There is no reader available for '" + s2 + "'.");
          a = new n(r2, e3), a.read(), i.isFunction(o) && o(r2);
        }}, !e2.isMetroApp() && e2.isBrowser && typeof navigator == "object" && /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && document && document.write && document.write(`<script type="text/vbscript">
Function Base64Encode(inData)
  Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  Dim cOut, sOut, I
  For I = 1 To LenB(inData) Step 3
    Dim nGroup, pOut, sGroup
    nGroup = &H10000 * AscB(MidB(inData, I, 1)) + _
      &H100 * MyASC(MidB(inData, I + 1, 1)) + MyASC(MidB(inData, I + 2, 1))
    nGroup = Oct(nGroup)
    nGroup = String(8 - Len(nGroup), "0") & nGroup
    pOut = Mid(Base64, CLng("&o" & Mid(nGroup, 1, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 3, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 5, 2)) + 1, 1) + _
      Mid(Base64, CLng("&o" & Mid(nGroup, 7, 2)) + 1, 1)
    sOut = sOut + pOut
  Next
  Select Case LenB(inData) Mod 3
    Case 1: '8 bit final
      sOut = Left(sOut, Len(sOut) - 2) + "=="
    Case 2: '16 bit final
      sOut = Left(sOut, Len(sOut) - 1) + "="
  End Select
  Base64Encode = sOut
End Function

Function MyASC(OneChar)
  If OneChar = "" Then MyASC = 0 Else MyASC = AscB(OneChar)
End Function

Function jxgBinFileReader(xhr)
    Dim byteString
    Dim b64String
    Dim i
    byteString = xhr.responseBody
    ReDim byteArray(LenB(byteString))
    For i = 1 To LenB(byteString)
        byteArray(i-1) = AscB(MidB(byteString, i, 1))
    Next
    b64String = Base64Encode(byteString)
    jxgBinFileReader = b64String
End Function
</script>
`), t.FileReader;
      }), define("parser/geonext", ["jxg", "base/constants", "utils/type"], function(t, e2, i) {
        "use strict";
        return t.GeonextParser = {replacePow: function(t2) {
          var e3, i2, r, s, o, n, a, h, l, c, d, u;
          for (t2 = t2.replace(/(\s*)\^(\s*)/g, "^"), c = t2.indexOf("^"), s = -1; c >= 0 && c < t2.length - 1; ) {
            if (s === c)
              throw new Error("JSXGraph: Error while parsing expression '" + t2 + "'");
            if (s = c, l = t2.slice(0, c), d = t2.slice(c + 1), l.charAt(l.length - 1) === ")") {
              for (e3 = 1, i2 = l.length - 2; i2 >= 0 && e3 > 0; )
                r = l.charAt(i2), r === ")" ? e3++ : r === "(" && (e3 -= 1), i2 -= 1;
              if (e3 !== 0)
                throw new Error("JSXGraph: Missing '(' in expression");
              for (o = "", a = l.substring(0, i2 + 1), h = i2; h >= 0 && a.substr(h, 1).match(/([\w\.]+)/); )
                o = RegExp.$1 + o, h -= 1;
              o += l.substring(i2 + 1, l.length), o = o.replace(/([\(\)\+\*\%\^\-\/\]\[])/g, "\\$1");
            } else
              o = "[\\w\\.]+";
            if (d.match(/^([\w\.]*\()/)) {
              for (e3 = 1, i2 = RegExp.$1.length; i2 < d.length && e3 > 0; )
                r = d.charAt(i2), r === ")" ? e3 -= 1 : r === "(" && (e3 += 1), i2 += 1;
              if (e3 !== 0)
                throw new Error("JSXGraph: Missing ')' in expression");
              n = d.substring(0, i2), n = n.replace(/([\(\)\+\*\%\^\-\/\[\]])/g, "\\$1");
            } else
              n = "[\\w\\.]+";
            u = new RegExp("(" + o + ")\\^(" + n + ")"), t2 = t2.replace(u, "pow($1,$2)"), c = t2.indexOf("^");
          }
          return t2;
        }, replaceIf: function(t2) {
          var e3, i2, r, s, o, n, a, h, l, c = "", d = null, u = null, p = null;
          if ((r = t2.indexOf("If(")) < 0)
            return t2;
          for (t2 = t2.replace(/""/g, "0"); r >= 0; ) {
            for (e3 = t2.slice(0, r), i2 = t2.slice(r + 3), o = 1, s = 0, n = -1, a = -1; s < i2.length && o > 0; )
              h = i2.charAt(s), h === ")" ? o -= 1 : h === "(" ? o += 1 : h === "," && o === 1 && (n < 0 ? n = s : a = s), s += 1;
            if (l = i2.slice(0, s - 1), i2 = i2.slice(s), n < 0)
              return "";
            if (a < 0)
              return "";
            d = l.slice(0, n), u = l.slice(n + 1, a), p = l.slice(a + 1), d = this.replaceIf(d), u = this.replaceIf(u), p = this.replaceIf(p), c += e3 + "((" + d + ")?(" + u + "):(" + p + "))", t2 = i2, d = null, u = null, r = t2.indexOf("If(");
          }
          return c += i2;
        }, replaceNameById: function(t2, e3, i2) {
          var r, s, o, n, a = 0, h = ["X", "Y", "L", "V"], l = function(t3) {
            return i2 ? "$('" + t3 + "')" : t3;
          };
          for (n = 0; n < h.length; n++)
            for (a = t2.indexOf(h[n] + "("); a >= 0; )
              a >= 0 && (r = t2.indexOf(")", a + 2)) >= 0 && (s = t2.slice(a + 2, r), s = s.replace(/\\(['"])?/g, "$1"), (o = e3.elementsByName[s]) && (t2 = t2.slice(0, a + 2) + (i2 ? "$('" : "") + l(o.id) + t2.slice(r))), r = t2.indexOf(")", a + 2), a = t2.indexOf(h[n] + "(", r);
          for (a = t2.indexOf("Dist("); a >= 0; )
            a >= 0 && (r = t2.indexOf(",", a + 5)) >= 0 && (s = t2.slice(a + 5, r), s = s.replace(/\\(['"])?/g, "$1"), (o = e3.elementsByName[s]) && (t2 = t2.slice(0, a + 5) + l(o.id) + t2.slice(r))), r = t2.indexOf(",", a + 5), a = t2.indexOf(",", r), r = t2.indexOf(")", a + 1), r >= 0 && (s = t2.slice(a + 1, r), s = s.replace(/\\(['"])?/g, "$1"), (o = e3.elementsByName[s]) && (t2 = t2.slice(0, a + 1) + l(o.id) + t2.slice(r))), r = t2.indexOf(")", a + 1), a = t2.indexOf("Dist(", r);
          for (h = ["Deg", "Rad"], n = 0; n < h.length; n++)
            for (a = t2.indexOf(h[n] + "("); a >= 0; )
              a >= 0 && (r = t2.indexOf(",", a + 4)) >= 0 && (s = t2.slice(a + 4, r), s = s.replace(/\\(['"])?/g, "$1"), (o = e3.elementsByName[s]) && (t2 = t2.slice(0, a + 4) + l(o.id) + t2.slice(r))), r = t2.indexOf(",", a + 4), a = t2.indexOf(",", r), r = t2.indexOf(",", a + 1), r >= 0 && (s = t2.slice(a + 1, r), s = s.replace(/\\(['"])?/g, "$1"), (o = e3.elementsByName[s]) && (t2 = t2.slice(0, a + 1) + l(o.id) + t2.slice(r))), r = t2.indexOf(",", a + 1), a = t2.indexOf(",", r), r = t2.indexOf(")", a + 1), r >= 0 && (s = t2.slice(a + 1, r), s = s.replace(/\\(['"])?/g, "$1"), (o = e3.elementsByName[s]) && (t2 = t2.slice(0, a + 1) + l(o.id) + t2.slice(r))), r = t2.indexOf(")", a + 1), a = t2.indexOf(h[n] + "(", r);
          return t2;
        }, replaceIdByObj: function(t2) {
          var e3 = /(X|Y|L)\(([\w_]+)\)/g;
          return t2 = t2.replace(e3, "$('$2').$1()"), e3 = /(V)\(([\w_]+)\)/g, t2 = t2.replace(e3, "$('$2').Value()"), e3 = /(Dist)\(([\w_]+),([\w_]+)\)/g, t2 = t2.replace(e3, "dist($('$2'), $('$3'))"), e3 = /(Deg)\(([\w_]+),([ \w\[\w_]+),([\w_]+)\)/g, t2 = t2.replace(e3, "deg($('$2'),$('$3'),$('$4'))"), e3 = /Rad\(([\w_]+),([\w_]+),([\w_]+)\)/g, t2 = t2.replace(e3, "rad($('$1'),$('$2'),$('$3'))"), e3 = /N\((.+)\)/g, t2 = t2.replace(e3, "($1)");
        }, geonext2JS: function(t2, e3) {
          var i2, r, s, o = ["Abs", "ACos", "ASin", "ATan", "Ceil", "Cos", "Exp", "Factorial", "Floor", "Log", "Max", "Min", "Random", "Round", "Sin", "Sqrt", "Tan", "Trunc"], n = ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "factorial", "floor", "log", "max", "min", "random", "round", "sin", "sqrt", "tan", "ceil"];
          for (t2 = t2.replace(/&lt;/g, "<"), t2 = t2.replace(/&gt;/g, ">"), t2 = t2.replace(/&amp;/g, "&"), r = t2, r = this.replaceNameById(r, e3), r = this.replaceIf(r), r = this.replacePow(r), r = this.replaceIdByObj(r), s = 0; s < o.length; s++)
            i2 = new RegExp(["(\\W|^)(", o[s], ")"].join(""), "ig"), r = r.replace(i2, ["$1", n[s]].join(""));
          return r = r.replace(/True/g, "true"), r = r.replace(/False/g, "false"), r = r.replace(/fasle/g, "false"), r = r.replace(/Pi/g, "PI"), r = r.replace(/"/g, "'");
        }, findDependencies: function(t2, r, s) {
          var o, n, a, h;
          i.exists(s) || (s = t2.board), o = s.elementsByName;
          for (n in o)
            o.hasOwnProperty(n) && n !== t2.name && (o[n].elementClass === e2.OBJECT_CLASS_TEXT ? i.evaluate(o[n].visProp.islabel) || (h = n.replace(/\[/g, "\\["), h = h.replace(/\]/g, "\\]"), a = new RegExp("\\(([\\w\\[\\]'_ ]+,)*(" + h + ")(,[\\w\\[\\]'_ ]+)*\\)", "g"), r.search(a) >= 0 && o[n].addChild(t2)) : (h = n.replace(/\[/g, "\\["), h = h.replace(/\]/g, "\\]"), a = new RegExp("\\(([\\w\\[\\]'_ ]+,)*(" + h + ")(,[\\w\\[\\]'_ ]+)*\\)", "g"), r.search(a) >= 0 && o[n].addChild(t2)));
        }, gxt2jc: function(t2, e3) {
          var i2;
          return t2 = t2.replace(/&lt;/g, "<"), t2 = t2.replace(/&gt;/g, ">"), t2 = t2.replace(/&amp;/g, "&"), i2 = t2, i2 = this.replaceNameById(i2, e3, true), i2 = i2.replace(/True/g, "true"), i2 = i2.replace(/False/g, "false"), i2 = i2.replace(/fasle/g, "false");
        }}, t.GeonextParser;
      }), define("base/element", ["jxg", "base/constants", "base/coords", "math/math", "math/statistics", "options", "parser/geonext", "utils/event", "utils/color", "utils/type"], function(t, e2, i, r, s, o, n, a, h, l) {
        "use strict";
        return t.GeometryElement = function(t2, i2, r2, s2) {
          var o2, n3, h2;
          if (this.needsUpdate = true, this.isDraggable = false, this.isReal = true, this.childElements = {}, this.hasLabel = false, this.highlighted = false, this.notExistingParents = {}, this.traces = {}, this.numTraces = 0, this.transformations = [], this.baseElement = null, this.descendants = {}, this.ancestors = {}, this.parents = [], this.symbolic = {}, this.rendNode = null, this.elType = "", this.dump = true, this.subs = {}, this.inherits = [], this._pos = -1, this.stdform = [1, 0, 0, 0, 1, 1, 0, 0], this.methodMap = {setLabel: "setLabel", label: "label", setName: "setName", getName: "getName", addTransform: "addTransform", setProperty: "setAttribute", setAttribute: "setAttribute", addChild: "addChild", animate: "animate", on: "on", off: "off", trigger: "trigger", addTicks: "addTicks", removeTicks: "removeTicks", removeAllTicks: "removeAllTicks"}, this.quadraticform = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], this.visProp = {}, this.visPropCalc = {visible: false}, a.eventify(this), this.mouseover = false, this.lastDragTime = new Date(), arguments.length > 0) {
            this.board = t2, this.type = r2, this._org_type = r2, this.elementClass = s2 || e2.OBJECT_CLASS_OTHER, this.id = i2.id, o2 = i2.name, l.exists(o2) || (o2 = this.board.generateName(this)), o2 !== "" && (this.board.elementsByName[o2] = this), this.name = o2, this.needsRegularUpdate = i2.needsregularupdate, l.clearVisPropOld(this), h2 = this.resolveShortcuts(i2);
            for (n3 in h2)
              h2.hasOwnProperty(n3) && this._set(n3, h2[n3]);
            this.visProp.draft = h2.draft && h2.draft.draft;
          }
        }, t.extend(t.GeometryElement.prototype, {addChild: function(t2) {
          var e3, i2;
          this.childElements[t2.id] = t2, this.addDescendants(t2), t2.ancestors[this.id] = this;
          for (e3 in this.descendants)
            if (this.descendants.hasOwnProperty(e3)) {
              this.descendants[e3].ancestors[this.id] = this;
              for (i2 in this.ancestors)
                this.ancestors.hasOwnProperty(i2) && (this.descendants[e3].ancestors[this.ancestors[i2].id] = this.ancestors[i2]);
            }
          for (e3 in this.ancestors)
            if (this.ancestors.hasOwnProperty(e3))
              for (i2 in this.descendants)
                this.descendants.hasOwnProperty(i2) && (this.ancestors[e3].descendants[this.descendants[i2].id] = this.descendants[i2]);
          return this;
        }, addDescendants: function(t2) {
          var e3;
          this.descendants[t2.id] = t2;
          for (e3 in t2.childElements)
            t2.childElements.hasOwnProperty(e3) && this.addDescendants(t2.childElements[e3]);
          return this;
        }, addParents: function(t2) {
          var e3, i2, r2;
          for (r2 = l.isArray(t2) ? t2 : arguments, i2 = r2.length, e3 = 0; e3 < i2; ++e3)
            l.exists(r2[e3]) && (l.isId(this.board, r2[e3]) ? this.parents.push(r2[e3]) : l.exists(r2[e3].id) && this.parents.push(r2[e3].id));
          this.parents = l.uniqueArray(this.parents);
        }, setParents: function(t2) {
          this.parents = [], this.addParents(t2);
        }, removeChild: function(t2) {
          return delete this.childElements[t2.id], this.removeDescendants(t2), delete t2.ancestors[this.id], this;
        }, removeDescendants: function(t2) {
          var e3;
          delete this.descendants[t2.id];
          for (e3 in t2.childElements)
            t2.childElements.hasOwnProperty(e3) && this.removeDescendants(t2.childElements[e3]);
          return this;
        }, countChildren: function() {
          var t2, e3, i2 = 0;
          e3 = this.childElements;
          for (t2 in e3)
            e3.hasOwnProperty(t2) && t2.indexOf("Label") < 0 && i2++;
          return i2;
        }, getName: function() {
          return this.name;
        }, addTransform: function(t2) {
          return this;
        }, draggable: function() {
          return this.isDraggable && !l.evaluate(this.visProp.fixed) && this.type !== e2.OBJECT_TYPE_GLIDER;
        }, setPosition: function(t2, i2) {
          var r2, s2, o2, n3, a2 = [];
          if (!l.exists(this.parents))
            return this;
          for (o2 = this.parents.length, s2 = 0; s2 < o2; ++s2)
            if (r2 = this.board.select(this.parents[s2]), l.isPoint(r2)) {
              if (!r2.draggable())
                return this;
              a2.push(r2);
            }
          for (i2.length === 3 && (i2 = i2.slice(1)), n3 = this.board.create("transform", i2, {type: "translate"}), o2 = a2.length, o2 > 0 ? n3.applyOnce(a2) : this.transformations.length > 0 && this.transformations[this.transformations.length - 1].isNumericMatrix ? this.transformations[this.transformations.length - 1].melt(n3) : this.addTransform(n3), s2 = 0; s2 < o2; ++s2)
            a2[s2].type === e2.OBJECT_TYPE_GLIDER && a2[s2].updateGlider();
          return this;
        }, setPositionDirectly: function(t2, r2, o2) {
          var n3 = new i(t2, r2, this.board, false), a2 = new i(t2, o2, this.board, false), h2 = s.subtract(n3.usrCoords, a2.usrCoords);
          return this.setPosition(e2.COORDS_BY_USER, h2), this;
        }, generatePolynomial: function() {
          return [];
        }, animate: function(t2, e3, i2) {
          i2 = i2 || {};
          var r2, s2, o2, n3 = this.board.attr.animationdelay, a2 = Math.ceil(e3 / n3), c = this, d = function(t3, e4, i3, r3) {
            var s3, n4;
            if (t3 = parseFloat(t3), e4 = parseFloat(e4), !isNaN(t3) && !isNaN(e4))
              for (n4 = (e4 - t3) / a2, c.animationData[i3] = [], o2 = 0; o2 < a2; o2++)
                s3 = t3 + (o2 + 1) * n4, c.animationData[i3][a2 - o2 - 1] = r3 ? Math.floor(s3) : s3;
          };
          this.animationData = {};
          for (r2 in t2)
            if (t2.hasOwnProperty(r2))
              switch (s2 = r2.toLowerCase()) {
                case "strokecolor":
                case "fillcolor":
                  !function(t3, e4, i3) {
                    var r3, s3, n4, l2, d2;
                    for (r3 = h.rgb2hsv(t3), s3 = h.rgb2hsv(e4), n4 = (s3[0] - r3[0]) / a2, l2 = (s3[1] - r3[1]) / a2, d2 = (s3[2] - r3[2]) / a2, c.animationData[i3] = [], o2 = 0; o2 < a2; o2++)
                      c.animationData[i3][a2 - o2 - 1] = h.hsv2rgb(r3[0] + (o2 + 1) * n4, r3[1] + (o2 + 1) * l2, r3[2] + (o2 + 1) * d2);
                  }(this.visProp[s2], t2[r2], s2);
                  break;
                case "size":
                  if (!l.isPoint(this))
                    break;
                  d(this.visProp[s2], t2[r2], s2, true);
                  break;
                case "strokeopacity":
                case "strokewidth":
                case "fillopacity":
                  d(this.visProp[s2], t2[r2], s2, false);
              }
          return this.animationCallback = i2.callback, this.board.addAnimation(this), this;
        }, update: function() {
          return l.evaluate(this.visProp.trace) && this.cloneToBackground(), this;
        }, updateRenderer: function() {
          return this;
        }, fullUpdate: function(t2) {
          return this.prepareUpdate().update().updateVisibility(t2).updateRenderer();
        }, setDisplayRendNode: function(t2) {
          var e3, i2, r2, s2, o2;
          if (t2 === void 0 && (t2 = this.visPropCalc.visible), t2 === this.visPropOld.visible)
            return this;
          for (this.board.renderer.display(this, t2), i2 = this.inherits.length, r2 = 0; r2 < i2; r2++)
            if (o2 = this.inherits[r2], l.isArray(o2))
              for (s2 = o2.length, e3 = 0; e3 < s2; e3++)
                l.exists(o2[e3]) && l.exists(o2[e3].rendNode) && l.evaluate(o2[e3].visProp.visible) === "inherit" && o2[e3].setDisplayRendNode(t2);
            else
              l.exists(o2) && l.exists(o2.rendNode) && l.evaluate(o2.visProp.visible) === "inherit" && o2.setDisplayRendNode(t2);
          return this.hasLabel && l.exists(this.label) && l.exists(this.label.rendNode) && l.evaluate(this.label.visProp.visible) === "inherit" && this.label.setDisplayRendNode(t2), this;
        }, hideElement: function() {
          return t.deprecated("Element.hideElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = this.visProp.visible = false, this.board.renderer.display(this, false), l.exists(this.label) && this.hasLabel && (this.label.hiddenByParent = true, this.label.visPropCalc.visible && this.label.hideElement()), this;
        }, showElement: function() {
          return t.deprecated("Element.showElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = this.visProp.visible = true, this.board.renderer.display(this, true), l.exists(this.label) && this.hasLabel && this.label.hiddenByParent && (this.label.hiddenByParent = false, this.label.visPropCalc.visible || this.label.showElement().updateRenderer()), this;
        }, updateVisibility: function(t2) {
          var e3, i2, r2, s2, o2, n3;
          if (this.needsUpdate) {
            for (t2 !== void 0 ? this.visPropCalc.visible = t2 : (n3 = l.evaluate(this.visProp.visible), l.exists(this.hiddenByParent) && this.hiddenByParent && (n3 = false), n3 !== "inherit" && (this.visPropCalc.visible = n3)), i2 = this.inherits.length, r2 = 0; r2 < i2; r2++)
              if (o2 = this.inherits[r2], l.isArray(o2))
                for (s2 = o2.length, e3 = 0; e3 < s2; e3++)
                  l.exists(o2[e3]) && l.evaluate(o2[e3].visProp.visible) === "inherit" && o2[e3].prepareUpdate().updateVisibility(this.visPropCalc.visible);
              else
                l.exists(o2) && l.evaluate(o2.visProp.visible) === "inherit" && o2.prepareUpdate().updateVisibility(this.visPropCalc.visible);
            l.exists(this.label) && l.exists(this.label.visProp) && l.evaluate(this.label.visProp.visible) && this.label.prepareUpdate().updateVisibility(this.visPropCalc.visible);
          }
          return this;
        }, _set: function(t2, e3) {
          var i2;
          if (t2 = t2.toLocaleLowerCase(), this.visProp.hasOwnProperty(t2) && t2.indexOf("color") >= 0 && l.isString(e3) && e3.length === 9 && e3.charAt(0) === "#")
            e3 = h.rgba2rgbo(e3), this.visProp[t2] = e3[0], this.visProp[t2.replace("color", "opacity")] = e3[1];
          else if (e3 === null || !l.isObject(e3) || l.exists(e3.id) || l.exists(e3.name))
            this.visProp[t2] = e3;
          else {
            this.visProp[t2] = {};
            for (i2 in e3)
              e3.hasOwnProperty(i2) && (this.visProp[t2][i2.toLocaleLowerCase()] = e3[i2]);
          }
        }, resolveShortcuts: function(t2) {
          var e3, i2;
          for (e3 in o.shortcuts)
            if (o.shortcuts.hasOwnProperty(e3) && l.exists(t2[e3]))
              for (i2 = 0; i2 < o.shortcuts[e3].length; i2++)
                l.exists(t2[o.shortcuts[e3][i2]]) || (t2[o.shortcuts[e3][i2]] = t2[e3]);
          return t2;
        }, setLabel: function(t2) {
          this.hasLabel || this.setAttribute({withlabel: true}), this.setLabelText(t2);
        }, setLabelText: function(t2) {
          return l.exists(this.label) && (t2 = t2.replace(/</g, "&lt;").replace(/>/g, "&gt;"), this.label.setText(t2)), this;
        }, setName: function(t2) {
          t2 = t2.replace(/</g, "&lt;").replace(/>/g, "&gt;"), this.elType !== "slider" && this.setLabelText(t2), this.setAttribute({name: t2});
        }, setProperty: function() {
          t.deprecated("setProperty()", "setAttribute()"), this.setAttribute.apply(this, arguments);
        }, setAttribute: function(i2) {
          var r2, s2, o2, n3, a2, c, d, u, p, f = {};
          for (r2 = 0; r2 < arguments.length; r2++)
            c = arguments[r2], l.isString(c) ? (u = c.split(":"), f[l.trim(u[0])] = l.trim(u[1])) : l.isArray(c) ? f[c[0]] = c[1] : t.extend(f, c);
          f = this.resolveShortcuts(f);
          for (r2 in f)
            if (f.hasOwnProperty(r2)) {
              if (n3 = r2.replace(/\s+/g, "").toLowerCase(), a2 = f[r2], l.isObject(a2) && l.exists(this.visProp[n3])) {
                if (this.visProp[n3] = l.merge(this.visProp[n3], a2), this.type === e2.OBJECT_TYPE_TICKS && l.exists(this.labels))
                  for (o2 = this.labels.length, s2 = 0; s2 < o2; s2++)
                    this.labels[s2].setAttribute(a2);
                else if (l.exists(this[n3]))
                  if (l.isArray(this[n3]))
                    for (s2 = 0; s2 < this[n3].length; s2++)
                      this[n3][s2].setAttribute(a2);
                  else
                    this[n3].setAttribute(a2);
                continue;
              }
              switch (p = this.visProp[n3], n3) {
                case "name":
                  p = this.name, delete this.board.elementsByName[this.name], this.name = a2, this.board.elementsByName[this.name] = this;
                  break;
                case "needsregularupdate":
                  this.needsRegularUpdate = !(a2 === "false" || a2 === false), this.board.renderer.setBuffering(this, this.needsRegularUpdate ? "auto" : "static");
                  break;
                case "labelcolor":
                  a2 = h.rgba2rgbo(a2), d = a2[1], a2 = a2[0], d === 0 && l.exists(this.label) && this.hasLabel && this.label.hideElement(), l.exists(this.label) && this.hasLabel && (this.label.visProp.strokecolor = a2, this.board.renderer.setObjectStrokeColor(this.label, a2, d)), this.elementClass === e2.OBJECT_CLASS_TEXT && (this.visProp.strokecolor = a2, this.visProp.strokeopacity = d, this.board.renderer.setObjectStrokeColor(this, a2, d));
                  break;
                case "infoboxtext":
                  l.isString(a2) ? this.infoboxText = a2 : this.infoboxText = false;
                  break;
                case "visible":
                  this.visProp.visible = a2 !== "false" && (a2 === "true" || a2), this.setDisplayRendNode(l.evaluate(this.visProp.visible)), l.evaluate(this.visProp.visible) && l.exists(this.updateSize) && this.updateSize();
                  break;
                case "face":
                  l.isPoint(this) && (this.visProp.face = a2, this.board.renderer.changePointStyle(this));
                  break;
                case "trace":
                  a2 === "false" || a2 === false ? (this.clearTrace(), this.visProp.trace = false) : this.visProp.trace = a2 !== "pause";
                  break;
                case "gradient":
                  this.visProp.gradient = a2, this.board.renderer.setGradient(this);
                  break;
                case "gradientsecondcolor":
                  a2 = h.rgba2rgbo(a2), this.visProp.gradientsecondcolor = a2[0], this.visProp.gradientsecondopacity = a2[1], this.board.renderer.updateGradient(this);
                  break;
                case "gradientsecondopacity":
                  this.visProp.gradientsecondopacity = a2, this.board.renderer.updateGradient(this);
                  break;
                case "withlabel":
                  this.visProp.withlabel = a2, l.evaluate(a2) ? (this.label || this.createLabel(), this.label.setAttribute({visible: "inherit"})) : this.label && this.hasLabel && this.label.setAttribute({visible: false}), this.hasLabel = a2;
                  break;
                case "radius":
                  this.type !== e2.OBJECT_TYPE_ANGLE && this.type !== e2.OBJECT_TYPE_SECTOR || this.setRadius(a2);
                  break;
                case "rotate":
                  (this.elementClass === e2.OBJECT_CLASS_TEXT && l.evaluate(this.visProp.display) === "internal" || this.type === e2.OBJECT_TYPE_IMAGE) && this.addRotation(a2);
                  break;
                case "ticksdistance":
                  this.type === e2.OBJECT_TYPE_TICKS && l.isNumber(a2) && (this.ticksFunction = this.makeTicksFunction(a2));
                  break;
                case "generatelabelvalue":
                  this.type === e2.OBJECT_TYPE_TICKS && l.isFunction(a2) && (this.generateLabelValue = a2);
                  break;
                case "onpolygon":
                  this.type === e2.OBJECT_TYPE_GLIDER && (this.onPolygon = !!a2);
                  break;
                case "disabled":
                  l.exists(this.rendNodeTag) && (this.rendNodeTag.disabled = !!a2);
                  break;
                case "checked":
                  l.exists(this.rendNodeTag) && (this.rendNodeCheckbox.checked = !!a2);
                  break;
                case "maxlength":
                  l.exists(this.rendNodeTag) && (this.rendNodeTag.maxlength = !!a2);
                  break;
                case "layer":
                  this.board.renderer.setLayer(this, l.evaluate(a2)), this._set(n3, a2);
                  break;
                default:
                  l.exists(this.visProp[n3]) && (!t.Validator[n3] || t.Validator[n3] && t.Validator[n3](a2) || t.Validator[n3] && l.isFunction(a2) && t.Validator[n3](a2())) && (a2 = (!a2.toLowerCase || a2.toLowerCase() !== "false") && a2, this._set(n3, a2));
              }
              this.triggerEventHandlers(["attribute:" + n3], [p, a2, this]);
            }
          return this.triggerEventHandlers(["attribute"], [f, this]), l.evaluate(this.visProp.needsregularupdate) ? this.board.update(this) : this.board.fullUpdate(), this;
        }, getProperty: function() {
          t.deprecated("getProperty()", "getAttribute()"), this.getProperty.apply(this, arguments);
        }, getAttribute: function(t2) {
          var e3;
          switch (t2 = t2.toLowerCase()) {
            case "needsregularupdate":
              e3 = this.needsRegularUpdate;
              break;
            case "labelcolor":
              e3 = this.label.visProp.strokecolor;
              break;
            case "infoboxtext":
              e3 = this.infoboxText;
              break;
            case "withlabel":
              e3 = this.hasLabel;
              break;
            default:
              e3 = this.visProp[t2];
          }
          return e3;
        }, setDash: function(t2) {
          return this.setAttribute({dash: t2}), this;
        }, prepareUpdate: function() {
          return this.needsUpdate = true, this;
        }, remove: function() {
          return this.board.renderer.remove(this.board.renderer.getElementById(this.id)), this.hasLabel && this.board.renderer.remove(this.board.renderer.getElementById(this.label.id)), this;
        }, getTextAnchor: function() {
          return new i(e2.COORDS_BY_USER, [0, 0], this.board);
        }, getLabelAnchor: function() {
          return new i(e2.COORDS_BY_USER, [0, 0], this.board);
        }, setArrow: function(t2, i2) {
          return this.visProp.firstarrow = t2, this.visProp.lastarrow = i2, i2 && (this.type = e2.OBJECT_TYPE_VECTOR, this.elType = "arrow"), this.prepareUpdate().update().updateVisibility().updateRenderer(), this;
        }, createGradient: function() {
          var t2 = l.evaluate(this.visProp.gradient);
          t2 !== "linear" && t2 !== "radial" || this.board.renderer.setGradient(this);
        }, createLabel: function() {
          var e3, i2 = this;
          return t.elements.text ? (e3 = l.deepCopy(this.visProp.label, null), e3.id = this.id + "Label", e3.isLabel = true, e3.anchor = this, e3.priv = this.visProp.priv, this.visProp.withlabel && (this.label = t.elements.text(this.board, [0, 0, function() {
            return l.isFunction(i2.name) ? i2.name() : i2.name;
          }], e3), this.label.needsUpdate = true, this.label.dump = false, this.label.fullUpdate(), this.hasLabel = true)) : t.debug("JSXGraph: Can't create label: text element is not available. Make sure you include base/text"), this;
        }, highlight: function(t2) {
          return t2 = l.def(t2, false), !l.evaluate(this.visProp.highlight) || this.highlighted && !t2 || (this.highlighted = true, this.board.highlightedObjects[this.id] = this, this.board.renderer.highlight(this)), this;
        }, noHighlight: function() {
          return this.highlighted && (this.highlighted = false, delete this.board.highlightedObjects[this.id], this.board.renderer.noHighlight(this)), this;
        }, clearTrace: function() {
          var t2;
          for (t2 in this.traces)
            this.traces.hasOwnProperty(t2) && this.board.renderer.remove(this.traces[t2]);
          return this.numTraces = 0, this;
        }, cloneToBackground: function() {
          return this;
        }, bounds: function() {
          return [0, 0, 0, 0];
        }, normalize: function() {
          return this.stdform = r.normalize(this.stdform), this;
        }, toJSON: function() {
          var t2, e3, i2 = ['{"name":', this.name];
          i2.push(', "id":' + this.id), t2 = [];
          for (e3 in this.visProp)
            this.visProp.hasOwnProperty(e3) && l.exists(this.visProp[e3]) && t2.push('"' + e3 + '":' + this.visProp[e3]);
          return i2.push(', "visProp":{' + t2.toString() + "}"), i2.push("}"), i2.join("");
        }, addRotation: function(t2) {
          var i2, r2, s2, o2, n3, a2 = this;
          return (this.elementClass === e2.OBJECT_CLASS_TEXT && l.evaluate(this.visProp.display) === "internal" || this.type === e2.OBJECT_TYPE_IMAGE) && t2 !== 0 && (i2 = this.board.create("transform", [function() {
            return -a2.X();
          }, function() {
            return -a2.Y();
          }], {type: "translate"}), r2 = this.board.create("transform", [function() {
            return a2.X();
          }, function() {
            return a2.Y();
          }], {type: "translate"}), s2 = this.board.create("transform", [function() {
            return a2.board.unitX / a2.board.unitY;
          }, function() {
            return 1;
          }], {type: "scale"}), o2 = this.board.create("transform", [function() {
            return a2.board.unitY / a2.board.unitX;
          }, function() {
            return 1;
          }], {type: "scale"}), n3 = this.board.create("transform", [function() {
            return l.evaluate(t2) * Math.PI / 180;
          }], {type: "rotate"}), i2.bindTo(this), s2.bindTo(this), n3.bindTo(this), o2.bindTo(this), r2.bindTo(this)), this;
        }, highlightStrokeColor: function(e3) {
          return t.deprecated("highlightStrokeColor()", "setAttribute()"), this.setAttribute({highlightStrokeColor: e3}), this;
        }, strokeColor: function(e3) {
          return t.deprecated("strokeColor()", "setAttribute()"), this.setAttribute({strokeColor: e3}), this;
        }, strokeWidth: function(e3) {
          return t.deprecated("strokeWidth()", "setAttribute()"), this.setAttribute({strokeWidth: e3}), this;
        }, fillColor: function(e3) {
          return t.deprecated("fillColor()", "setAttribute()"), this.setAttribute({fillColor: e3}), this;
        }, highlightFillColor: function(e3) {
          return t.deprecated("highlightFillColor()", "setAttribute()"), this.setAttribute({highlightFillColor: e3}), this;
        }, labelColor: function(e3) {
          return t.deprecated("labelColor()", "setAttribute()"), this.setAttribute({labelColor: e3}), this;
        }, dash: function(e3) {
          return t.deprecated("dash()", "setAttribute()"), this.setAttribute({dash: e3}), this;
        }, visible: function(e3) {
          return t.deprecated("visible()", "setAttribute()"), this.setAttribute({visible: e3}), this;
        }, shadow: function(e3) {
          return t.deprecated("shadow()", "setAttribute()"), this.setAttribute({shadow: e3}), this;
        }, getType: function() {
          return this.elType;
        }, getParents: function() {
          return l.isArray(this.parents) ? this.parents : [];
        }, snapToGrid: function() {
          return this;
        }, snapToPoints: function() {
          return this;
        }, getAttributes: function() {
          var t2, e3 = l.deepCopy(this.visProp), i2 = [], r2 = i2.length;
          for (e3.id = this.id, e3.name = this.name, t2 = 0; t2 < r2; t2++)
            delete e3[i2[t2]];
          return e3;
        }, hasPoint: function(t2, e3) {
          return false;
        }, addTicks: function(t2) {
          return t2.id !== "" && l.exists(t2.id) || (t2.id = this.id + "_ticks_" + (this.ticks.length + 1)), this.board.renderer.drawTicks(t2), this.ticks.push(t2), t2.id;
        }, removeAllTicks: function() {
          var t2;
          if (l.exists(this.ticks)) {
            for (t2 = this.ticks.length; t2 > 0; t2--)
              this.removeTicks(this.ticks[t2 - 1]);
            this.ticks = [], this.board.update();
          }
        }, removeTicks: function(t2) {
          var e3, i2;
          if (l.exists(this.defaultTicks) && this.defaultTicks === t2 && (this.defaultTicks = null), l.exists(this.ticks)) {
            for (e3 = this.ticks.length; e3 > 0; e3--)
              if (this.ticks[e3 - 1] === t2) {
                if (this.board.removeObject(this.ticks[e3 - 1]), this.ticks[e3 - 1].ticks)
                  for (i2 = 0; i2 < this.ticks[e3 - 1].ticks.length; i2++)
                    l.exists(this.ticks[e3 - 1].labels[i2]) && this.board.removeObject(this.ticks[e3 - 1].labels[i2]);
                delete this.ticks[e3 - 1];
                break;
              }
          }
        }, handleSnapToGrid: function(t2, i2) {
          var r2, s2, o2, n3, a2 = false, h2 = l.evaluate(this.visProp.snapsizex), c = l.evaluate(this.visProp.snapsizey);
          return l.exists(this.coords) ? (a2 = l.evaluate(this.visProp.snaptogrid) || t2 === true, a2 && (r2 = this.coords.usrCoords[1], s2 = this.coords.usrCoords[2], h2 <= 0 && this.board.defaultAxes && this.board.defaultAxes.x.defaultTicks && (o2 = this.board.defaultAxes.x.defaultTicks, h2 = o2.ticksDelta * (l.evaluate(o2.visProp.minorticks) + 1)), c <= 0 && this.board.defaultAxes && this.board.defaultAxes.y.defaultTicks && (o2 = this.board.defaultAxes.y.defaultTicks, c = o2.ticksDelta * (l.evaluate(o2.visProp.minorticks) + 1)), h2 > 0 && c > 0 && (n3 = this.board.getBoundingBox(), r2 = Math.round(r2 / h2) * h2, s2 = Math.round(s2 / c) * c, i2 || (r2 < n3[0] ? r2 += h2 : r2 > n3[2] && (r2 -= h2), s2 < n3[3] ? s2 += c : s2 > n3[1] && (s2 -= c)), this.coords.setCoordinates(e2.COORDS_BY_USER, [r2, s2]))), this) : this;
        }, getBoundingBox: function() {
          var t2, i2, r2, s2, o2, n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (this.type === e2.OBJECT_TYPE_POLYGON) {
            if ((i2 = this.vertices.length - 1) <= 0)
              return n3;
            for (t2 = 0; t2 < i2; t2++)
              r2 = this.vertices[t2].X(), n3[0] = r2 < n3[0] ? r2 : n3[0], n3[2] = r2 > n3[2] ? r2 : n3[2], r2 = this.vertices[t2].Y(), n3[1] = r2 < n3[1] ? r2 : n3[1], n3[3] = r2 > n3[3] ? r2 : n3[3];
          } else if (this.elementClass === e2.OBJECT_CLASS_CIRCLE)
            s2 = this.center.X(), o2 = this.center.Y(), n3 = [s2 - this.radius, o2 + this.radius, s2 + this.radius, o2 - this.radius];
          else if (this.elementClass === e2.OBJECT_CLASS_CURVE) {
            if ((i2 = this.vertices.length) === 0)
              return n3;
            for (t2 = 0; t2 < i2; t2++)
              r2 = this.points[t2].coords.usrCoords[1], n3[0] = r2 < n3[0] ? r2 : n3[0], n3[2] = r2 > n3[2] ? r2 : n3[2], r2 = this.points[t2].coords.usrCoords[1], n3[1] = r2 < n3[1] ? r2 : n3[1], n3[3] = r2 > n3[3] ? r2 : n3[3];
          }
          return n3;
        }, addEvent: t.shortcut(t.GeometryElement.prototype, "on"), removeEvent: t.shortcut(t.GeometryElement.prototype, "off"), __evt__over: function(t2) {
        }, __evt__mouseover: function(t2) {
        }, __evt__out: function(t2) {
        }, __evt__mouseout: function(t2) {
        }, __evt__move: function(t2) {
        }, __evt__mousemove: function(t2) {
        }, __evt__drag: function(t2) {
        }, __evt__mousedrag: function(t2) {
        }, __evt__pendrag: function(t2) {
        }, __evt__touchdrag: function(t2) {
        }, __evt__down: function(t2) {
        }, __evt__mousedown: function(t2) {
        }, __evt__pendown: function(t2) {
        }, __evt__touchdown: function(t2) {
        }, __evt__up: function(t2) {
        }, __evt__mouseup: function(t2) {
        }, __evt__penup: function(t2) {
        }, __evt__touchup: function(t2) {
        }, __evt__attribute: function(t2, e3) {
        }, __evt__attribute_: function(t2, e3, i2) {
        }, __evt: function() {
        }}), t.GeometryElement;
      }), define("base/transformation", ["jxg", "base/constants", "math/math", "utils/type"], function(t, e2, i, r) {
        "use strict";
        return t.Transformation = function(t2, i2, r2) {
          this.elementClass = e2.OBJECT_CLASS_OTHER, this.type = e2.OBJECT_TYPE_TRANSFORMATION, this.matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], this.board = t2, this.isNumericMatrix = false, this.setMatrix(t2, i2, r2), this.methodMap = {apply: "apply", applyOnce: "applyOnce", bindTo: "bindTo", bind: "bind", melt: "melt"};
        }, t.Transformation.prototype = {}, t.extend(t.Transformation.prototype, {update: function() {
          return this;
        }, setMatrix: function(t2, e3, s) {
          var o;
          for (this.isNumericMatrix = true, o = 0; o < s.length; o++)
            if (typeof s[o] != "number") {
              this.isNumericMatrix = false;
              break;
            }
          if (e3 === "translate") {
            if (s.length !== 2)
              throw new Error("JSXGraph: translate transformation needs 2 parameters.");
            this.evalParam = r.createEvalFunction(t2, s, 2), this.update = function() {
              this.matrix[1][0] = this.evalParam(0), this.matrix[2][0] = this.evalParam(1);
            };
          } else if (e3 === "scale") {
            if (s.length !== 2)
              throw new Error("JSXGraph: scale transformation needs 2 parameters.");
            this.evalParam = r.createEvalFunction(t2, s, 2), this.update = function() {
              this.matrix[1][1] = this.evalParam(0), this.matrix[2][2] = this.evalParam(1);
            };
          } else if (e3 === "reflect")
            s.length < 4 && (s[0] = t2.select(s[0])), s.length === 2 && (s[1] = t2.select(s[1])), s.length === 4 && (this.evalParam = r.createEvalFunction(t2, s, 4)), this.update = function() {
              var t3, e4, r2, o2, n, a, h, l;
              s.length === 1 ? h = s[0].stdform : s.length === 2 ? h = i.crossProduct(s[1].coords.usrCoords, s[0].coords.usrCoords) : s.length === 4 && (h = i.crossProduct([1, this.evalParam(2), this.evalParam(3)], [1, this.evalParam(0), this.evalParam(1)])), t3 = h[1], e4 = h[2], r2 = h[0], l = [-r2 * t3, -r2 * e4, t3 * t3 + e4 * e4], a = l[2], o2 = l[0] / l[2], n = l[1] / l[2], t3 = -h[2], e4 = h[1], this.matrix[1][1] = (t3 * t3 - e4 * e4) / a, this.matrix[1][2] = 2 * t3 * e4 / a, this.matrix[2][1] = this.matrix[1][2], this.matrix[2][2] = -this.matrix[1][1], this.matrix[1][0] = o2 * (1 - this.matrix[1][1]) - n * this.matrix[1][2], this.matrix[2][0] = n * (1 - this.matrix[2][2]) - o2 * this.matrix[2][1];
            };
          else if (e3 === "rotate")
            s.length === 3 ? this.evalParam = r.createEvalFunction(t2, s, 3) : s.length > 0 && s.length <= 2 && (this.evalParam = r.createEvalFunction(t2, s, 1), s.length !== 2 || r.isArray(s[1]) || (s[1] = t2.select(s[1]))), this.update = function() {
              var t3, e4, i2 = this.evalParam(0), o2 = Math.cos(i2), n = Math.sin(i2);
              this.matrix[1][1] = o2, this.matrix[1][2] = -n, this.matrix[2][1] = n, this.matrix[2][2] = o2, s.length > 1 && (s.length === 3 ? (t3 = this.evalParam(1), e4 = this.evalParam(2)) : r.isArray(s[1]) ? (t3 = s[1][0], e4 = s[1][1]) : (t3 = s[1].X(), e4 = s[1].Y()), this.matrix[1][0] = t3 * (1 - o2) + e4 * n, this.matrix[2][0] = e4 * (1 - o2) - t3 * n);
            };
          else if (e3 === "shear") {
            if (s.length !== 2)
              throw new Error("JSXGraph: shear transformation needs 2 parameters.");
            this.evalParam = r.createEvalFunction(t2, s, 2), this.update = function() {
              this.matrix[1][2] = this.evalParam(0), this.matrix[2][1] = this.evalParam(1);
            };
          } else if (e3 === "generic") {
            if (s.length !== 9)
              throw new Error("JSXGraph: generic transformation needs 9 parameters.");
            this.evalParam = r.createEvalFunction(t2, s, 9), this.update = function() {
              this.matrix[0][0] = this.evalParam(0), this.matrix[0][1] = this.evalParam(1), this.matrix[0][2] = this.evalParam(2), this.matrix[1][0] = this.evalParam(3), this.matrix[1][1] = this.evalParam(4), this.matrix[1][2] = this.evalParam(5), this.matrix[2][0] = this.evalParam(6), this.matrix[2][1] = this.evalParam(7), this.matrix[2][2] = this.evalParam(8);
            };
          }
        }, apply: function(t2, e3) {
          return this.update(), r.exists(e3) ? i.matVecMult(this.matrix, t2.initialCoords.usrCoords) : i.matVecMult(this.matrix, t2.coords.usrCoords);
        }, applyOnce: function(t2) {
          var s, o, n;
          for (r.isArray(t2) || (t2 = [t2]), o = t2.length, n = 0; n < o; n++)
            this.update(), s = i.matVecMult(this.matrix, t2[n].coords.usrCoords), t2[n].coords.setCoordinates(e2.COORDS_BY_USER, s);
        }, bindTo: function(t2) {
          var e3, i2;
          if (r.isArray(t2))
            for (i2 = t2.length, e3 = 0; e3 < i2; e3++)
              t2[e3].transformations.push(this);
          else
            t2.transformations.push(this);
        }, setProperty: function(e3) {
          t.deprecated("Transformation.setProperty()", "Transformation.setAttribute()");
        }, setAttribute: function(t2) {
        }, melt: function(t2) {
          var e3, i2, r2, s, o, n, a = [];
          for (i2 = t2.matrix.length, r2 = this.matrix[0].length, e3 = 0; e3 < i2; e3++)
            a[e3] = [];
          for (this.update(), t2.update(), e3 = 0; e3 < i2; e3++)
            for (n = 0; n < r2; n++) {
              for (o = 0, s = 0; s < i2; s++)
                o += t2.matrix[e3][s] * this.matrix[s][n];
              a[e3][n] = o;
            }
          return this.update = function() {
            var t3 = this.matrix.length, i3 = this.matrix[0].length;
            for (e3 = 0; e3 < t3; e3++)
              for (n = 0; n < i3; n++)
                this.matrix[e3][n] = a[e3][n];
          }, this;
        }, getParents: function() {
          var t2 = [[].concat.apply([], this.matrix)];
          return this.parents.length !== 0 && (t2 = this.parents), t2;
        }}), t.createTransform = function(e3, i2, r2) {
          return new t.Transformation(e3, r2.type, i2);
        }, t.registerElement("transform", t.createTransform), {Transformation: t.Transformation, createTransform: t.createTransform};
      }), define("base/coordselement", ["jxg", "options", "math/math", "math/geometry", "math/numerics", "math/statistics", "base/coords", "base/constants", "base/element", "parser/geonext", "utils/type", "base/transformation"], function(t, e2, i, r, s, o, n, a, h, l, c, d) {
        "use strict";
        return t.CoordsElement = function(t2, e3) {
          var i2;
          for (c.exists(t2) || (t2 = [1, 0, 0]), i2 = 0; i2 < t2.length; ++i2)
            t2[i2] = parseFloat(t2[i2]);
          this.coords = new n(a.COORDS_BY_USER, t2, this.board), this.initialCoords = new n(a.COORDS_BY_USER, t2, this.board), this.position = null, this.onPolygon = false, this.slideObject = null, this.slideObjects = [], this.needsUpdateFromParent = true, this.updateConstraint = function() {
            return this;
          }, this.groups = [], this.Xjc = null, this.Yjc = null, this.methodMap = c.deepCopy(this.methodMap, {move: "moveTo", moveTo: "moveTo", moveAlong: "moveAlong", visit: "visit", glide: "makeGlider", makeGlider: "makeGlider", intersect: "makeIntersection", makeIntersection: "makeIntersection", X: "X", Y: "Y", free: "free", setPosition: "setGliderPosition", setGliderPosition: "setGliderPosition", addConstraint: "addConstraint", dist: "Dist", onPolygon: "onPolygon"}), c.exists(this.element) && this.addAnchor(t2, e3), this.isDraggable = true;
        }, t.extend(t.CoordsElement.prototype, {updateCoords: function(t2) {
          return this.needsUpdate ? (c.exists(t2) || (t2 = false), this.type === a.OBJECT_TYPE_GLIDER && (t2 ? this.updateGliderFromParent() : this.updateGlider()), c.evaluate(this.visProp.frozen) || this.updateConstraint(), this.updateTransform(), this) : this;
        }, updateGlider: function() {
          var t2, e3, s2, o2, h2, l2, d2, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S, O = 2 * Math.PI, w = false, T = this.slideObject, N = [];
          if (this.needsUpdateFromParent = false, T.elementClass === a.OBJECT_CLASS_CIRCLE)
            c.evaluate(this.visProp.isgeonext) && (O = 1), C = r.projectPointToCircle(this, T, this.board), _4 = r.rad([T.center.X() + 1, T.center.Y()], T.center, this) / O;
          else if (T.elementClass === a.OBJECT_CLASS_LINE) {
            if (this.onPolygon) {
              if (e3 = T.point1.coords.usrCoords, s2 = T.point2.coords.usrCoords, t2 = 1, o2 = s2[t2] - e3[t2], Math.abs(o2) < i.eps && (t2 = 2, o2 = s2[t2] - e3[t2]), d2 = r.projectPointToLine(this, T, this.board), u = (d2.usrCoords[t2] - e3[t2]) / o2, l2 = T.parentPolygon, u < 0) {
                for (t2 = 0; t2 < l2.borders.length; t2++)
                  if (T === l2.borders[t2]) {
                    T = l2.borders[(t2 - 1 + l2.borders.length) % l2.borders.length];
                    break;
                  }
              } else if (u > 1) {
                for (t2 = 0; t2 < l2.borders.length; t2++)
                  if (T === l2.borders[t2]) {
                    T = l2.borders[(t2 + 1 + l2.borders.length) % l2.borders.length];
                    break;
                  }
              }
              T.id !== this.slideObject.id && (this.slideObject = T);
            }
            e3 = T.point1.coords, s2 = T.point2.coords, o2 = e3.distance(a.COORDS_BY_USER, s2), o2 < i.eps ? (C = e3, w = true, _4 = 0) : (C = r.projectPointToLine(this, T, this.board), e3 = e3.usrCoords.slice(0), s2 = s2.usrCoords.slice(0), Math.abs(s2[0]) < i.eps ? (t2 = 1, o2 = s2[t2], Math.abs(o2) < i.eps && (t2 = 2, o2 = s2[t2]), o2 = (C.usrCoords[t2] - e3[t2]) / o2, p = o2 >= 0 ? 1 : -1, o2 = Math.abs(o2), _4 = p * o2 / (o2 + 1)) : Math.abs(e3[0]) < i.eps ? (t2 = 1, o2 = e3[t2], Math.abs(o2) < i.eps && (t2 = 2, o2 = e3[t2]), o2 = (C.usrCoords[t2] - s2[t2]) / o2, _4 = o2 < 0 ? (1 - 2 * o2) / (1 - o2) : 1 / (o2 + 1)) : (t2 = 1, o2 = s2[t2] - e3[t2], Math.abs(o2) < i.eps && (t2 = 2, o2 = s2[t2] - e3[t2]), _4 = (C.usrCoords[t2] - e3[t2]) / o2)), P2 = c.evaluate(this.visProp.snapwidth), c.evaluate(P2) > 0 && Math.abs(this._smax - this._smin) >= i.eps && (_4 = Math.max(Math.min(_4, 1), 0), h2 = _4 * (this._smax - this._smin) + this._smin, h2 = Math.round(h2 / P2) * P2, _4 = (h2 - this._smin) / (this._smax - this._smin), this.update(true)), e3 = T.point1.coords, !c.evaluate(T.visProp.straightfirst) && Math.abs(e3.usrCoords[0]) > i.eps && _4 < 0 && (C = e3, w = true, _4 = 0), s2 = T.point2.coords, !c.evaluate(T.visProp.straightlast) && Math.abs(s2.usrCoords[0]) > i.eps && _4 > 1 && (C = s2, w = true, _4 = 1);
          } else if (T.type === a.OBJECT_TYPE_TURTLE)
            this.updateConstraint(), C = r.projectPointToTurtle(this, T, this.board), _4 = this.position;
          else if (T.elementClass === a.OBJECT_CLASS_CURVE)
            if (T.type === a.OBJECT_TYPE_ARC || T.type === a.OBJECT_TYPE_SECTOR)
              C = r.projectPointToCircle(this, T, this.board), g = r.rad(T.radiuspoint, T.center, this), f = 0, m = r.rad(T.radiuspoint, T.center, T.anglepoint), _4 = g, P2 = c.evaluate(T.visProp.selection), (P2 === "minor" && m > Math.PI || P2 === "major" && m < Math.PI) && (f = m, m = 2 * Math.PI), (g < f || g > m) && (_4 = m, (g < f && g > 0.5 * f || g > m && g > 0.5 * m + Math.PI) && (_4 = f), this.needsUpdateFromParent = true, this.updateGliderFromParent()), O = m - f, this.visProp.isgeonext && (O = 1), Math.abs(O) > i.eps && (_4 /= O);
            else if (this.updateConstraint(), T.transformations.length > 0) {
              for (S = false, E = T.getTransformationSource(), E[0] && (S = E[0], N.push(T), N.push(E[1])); E[0] && c.exists(E[1]._transformationSource); )
                E = E[1].getTransformationSource(), N.push(E[1]);
              if (x = this.coords.usrCoords, S) {
                for (t2 = 0; t2 < N.length; t2++)
                  N[t2].updateTransformMatrix(), y = i.inverse(N[t2].transformMat), x = i.matVecMult(y, x);
                for (b = new n(a.COORDS_BY_USER, x, this.board).usrCoords, v = r.projectCoordsToCurve(b[1], b[2], this.position || 0, N[N.length - 1], this.board), x = v[0].usrCoords, t2 = N.length - 2; t2 >= 0; t2--)
                  x = i.matVecMult(N[t2].transformMat, x);
                v[0] = new n(a.COORDS_BY_USER, x, this.board);
              } else
                T.updateTransformMatrix(), y = i.inverse(T.transformMat), x = i.matVecMult(y, x), b = new n(a.COORDS_BY_USER, x, this.board).usrCoords, v = r.projectCoordsToCurve(b[1], b[2], this.position || 0, T, this.board);
              C = v[0], _4 = v[1];
            } else
              C = r.projectPointToCurve(this, T, this.board), _4 = this.position;
          else
            c.isPoint(T) && (C = r.projectPointToPoint(this, T, this.board), _4 = this.position);
          this.coords.setCoordinates(a.COORDS_BY_USER, C.usrCoords, w), this.position = _4;
        }, updateGliderFromParent: function() {
          var t2, e3, s2, o2, h2, l2, d2, u, p, f, m, g, b = this.slideObject, v = [], y = 2 * Math.PI;
          if (!this.needsUpdateFromParent)
            return void (this.needsUpdateFromParent = true);
          if (b.elementClass === a.OBJECT_CLASS_CIRCLE)
            s2 = b.Radius(), c.evaluate(this.visProp.isgeonext) && (y = 1), h2 = [b.center.X() + s2 * Math.cos(this.position * y), b.center.Y() + s2 * Math.sin(this.position * y)];
          else if (b.elementClass === a.OBJECT_CLASS_LINE)
            t2 = b.point1.coords.usrCoords, e3 = b.point2.coords.usrCoords, t2[0] === 0 && t2[1] === 0 && t2[2] === 0 || e3[0] === 0 && e3[1] === 0 && e3[2] === 0 ? h2 = [0, 0, 0] : Math.abs(e3[0]) < i.eps ? (o2 = Math.min(Math.abs(this.position), 1 - i.eps), o2 /= 1 - o2, this.position < 0 && (o2 = -o2), h2 = [t2[0] + o2 * e3[0], t2[1] + o2 * e3[1], t2[2] + o2 * e3[2]]) : Math.abs(t2[0]) < i.eps ? (o2 = Math.max(this.position, i.eps), o2 = Math.min(o2, 2 - i.eps), o2 = o2 > 1 ? (o2 - 1) / (o2 - 2) : (1 - o2) / o2, h2 = [e3[0] + o2 * t2[0], e3[1] + o2 * t2[1], e3[2] + o2 * t2[2]]) : (o2 = this.position, h2 = [t2[0] + o2 * (e3[0] - t2[0]), t2[1] + o2 * (e3[1] - t2[1]), t2[2] + o2 * (e3[2] - t2[2])]);
          else if (b.type === a.OBJECT_TYPE_TURTLE)
            this.coords.setCoordinates(a.COORDS_BY_USER, [b.Z(this.position), b.X(this.position), b.Y(this.position)]), this.updateConstraint(), h2 = r.projectPointToTurtle(this, b, this.board).usrCoords;
          else if (b.elementClass === a.OBJECT_CLASS_CURVE) {
            for (u = false, l2 = b.getTransformationSource(), l2[0] && (u = l2[0], v.push(b), v.push(l2[1])); l2[0] && c.exists(l2[1]._transformationSource); )
              l2 = l2[1].getTransformationSource(), v.push(l2[1]);
            if (u ? this.coords.setCoordinates(a.COORDS_BY_USER, [v[v.length - 1].Z(this.position), v[v.length - 1].X(this.position), v[v.length - 1].Y(this.position)]) : this.coords.setCoordinates(a.COORDS_BY_USER, [b.Z(this.position), b.X(this.position), b.Y(this.position)]), b.type === a.OBJECT_TYPE_ARC || b.type === a.OBJECT_TYPE_SECTOR)
              p = r.rad([b.center.X() + 1, b.center.Y()], b.center, b.radiuspoint), f = 0, g = r.rad(b.radiuspoint, b.center, b.anglepoint), (b.visProp.selection === "minor" && g > Math.PI || b.visProp.selection === "major" && g < Math.PI) && (f = g, g = 2 * Math.PI), y = g - f, c.evaluate(this.visProp.isgeonext) && (y = 1), m = this.position * y, (m < f || m > g) && (m = g, (m < f && m > 0.5 * f || m > g && m > 0.5 * g + Math.PI) && (m = f), this.position = m, Math.abs(y) > i.eps && (this.position /= y)), s2 = b.Radius(), h2 = [b.center.X() + s2 * Math.cos(this.position * y + p), b.center.Y() + s2 * Math.sin(this.position * y + p)];
            else if (this.updateConstraint(), u)
              for (h2 = r.projectPointToCurve(this, v[v.length - 1], this.board).usrCoords, d2 = v.length - 2; d2 >= 0; d2--)
                h2 = new n(a.COORDS_BY_USER, i.matVecMult(v[d2].transformMat, h2), this.board).usrCoords;
            else
              h2 = r.projectPointToCurve(this, b, this.board).usrCoords;
          } else
            c.isPoint(b) && (h2 = r.projectPointToPoint(this, b, this.board).usrCoords);
          this.coords.setCoordinates(a.COORDS_BY_USER, h2, false);
        }, updateRendererGeneric: function(t2) {
          return this.needsUpdate ? (this.visPropCalc.visible && (this.isReal = !isNaN(this.coords.usrCoords[1] + this.coords.usrCoords[2]), this.isReal = Math.abs(this.coords.usrCoords[0]) > i.eps && this.isReal, this.isReal || this.updateVisibility(false)), this.visPropCalc.visible && this.board.renderer[t2](this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
        }, X: function() {
          return this.coords.usrCoords[1];
        }, Y: function() {
          return this.coords.usrCoords[2];
        }, Z: function() {
          return this.coords.usrCoords[0];
        }, XEval: function() {
          return this.coords.usrCoords[1];
        }, YEval: function() {
          return this.coords.usrCoords[2];
        }, ZEval: function() {
          return this.coords.usrCoords[0];
        }, Dist: function(t2) {
          return this.isReal && t2.isReal ? this.coords.distance(a.COORDS_BY_USER, t2.coords) : NaN;
        }, snapToGrid: function(t2) {
          return this.handleSnapToGrid(t2);
        }, handleSnapToPoints: function(t2) {
          var e3, i2, s2, o2, n3, h2, l2, d2, u = 0, p = 1 / 0, f = null, m = c.evaluate(this.visProp.ignoredsnaptopoints), g = false;
          if (o2 = this.board.objectsList.length, m && (l2 = m.length), c.evaluate(this.visProp.snaptopoints) || t2) {
            for (n3 = c.evaluate(this.visProp.attractorunit), h2 = c.evaluate(this.visProp.attractordistance), e3 = 0; e3 < o2; e3++) {
              if (i2 = this.board.objectsList[e3], m) {
                for (g = false, d2 = 0; d2 < l2; d2++)
                  if (i2 === this.board.select(m[d2])) {
                    g = true;
                    break;
                  }
                if (g)
                  continue;
              }
              c.isPoint(i2) && i2 !== this && i2.visPropCalc.visible && (s2 = r.projectPointToPoint(this, i2, this.board), (u = n3 === "screen" ? s2.distance(a.COORDS_BY_SCREEN, this.coords) : s2.distance(a.COORDS_BY_USER, this.coords)) < h2 && u < p && (p = u, f = s2));
            }
            f !== null && this.coords.setCoordinates(a.COORDS_BY_USER, f.usrCoords);
          }
          return this;
        }, snapToPoints: function(t2) {
          return this.handleSnapToPoints(t2);
        }, handleAttractors: function() {
          var t2, e3, i2, s2, o2 = 0, h2 = c.evaluate(this.visProp.attractorunit), l2 = c.evaluate(this.visProp.attractordistance), d2 = c.evaluate(this.visProp.snatchdistance), u = c.evaluate(this.visProp.attractors), p = u.length;
          if (l2 !== 0) {
            for (t2 = 0; t2 < p; t2++)
              if (e3 = this.board.select(u[t2]), c.exists(e3) && e3 !== this) {
                if (c.isPoint(e3) ? i2 = r.projectPointToPoint(this, e3, this.board) : e3.elementClass === a.OBJECT_CLASS_LINE ? (s2 = r.projectCoordsToSegment(this.coords.usrCoords, e3.point1.coords.usrCoords, e3.point2.coords.usrCoords), i2 = !c.evaluate(e3.visProp.straightfirst) && s2[1] < 0 ? e3.point1.coords : !c.evaluate(e3.visProp.straightlast) && s2[1] > 1 ? e3.point2.coords : new n(a.COORDS_BY_USER, s2[0], this.board)) : e3.elementClass === a.OBJECT_CLASS_CIRCLE ? i2 = r.projectPointToCircle(this, e3, this.board) : e3.elementClass === a.OBJECT_CLASS_CURVE ? i2 = r.projectPointToCurve(this, e3, this.board) : e3.type === a.OBJECT_TYPE_TURTLE && (i2 = r.projectPointToTurtle(this, e3, this.board)), (o2 = h2 === "screen" ? i2.distance(a.COORDS_BY_SCREEN, this.coords) : i2.distance(a.COORDS_BY_USER, this.coords)) < l2) {
                  this.type === a.OBJECT_TYPE_GLIDER && this.slideObject === e3 || this.makeGlider(e3);
                  break;
                }
                e3 === this.slideObject && o2 >= d2 && this.popSlideObject();
              }
            return this;
          }
        }, setPositionDirectly: function(t2, e3) {
          var r2, s2, h2, l2, d2 = this.coords;
          if (this.relativeCoords)
            return s2 = new n(t2, e3, this.board), c.evaluate(this.visProp.islabel) ? (h2 = o.subtract(s2.scrCoords, d2.scrCoords), this.relativeCoords.scrCoords[1] += h2[1], this.relativeCoords.scrCoords[2] += h2[2]) : (h2 = o.subtract(s2.usrCoords, d2.usrCoords), this.relativeCoords.usrCoords[1] += h2[1], this.relativeCoords.usrCoords[2] += h2[2]), this;
          for (this.coords.setCoordinates(t2, e3), this.handleSnapToGrid(), this.handleSnapToPoints(), this.handleAttractors(), r2 = this.transformations.length - 1; r2 >= 0; r2--)
            t2 === a.COORDS_BY_SCREEN ? l2 = new n(t2, e3, this.board).usrCoords : (e3.length === 2 && (e3 = [1].concat(e3)), l2 = e3), this.initialCoords.setCoordinates(a.COORDS_BY_USER, i.matVecMult(i.inverse(this.transformations[r2].matrix), l2));
          return this.prepareUpdate().update(), this.board.isSuspendedUpdate && this.type === a.OBJECT_TYPE_GLIDER && this.updateGlider(), this;
        }, setPositionByTransform: function(t2, e3) {
          var i2;
          return e3 = new n(t2, e3, this.board), i2 = this.board.create("transform", e3.usrCoords.slice(1), {type: "translate"}), this.transformations.length > 0 && this.transformations[this.transformations.length - 1].isNumericMatrix ? this.transformations[this.transformations.length - 1].melt(i2) : this.addTransform(this, i2), this.prepareUpdate().update(), this;
        }, setPosition: function(t2, e3) {
          return this.setPositionDirectly(t2, e3);
        }, setGliderPosition: function(t2) {
          return this.type === a.OBJECT_TYPE_GLIDER && (this.position = t2, this.board.update()), this;
        }, makeGlider: function(e3) {
          var i2, r2, s2, o2 = this.board.select(e3), n3 = false;
          if (o2.type === a.OBJECT_TYPE_POLYGON) {
            for (i2 = Number.MAX_VALUE, r2 = 0; r2 < o2.borders.length; r2++)
              (s2 = t.Math.Geometry.distPointLine(this.coords.usrCoords, o2.borders[r2].stdform)) < i2 && (i2 = s2, e3 = o2.borders[r2]);
            o2 = this.board.select(e3), n3 = true;
          }
          if (!c.exists(o2))
            throw new Error("JSXGraph: slide object undefined.");
          if (o2.type === a.OBJECT_TYPE_TICKS)
            throw new Error("JSXGraph: gliders on ticks are not possible.");
          return this.slideObject = this.board.select(e3), this.slideObjects.push(this.slideObject), this.addParents(e3), this.type = a.OBJECT_TYPE_GLIDER, this.elType = "glider", this.visProp.snapwidth = -1, this.slideObject.addChild(this), this.isDraggable = true, this.onPolygon = n3, this.generatePolynomial = function() {
            return this.slideObject.generatePolynomial(this);
          }, this.updateGlider(), this.needsUpdateFromParent = true, this.updateGliderFromParent(), this;
        }, popSlideObject: function() {
          this.slideObjects.length > 0 && (this.slideObjects.pop(), this.slideObject.removeChild(this), this.slideObjects.length === 0 ? (this.type = this._org_type, this.type === a.OBJECT_TYPE_POINT ? this.elType = "point" : this.elementClass === a.OBJECT_CLASS_TEXT ? this.elType = "text" : this.type === a.OBJECT_TYPE_IMAGE && (this.elType = "image"), this.slideObject = null) : this.slideObject = this.slideObjects[this.slideObjects.length - 1]);
        }, free: function() {
          var t2, e3;
          if (this.type !== a.OBJECT_TYPE_GLIDER) {
            if (this.transformations.length = 0, this.updateConstraint = function() {
              return this;
            }, this.isDraggable)
              return;
            this.isDraggable = true, this.elementClass === a.OBJECT_CLASS_POINT && (this.type = a.OBJECT_TYPE_POINT, this.elType = "point"), this.XEval = function() {
              return this.coords.usrCoords[1];
            }, this.YEval = function() {
              return this.coords.usrCoords[2];
            }, this.ZEval = function() {
              return this.coords.usrCoords[0];
            }, this.Xjc = null, this.Yjc = null;
          }
          for (t2 in this.board.objects)
            this.board.objects.hasOwnProperty(t2) && (e3 = this.board.objects[t2], e3.descendants && (delete e3.descendants[this.id], delete e3.childElements[this.id], this.hasLabel && (delete e3.descendants[this.label.id], delete e3.childElements[this.label.id])));
          this.ancestors = {}, this.slideObject = null, this.slideObjects = [], this.elementClass === a.OBJECT_CLASS_POINT ? (this.type = a.OBJECT_TYPE_POINT, this.elType = "point") : this.elementClass === a.OBJECT_CLASS_TEXT ? (this.type = this._org_type, this.elType = "text") : this.elementClass === a.OBJECT_CLASS_OTHER && (this.type = this._org_type, this.elType = "image");
        }, addConstraint: function(t2) {
          var e3, i2, r2 = [], s2 = ["X", "Y"];
          for (this.elementClass === a.OBJECT_CLASS_POINT && (this.type = a.OBJECT_TYPE_CAS), this.isDraggable = false, e3 = 0; e3 < t2.length; e3++)
            i2 = t2[e3], c.isString(i2) ? (r2[e3] = this.board.jc.snippet(i2, true, null, true), t2.length === 2 && (this[s2[e3] + "jc"] = t2[e3])) : c.isFunction(i2) ? r2[e3] = i2 : c.isNumber(i2) ? r2[e3] = function(t3) {
              return function() {
                return t3;
              };
            }(i2) : c.isObject(i2) && c.isFunction(i2.Value) && (r2[e3] = function(t3) {
              return function() {
                return t3.Value();
              };
            }(i2)), r2[e3].origin = i2;
          return t2.length === 1 ? this.updateConstraint = function() {
            var t3 = r2[0]();
            c.isArray(t3) ? this.coords.setCoordinates(a.COORDS_BY_USER, t3) : this.coords = t3;
          } : t2.length === 2 ? (this.XEval = r2[0], this.YEval = r2[1], this.setParents([r2[0].origin, r2[1].origin]), this.updateConstraint = function() {
            this.coords.setCoordinates(a.COORDS_BY_USER, [this.XEval(), this.YEval()]);
          }) : (this.ZEval = r2[0], this.XEval = r2[1], this.YEval = r2[2], this.setParents([r2[0].origin, r2[1].origin, r2[2].origin]), this.updateConstraint = function() {
            this.coords.setCoordinates(a.COORDS_BY_USER, [this.ZEval(), this.XEval(), this.YEval()]);
          }), this.prepareUpdate().update(), this.board.isSuspendedUpdate || (this.updateVisibility().updateRenderer(), this.hasLabel && this.label.fullUpdate()), this;
        }, addAnchor: function(t2, e3) {
          this.relativeCoords = e3 ? new n(a.COORDS_BY_SCREEN, t2.slice(0, 2), this.board) : new n(a.COORDS_BY_USER, t2, this.board), this.element.addChild(this), e3 && this.addParents(this.element), this.XEval = function() {
            var t3, e4, i2, r2;
            return c.evaluate(this.visProp.islabel) ? (r2 = c.evaluate(this.visProp.offset), t3 = parseFloat(r2[0]), i2 = this.element.getLabelAnchor(), e4 = new n(a.COORDS_BY_SCREEN, [t3 + this.relativeCoords.scrCoords[1] + i2.scrCoords[1], 0], this.board), e4.usrCoords[1]) : (i2 = this.element.getTextAnchor(), this.relativeCoords.usrCoords[1] + i2.usrCoords[1]);
          }, this.YEval = function() {
            var t3, e4, i2, r2;
            return c.evaluate(this.visProp.islabel) ? (r2 = c.evaluate(this.visProp.offset), t3 = -parseFloat(r2[1]), i2 = this.element.getLabelAnchor(), e4 = new n(a.COORDS_BY_SCREEN, [0, t3 + this.relativeCoords.scrCoords[2] + i2.scrCoords[2]], this.board), e4.usrCoords[2]) : (i2 = this.element.getTextAnchor(), this.relativeCoords.usrCoords[2] + i2.usrCoords[2]);
          }, this.ZEval = c.createFunction(1, this.board, ""), this.updateConstraint = function() {
            this.coords.setCoordinates(a.COORDS_BY_USER, [this.ZEval(), this.XEval(), this.YEval()]);
          }, this.updateConstraint();
        }, updateTransform: function() {
          var t2;
          if (this.transformations.length === 0)
            return this;
          for (t2 = 0; t2 < this.transformations.length; t2++)
            this.transformations[t2].update();
          return this;
        }, addTransform: function(t2, e3) {
          var i2, r2 = c.isArray(e3) ? e3 : [e3], s2 = r2.length;
          for (this.transformations.length === 0 && (this.baseElement = t2), i2 = 0; i2 < s2; i2++)
            this.transformations.push(r2[i2]);
          return this;
        }, startAnimation: function(t2, e3, i2) {
          var r2 = this;
          return i2 = i2 || 250, this.type !== a.OBJECT_TYPE_GLIDER || c.exists(this.intervalCode) || (this.intervalCode = window.setInterval(function() {
            r2._anim(t2, e3);
          }, i2), c.exists(this.intervalCount) || (this.intervalCount = 0)), this;
        }, stopAnimation: function() {
          return c.exists(this.intervalCode) && (window.clearInterval(this.intervalCode), delete this.intervalCode), this;
        }, moveAlong: function(t2, e3, i2) {
          i2 = i2 || {};
          var r2, o2, n3, h2, l2, d2 = [], u = [], p = this.board.attr.animationdelay, f = e3 / p, m = function(e4, i3) {
            return function() {
              return t2[e4][i3];
            };
          };
          if (c.isArray(t2)) {
            for (n3 = t2.length, r2 = 0; r2 < n3; r2++)
              c.isPoint(t2[r2]) ? u[r2] = t2[r2] : u[r2] = {elementClass: a.OBJECT_CLASS_POINT, X: m(r2, 0), Y: m(r2, 1)};
            if ((e3 = e3 || 0) === 0)
              return this.setPosition(a.COORDS_BY_USER, [u[u.length - 1].X(), u[u.length - 1].Y()]), this.board.update(this);
            if (!c.exists(i2.interpolate) || i2.interpolate)
              for (o2 = s.Neville(u), r2 = 0; r2 < f; r2++)
                d2[r2] = [], d2[r2][0] = o2[0]((f - r2) / f * o2[3]()), d2[r2][1] = o2[1]((f - r2) / f * o2[3]());
            else {
              for (n3 = t2.length - 1, r2 = 0; r2 < f; ++r2)
                h2 = Math.floor(r2 / f * n3), l2 = r2 / f * n3 - h2, d2[r2] = [], d2[r2][0] = (1 - l2) * u[h2].X() + l2 * u[h2 + 1].X(), d2[r2][1] = (1 - l2) * u[h2].Y() + l2 * u[h2 + 1].Y();
              d2.push([u[n3].X(), u[n3].Y()]), d2.reverse();
            }
            this.animationPath = d2;
          } else
            c.isFunction(t2) && (this.animationPath = t2, this.animationStart = new Date().getTime());
          return this.animationCallback = i2.callback, this.board.addAnimation(this), this;
        }, moveTo: function(t2, e3, r2) {
          r2 = r2 || {}, t2 = new n(a.COORDS_BY_USER, t2, this.board);
          var s2, o2 = this.board.attr.animationdelay, h2 = Math.ceil(e3 / o2), l2 = [], d2 = this.coords.usrCoords[1], u = this.coords.usrCoords[2], p = t2.usrCoords[1] - d2, f = t2.usrCoords[2] - u, m = function(t3) {
            return r2.effect && r2.effect === "<>" ? Math.pow(Math.sin(t3 / h2 * Math.PI / 2), 2) : t3 / h2;
          };
          if (!c.exists(e3) || e3 === 0 || Math.abs(t2.usrCoords[0] - this.coords.usrCoords[0]) > i.eps)
            return this.setPosition(a.COORDS_BY_USER, t2.usrCoords), this.board.update(this);
          if (!c.exists(r2.callback) && Math.abs(p) < i.eps && Math.abs(f) < i.eps)
            return this;
          for (s2 = h2; s2 >= 0; s2--)
            l2[h2 - s2] = [t2.usrCoords[0], d2 + p * m(s2), u + f * m(s2)];
          return this.animationPath = l2, this.animationCallback = r2.callback, this.board.addAnimation(this), this;
        }, visit: function(t2, e3, i2) {
          t2 = new n(a.COORDS_BY_USER, t2, this.board);
          var r2, s2, o2, h2 = this.board.attr.animationdelay, l2 = [], d2 = this.coords.usrCoords[1], u = this.coords.usrCoords[2], p = t2.usrCoords[1] - d2, f = t2.usrCoords[2] - u, m = function(t3) {
            var e4 = t3 < o2 / 2 ? 2 * t3 / o2 : 2 * (o2 - t3) / o2;
            return i2.effect && i2.effect === "<>" ? Math.pow(Math.sin(e4 * Math.PI / 2), 2) : e4;
          };
          for (c.isNumber(i2) ? i2 = {repeat: i2} : (i2 = i2 || {}, c.exists(i2.repeat) || (i2.repeat = 1)), o2 = Math.ceil(e3 / (h2 * i2.repeat)), s2 = 0; s2 < i2.repeat; s2++)
            for (r2 = o2; r2 >= 0; r2--)
              l2[s2 * (o2 + 1) + o2 - r2] = [t2.usrCoords[0], d2 + p * m(r2), u + f * m(r2)];
          return this.animationPath = l2, this.animationCallback = i2.callback, this.board.addAnimation(this), this;
        }, _anim: function(t2, e3) {
          var i2, s2, o2, n3, h2, l2, c2, d2;
          return this.intervalCount += 1, this.intervalCount > e3 && (this.intervalCount = 0), this.slideObject.elementClass === a.OBJECT_CLASS_LINE ? (c2 = this.slideObject.point1.coords.scrCoords, d2 = this.slideObject.point2.coords.scrCoords, i2 = Math.round((d2[1] - c2[1]) * this.intervalCount / e3), s2 = Math.round((d2[2] - c2[2]) * this.intervalCount / e3), t2 > 0 ? n3 = this.slideObject.point1 : (n3 = this.slideObject.point2, i2 *= -1, s2 *= -1), this.coords.setCoordinates(a.COORDS_BY_SCREEN, [n3.coords.scrCoords[1] + i2, n3.coords.scrCoords[2] + s2])) : this.slideObject.elementClass === a.OBJECT_CLASS_CURVE ? (h2 = t2 > 0 ? Math.round(this.intervalCount / e3 * this.board.canvasWidth) : Math.round((e3 - this.intervalCount) / e3 * this.board.canvasWidth), this.coords.setCoordinates(a.COORDS_BY_SCREEN, [h2, 0]), this.coords = r.projectPointToCurve(this, this.slideObject, this.board)) : this.slideObject.elementClass === a.OBJECT_CLASS_CIRCLE && (o2 = 2 * Math.PI, o2 *= t2 < 0 ? this.intervalCount / e3 : e3 - this.intervalCount, l2 = this.slideObject.Radius(), this.coords.setCoordinates(a.COORDS_BY_USER, [this.slideObject.center.coords.usrCoords[1] + l2 * Math.cos(o2), this.slideObject.center.coords.usrCoords[2] + l2 * Math.sin(o2)])), this.board.update(this), this;
        }, getTextAnchor: function() {
          return this.coords;
        }, getLabelAnchor: function() {
          return this.coords;
        }, getParents: function() {
          var t2 = [this.Z(), this.X(), this.Y()];
          return this.parents.length !== 0 && (t2 = this.parents), this.type === a.OBJECT_TYPE_GLIDER && (t2 = [this.X(), this.Y(), this.slideObject.id]), t2;
        }}), t.CoordsElement.create = function(t2, e3, i2, r2, s2, o2) {
          var n3, a2, h2 = false;
          for (a2 = 0; a2 < i2.length; a2++)
            (c.isFunction(i2[a2]) || c.isString(i2[a2])) && (h2 = true);
          if (h2)
            n3 = new t2(e3, [0, 0], r2, s2, o2), n3.addConstraint(i2);
          else if (c.isNumber(i2[0]) && c.isNumber(i2[1]))
            n3 = new t2(e3, i2, r2, s2, o2), c.exists(r2.slideobject) ? n3.makeGlider(r2.slideobject) : n3.baseElement = n3, n3.isDraggable = true;
          else {
            if (!c.isObject(i2[0]) || !c.isTransformationOrArray(i2[1]))
              return false;
            n3 = new t2(e3, [0, 0], r2, s2, o2), n3.addTransform(i2[0], i2[1]), n3.isDraggable = false;
          }
          return n3.handleSnapToGrid(), n3.handleSnapToPoints(), n3.handleAttractors(), n3.addParents(i2), n3;
        }, t.CoordsElement;
      }), define("base/text", ["jxg", "base/constants", "base/element", "parser/geonext", "utils/env", "utils/type", "math/math", "math/geometry", "base/coordselement"], function(t, e2, i, r, s, o, n, a, h) {
        "use strict";
        var l = {HTMLSliderInputEventHandler: function() {
          this._val = parseFloat(this.rendNodeRange.value), this.rendNodeOut.value = this.rendNodeRange.value, this.board.update();
        }};
        return t.Text = function(t2, i2, r2, s2) {
          this.constructor(t2, r2, e2.OBJECT_TYPE_TEXT, e2.OBJECT_CLASS_TEXT), this.element = this.board.select(r2.anchor), this.coordsConstructor(i2, o.evaluate(this.visProp.islabel)), this.content = "", this.plaintext = "", this.plaintextOld = null, this.orgText = "", this.needsSizeUpdate = false, this.hiddenByParent = false, this.size = [1, 1], this.id = this.board.setId(this, "T"), this._setUpdateText(s2), this.updateText(), this.board.renderer.drawText(this), this.board.finalizeAdding(this), o.isString(this.content) && this.notifyParents(this.content), this.elType = "text", this.methodMap = o.deepCopy(this.methodMap, {setText: "setTextJessieCode", move: "setCoords"});
        }, t.Text.prototype = new i(), o.copyPrototypeMethods(t.Text, h, "coordsConstructor"), t.extend(t.Text.prototype, {hasPoint: function(t2, e3) {
          var i2, r2, s2, a2, h2, l2, c, d;
          return o.isObject(o.evaluate(this.visProp.precision)) ? (c = this.board._inputDevice, d = o.evaluate(this.visProp.precision[c])) : d = this.board.options.precision.hasPoint, this.transformations.length > 0 && (i2 = n.matVecMult(n.inverse(this.board.renderer.joinTransforms(this, this.transformations)), [1, t2, e3]), t2 = i2[1], e3 = i2[2]), h2 = this.getAnchorX(), i2 = h2 === "right" ? this.coords.scrCoords[1] - this.size[0] : h2 === "middle" ? this.coords.scrCoords[1] - 0.5 * this.size[0] : this.coords.scrCoords[1], r2 = i2 + this.size[0], l2 = this.getAnchorY(), a2 = l2 === "top" ? this.coords.scrCoords[2] + this.size[1] : l2 === "middle" ? this.coords.scrCoords[2] + 0.5 * this.size[1] : this.coords.scrCoords[2], s2 = a2 - this.size[1], o.evaluate(this.visProp.dragarea) === "all" ? t2 >= i2 - d && t2 < r2 + d && e3 >= s2 - d && e3 <= a2 + d : e3 >= s2 - d && e3 <= a2 + d && (t2 >= i2 - d && t2 <= i2 + 2 * d || t2 >= r2 - 2 * d && t2 <= r2 + d);
        }, _setUpdateText: function(t2) {
          var e3, i2, r2 = o.evaluate(this.visProp.parse), s2 = o.evaluate(this.visProp.usemathjax);
          this.orgText = t2, o.isFunction(t2) ? this.updateText = function() {
            i2 = t2().toString(), this.plaintext = r2 && !s2 ? this.replaceSub(this.replaceSup(this.convertGeonext2CSS(i2))) : i2;
          } : o.isString(t2) && !r2 ? this.updateText = function() {
            this.plaintext = t2;
          } : (o.isNumber(t2) ? this.content = o.toFixed(t2, o.evaluate(this.visProp.digits)) : o.evaluate(this.visProp.useasciimathml) ? this.content = "'`" + t2 + "`'" : this.content = s2 ? "'" + t2 + "'" : this.generateTerm(t2, true, true), e3 = this.board.jc.snippet(this.content, true, "", false), this.updateText = function() {
            this.plaintext = e3();
          });
        }, _setText: function(t2) {
          return this._setUpdateText(t2), this.updateText(), this.fullUpdate(), this.board.infobox && this.id === this.board.infobox.id || this.updateSize(), this;
        }, setTextJessieCode: function(t2) {
          var e3;
          return this.visProp.castext = t2, e3 = o.isFunction(t2) ? function() {
            return o.sanitizeHTML(t2());
          } : o.isNumber(t2) ? t2 : o.sanitizeHTML(t2), this._setText(e3);
        }, setText: function(t2) {
          return this._setText(t2);
        }, updateSize: function() {
          var t2, e3, i2, r2 = o.evaluate(this.visProp.display);
          return s.isBrowser && this.board.renderer.type !== "no" ? (i2 = this.rendNode, r2 === "html" || this.board.renderer.type === "vml" ? o.exists(i2.offsetWidth) ? (e3 = this, window.setTimeout(function() {
            e3.size = [i2.offsetWidth, i2.offsetHeight], e3.needsUpdate = true, e3.updateRenderer();
          }, 0)) : this.size = this.crudeSizeEstimate() : r2 === "internal" && (this.board.renderer.type === "svg" ? (e3 = this, window.setTimeout(function() {
            try {
              t2 = i2.getBBox(), e3.size = [t2.width, t2.height], e3.needsUpdate = true, e3.updateRenderer();
            } catch (t3) {
            }
          }, 0)) : this.board.renderer.type === "canvas" && (this.size = this.crudeSizeEstimate())), this) : this;
        }, crudeSizeEstimate: function() {
          var t2 = parseFloat(o.evaluate(this.visProp.fontsize));
          return [t2 * this.plaintext.length * 0.45, 0.9 * t2];
        }, utf8_decode: function(t2) {
          return t2.replace(/&#x(\w+);/g, function(t3, e3) {
            return String.fromCharCode(parseInt(e3, 16));
          });
        }, replaceSub: function(t2) {
          if (!t2.indexOf)
            return t2;
          for (var e3, i2 = t2.indexOf("_{"); i2 >= 0; )
            t2 = t2.substr(0, i2) + t2.substr(i2).replace(/_\{/, "<sub>"), e3 = t2.substr(i2).indexOf("}"), e3 >= 0 && (t2 = t2.substr(0, e3) + t2.substr(e3).replace(/\}/, "</sub>")), i2 = t2.indexOf("_{");
          for (i2 = t2.indexOf("_"); i2 >= 0; )
            t2 = t2.substr(0, i2) + t2.substr(i2).replace(/_(.?)/, "<sub>$1</sub>"), i2 = t2.indexOf("_");
          return t2;
        }, replaceSup: function(t2) {
          if (!t2.indexOf)
            return t2;
          for (var e3, i2 = t2.indexOf("^{"); i2 >= 0; )
            t2 = t2.substr(0, i2) + t2.substr(i2).replace(/\^\{/, "<sup>"), e3 = t2.substr(i2).indexOf("}"), e3 >= 0 && (t2 = t2.substr(0, e3) + t2.substr(e3).replace(/\}/, "</sup>")), i2 = t2.indexOf("^{");
          for (i2 = t2.indexOf("^"); i2 >= 0; )
            t2 = t2.substr(0, i2) + t2.substr(i2).replace(/\^(.?)/, "<sup>$1</sup>"), i2 = t2.indexOf("^");
          return t2;
        }, getSize: function() {
          return this.size;
        }, setCoords: function(t2, i2) {
          var r2, s2, n3;
          return o.isArray(t2) && t2.length > 1 && (i2 = t2[1], t2 = t2[0]), o.evaluate(this.visProp.islabel) && o.exists(this.element) ? (r2 = this.element.getLabelAnchor(), s2 = (t2 - r2.usrCoords[1]) * this.board.unitX, n3 = -(i2 - r2.usrCoords[2]) * this.board.unitY, this.relativeCoords.setCoordinates(e2.COORDS_BY_SCREEN, [s2, n3])) : this.coords.setCoordinates(e2.COORDS_BY_USER, [t2, i2]), this.fullUpdate(), this;
        }, update: function(t2) {
          return this.needsUpdate ? (this.updateCoords(t2), this.updateText(), o.evaluate(this.visProp.display) === "internal" && o.isString(this.plaintext) && (this.plaintext = this.utf8_decode(this.plaintext)), this.checkForSizeUpdate(), this.needsSizeUpdate && this.updateSize(), this) : this;
        }, checkForSizeUpdate: function() {
          this.board.infobox && this.id === this.board.infobox.id ? this.needsSizeUpdate = false : (this.needsSizeUpdate = this.plaintextOld !== this.plaintext, this.needsSizeUpdate && (this.plaintextOld = this.plaintext));
        }, updateRenderer: function() {
          return o.evaluate(this.visProp.autoposition) && this.setAutoPosition().updateConstraint(), this.updateRendererGeneric("updateText");
        }, expandShortMath: function(t2) {
          var e3 = /([\)0-9\.])\s*([\(a-zA-Z_])/g;
          return t2.replace(e3, "$1*$2");
        }, generateTerm: function(t2, e3, i2) {
          var s2, n3, a2, h2, l2 = '""';
          if (t2 = t2 || "", t2 = t2.replace(/\r/g, ""), t2 = t2.replace(/\n/g, ""), t2 = t2.replace(/"/g, "'"), t2 = t2.replace(/'/g, "\\'"), t2 = t2.replace(/&amp;arc;/g, "&ang;"), t2 = t2.replace(/<arc\s*\/>/g, "&ang;"), t2 = t2.replace(/&lt;arc\s*\/&gt;/g, "&ang;"), t2 = t2.replace(/&lt;sqrt\s*\/&gt;/g, "&radic;"), t2 = t2.replace(/&lt;value&gt;/g, "<value>"), t2 = t2.replace(/&lt;\/value&gt;/g, "</value>"), a2 = t2.indexOf("<value>"), h2 = t2.indexOf("</value>"), a2 >= 0)
            for (; a2 >= 0; )
              l2 += ' + "' + this.replaceSub(this.replaceSup(t2.slice(0, a2))) + '"', n3 = t2.slice(a2 + 7, h2), n3 = n3.replace(/\s+/g, ""), e3 === true && (n3 = this.expandShortMath(n3)), s2 = i2 ? n3 : r.geonext2JS(n3, this.board), s2 = s2.replace(/\\"/g, "'"), s2 = s2.replace(/\\'/g, "'"), s2.indexOf("toFixed") < 0 && o.isNumber(o.bind(this.board.jc.snippet(s2, true, "", false), this)()) ? l2 += "+(" + s2 + ").toFixed(" + o.evaluate(this.visProp.digits) + ")" : l2 += "+(" + s2 + ")", t2 = t2.slice(h2 + 8), a2 = t2.indexOf("<value>"), h2 = t2.indexOf("</value>");
          return l2 += ' + "' + this.replaceSub(this.replaceSup(t2)) + '"', l2 = this.convertGeonext2CSS(l2), l2 = l2.replace(/&amp;/g, "&"), l2 = l2.replace(/"/g, "'");
        }, convertGeonext2CSS: function(t2) {
          return o.isString(t2) && (t2 = t2.replace(/<overline>/g, "<span style=text-decoration:overline>"), t2 = t2.replace(/&lt;overline&gt;/g, "<span style=text-decoration:overline>"), t2 = t2.replace(/<\/overline>/g, "</span>"), t2 = t2.replace(/&lt;\/overline&gt;/g, "</span>"), t2 = t2.replace(/<arrow>/g, "<span style=text-decoration:overline>"), t2 = t2.replace(/&lt;arrow&gt;/g, "<span style=text-decoration:overline>"), t2 = t2.replace(/<\/arrow>/g, "</span>"), t2 = t2.replace(/&lt;\/arrow&gt;/g, "</span>")), t2;
        }, notifyParents: function(t2) {
          var e3, i2 = null;
          t2 = t2.replace(/&lt;value&gt;/g, "<value>"), t2 = t2.replace(/&lt;\/value&gt;/g, "</value>");
          do {
            e3 = /<value>([\w\s\*\/\^\-\+\(\)\[\],<>=!]+)<\/value>/, (i2 = e3.exec(t2)) !== null && (r.findDependencies(this, i2[1], this.board), t2 = t2.substr(i2.index), t2 = t2.replace(e3, ""));
          } while (i2 !== null);
          return this;
        }, getParents: function() {
          var t2;
          return t2 = this.relativeCoords !== void 0 ? [this.relativeCoords.usrCoords[1], this.relativeCoords.usrCoords[2], this.orgText] : [this.Z(), this.X(), this.Y(), this.orgText], this.parents.length !== 0 && (t2 = this.parents), t2;
        }, bounds: function() {
          var t2 = this.coords.usrCoords;
          return o.evaluate(this.visProp.islabel) || this.board.unitY === 0 || this.board.unitX === 0 ? [0, 0, 0, 0] : [t2[1], t2[2] + this.size[1] / this.board.unitY, t2[1] + this.size[0] / this.board.unitX, t2[2]];
        }, getAnchorX: function() {
          var t2 = o.evaluate(this.visProp.anchorx);
          if (t2 === "auto")
            switch (this.visProp.position) {
              case "top":
              case "bot":
                return "middle";
              case "rt":
              case "lrt":
              case "urt":
                return "left";
              case "lft":
              case "llft":
              case "ulft":
              default:
                return "right";
            }
          return t2;
        }, getAnchorY: function() {
          var t2 = o.evaluate(this.visProp.anchory);
          if (t2 === "auto")
            switch (this.visProp.position) {
              case "top":
              case "ulft":
              case "urt":
                return "bottom";
              case "bot":
              case "lrt":
              case "llft":
                return "top";
              case "rt":
              case "lft":
              default:
                return "middle";
            }
          return t2;
        }, getNumberofConflicts: function(t2, e3, i2, r2) {
          var s2, o2, n3, a2, h2 = 0;
          for (a2 = this.board.options.precision.hasPoint, this.board.options.precision.hasPoint = 0.5 * Math.max(i2, r2), s2 = 0, n3 = this.board.objectsList.length; s2 < n3; s2++)
            o2 = this.board.objectsList[s2], o2.visPropCalc.visible && o2.elType !== "axis" && o2.elType !== "ticks" && o2 !== this.board.infobox && o2 !== this && o2.hasPoint(t2, e3) && h2++;
          return this.board.options.precision.hasPoint = a2, h2;
        }, setAutoPosition: function() {
          var t2, e3, i2, r2, s2, n3, h2, l2, c, d, u, p, f, m, g, b, v = this.size[0], y = this.size[1], C = 1 / 0, _4 = 2 * Math.PI / 12;
          if (this === this.board.infobox || !o.evaluate(this.visProp.islabel) || !this.element)
            return this;
          if (o.evaluate(this.visProp.anchorx), o.evaluate(this.visProp.anchory), d = o.evaluate(this.visProp.offset), s2 = this.element.getLabelAnchor(), i2 = s2.scrCoords[1], r2 = s2.scrCoords[2], f = d[0], m = d[1], (c = this.getNumberofConflicts(i2 + f, r2 - m, v, y)) === 0)
            return this;
          for (u = a.distance([0, 0], [f, m], 2), n3 = Math.atan2(m, f), l2 = n3, C = c, p = 1, h2 = n3 + _4; p < 12 && (g = Math.cos(h2), b = Math.sin(h2), t2 = i2 + u * g, e3 = r2 - u * b, c = this.getNumberofConflicts(t2, e3, v, y), c < C && (C = c, l2 = h2), C !== 0); p++)
            h2 += _4;
          return u = a.distance([0, 0], d, 2), g = Math.cos(l2), b = Math.sin(l2), this.visProp.offset = [u * g, u * b], this.visProp.anchorx = g < -0.2 ? "right" : g > 0.2 ? "left" : "middle", this;
        }}), t.createText = function(e3, i2, r2) {
          var s2, n3 = o.copyAttributes(r2, e3.options, "text"), a2 = i2.slice(0, -1), l2 = i2[i2.length - 1];
          if (n3.anchor = n3.parent || n3.anchor, !(s2 = h.create(t.Text, e3, a2, n3, l2)))
            throw new Error("JSXGraph: Can't create text with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
          return n3.rotate !== 0 && n3.display === "internal" && s2.addRotation(n3.rotate), s2;
        }, t.registerElement("text", t.createText), t.createHTMLSlider = function(e3, i2, r2) {
          var n3, a2, h2 = o.copyAttributes(r2, e3.options, "htmlslider");
          if (i2.length !== 2 || i2[0].length !== 2 || i2[1].length !== 3)
            throw new Error("JSXGraph: Can't create htmlslider with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parents are: [[x,y], [min, start, max]]");
          h2.anchor = h2.parent || h2.anchor, h2.fixed = h2.fixed || true, a2 = [i2[0][0], i2[0][1], '<form style="display:inline"><input type="range" /><span></span><input type="text" /></form>'], n3 = t.createText(e3, a2, h2), n3.type = o.OBJECT_TYPE_HTMLSLIDER, n3.rendNodeForm = n3.rendNode.childNodes[0], n3.rendNodeRange = n3.rendNodeForm.childNodes[0], n3.rendNodeRange.min = i2[1][0], n3.rendNodeRange.max = i2[1][2], n3.rendNodeRange.step = h2.step, n3.rendNodeRange.value = i2[1][1], n3.rendNodeLabel = n3.rendNodeForm.childNodes[1], n3.rendNodeLabel.id = n3.rendNode.id + "_label", h2.withlabel && (n3.rendNodeLabel.innerHTML = n3.name + "="), n3.rendNodeOut = n3.rendNodeForm.childNodes[2], n3.rendNodeOut.value = i2[1][1];
          try {
            n3.rendNodeForm.id = n3.rendNode.id + "_form", n3.rendNodeRange.id = n3.rendNode.id + "_range", n3.rendNodeOut.id = n3.rendNode.id + "_out";
          } catch (e4) {
            t.debug(e4);
          }
          return n3.rendNodeRange.style.width = h2.widthrange + "px", n3.rendNodeRange.style.verticalAlign = "middle", n3.rendNodeOut.style.width = h2.widthout + "px", n3._val = i2[1][1], t.supportsVML() ? s.addEvent(n3.rendNodeForm, "change", l.HTMLSliderInputEventHandler, n3) : s.addEvent(n3.rendNodeForm, "input", l.HTMLSliderInputEventHandler, n3), n3.Value = function() {
            return this._val;
          }, n3;
        }, t.registerElement("htmlslider", t.createHTMLSlider), {Text: t.Text, createText: t.createText, createHTMLSlider: t.createHTMLSlider};
      }), define("utils/uuid", ["jxg"], function(t) {
        "use strict";
        var e2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", i = e2.split("");
        return t.Util = t.Util || {}, t.Util.genUUID = function(t2) {
          var e3, r, s = [], o = 0;
          for (t2 = t2 || "", t2 !== "" && t2.substr(t2.length - 1) !== "-" && (t2 += "-"), r = 0; r < 36; r++)
            r === 8 || r === 13 || r === 18 || r === 23 ? s[r] = "-" : r === 14 ? s[r] = "4" : (o <= 2 && (o = 33554432 + 16777216 * Math.random() | 0), e3 = 15 & o, o >>= 4, s[r] = i[r === 19 ? 3 & e3 | 8 : e3]);
          return t2 + s.join("");
        }, t.Util;
      }), define("parser/jessiecode", ["jxg", "base/constants", "base/text", "math/math", "math/ia", "math/geometry", "math/statistics", "utils/type", "utils/uuid", "utils/env"], function(JXG, Const, Text, Mat, Interval, Geometry, Statistics, Type, UUID, Env) {
        Object.create || (Object.create = function(t, e2) {
          function i() {
          }
          if (typeof t != "object" && typeof t != "function")
            throw new TypeError("Object prototype may only be an Object: " + t);
          if (t === null)
            throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");
          if (e2 !== void 0)
            throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");
          return i.prototype = t, new i();
        });
        var priv = {modules: {math: Mat, "math/geometry": Geometry, "math/statistics": Statistics, "math/numerics": Mat.Numerics}};
        JXG.JessieCode = function(t, e2) {
          this.scope = {id: 0, hasChild: true, args: [], locals: {}, context: null, previous: null}, this.scopes = [], this.scopes.push(this.scope), this.dpstack = [[]], this.pscope = 0, this.propstack = [{}], this.propscope = 0, this.lhs = [], this.isLHS = false, this.warnLog = "jcwarn", this.$log = [], this.builtIn = this.defineBuiltIn(), this.board = null, this.lineToElement = {}, this.parCurLine = 1, this.parCurColumn = 0, this.line = 1, this.col = 1, JXG.CA && (this.CA = new JXG.CA(this.node, this.createNode, this)), this.code = "", typeof t == "string" && this.parse(t, e2);
        }, JXG.extend(JXG.JessieCode.prototype, {node: function(t, e2, i) {
          return {type: t, value: e2, children: i};
        }, createNode: function(t, e2, i) {
          var r, s = this.node(t, e2, []);
          for (r = 2; r < arguments.length; r++)
            s.children.push(arguments[r]);
          return s.type == "node_const" && Type.isNumber(s.value) && (s.isMath = true), s.line = this.parCurLine, s.col = this.parCurColumn, s;
        }, pushScope: function(t) {
          var e2 = {args: t, locals: {}, context: null, previous: this.scope};
          return this.scope.hasChild = true, this.scope = e2, e2.id = this.scopes.push(e2) - 1, e2;
        }, popScope: function() {
          var t = this.scope.previous;
          return this.scope = t !== null ? t : this.scope, this.scope;
        }, getElementById: function(t) {
          return this.board.objects[t];
        }, log: function() {
          this.$log.push(arguments), typeof console == "object" && console.log && console.log.apply(console, arguments);
        }, creator: function() {
          var t, e2 = {};
          return t = function(t2) {
            var i;
            return typeof e2[this.board.id + t2] == "function" ? i = e2[this.board.id + t2] : (i = function(e3) {
              return function(i2, r) {
                var s;
                return s = Type.exists(r) ? r : {name: e3.lhs[e3.scope] !== 0 ? e3.lhs[e3.scope] : ""}, e3.board.create(t2, i2, s);
              };
            }(this), i.creator = true, e2[this.board.id + t2] = i), i;
          }, t.clearCache = function() {
            e2 = {};
          }, t;
        }(), letvar: function(t, e2) {
          this.builtIn[t] && this._warn('"' + t + '" is a predefined value.'), this.scope.locals[t] = e2;
        }, isLocalVariable: function(t) {
          for (var e2 = this.scope; e2 !== null; ) {
            if (Type.exists(e2.locals[t]))
              return e2;
            e2 = e2.previous;
          }
          return null;
        }, isParameter: function(t) {
          for (var e2 = this.scope; e2 !== null; ) {
            if (Type.indexOf(e2.args, t) > -1)
              return e2;
            e2 = e2.previous;
          }
          return null;
        }, isCreator: function(t) {
          return !!JXG.elements[t];
        }, isMathMethod: function(t) {
          return t !== "E" && !!Math[t];
        }, isBuiltIn: function(t) {
          return !!this.builtIn[t];
        }, getvar: function(t, e2) {
          var i;
          return e2 = Type.def(e2, false), i = this.isLocalVariable(t), i !== null ? i.locals[t] : this.isCreator(t) ? this.creator(t) : this.isBuiltIn(t) ? this.builtIn[t] : this.isMathMethod(t) ? Math[t] : e2 || (i = this.board.select(t)) === t ? void 0 : i;
        }, resolve: function(t) {
          for (var e2 = this.scope; e2 !== null; ) {
            if (Type.exists(e2.locals[t]))
              return e2.locals[t];
            e2 = e2.previous;
          }
        }, getvarJS: function(t, e2, i) {
          var r, s = "";
          return e2 = Type.def(e2, false), i = Type.def(i, false), this.isParameter(t) !== null ? t : this.isLocalVariable(t) === null || i ? this.isCreator(t) ? "(function () { var a = Array.prototype.slice.call(arguments, 0), props = " + (i ? "a.pop()" : "{}") + "; return $jc$.board.create.apply($jc$.board, ['" + t + "'].concat([a, props])); })" : (i && this._error("Syntax error (attribute values are allowed with element creators only)"), this.isBuiltIn(t) ? (s = this.builtIn[t].src || this.builtIn[t], Type.isNumber(s) ? s : s.match(/board\.select/) ? s : (t = s.split(".").pop(), Type.exists(this.board.mathLib) && (r = new RegExp("^Math." + t), r.exec(s) !== null) ? s.replace(r, "$jc$.board.mathLib." + t) : Type.exists(this.board.mathLibJXG) ? (r = new RegExp("^JXG.Math."), r.exec(s) !== null ? s.replace(r, "$jc$.board.mathLibJXG.") : s) : s)) : this.isMathMethod(t) ? "$jc$.board.mathLib." + t : e2 ? "" : (Type.isId(this.board, t) ? (s = "$jc$.board.objects['" + t + "']", this.board.objects[t].elType === "slider" && (s += ".Value()")) : Type.isName(this.board, t) ? (s = "$jc$.board.elementsByName['" + t + "']", this.board.elementsByName[t].elType === "slider" && (s += ".Value()")) : Type.isGroup(this.board, t) && (s = "$jc$.board.groups['" + t + "']"), s)) : "$jc$.resolve('" + t + "')";
        }, makeMap: function(t) {
          return t.isMap = true, t;
        }, functionCodeJS: function(t) {
          var e2 = t.children[0].join(", "), i = "", r = "";
          return t.value === "op_map" && (i = "{ return  ", r = " }"), "function (" + e2 + ") {\nvar $oldscope$ = $jc$.scope;\n$jc$.scope = $jc$.scopes[" + this.scope.id + "];\nvar r = (function () " + i + this.compile(t.children[1], true) + r + ")();\n$jc$.scope = $oldscope$;\nreturn r;\n}";
        }, defineFunction: function(node) {
          var fun, i, list = node.children[0], scope = this.pushScope(list);
          if (this.board.options.jc.compile) {
            for (this.isLHS = false, i = 0; i < list.length; i++)
              scope.locals[list[i]] = list[i];
            this.replaceNames(node.children[1]), fun = function($jc$) {
              var fun, str = "var f = " + $jc$.functionCodeJS(node) + "; f;";
              try {
                return fun = eval(str);
              } catch (t) {
                return $jc$._warn("error compiling function\n\n" + str + "\n\n" + t.toString()), function() {
                };
              }
            }(this), this.popScope();
          } else
            fun = function(t, e2, i) {
              return function() {
                var r, s;
                for (s = e2.scope, e2.scope = e2.scopes[i], r = 0; r < t.length; r++)
                  e2.scope.locals[t[r]] = arguments[r];
                return r = e2.execute(node.children[1]), e2.scope = s, r;
              };
            }(list, this, scope.id);
          return fun.node = node, fun.scope = scope, fun.toJS = fun.toString, fun.toString = function(t) {
            return function() {
              return t.compile(t.replaceIDs(Type.deepCopy(node)));
            };
          }(this), fun.deps = {}, this.collectDependencies(node.children[1], fun.deps), fun;
        }, mergeAttributes: function(t) {
          var e2, i = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            i = Type.deepCopy(i, arguments[e2], true);
          return i;
        }, setProp: function(t, e2, i) {
          var r, s, o = {};
          t.elementClass !== Const.OBJECT_CLASS_POINT || e2 !== "X" && e2 !== "Y" ? t.elementClass !== Const.OBJECT_CLASS_TEXT || e2 !== "X" && e2 !== "Y" ? t.type && t.elementClass && t.visProp ? Type.exists(t[t.methodMap[e2]]) && typeof t[t.methodMap[e2]] != "function" ? t[t.methodMap[e2]] = i : (o[e2] = i, t.setAttribute(o)) : t[e2] = i : (typeof i == "number" ? t[e2] = function() {
            return i;
          } : typeof i == "function" ? (t.isDraggable = false, t[e2] = i) : typeof i == "string" && (t.isDraggable = false, t[e2] = Type.createFunction(i, this.board, null, true), t[e2 + "jc"] = i), t[e2].origin = i, this.board.update()) : (e2 = e2.toLowerCase(), t.isDraggable && typeof i == "number" ? (r = e2 === "x" ? i : t.X(), s = e2 === "y" ? i : t.Y(), t.setPosition(Const.COORDS_BY_USER, [r, s])) : !t.isDraggable || typeof i != "function" && typeof i != "string" ? t.isDraggable || (r = e2 === "x" ? i : t.XEval.origin, s = e2 === "y" ? i : t.YEval.origin, t.addConstraint([r, s])) : (r = e2 === "x" ? i : t.coords.usrCoords[1], s = e2 === "y" ? i : t.coords.usrCoords[2], t.addConstraint([r, s])), this.board.update());
        }, _genericParse: function(t, e2, i, r) {
          var s, o, n, a, h = t.replace(/\r\n/g, "\n").split("\n"), l = [];
          r || (this.code += t + "\n"), Text && (o = Text.Text.prototype.setText, Text.Text.prototype.setText = Text.Text.prototype.setTextJessieCode);
          try {
            for (Type.exists(i) || (i = false), s = 0; s < h.length; s++)
              i && (h[s] = JXG.GeonextParser.geonext2JS(h[s], this.board)), l.push(h[s]);
            switch (t = l.join("\n"), n = parser.parse(t), this.CA && (n = this.CA.expandDerivatives(n, null, n), n = this.CA.removeTrivialNodes(n)), e2) {
              case "parse":
                a = this.execute(n);
                break;
              case "manipulate":
                a = this.compile(n);
                break;
              case "getAst":
                a = n;
                break;
              default:
                a = false;
            }
          } catch (t2) {
            throw t2;
          } finally {
            Text && (Text.Text.prototype.setText = o);
          }
          return a;
        }, parse: function(t, e2, i) {
          return this._genericParse(t, "parse", e2, i);
        }, manipulate: function(t, e2, i) {
          return this._genericParse(t, "manipulate", e2, i);
        }, getAST: function(t, e2, i) {
          return this._genericParse(t, "getAst", e2, i);
        }, snippet: function(t, e2, i, r) {
          var s;
          return e2 = Type.def(e2, true), i = Type.def(i, ""), r = Type.def(r, false), s = (e2 ? " function (" + i + ") { return " : "") + t + (e2 ? "; }" : "") + ";", this.parse(s, r, true);
        }, replaceIDs: function(t) {
          var e2, i;
          if (t.replaced && (i = this.board.objects[t.children[1][0].value], Type.exists(i) && i.name !== "" && (t.type = "node_var", t.value = i.name, t.children.length = 0, delete t.replaced)), t.children)
            for (e2 = t.children.length; e2 > 0; e2--)
              Type.exists(t.children[e2 - 1]) && (t.children[e2 - 1] = this.replaceIDs(t.children[e2 - 1]));
          return t;
        }, replaceNames: function(t) {
          var e2, i;
          if (i = t.value, t.type === "node_op" && i === "op_lhs" && t.children.length === 1 ? this.isLHS = true : t.type === "node_var" && (this.isLHS ? this.letvar(i, true) : !Type.exists(this.getvar(i, true)) && Type.exists(this.board.elementsByName[i]) && (t = this.createReplacementNode(t))), t.children)
            for (e2 = t.children.length; e2 > 0; e2--)
              Type.exists(t.children[e2 - 1]) && (t.children[e2 - 1] = this.replaceNames(t.children[e2 - 1]));
          return t.type === "node_op" && t.value === "op_lhs" && t.children.length === 1 && (this.isLHS = false), t;
        }, createReplacementNode: function(t) {
          var e2 = t.value, i = this.board.elementsByName[e2];
          return t = this.createNode("node_op", "op_execfun", this.createNode("node_var", "$"), [this.createNode("node_str", i.id)]), t.replaced = true, t;
        }, collectDependencies: function(t, e2) {
          var i, r, s, o;
          if (Type.isArray(t))
            for (o = t.length, i = 0; i < o; i++)
              this.collectDependencies(t[i], e2);
          else if (r = t.value, t.type === "node_var" && (s = this.getvar(r)) && s.visProp && s.type && s.elementClass && s.id && (e2[s.id] = s), t.type === "node_op" && t.value === "op_execfun" && t.children.length > 1 && t.children[0].value === "$" && t.children[1].length > 0 && (s = t.children[1][0].value, e2[s] = this.board.objects[s]), t.children)
            for (i = t.children.length; i > 0; i--)
              Type.exists(t.children[i - 1]) && this.collectDependencies(t.children[i - 1], e2);
        }, resolveProperty: function(t, e2, i) {
          return i = Type.def(i, false), t && t.methodMap && (Type.exists(t.subs) && Type.exists(t.subs[e2]) ? t = t.subs : Type.exists(t.methodMap[e2]) ? e2 = t.methodMap[e2] : (t = t.visProp, e2 = e2.toLowerCase())), Type.isFunction(t) && this._error("Accessing function properties is not allowed."), Type.exists(t) || this._error(t + " is not an object"), Type.exists(t[e2]) || this._error("unknown property " + e2), i && typeof t[e2] == "function" ? function() {
            return t[e2].apply(t, arguments);
          } : t[e2];
        }, getLHS: function(t) {
          var e2;
          if (t.type === "node_var")
            e2 = {o: this.scope.locals, what: t.value};
          else if (t.type === "node_op" && t.value === "op_property")
            e2 = {o: this.execute(t.children[0]), what: t.children[1]};
          else {
            if (t.type !== "node_op" || t.value !== "op_extvalue")
              throw new Error("Syntax error: Invalid left-hand side of assignment.");
            e2 = {o: this.execute(t.children[0]), what: this.execute(t.children[1])};
          }
          return e2;
        }, getLHSCompiler: function(t, e2) {
          var i;
          if (t.type === "node_var")
            i = t.value;
          else if (t.type === "node_op" && t.value === "op_property")
            i = [this.compile(t.children[0], e2), "'" + t.children[1] + "'"];
          else {
            if (t.type !== "node_op" || t.value !== "op_extvalue")
              throw new Error("Syntax error: Invalid left-hand side of assignment.");
            i = [this.compile(t.children[0], e2), t.children[1].type === "node_const" ? t.children[1].value : this.compile(t.children[1], e2)];
          }
          return i;
        }, execute: function(t) {
          var e2, i, r, s, o, n, a, h, l, c, d = [];
          if (e2 = 0, !t)
            return e2;
          switch (this.line = t.line, this.col = t.col, t.type) {
            case "node_op":
              switch (t.value) {
                case "op_none":
                  t.children[0] && this.execute(t.children[0]), t.children[1] && (e2 = this.execute(t.children[1]));
                  break;
                case "op_assign":
                  i = this.getLHS(t.children[0]), this.lhs[this.scope.id] = i[1], i.o.type && i.o.elementClass && i.o.methodMap && i.what === "label" && this._error("Left-hand side of assignment is read-only."), e2 = this.execute(t.children[1]), i.o !== this.scope.locals || Type.isArray(i.o) && typeof i.what == "number" ? this.setProp(i.o, i.what, e2) : this.letvar(i.what, e2), this.lhs[this.scope.id] = 0;
                  break;
                case "op_if":
                  this.execute(t.children[0]) && (e2 = this.execute(t.children[1]));
                  break;
                case "op_conditional":
                case "op_if_else":
                  e2 = this.execute(t.children[0]) ? this.execute(t.children[1]) : this.execute(t.children[2]);
                  break;
                case "op_while":
                  for (; this.execute(t.children[0]); )
                    this.execute(t.children[1]);
                  break;
                case "op_do":
                  do {
                    this.execute(t.children[0]);
                  } while (this.execute(t.children[1]));
                  break;
                case "op_for":
                  for (this.execute(t.children[0]); this.execute(t.children[1]); this.execute(t.children[2]))
                    this.execute(t.children[3]);
                  break;
                case "op_proplst":
                  t.children[0] && this.execute(t.children[0]), t.children[1] && this.execute(t.children[1]);
                  break;
                case "op_emptyobject":
                  e2 = {};
                  break;
                case "op_proplst_val":
                  this.propstack.push({}), this.propscope++, this.execute(t.children[0]), e2 = this.propstack[this.propscope], this.propstack.pop(), this.propscope--;
                  break;
                case "op_prop":
                  this.propstack[this.propscope][t.children[0]] = this.execute(t.children[1]);
                  break;
                case "op_array":
                  for (e2 = [], o = t.children[0].length, r = 0; r < o; r++)
                    e2.push(this.execute(t.children[0][r]));
                  break;
                case "op_extvalue":
                  e2 = this.execute(t.children[0]), r = this.execute(t.children[1]), e2 = typeof r == "number" && Math.abs(Math.round(r) - r) < Mat.eps ? e2[r] : void 0;
                  break;
                case "op_return":
                  if (this.scope !== 0)
                    return this.execute(t.children[0]);
                  this._error("Unexpected return.");
                  break;
                case "op_map":
                  t.children[1].isMath || t.children[1].type === "node_var" || this._error("execute: In a map only function calls and mathematical expressions are allowed."), h = this.defineFunction(t), h.isMap = true, e2 = h;
                  break;
                case "op_function":
                  h = this.defineFunction(t), h.isMap = false, e2 = h;
                  break;
                case "op_execfun":
                  if (this.dpstack.push([]), this.pscope++, n = t.children[1], Type.exists(t.children[2]))
                    if (t.children[3])
                      for (a = t.children[2], l = {}, r = 0; r < a.length; r++)
                        l = Type.deepCopy(l, this.execute(a[r]), true);
                    else
                      l = this.execute(t.children[2]);
                  for (h = this.execute(t.children[0]), c = h && h.sc ? h.sc : this, !h.creator && Type.exists(t.children[2]) && this._error("Unexpected value. Only element creators are allowed to have a value after the function call."), r = 0; r < n.length; r++)
                    d[r] = this.execute(n[r]), this.dpstack[this.pscope].push({line: t.children[1][r].line, col: t.children[1][r].ecol});
                  if (typeof h != "function" || h.creator)
                    if (typeof h == "function" && h.creator) {
                      s = this.line;
                      try {
                        for (e2 = h(d, l), e2.jcLineStart = s, e2.jcLineEnd = t.eline, r = s; r <= t.line; r++)
                          this.lineToElement[r] = e2;
                        e2.debugParents = this.dpstack[this.pscope];
                      } catch (t2) {
                        this._error(t2.toString());
                      }
                    } else
                      this._error("Function '" + h + "' is undefined.");
                  else
                    e2 = h.apply(c, d);
                  this.dpstack.pop(), this.pscope--;
                  break;
                case "op_property":
                  s = this.execute(t.children[0]), i = t.children[1], e2 = this.resolveProperty(s, i, false), Type.exists(e2) && (e2.sc = s);
                  break;
                case "op_use":
                  this._warn("Use of the 'use' operator is deprecated."), this.use(t.children[0].toString());
                  break;
                case "op_delete":
                  this._warn("Use of the 'delete' operator is deprecated. Please use the remove() function."), i = this.getvar(t.children[0]), e2 = this.del(i);
                  break;
                case "op_equ":
                  e2 = this.execute(t.children[0]) == this.execute(t.children[1]);
                  break;
                case "op_neq":
                  e2 = this.execute(t.children[0]) != this.execute(t.children[1]);
                  break;
                case "op_approx":
                  e2 = Math.abs(this.execute(t.children[0]) - this.execute(t.children[1])) < Mat.eps;
                  break;
                case "op_grt":
                  e2 = this.execute(t.children[0]) > this.execute(t.children[1]);
                  break;
                case "op_lot":
                  e2 = this.execute(t.children[0]) < this.execute(t.children[1]);
                  break;
                case "op_gre":
                  e2 = this.execute(t.children[0]) >= this.execute(t.children[1]);
                  break;
                case "op_loe":
                  e2 = this.execute(t.children[0]) <= this.execute(t.children[1]);
                  break;
                case "op_or":
                  e2 = this.execute(t.children[0]) || this.execute(t.children[1]);
                  break;
                case "op_and":
                  e2 = this.execute(t.children[0]) && this.execute(t.children[1]);
                  break;
                case "op_not":
                  e2 = !this.execute(t.children[0]);
                  break;
                case "op_add":
                  e2 = this.add(this.execute(t.children[0]), this.execute(t.children[1]));
                  break;
                case "op_sub":
                  e2 = this.sub(this.execute(t.children[0]), this.execute(t.children[1]));
                  break;
                case "op_div":
                  e2 = this.div(this.execute(t.children[0]), this.execute(t.children[1]));
                  break;
                case "op_mod":
                  e2 = this.mod(this.execute(t.children[0]), this.execute(t.children[1]), true);
                  break;
                case "op_mul":
                  e2 = this.mul(this.execute(t.children[0]), this.execute(t.children[1]));
                  break;
                case "op_exp":
                  e2 = this.pow(this.execute(t.children[0]), this.execute(t.children[1]));
                  break;
                case "op_neg":
                  e2 = this.neg(this.execute(t.children[0]));
              }
              break;
            case "node_var":
              e2 = this.getvar(t.value);
              break;
            case "node_const":
              e2 = Number(t.value);
              break;
            case "node_const_bool":
              e2 = t.value;
              break;
            case "node_str":
              e2 = t.value.replace(/\\(.)/, "$1");
          }
          return e2;
        }, compile: function(t, e2) {
          var i, r, s, o = "";
          if (Type.exists(e2) || (e2 = false), !t)
            return o;
          switch (t.type) {
            case "node_op":
              switch (t.value) {
                case "op_none":
                  t.children[0] && (o = this.compile(t.children[0], e2)), t.children[1] && (o += this.compile(t.children[1], e2));
                  break;
                case "op_assign":
                  e2 ? (i = this.getLHSCompiler(t.children[0], e2), Type.isArray(i) ? o = "$jc$.setProp(" + i[0] + ", " + i[1] + ", " + this.compile(t.children[1], e2) + ");\n" : (this.isLocalVariable(i) !== this.scope && (this.scope.locals[i] = true), o = "$jc$.scopes[" + this.scope.id + "].locals['" + i + "'] = " + this.compile(t.children[1], e2) + ";\n")) : (i = this.compile(t.children[0]), o = i + " = " + this.compile(t.children[1], e2) + ";\n");
                  break;
                case "op_if":
                  o = " if (" + this.compile(t.children[0], e2) + ") " + this.compile(t.children[1], e2);
                  break;
                case "op_if_else":
                  o = " if (" + this.compile(t.children[0], e2) + ")" + this.compile(t.children[1], e2), o += " else " + this.compile(t.children[2], e2);
                  break;
                case "op_conditional":
                  o = "((" + this.compile(t.children[0], e2) + ")?(" + this.compile(t.children[1], e2), o += "):(" + this.compile(t.children[2], e2) + "))";
                  break;
                case "op_while":
                  o = " while (" + this.compile(t.children[0], e2) + ") {\n" + this.compile(t.children[1], e2) + "}\n";
                  break;
                case "op_do":
                  o = " do {\n" + this.compile(t.children[0], e2) + "} while (" + this.compile(t.children[1], e2) + ");\n";
                  break;
                case "op_for":
                  o = " for (" + this.compile(t.children[0], e2) + this.compile(t.children[1], e2) + "; " + this.compile(t.children[2], e2).slice(0, -2) + ") {\n" + this.compile(t.children[3], e2) + "\n}\n";
                  break;
                case "op_proplst":
                  t.children[0] && (o = this.compile(t.children[0], e2) + ", "), o += this.compile(t.children[1], e2);
                  break;
                case "op_prop":
                  o = t.children[0] + ": " + this.compile(t.children[1], e2);
                  break;
                case "op_emptyobject":
                  o = e2 ? "{}" : "<< >>";
                  break;
                case "op_proplst_val":
                  o = this.compile(t.children[0], e2);
                  break;
                case "op_array":
                  for (s = [], r = 0; r < t.children[0].length; r++)
                    s.push(this.compile(t.children[0][r], e2));
                  o = "[" + s.join(", ") + "]";
                  break;
                case "op_extvalue":
                  o = this.compile(t.children[0], e2) + "[" + this.compile(t.children[1], e2) + "]";
                  break;
                case "op_return":
                  o = " return " + this.compile(t.children[0], e2) + ";\n";
                  break;
                case "op_map":
                  t.children[1].isMath || t.children[1].type === "node_var" || this._error("compile: In a map only function calls and mathematical expressions are allowed."), s = t.children[0], o = e2 ? " $jc$.makeMap(function (" + s.join(", ") + ") { return " + this.compile(t.children[1], e2) + "; })" : "map (" + s.join(", ") + ") -> " + this.compile(t.children[1], e2);
                  break;
                case "op_function":
                  s = t.children[0], this.pushScope(s), o = e2 ? this.functionCodeJS(t) : " function (" + s.join(", ") + ") " + this.compile(t.children[1], e2), this.popScope();
                  break;
                case "op_execfunmath":
                  console.log("TODO"), o = "-1";
                  break;
                case "op_execfun":
                  if (t.children[2]) {
                    for (s = [], r = 0; r < t.children[2].length; r++)
                      s.push(this.compile(t.children[2][r], e2));
                    e2 && (i = "$jc$.mergeAttributes(" + s.join(", ") + ")");
                  }
                  for (t.children[0].withProps = !!t.children[2], s = [], r = 0; r < t.children[1].length; r++)
                    s.push(this.compile(t.children[1][r], e2));
                  o = this.compile(t.children[0], e2) + "(" + s.join(", ") + (t.children[2] && e2 ? ", " + i : "") + ")" + (t.children[2] && !e2 ? i : ""), e2 && (o += "\n"), e2 && t.children[0].value === "$" && (o = "$jc$.board.objects[" + this.compile(t.children[1][0], e2) + "]");
                  break;
                case "op_property":
                  o = e2 && t.children[1] !== "X" && t.children[1] !== "Y" ? "$jc$.resolveProperty(" + this.compile(t.children[0], e2) + ", '" + t.children[1] + "', true)" : this.compile(t.children[0], e2) + "." + t.children[1];
                  break;
                case "op_use":
                  this._warn("Use of the 'use' operator is deprecated."), o = e2 ? "$jc$.use('" : "use('", o += t.children[0].toString() + "');";
                  break;
                case "op_delete":
                  this._warn("Use of the 'delete' operator is deprecated. Please use the remove() function."), o = e2 ? "$jc$.del(" : "remove(", o += this.compile(t.children[0], e2) + ")";
                  break;
                case "op_equ":
                  o = "(" + this.compile(t.children[0], e2) + " == " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_neq":
                  o = "(" + this.compile(t.children[0], e2) + " != " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_approx":
                  o = "(" + this.compile(t.children[0], e2) + " ~= " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_grt":
                  o = e2 ? "$jc$.gt(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + " > " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_lot":
                  o = e2 ? "$jc$.lt(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + " < " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_gre":
                  o = e2 ? "$jc$.geq(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + " >= " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_loe":
                  o = e2 ? "$jc$.leq(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + " <= " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_or":
                  o = "(" + this.compile(t.children[0], e2) + " || " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_and":
                  o = "(" + this.compile(t.children[0], e2) + " && " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_not":
                  o = "!(" + this.compile(t.children[0], e2) + ")";
                  break;
                case "op_add":
                  o = e2 ? "$jc$.add(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + " + " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_sub":
                  o = e2 ? "$jc$.sub(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + " - " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_div":
                  o = e2 ? "$jc$.div(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + " / " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_mod":
                  o = e2 ? "$jc$.mod(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ", true)" : "(" + this.compile(t.children[0], e2) + " % " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_mul":
                  o = e2 ? "$jc$.mul(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + " * " + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_exp":
                  o = e2 ? "$jc$.pow(" + this.compile(t.children[0], e2) + ", " + this.compile(t.children[1], e2) + ")" : "(" + this.compile(t.children[0], e2) + "^" + this.compile(t.children[1], e2) + ")";
                  break;
                case "op_neg":
                  o = e2 ? "$jc$.neg(" + this.compile(t.children[0], e2) + ")" : "(-" + this.compile(t.children[0], e2) + ")";
              }
              break;
            case "node_var":
              o = e2 ? this.getvarJS(t.value, false, t.withProps) : t.value;
              break;
            case "node_const":
            case "node_const_bool":
              o = t.value;
              break;
            case "node_str":
              o = "'" + t.value + "'";
          }
          return t.needsBrackets && (o = "{\n" + o + "}\n"), o;
        }, X: function(t) {
          return t.X();
        }, Y: function(t) {
          return t.Y();
        }, V: function(t) {
          return t.Value();
        }, L: function(t) {
          return t.L();
        }, dist: function(t, e2) {
          return Type.exists(t) && Type.exists(t.Dist) || this._error("Error: Can't calculate distance."), t.Dist(e2);
        }, add: function(t, e2) {
          var i, r, s;
          if (t = Type.evalSlider(t), e2 = Type.evalSlider(e2), Interval.isInterval(t) || Interval.isInterval(e2))
            s = Interval.add(t, e2);
          else if (Type.isArray(t) && Type.isArray(e2))
            for (r = Math.min(t.length, e2.length), s = [], i = 0; i < r; i++)
              s[i] = t[i] + e2[i];
          else
            Type.isNumber(t) && Type.isNumber(e2) ? s = t + e2 : Type.isString(t) || Type.isString(e2) ? s = t.toString() + e2.toString() : this._error("Operation + not defined on operands " + typeof t + " and " + typeof e2);
          return s;
        }, sub: function(t, e2) {
          var i, r, s;
          if (t = Type.evalSlider(t), e2 = Type.evalSlider(e2), Interval.isInterval(t) || Interval.isInterval(e2))
            s = Interval.sub(t, e2);
          else if (Type.isArray(t) && Type.isArray(e2))
            for (r = Math.min(t.length, e2.length), s = [], i = 0; i < r; i++)
              s[i] = t[i] - e2[i];
          else
            Type.isNumber(t) && Type.isNumber(e2) ? s = t - e2 : this._error("Operation - not defined on operands " + typeof t + " and " + typeof e2);
          return s;
        }, neg: function(t) {
          var e2, i, r;
          if (t = Type.evalSlider(t), Interval.isInterval(t))
            r = Interval.negative(t);
          else if (Type.isArray(t))
            for (i = t.length, r = [], e2 = 0; e2 < i; e2++)
              r[e2] = -t[e2];
          else
            Type.isNumber(t) ? r = -t : this._error("Unary operation - not defined on operand " + typeof t);
          return r;
        }, mul: function(t, e2) {
          var i, r, s;
          if (t = Type.evalSlider(t), e2 = Type.evalSlider(e2), Type.isArray(t) && Type.isNumber(e2) && (i = t, t = e2, e2 = t), Interval.isInterval(t) || Interval.isInterval(e2))
            s = Interval.mul(t, e2);
          else if (Type.isArray(t) && Type.isArray(e2))
            r = Math.min(t.length, e2.length), s = Mat.innerProduct(t, e2, r);
          else if (Type.isNumber(t) && Type.isArray(e2))
            for (r = e2.length, s = [], i = 0; i < r; i++)
              s[i] = t * e2[i];
          else
            Type.isNumber(t) && Type.isNumber(e2) ? s = t * e2 : this._error("Operation * not defined on operands " + typeof t + " and " + typeof e2);
          return s;
        }, div: function(t, e2) {
          var i, r, s;
          if (t = Type.evalSlider(t), e2 = Type.evalSlider(e2), Interval.isInterval(t) || Interval.isInterval(e2))
            s = Interval.div(t, e2);
          else if (Type.isArray(t) && Type.isNumber(e2))
            for (r = t.length, s = [], i = 0; i < r; i++)
              s[i] = t[i] / e2;
          else
            Type.isNumber(t) && Type.isNumber(e2) ? s = t / e2 : this._error("Operation * not defined on operands " + typeof t + " and " + typeof e2);
          return s;
        }, mod: function(t, e2) {
          var i, r, s;
          if (t = Type.evalSlider(t), e2 = Type.evalSlider(e2), Interval.isInterval(t) || Interval.isInterval(e2))
            return Interval.fmod(t, e2);
          if (Type.isArray(t) && Type.isNumber(e2))
            for (r = t.length, s = [], i = 0; i < r; i++)
              s[i] = Mat.mod(t[i], e2, true);
          else
            Type.isNumber(t) && Type.isNumber(e2) ? s = Mat.mod(t, e2, true) : this._error("Operation * not defined on operands " + typeof t + " and " + typeof e2);
          return s;
        }, pow: function(t, e2) {
          return t = Type.evalSlider(t), e2 = Type.evalSlider(e2), Interval.isInterval(t) || Interval.isInterval(e2) ? Interval.pow(t, e2) : Mat.pow(t, e2);
        }, lt: function(t, e2) {
          return Interval.isInterval(t) || Interval.isInterval(e2) ? Interval.lt(t, e2) : t < e2;
        }, leq: function(t, e2) {
          return Interval.isInterval(t) || Interval.isInterval(e2) ? Interval.leq(t, e2) : t <= e2;
        }, gt: function(t, e2) {
          return Interval.isInterval(t) || Interval.isInterval(e2) ? Interval.gt(t, e2) : t > e2;
        }, geq: function(t, e2) {
          return Interval.isInterval(t) || Interval.isInterval(e2) ? Intervalt.geq(t, e2) : t >= e2;
        }, DDD: function(t) {
          console.log("Dummy derivative function. This should never appear!");
        }, ifthen: function(t, e2, i) {
          return t ? e2 : i;
        }, del: function(t) {
          typeof t == "object" && JXG.exists(t.type) && JXG.exists(t.elementClass) && this.board.removeObject(t);
        }, use: function(t) {
          var e2, i, r = false;
          if (typeof t == "string") {
            for (e2 in JXG.boards)
              if (JXG.boards.hasOwnProperty(e2) && JXG.boards[e2].container === t) {
                i = JXG.boards[e2], r = true;
                break;
              }
          } else
            i = t, r = true;
          r ? (this.board = i, this.builtIn.$board = i, this.builtIn.$board.src = "$jc$.board") : this._error("Board '" + t + "' not found!");
        }, findSymbol: function(t, e2) {
          var i, r;
          for (e2 = Type.def(e2, -1), r = e2 === -1 ? this.scope : this.scopes[e2]; r !== null; ) {
            for (i in r.locals)
              if (r.locals.hasOwnProperty(i) && r.locals[i] === t)
                return [i, r];
            r = r.previous;
          }
          return [];
        }, importModule: function(t) {
          return priv.modules[t.toLowerCase()];
        }, defineBuiltIn: function() {
          var t = this, e2 = {PI: Math.PI, EULER: Math.E, X: t.X, Y: t.Y, V: t.V, L: t.L, dist: t.dist, rad: Geometry.rad, deg: Geometry.trueAngle, factorial: Mat.factorial, trunc: Type.trunc, log: Mat.log, ln: Math.log, log10: Mat.log10, lg: Mat.log10, log2: Mat.log2, lb: Mat.log2, ld: Mat.log2, cosh: Mat.cosh, sinh: Mat.sinh, cot: Mat.cot, acot: Mat.acot, nthroot: Mat.nthroot, cbrt: Mat.cbrt, pow: Mat.pow, ratpow: Mat.ratpow, gcd: Mat.gcd, lcm: Mat.lcm, binomial: Mat.binomial, IfThen: t.ifthen, import: t.importModule, use: t.use, remove: t.del, $: t.getElementById, $board: t.board, $log: t.log, D: t.DDD};
          return e2.rad.sc = Geometry, e2.deg.sc = Geometry, e2.factorial.sc = Mat, e2.X.src = "$jc$.X", e2.Y.src = "$jc$.Y", e2.V.src = "$jc$.V", e2.L.src = "$jc$.L", e2.dist.src = "$jc$.dist", e2.rad.src = "JXG.Math.Geometry.rad", e2.deg.src = "JXG.Math.Geometry.trueAngle", e2.factorial.src = "JXG.Math.factorial", e2.trunc.src = "JXG.trunc", e2.log.src = "JXG.Math.log", e2.ln.src = "Math.log", e2.log10.src = "JXG.Math.log10", e2.lg.src = "JXG.Math.log10", e2.log2.src = "JXG.Math.log2", e2.lb.src = "JXG.Math.log2", e2.ld.src = "JXG.Math.log2", e2.cosh.src = "JXG.Math.cosh", e2.sinh.src = "JXG.Math.sinh", e2.cot.src = "JXG.Math.cot", e2.acot.src = "JXG.Math.acot", e2.nthroot.src = "JXG.Math.nthroot", e2.cbrt.src = "JXG.Math.cbrt", e2.pow.src = "JXG.Math.pow", e2.ratpow.src = "JXG.Math.ratpow", e2.gcd.src = "JXG.Math.gcd", e2.lcm.src = "JXG.Math.lcm", e2.binomial.src = "JXG.Math.binomial", e2.import.src = "$jc$.importModule", e2.use.src = "$jc$.use", e2.remove.src = "$jc$.del", e2.IfThen.src = "$jc$.ifthen", e2.$.src = "(function (n) { return $jc$.board.select(n); })", e2.$board && (e2.$board.src = "$jc$.board"), e2.$log.src = "$jc$.log", e2;
        }, _debug: function(t) {
          typeof console == "object" ? console.log(t) : Env.isBrowser && document && document.getElementById("debug") !== null && (document.getElementById("debug").innerHTML += t + "<br />");
        }, _error: function(t) {
          var e2 = new Error("Error(" + this.line + "): " + t);
          throw e2.line = this.line, e2;
        }, _warn: function(t) {
          typeof console == "object" ? console.log("Warning(" + this.line + "): " + t) : Env.isBrowser && document && document.getElementById(this.warnLog) !== null && (document.getElementById(this.warnLog).innerHTML += "Warning(" + this.line + "): " + t + "<br />");
        }, _log: function(t) {
          typeof window != "object" && typeof self == "object" && self.postMessage ? self.postMessage({type: "log", msg: "Log: " + t.toString()}) : console.log("Log: ", arguments);
        }});
        var parser = function() {
          function t() {
            this.yy = {};
          }
          var e2 = function(t2, e3, i2, r2) {
            for (i2 = i2 || {}, r2 = t2.length; r2--; i2[t2[r2]] = e3)
              ;
            return i2;
          }, i = [2, 14], r = [1, 13], s = [1, 37], o = [1, 14], n = [1, 15], a = [1, 21], h = [1, 16], l = [1, 17], c = [1, 33], d = [1, 18], u = [1, 19], p = [1, 12], f = [1, 59], m = [1, 60], g = [1, 58], b = [1, 46], v = [1, 48], y = [1, 49], C = [1, 50], _4 = [1, 51], P2 = [1, 52], E = [1, 53], x = [1, 54], S = [1, 45], O = [1, 38], w = [1, 39], T = [5, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], N = [5, 7, 8, 12, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], M = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], A = [2, 48], R = [1, 72], L = [10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 66, 83, 86], k = [1, 78], B = [8, 10, 16, 32, 34, 35, 37, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], I = [1, 82], Y = [8, 10, 16, 32, 34, 35, 37, 39, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], D = [1, 83], j = [1, 84], X = [1, 85], U = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], F = [1, 89], G = [1, 90], J = [1, 91], z = [1, 92], H = [1, 97], V = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 53, 54, 55, 57, 64, 65, 66, 83, 86], $ = [1, 103], q = [1, 104], W = [8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 57, 64, 65, 66, 83, 86], Z = [1, 105], Q2 = [1, 106], K = [1, 107], tt = [1, 126], et = [1, 139], it = [83, 86], rt = [1, 149], st = [10, 66, 86], ot = [8, 10, 16, 20, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 82, 83, 86], nt = [1, 166], at = [10, 86], ht = {trace: function() {
          }, yy: {}, symbols_: {error: 2, Program: 3, StatementList: 4, EOF: 5, IfStatement: 6, IF: 7, "(": 8, Expression: 9, ")": 10, Statement: 11, ELSE: 12, LoopStatement: 13, WHILE: 14, FOR: 15, ";": 16, DO: 17, UnaryStatement: 18, USE: 19, IDENTIFIER: 20, DELETE: 21, ReturnStatement: 22, RETURN: 23, EmptyStatement: 24, StatementBlock: 25, "{": 26, "}": 27, ExpressionStatement: 28, AssignmentExpression: 29, ConditionalExpression: 30, LeftHandSideExpression: 31, "=": 32, LogicalORExpression: 33, "?": 34, ":": 35, LogicalANDExpression: 36, "||": 37, EqualityExpression: 38, "&&": 39, RelationalExpression: 40, "==": 41, "!=": 42, "~=": 43, AdditiveExpression: 44, "<": 45, ">": 46, "<=": 47, ">=": 48, MultiplicativeExpression: 49, "+": 50, "-": 51, UnaryExpression: 52, "*": 53, "/": 54, "%": 55, ExponentExpression: 56, "^": 57, "!": 58, MemberExpression: 59, CallExpression: 60, PrimaryExpression: 61, FunctionExpression: 62, MapExpression: 63, ".": 64, "[": 65, "]": 66, BasicLiteral: 67, ObjectLiteral: 68, ArrayLiteral: 69, NullLiteral: 70, BooleanLiteral: 71, StringLiteral: 72, NumberLiteral: 73, NULL: 74, TRUE: 75, FALSE: 76, STRING: 77, NUMBER: 78, NAN: 79, INFINITY: 80, ElementList: 81, "<<": 82, ">>": 83, PropertyList: 84, Property: 85, ",": 86, PropertyName: 87, Arguments: 88, AttributeList: 89, Attribute: 90, FUNCTION: 91, ParameterDefinitionList: 92, MAP: 93, "->": 94, $accept: 0, $end: 1}, terminals_: {
            2: "error",
            5: "EOF",
            7: "IF",
            8: "(",
            10: ")",
            12: "ELSE",
            14: "WHILE",
            15: "FOR",
            16: ";",
            17: "DO",
            19: "USE",
            20: "IDENTIFIER",
            21: "DELETE",
            23: "RETURN",
            26: "{",
            27: "}",
            32: "=",
            34: "?",
            35: ":",
            37: "||",
            39: "&&",
            41: "==",
            42: "!=",
            43: "~=",
            45: "<",
            46: ">",
            47: "<=",
            48: ">=",
            50: "+",
            51: "-",
            53: "*",
            54: "/",
            55: "%",
            57: "^",
            58: "!",
            64: ".",
            65: "[",
            66: "]",
            74: "NULL",
            75: "TRUE",
            76: "FALSE",
            77: "STRING",
            78: "NUMBER",
            79: "NAN",
            80: "INFINITY",
            82: "<<",
            83: ">>",
            86: ",",
            91: "FUNCTION",
            93: "MAP",
            94: "->"
          }, productions_: [0, [3, 2], [6, 5], [6, 7], [13, 5], [13, 9], [13, 7], [18, 2], [18, 2], [22, 2], [22, 3], [24, 1], [25, 3], [4, 2], [4, 0], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [28, 2], [9, 1], [29, 1], [29, 3], [30, 1], [30, 5], [33, 1], [33, 3], [36, 1], [36, 3], [38, 1], [38, 3], [38, 3], [38, 3], [40, 1], [40, 3], [40, 3], [40, 3], [40, 3], [44, 1], [44, 3], [44, 3], [49, 1], [49, 3], [49, 3], [49, 3], [56, 1], [56, 3], [52, 1], [52, 2], [52, 2], [52, 2], [31, 1], [31, 1], [59, 1], [59, 1], [59, 1], [59, 3], [59, 4], [61, 1], [61, 1], [61, 1], [61, 1], [61, 3], [67, 1], [67, 1], [67, 1], [67, 1], [70, 1], [71, 1], [71, 1], [72, 1], [73, 1], [73, 1], [73, 1], [69, 2], [69, 3], [68, 2], [68, 3], [84, 1], [84, 3], [85, 3], [87, 1], [87, 1], [87, 1], [60, 2], [60, 3], [60, 2], [60, 4], [60, 3], [88, 2], [88, 3], [89, 1], [89, 3], [90, 1], [90, 1], [81, 1], [81, 3], [62, 4], [62, 5], [63, 6], [92, 1], [92, 3]], performAction: function(t2, e3, i2, r2, s2, o2, n3) {
            var a2 = o2.length - 1;
            switch (s2) {
              case 1:
                return o2[a2 - 1];
              case 2:
                this.$ = lt.createNode(ct(n3[a2 - 4]), "node_op", "op_if", o2[a2 - 2], o2[a2]);
                break;
              case 3:
                this.$ = lt.createNode(ct(n3[a2 - 6]), "node_op", "op_if_else", o2[a2 - 4], o2[a2 - 2], o2[a2]);
                break;
              case 4:
                this.$ = lt.createNode(ct(n3[a2 - 4]), "node_op", "op_while", o2[a2 - 2], o2[a2]);
                break;
              case 5:
                this.$ = lt.createNode(ct(n3[a2 - 8]), "node_op", "op_for", o2[a2 - 6], o2[a2 - 4], o2[a2 - 2], o2[a2]);
                break;
              case 6:
                this.$ = lt.createNode(ct(n3[a2 - 6]), "node_op", "op_do", o2[a2 - 5], o2[a2 - 2]);
                break;
              case 7:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_use", o2[a2]);
                break;
              case 8:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_delete", o2[a2]);
                break;
              case 9:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_return", void 0);
                break;
              case 10:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_return", o2[a2 - 1]);
                break;
              case 11:
              case 14:
                this.$ = lt.createNode(ct(n3[a2]), "node_op", "op_none");
                break;
              case 12:
                this.$ = o2[a2 - 1], this.$.needsBrackets = true;
                break;
              case 13:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_none", o2[a2 - 1], o2[a2]);
                break;
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 23:
              case 24:
              case 26:
              case 28:
              case 30:
              case 32:
              case 36:
              case 41:
              case 44:
              case 48:
              case 50:
              case 52:
              case 54:
              case 55:
              case 56:
              case 58:
              case 62:
              case 81:
              case 84:
              case 85:
              case 86:
                this.$ = o2[a2];
                break;
              case 22:
              case 65:
              case 93:
                this.$ = o2[a2 - 1];
                break;
              case 25:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_assign", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 27:
                this.$ = lt.createNode(ct(n3[a2 - 4]), "node_op", "op_conditional", o2[a2 - 4], o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 29:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_or", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 31:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_and", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 33:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_equ", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 34:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_neq", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 35:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_approx", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 37:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_lot", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 38:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_grt", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 39:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_loe", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 40:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_gre", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 42:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_add", o2[a2 - 2], o2[a2]), this.$.isMath = true;
                break;
              case 43:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_sub", o2[a2 - 2], o2[a2]), this.$.isMath = true;
                break;
              case 45:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_mul", o2[a2 - 2], o2[a2]), this.$.isMath = true;
                break;
              case 46:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_div", o2[a2 - 2], o2[a2]), this.$.isMath = true;
                break;
              case 47:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_mod", o2[a2 - 2], o2[a2]), this.$.isMath = true;
                break;
              case 49:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_exp", o2[a2 - 2], o2[a2]), this.$.isMath = true;
                break;
              case 51:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_not", o2[a2]), this.$.isMath = false;
                break;
              case 53:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_neg", o2[a2]), this.$.isMath = true;
                break;
              case 57:
              case 63:
              case 64:
              case 66:
              case 67:
              case 68:
              case 97:
                this.$ = o2[a2], this.$.isMath = false;
                break;
              case 59:
              case 91:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_property", o2[a2 - 2], o2[a2]), this.$.isMath = true;
                break;
              case 60:
              case 90:
                this.$ = lt.createNode(ct(n3[a2 - 3]), "node_op", "op_extvalue", o2[a2 - 3], o2[a2 - 1]), this.$.isMath = true;
                break;
              case 61:
                this.$ = lt.createNode(ct(n3[a2]), "node_var", o2[a2]);
                break;
              case 69:
                this.$ = o2[a2], this.$.isMath = true;
                break;
              case 70:
                this.$ = lt.createNode(ct(n3[a2]), "node_const", null);
                break;
              case 71:
                this.$ = lt.createNode(ct(n3[a2]), "node_const_bool", true);
                break;
              case 72:
                this.$ = lt.createNode(ct(n3[a2]), "node_const_bool", false);
                break;
              case 73:
                this.$ = lt.createNode(ct(n3[a2]), "node_str", o2[a2].substring(1, o2[a2].length - 1));
                break;
              case 74:
                this.$ = lt.createNode(ct(n3[a2]), "node_const", parseFloat(o2[a2]));
                break;
              case 75:
                this.$ = lt.createNode(ct(n3[a2]), "node_const", NaN);
                break;
              case 76:
                this.$ = lt.createNode(ct(n3[a2]), "node_const", 1 / 0);
                break;
              case 77:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_array", []);
                break;
              case 78:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_array", o2[a2 - 1]);
                break;
              case 79:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_emptyobject", {});
                break;
              case 80:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_proplst_val", o2[a2 - 1]);
                break;
              case 82:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_proplst", o2[a2 - 2], o2[a2]);
                break;
              case 83:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_prop", o2[a2 - 2], o2[a2]);
                break;
              case 87:
              case 89:
                this.$ = lt.createNode(ct(n3[a2 - 1]), "node_op", "op_execfun", o2[a2 - 1], o2[a2]), this.$.isMath = true;
                break;
              case 88:
                this.$ = lt.createNode(ct(n3[a2 - 2]), "node_op", "op_execfun", o2[a2 - 2], o2[a2 - 1], o2[a2], true), this.$.isMath = false;
                break;
              case 92:
                this.$ = [];
                break;
              case 94:
              case 98:
              case 103:
                this.$ = [o2[a2]];
                break;
              case 95:
              case 99:
              case 104:
                this.$ = o2[a2 - 2].concat(o2[a2]);
                break;
              case 96:
                this.$ = lt.createNode(ct(n3[a2]), "node_var", o2[a2]), this.$.isMath = true;
                break;
              case 100:
                this.$ = lt.createNode(ct(n3[a2 - 3]), "node_op", "op_function", [], o2[a2]), this.$.isMath = false;
                break;
              case 101:
                this.$ = lt.createNode(ct(n3[a2 - 4]), "node_op", "op_function", o2[a2 - 2], o2[a2]), this.$.isMath = false;
                break;
              case 102:
                this.$ = lt.createNode(ct(n3[a2 - 5]), "node_op", "op_map", o2[a2 - 3], o2[a2]);
            }
          }, table: [e2([5, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], i, {3: 1, 4: 2}), {1: [3]}, {5: [1, 3], 6: 6, 7: r, 8: s, 9: 20, 11: 4, 13: 7, 14: o, 15: n, 16: a, 17: h, 18: 8, 19: l, 20: c, 21: d, 22: 9, 23: u, 24: 11, 25: 5, 26: p, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {1: [2, 1]}, e2(T, [2, 13]), e2(N, [2, 15]), e2(N, [2, 16]), e2(N, [2, 17]), e2(N, [2, 18]), e2(N, [2, 19]), e2(N, [2, 20]), e2(N, [2, 21]), e2([7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78, 79, 80, 82, 91, 93], i, {4: 61}), {8: [1, 62]}, {8: [1, 63]}, {8: [1, 64]}, {6: 6, 7: r, 8: s, 9: 20, 11: 65, 13: 7, 14: o, 15: n, 16: a, 17: h, 18: 8, 19: l, 20: c, 21: d, 22: 9, 23: u, 24: 11, 25: 5, 26: p, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {20: [1, 66]}, {20: [1, 67]}, {8: s, 9: 69, 16: [1, 68], 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {16: [1, 70]}, e2(N, [2, 11]), e2(M, [2, 23]), e2(M, [2, 24]), e2([8, 10, 16, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 64, 65, 66, 83, 86], A, {32: [1, 71], 57: R}), e2([8, 10, 16, 32, 35, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83, 86], [2, 26], {34: [1, 73], 37: [1, 74]}), e2(L, [2, 54], {88: 77, 8: k, 64: [1, 75], 65: [1, 76]}), e2(L, [2, 55], {88: 79, 8: k, 64: [1, 81], 65: [1, 80]}), e2(B, [2, 28], {39: I}), e2(M, [2, 56]), e2(M, [2, 57]), e2(M, [2, 58]), e2(Y, [2, 30], {41: D, 42: j, 43: X}), e2(M, [2, 61]), e2(M, [2, 62]), e2(M, [2, 63]), e2(M, [2, 64]), {8: s, 9: 86, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: [1, 87]}, {8: [1, 88]}, e2(U, [2, 32], {45: F, 46: G, 47: J, 48: z}), e2(M, [2, 66]), e2(M, [2, 67]), e2(M, [2, 68]), e2(M, [2, 69]), {20: H, 72: 98, 73: 99, 77: _4, 78: P2, 79: E, 80: x, 83: [1, 93], 84: 94, 85: 95, 87: 96}, {8: s, 20: c, 29: 102, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 66: [1, 100], 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 81: 101, 82: S, 91: O, 93: w}, e2(V, [2, 36], {50: $, 51: q}), e2(M, [2, 70]), e2(M, [2, 71]), e2(M, [2, 72]), e2(M, [2, 73]), e2(M, [2, 74]), e2(M, [2, 75]), e2(M, [2, 76]), e2(W, [2, 41], {53: Z, 54: Q2, 55: K}), e2(M, [2, 44]), e2(M, [2, 50]), {8: s, 20: c, 31: 109, 50: f, 51: m, 52: 108, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 50: f, 51: m, 52: 110, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 50: f, 51: m, 52: 111, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {6: 6, 7: r, 8: s, 9: 20, 11: 4, 13: 7, 14: o, 15: n, 16: a, 17: h, 18: 8, 19: l, 20: c, 21: d, 22: 9, 23: u, 24: 11, 25: 5, 26: p, 27: [1, 112], 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 9: 113, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 9: 114, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 9: 115, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {14: [1, 116]}, e2(N, [2, 7]), e2(N, [2, 8]), e2(N, [2, 9]), {16: [1, 117]}, e2(N, [2, 22]), {8: s, 20: c, 29: 118, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 50: f, 51: m, 52: 119, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 29: 120, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 36: 121, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {20: [1, 122]}, {8: s, 9: 123, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, e2(M, [2, 87], {89: 124, 90: 125, 68: 127, 20: tt, 82: S}), {8: s, 10: [1, 128], 20: c, 29: 102, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 81: 129, 82: S, 91: O, 93: w}, e2(M, [2, 89]), {8: s, 9: 130, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {20: [1, 131]}, {8: s, 20: c, 31: 109, 38: 132, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 40: 133, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 40: 134, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 40: 135, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {10: [1, 136]}, {10: [1, 137], 20: et, 92: 138}, {20: et, 92: 140}, {8: s, 20: c, 31: 109, 44: 141, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 44: 142, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 44: 143, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 44: 144, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, e2(M, [2, 79]), {83: [1, 145], 86: [1, 146]}, e2(it, [2, 81]), {35: [1, 147]}, {35: [2, 84]}, {35: [2, 85]}, {35: [2, 86]}, e2(M, [2, 77]), {66: [1, 148], 86: rt}, e2(st, [2, 98]), {8: s, 20: c, 31: 109, 49: 150, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 49: 151, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 50: f, 51: m, 52: 152, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 50: f, 51: m, 52: 153, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 31: 109, 50: f, 51: m, 52: 154, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, e2(M, [2, 51]), e2([8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 64, 65, 66, 83, 86], A, {57: R}), e2(M, [2, 52]), e2(M, [2, 53]), e2([5, 7, 8, 10, 12, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 58, 64, 65, 66, 74, 75, 76, 77, 78, 79, 80, 82, 83, 86, 91, 93], [2, 12]), {10: [1, 155]}, {10: [1, 156]}, {16: [1, 157]}, {8: [1, 158]}, e2(N, [2, 10]), e2(M, [2, 25]), e2(M, [2, 49]), {35: [1, 159]}, e2(B, [2, 29], {39: I}), e2(M, [2, 59]), {66: [1, 160]}, e2([8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83], [2, 88], {86: [1, 161]}), e2(M, [2, 94]), e2(M, [2, 96]), e2(M, [2, 97]), e2(ot, [2, 92]), {10: [1, 162], 86: rt}, {66: [1, 163]}, e2(M, [2, 91]), e2(Y, [2, 31], {41: D, 42: j, 43: X}), e2(U, [2, 33], {45: F, 46: G, 47: J, 48: z}), e2(U, [2, 34], {45: F, 46: G, 47: J, 48: z}), e2(U, [2, 35], {45: F, 46: G, 47: J, 48: z}), e2(M, [2, 65]), {25: 164, 26: p}, {10: [1, 165], 86: nt}, e2(at, [2, 103]), {10: [1, 167], 86: nt}, e2(V, [2, 37], {50: $, 51: q}), e2(V, [2, 38], {50: $, 51: q}), e2(V, [2, 39], {50: $, 51: q}), e2(V, [2, 40], {50: $, 51: q}), e2(M, [2, 80]), {20: H, 72: 98, 73: 99, 77: _4, 78: P2, 79: E, 80: x, 85: 168, 87: 96}, {8: s, 20: c, 29: 169, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, e2(M, [2, 78]), {8: s, 20: c, 29: 170, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, e2(W, [2, 42], {53: Z, 54: Q2, 55: K}), e2(W, [2, 43], {53: Z, 54: Q2, 55: K}), e2(M, [2, 45]), e2(M, [2, 46]), e2(M, [2, 47]), {6: 6, 7: r, 8: s, 9: 20, 11: 171, 13: 7, 14: o, 15: n, 16: a, 17: h, 18: 8, 19: l, 20: c, 21: d, 22: 9, 23: u, 24: 11, 25: 5, 26: p, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {6: 6, 7: r, 8: s, 9: 20, 11: 172, 13: 7, 14: o, 15: n, 16: a, 17: h, 18: 8, 19: l, 20: c, 21: d, 22: 9, 23: u, 24: 11, 25: 5, 26: p, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 9: 173, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 9: 174, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 20: c, 29: 175, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, e2(M, [2, 60]), {20: tt, 68: 127, 82: S, 90: 176}, e2(ot, [2, 93]), e2(M, [2, 90]), e2(M, [2, 100]), {25: 177, 26: p}, {20: [1, 178]}, {94: [1, 179]}, e2(it, [2, 82]), e2(it, [2, 83]), e2(st, [2, 99]), e2(T, [2, 2], {12: [1, 180]}), e2(N, [2, 4]), {16: [1, 181]}, {10: [1, 182]}, e2(M, [2, 27]), e2(M, [2, 95]), e2(M, [2, 101]), e2(at, [2, 104]), {8: s, 9: 183, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {6: 6, 7: r, 8: s, 9: 20, 11: 184, 13: 7, 14: o, 15: n, 16: a, 17: h, 18: 8, 19: l, 20: c, 21: d, 22: 9, 23: u, 24: 11, 25: 5, 26: p, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {8: s, 9: 185, 20: c, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, {16: [1, 186]}, e2(M, [2, 102]), e2(N, [2, 3]), {10: [1, 187]}, e2(N, [2, 6]), {6: 6, 7: r, 8: s, 9: 20, 11: 188, 13: 7, 14: o, 15: n, 16: a, 17: h, 18: 8, 19: l, 20: c, 21: d, 22: 9, 23: u, 24: 11, 25: 5, 26: p, 28: 10, 29: 22, 30: 23, 31: 24, 33: 25, 36: 28, 38: 32, 40: 40, 44: 47, 49: 55, 50: f, 51: m, 52: 56, 56: 57, 58: g, 59: 26, 60: 27, 61: 29, 62: 30, 63: 31, 65: b, 67: 34, 68: 35, 69: 36, 70: 41, 71: 42, 72: 43, 73: 44, 74: v, 75: y, 76: C, 77: _4, 78: P2, 79: E, 80: x, 82: S, 91: O, 93: w}, e2(N, [2, 5])], defaultActions: {3: [2, 1], 97: [2, 84], 98: [2, 85], 99: [2, 86]}, parseError: function(t2, e3) {
            if (!e3.recoverable) {
              var i2 = new Error(t2);
              throw i2.hash = e3, i2;
            }
            this.trace(t2);
          }, parse: function(t2) {
            var e3 = this, i2 = [0], r2 = [null], s2 = [], o2 = this.table, n3 = "", a2 = 0, h2 = 0, l2 = 0, c2 = s2.slice.call(arguments, 1), d2 = Object.create(this.lexer), u2 = {yy: {}};
            for (var p2 in this.yy)
              Object.prototype.hasOwnProperty.call(this.yy, p2) && (u2.yy[p2] = this.yy[p2]);
            d2.setInput(t2, u2.yy), u2.yy.lexer = d2, u2.yy.parser = this, d2.yylloc === void 0 && (d2.yylloc = {});
            var f2 = d2.yylloc;
            s2.push(f2);
            var m2 = d2.options && d2.options.ranges;
            typeof u2.yy.parseError == "function" ? this.parseError = u2.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
            for (var g2, b2, v2, y2, C2, _5, P3, E2, x2, S2 = function() {
              var t3;
              return t3 = d2.lex() || 1, typeof t3 != "number" && (t3 = e3.symbols_[t3] || t3), t3;
            }, O2 = {}; ; ) {
              if (v2 = i2[i2.length - 1], this.defaultActions[v2] ? y2 = this.defaultActions[v2] : (g2 !== null && g2 !== void 0 || (g2 = S2()), y2 = o2[v2] && o2[v2][g2]), y2 === void 0 || !y2.length || !y2[0]) {
                var w2 = "";
                x2 = [];
                for (_5 in o2[v2])
                  this.terminals_[_5] && _5 > 2 && x2.push("'" + this.terminals_[_5] + "'");
                w2 = d2.showPosition ? "Parse error on line " + (a2 + 1) + ":\n" + d2.showPosition() + "\nExpecting " + x2.join(", ") + ", got '" + (this.terminals_[g2] || g2) + "'" : "Parse error on line " + (a2 + 1) + ": Unexpected " + (g2 == 1 ? "end of input" : "'" + (this.terminals_[g2] || g2) + "'"), this.parseError(w2, {text: d2.match, token: this.terminals_[g2] || g2, line: d2.yylineno, loc: f2, expected: x2});
              }
              if (y2[0] instanceof Array && y2.length > 1)
                throw new Error("Parse Error: multiple actions possible at state: " + v2 + ", token: " + g2);
              switch (y2[0]) {
                case 1:
                  i2.push(g2), r2.push(d2.yytext), s2.push(d2.yylloc), i2.push(y2[1]), g2 = null, b2 ? (g2 = b2, b2 = null) : (h2 = d2.yyleng, n3 = d2.yytext, a2 = d2.yylineno, f2 = d2.yylloc, l2 > 0 && l2--);
                  break;
                case 2:
                  if (P3 = this.productions_[y2[1]][1], O2.$ = r2[r2.length - P3], O2._$ = {first_line: s2[s2.length - (P3 || 1)].first_line, last_line: s2[s2.length - 1].last_line, first_column: s2[s2.length - (P3 || 1)].first_column, last_column: s2[s2.length - 1].last_column}, m2 && (O2._$.range = [s2[s2.length - (P3 || 1)].range[0], s2[s2.length - 1].range[1]]), (C2 = this.performAction.apply(O2, [n3, h2, a2, u2.yy, y2[1], r2, s2].concat(c2))) !== void 0)
                    return C2;
                  P3 && (i2 = i2.slice(0, -1 * P3 * 2), r2 = r2.slice(0, -1 * P3), s2 = s2.slice(0, -1 * P3)), i2.push(this.productions_[y2[1]][0]), r2.push(O2.$), s2.push(O2._$), E2 = o2[i2[i2.length - 2]][i2[i2.length - 1]], i2.push(E2);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }}, lt = {node: function(t2, e3, i2) {
            return {type: t2, value: e3, children: i2};
          }, createNode: function(t2, e3, i2, r2) {
            var s2, o2 = this.node(e3, i2, []);
            for (s2 = 3; s2 < arguments.length; s2++)
              o2.children.push(arguments[s2]);
            return o2.line = t2[0], o2.col = t2[1], o2.eline = t2[2], o2.ecol = t2[3], o2;
          }}, ct = function(t2) {
            return [t2.first_line, t2.first_column, t2.last_line, t2.last_column];
          }, dt = function() {
            return {EOF: 1, parseError: function(t2, e3) {
              if (!this.yy.parser)
                throw new Error(t2);
              this.yy.parser.parseError(t2, e3);
            }, setInput: function(t2, e3) {
              return this.yy = e3 || this.yy || {}, this._input = t2, this._more = this._backtrack = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {first_line: 1, first_column: 0, last_line: 1, last_column: 0}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
            }, input: function() {
              var t2 = this._input[0];
              return this.yytext += t2, this.yyleng++, this.offset++, this.match += t2, this.matched += t2, t2.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), t2;
            }, unput: function(t2) {
              var e3 = t2.length, i2 = t2.split(/(?:\r\n?|\n)/g);
              this._input = t2 + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - e3), this.offset -= e3;
              var r2 = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), i2.length - 1 && (this.yylineno -= i2.length - 1);
              var s2 = this.yylloc.range;
              return this.yylloc = {first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: i2 ? (i2.length === r2.length ? this.yylloc.first_column : 0) + r2[r2.length - i2.length].length - i2[0].length : this.yylloc.first_column - e3}, this.options.ranges && (this.yylloc.range = [s2[0], s2[0] + this.yyleng - e3]), this.yyleng = this.yytext.length, this;
            }, more: function() {
              return this._more = true, this;
            }, reject: function() {
              return this.options.backtrack_lexer ? (this._backtrack = true, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {text: "", token: null, line: this.yylineno});
            }, less: function(t2) {
              this.unput(this.match.slice(t2));
            }, pastInput: function() {
              var t2 = this.matched.substr(0, this.matched.length - this.match.length);
              return (t2.length > 20 ? "..." : "") + t2.substr(-20).replace(/\n/g, "");
            }, upcomingInput: function() {
              var t2 = this.match;
              return t2.length < 20 && (t2 += this._input.substr(0, 20 - t2.length)), (t2.substr(0, 20) + (t2.length > 20 ? "..." : "")).replace(/\n/g, "");
            }, showPosition: function() {
              var t2 = this.pastInput(), e3 = new Array(t2.length + 1).join("-");
              return t2 + this.upcomingInput() + "\n" + e3 + "^";
            }, test_match: function(t2, e3) {
              var i2, r2, s2;
              if (this.options.backtrack_lexer && (s2 = {yylineno: this.yylineno, yylloc: {first_line: this.yylloc.first_line, last_line: this.last_line, first_column: this.yylloc.first_column, last_column: this.yylloc.last_column}, yytext: this.yytext, match: this.match, matches: this.matches, matched: this.matched, yyleng: this.yyleng, offset: this.offset, _more: this._more, _input: this._input, yy: this.yy, conditionStack: this.conditionStack.slice(0), done: this.done}, this.options.ranges && (s2.yylloc.range = this.yylloc.range.slice(0))), r2 = t2[0].match(/(?:\r\n?|\n).*/g), r2 && (this.yylineno += r2.length), this.yylloc = {first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: r2 ? r2[r2.length - 1].length - r2[r2.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + t2[0].length}, this.yytext += t2[0], this.match += t2[0], this.matches = t2, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = false, this._backtrack = false, this._input = this._input.slice(t2[0].length), this.matched += t2[0], i2 = this.performAction.call(this, this.yy, this, e3, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = false), i2)
                return i2;
              if (this._backtrack) {
                for (var o2 in s2)
                  this[o2] = s2[o2];
                return false;
              }
              return false;
            }, next: function() {
              if (this.done)
                return this.EOF;
              this._input || (this.done = true);
              var t2, e3, i2, r2;
              this._more || (this.yytext = "", this.match = "");
              for (var s2 = this._currentRules(), o2 = 0; o2 < s2.length; o2++)
                if ((i2 = this._input.match(this.rules[s2[o2]])) && (!e3 || i2[0].length > e3[0].length)) {
                  if (e3 = i2, r2 = o2, this.options.backtrack_lexer) {
                    if ((t2 = this.test_match(i2, s2[o2])) !== false)
                      return t2;
                    if (this._backtrack) {
                      e3 = false;
                      continue;
                    }
                    return false;
                  }
                  if (!this.options.flex)
                    break;
                }
              return e3 ? (t2 = this.test_match(e3, s2[r2])) !== false && t2 : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {text: "", token: null, line: this.yylineno});
            }, lex: function() {
              var t2 = this.next();
              return t2 || this.lex();
            }, begin: function(t2) {
              this.conditionStack.push(t2);
            }, popState: function() {
              return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
            }, _currentRules: function() {
              return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
            }, topState: function(t2) {
              return t2 = this.conditionStack.length - 1 - Math.abs(t2 || 0), t2 >= 0 ? this.conditionStack[t2] : "INITIAL";
            }, pushState: function(t2) {
              this.begin(t2);
            }, stateStackSize: function() {
              return this.conditionStack.length;
            }, options: {}, performAction: function(t2, e3, i2, r2) {
              switch (i2) {
                case 0:
                  break;
                case 1:
                case 2:
                  return 78;
                case 3:
                case 4:
                  return 77;
                case 5:
                case 6:
                  break;
                case 7:
                  return 7;
                case 8:
                  return 12;
                case 9:
                  return 14;
                case 10:
                  return 17;
                case 11:
                  return 15;
                case 12:
                  return 91;
                case 13:
                  return 93;
                case 14:
                  return 19;
                case 15:
                  return 23;
                case 16:
                  return 21;
                case 17:
                  return 75;
                case 18:
                  return 76;
                case 19:
                  return 74;
                case 20:
                  return 80;
                case 21:
                  return 94;
                case 22:
                  return 82;
                case 23:
                  return 83;
                case 24:
                  return 26;
                case 25:
                  return 27;
                case 26:
                  return 16;
                case 27:
                  return "#";
                case 28:
                  return 34;
                case 29:
                  return 35;
                case 30:
                  return 79;
                case 31:
                  return 64;
                case 32:
                  return 65;
                case 33:
                  return 66;
                case 34:
                  return 8;
                case 35:
                  return 10;
                case 36:
                  return 58;
                case 37:
                  return 57;
                case 38:
                  return 53;
                case 39:
                  return 54;
                case 40:
                  return 55;
                case 41:
                  return 50;
                case 42:
                  return 51;
                case 43:
                  return 47;
                case 44:
                  return 45;
                case 45:
                  return 48;
                case 46:
                  return 46;
                case 47:
                  return 41;
                case 48:
                  return 43;
                case 49:
                  return 42;
                case 50:
                  return 39;
                case 51:
                  return 37;
                case 52:
                  return 32;
                case 53:
                  return 86;
                case 54:
                  return 5;
                case 55:
                  return 20;
                case 56:
                  return "INVALID";
              }
            }, rules: [/^(?:\s+)/, /^(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+\b)/, /^(?:[0-9]+)/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:\/\/.*)/, /^(?:\/\*(.|\n|\r)*?\*\/)/, /^(?:if\b)/, /^(?:else\b)/, /^(?:while\b)/, /^(?:do\b)/, /^(?:for\b)/, /^(?:function\b)/, /^(?:map\b)/, /^(?:use\b)/, /^(?:return\b)/, /^(?:delete\b)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:Infinity\b)/, /^(?:->)/, /^(?:<<)/, /^(?:>>)/, /^(?:\{)/, /^(?:\})/, /^(?:;)/, /^(?:#)/, /^(?:\?)/, /^(?::)/, /^(?:NaN\b)/, /^(?:\.)/, /^(?:\[)/, /^(?:\])/, /^(?:\()/, /^(?:\))/, /^(?:!)/, /^(?:\^)/, /^(?:\*)/, /^(?:\/)/, /^(?:%)/, /^(?:\+)/, /^(?:-)/, /^(?:<=)/, /^(?:<)/, /^(?:>=)/, /^(?:>)/, /^(?:==)/, /^(?:~=)/, /^(?:!=)/, /^(?:&&)/, /^(?:\|\|)/, /^(?:=)/, /^(?:,)/, /^(?:$)/, /^(?:[A-Za-z_\$][A-Za-z0-9_]*)/, /^(?:.)/], conditions: {INITIAL: {rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56], inclusive: true}}};
          }();
          return ht.lexer = dt, t.prototype = ht, ht.Parser = t, new t();
        }();
        return require !== void 0 && typeof exports != "undefined" && (exports.parser = parser, exports.Parser = parser.Parser, exports.parse = function() {
          return parser.parse.apply(parser, arguments);
        }, exports.main = function(t) {
          t[1] || (console.log("Usage: " + t[0] + " FILE"), process.exit(1));
          var e2 = require("fs").readFileSync(require("path").normalize(t[1]), "utf8");
          return exports.parser.parse(e2);
        }, typeof module != "undefined" && require.main === module && exports.main(process.argv.slice(1))), parser.yy.parseError = parser.parseError, JXG.JessieCode;
      }), define("base/point", ["jxg", "options", "math/math", "math/geometry", "math/numerics", "base/coords", "base/constants", "base/element", "parser/geonext", "utils/type", "base/transformation", "base/coordselement"], function(t, e2, i, r, s, o, n, a, h, l, c, d) {
        "use strict";
        return t.Point = function(t2, e3, i2) {
          this.constructor(t2, i2, n.OBJECT_TYPE_POINT, n.OBJECT_CLASS_POINT), this.element = this.board.select(i2.anchor), this.coordsConstructor(e3), this.elType = "point", this.id = this.board.setId(this, "P"), this.board.renderer.drawPoint(this), this.board.finalizeAdding(this), this.createLabel();
        }, t.Point.prototype = new a(), l.copyPrototypeMethods(t.Point, d, "coordsConstructor"), t.extend(t.Point.prototype, {hasPoint: function(t2, e3) {
          var i2, r2, s2, o2 = this.coords.scrCoords, n3 = l.evaluate(this.visProp.sizeunit);
          return l.isObject(l.evaluate(this.visProp.precision)) ? (s2 = this.board._inputDevice, r2 = l.evaluate(this.visProp.precision[s2])) : r2 = this.board.options.precision.hasPoint, i2 = parseFloat(l.evaluate(this.visProp.size)), n3 === "user" && (i2 *= Math.sqrt(this.board.unitX * this.board.unitY)), i2 += 0.5 * parseFloat(l.evaluate(this.visProp.strokewidth)), i2 < r2 && (i2 = r2), Math.abs(o2[1] - t2) < i2 + 2 && Math.abs(o2[2] - e3) < i2 + 2;
        }, update: function(t2) {
          return this.needsUpdate ? (this.updateCoords(t2), l.evaluate(this.visProp.trace) && this.cloneToBackground(true), this) : this;
        }, updateTransform: function() {
          var t2, e3;
          if (this.transformations.length === 0 || this.baseElement === null)
            return this;
          for (t2 = this === this.baseElement ? this.transformations[0].apply(this.baseElement, "self") : this.transformations[0].apply(this.baseElement), this.coords.setCoordinates(n.COORDS_BY_USER, t2), e3 = 1; e3 < this.transformations.length; e3++)
            this.coords.setCoordinates(n.COORDS_BY_USER, this.transformations[e3].apply(this));
          return this;
        }, updateRenderer: function() {
          return this.updateRendererGeneric("updatePoint"), this;
        }, bounds: function() {
          return this.coords.usrCoords.slice(1).concat(this.coords.usrCoords.slice(1));
        }, makeIntersection: function(t2, e3, i2, s2) {
          var o2;
          t2 = this.board.select(t2), e3 = this.board.select(e3), o2 = r.intersectionFunction(this.board, t2, e3, i2, s2, l.evaluate(this.visProp.alwaysintersect)), this.addConstraint([o2]);
          try {
            t2.addChild(this), e3.addChild(this);
          } catch (i3) {
            throw new Error("JSXGraph: Can't create 'intersection' with parent types '" + typeof t2 + "' and '" + typeof e3 + "'.");
          }
          this.type = n.OBJECT_TYPE_INTERSECTION, this.elType = "intersection", this.parents = [t2.id, e3.id, i2, s2], this.generatePolynomial = function() {
            var i3 = t2.generatePolynomial(this), r2 = e3.generatePolynomial(this);
            return i3.length === 0 || r2.length === 0 ? [] : [i3[0], r2[0]];
          }, this.prepareUpdate().update();
        }, setStyle: function(t2) {
          var e3 = ["cross", "cross", "cross", "circle", "circle", "circle", "circle", "square", "square", "square", "plus", "plus", "plus"], i2 = [2, 3, 4, 1, 2, 3, 4, 2, 3, 4, 2, 3, 4];
          return this.visProp.face = e3[t2], this.visProp.size = i2[t2], this.board.renderer.changePointStyle(this), this;
        }, normalizeFace: function(i2) {
          return t.deprecated("Point.normalizeFace()", "JXG.normalizePointFace()"), e2.normalizePointFace(i2);
        }, face: function(e3) {
          t.deprecated("Point.face()", "Point.setAttribute()"), this.setAttribute({face: e3});
        }, size: function(e3) {
          t.deprecated("Point.size()", "Point.setAttribute()"), this.setAttribute({size: e3});
        }, cloneToBackground: function() {
          var t2 = {};
          return t2.id = this.id + "T" + this.numTraces, this.numTraces += 1, t2.coords = this.coords, t2.visProp = l.deepCopy(this.visProp, this.visProp.traceattributes, true), t2.visProp.layer = this.board.options.layer.trace, t2.elementClass = n.OBJECT_CLASS_POINT, t2.board = this.board, l.clearVisPropOld(t2), t2.visPropCalc = {visible: l.evaluate(t2.visProp.visible)}, this.board.renderer.drawPoint(t2), this.traces[t2.id] = t2.rendNode, this;
        }}), t.createPoint = function(e3, i2, r2) {
          var s2, o2;
          if (o2 = l.copyAttributes(r2, e3.options, "point"), !(s2 = d.create(t.Point, e3, i2, o2)))
            throw new Error("JSXGraph: Can't create point with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
          return s2;
        }, t.createGlider = function(t2, e3, i2) {
          var r2, s2, o2 = l.copyAttributes(i2, t2.options, "glider");
          return s2 = e3.length === 1 ? [0, 0] : e3.slice(0, 2), r2 = t2.create("point", s2, o2), r2.makeGlider(e3[e3.length - 1]), r2;
        }, t.createIntersectionPoint = function(t2, e3, i2) {
          var s2, o2, a2, h2, c2, d2, u = l.copyAttributes(i2, t2.options, "intersection");
          e3.push(0, 0), o2 = t2.select(e3[0]), a2 = t2.select(e3[1]), c2 = e3[2] || 0, d2 = e3[3] || 0, s2 = t2.create("point", [0, 0, 0], u), h2 = r.intersectionFunction(t2, o2, a2, c2, d2, s2.visProp.alwaysintersect), s2.addConstraint([h2]);
          try {
            o2.addChild(s2), a2.addChild(s2);
          } catch (t3) {
            throw new Error("JSXGraph: Can't create 'intersection' with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.");
          }
          return s2.type = n.OBJECT_TYPE_INTERSECTION, s2.elType = "intersection", s2.setParents([o2.id, a2.id]), s2.intersectionNumbers = [c2, d2], s2.getParents = function() {
            return this.parents.concat(this.intersectionNumbers);
          }, s2.generatePolynomial = function() {
            var t3 = o2.generatePolynomial(s2), e4 = a2.generatePolynomial(s2);
            return t3.length === 0 || e4.length === 0 ? [] : [t3[0], e4[0]];
          }, s2;
        }, t.createOtherIntersectionPoint = function(t2, e3, s2) {
          var o2, a2, h2, c2;
          if (e3.length !== 3 || !l.isPoint(e3[2]) || e3[0].elementClass !== n.OBJECT_CLASS_LINE && e3[0].elementClass !== n.OBJECT_CLASS_CIRCLE || e3[1].elementClass !== n.OBJECT_CLASS_LINE && e3[1].elementClass !== n.OBJECT_CLASS_CIRCLE)
            throw new Error("JSXGraph: Can't create 'other intersection point' with parent types '" + typeof e3[0] + "',  '" + typeof e3[1] + "'and  '" + typeof e3[2] + "'.\nPossible parent types: [circle|line,circle|line,point]");
          return a2 = t2.select(e3[0]), h2 = t2.select(e3[1]), c2 = t2.select(e3[2]), o2 = t2.create("point", [function() {
            var t3 = r.meet(a2.stdform, h2.stdform, 0, a2.board);
            return Math.abs(c2.X() - t3.usrCoords[1]) > i.eps || Math.abs(c2.Y() - t3.usrCoords[2]) > i.eps || Math.abs(c2.Z() - t3.usrCoords[0]) > i.eps ? t3 : r.meet(a2.stdform, h2.stdform, 1, a2.board);
          }], s2), o2.type = n.OBJECT_TYPE_INTERSECTION, o2.elType = "otherintersection", o2.setParents([a2.id, h2.id, c2]), a2.addChild(o2), h2.addChild(o2), o2.generatePolynomial = function() {
            var t3 = a2.generatePolynomial(o2), e4 = h2.generatePolynomial(o2);
            return t3.length === 0 || e4.length === 0 ? [] : [t3[0], e4[0]];
          }, o2;
        }, t.createPolePoint = function(e3, i2, r2) {
          var s2, o2, a2, h2, l2, c2, d2;
          if (i2.length > 1 && (h2 = i2[0].type === n.OBJECT_TYPE_CONIC || i2[0].elementClass === n.OBJECT_CLASS_CIRCLE, l2 = i2[1].type === n.OBJECT_TYPE_CONIC || i2[1].elementClass === n.OBJECT_CLASS_CIRCLE, c2 = i2[0].elementClass === n.OBJECT_CLASS_LINE, d2 = i2[1].elementClass === n.OBJECT_CLASS_LINE), i2.length !== 2 || !(h2 && d2 || c2 && l2))
            throw new Error("JSXGraph: Can't create 'pole point' with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent type: [conic|circle,line], [line,conic|circle]");
          return d2 ? (o2 = e3.select(i2[0]), a2 = e3.select(i2[1])) : (o2 = e3.select(i2[1]), a2 = e3.select(i2[0])), s2 = e3.create("point", [function() {
            var e4 = o2.quadraticform, i3 = a2.stdform.slice(0, 3);
            return [t.Math.Numerics.det([i3, e4[1], e4[2]]), t.Math.Numerics.det([e4[0], i3, e4[2]]), t.Math.Numerics.det([e4[0], e4[1], i3])];
          }], r2), s2.elType = "polepoint", s2.setParents([o2.id, a2.id]), o2.addChild(s2), a2.addChild(s2), s2;
        }, t.registerElement("point", t.createPoint), t.registerElement("glider", t.createGlider), t.registerElement("intersection", t.createIntersectionPoint), t.registerElement("otherintersection", t.createOtherIntersectionPoint), t.registerElement("polepoint", t.createPolePoint), {Point: t.Point, createPoint: t.createPoint, createGlider: t.createGlider, createIntersection: t.createIntersectionPoint, createOtherIntersection: t.createOtherIntersectionPoint, createPolePoint: t.createPolePoint};
      }), define("base/line", ["jxg", "math/math", "math/geometry", "math/numerics", "math/statistics", "base/constants", "base/coords", "base/element", "utils/type", "base/point"], function(t, e2, i, r, s, o, n, a, h, l) {
        "use strict";
        return t.Line = function(e3, i2, r2, s2) {
          this.constructor(e3, s2, o.OBJECT_TYPE_LINE, o.OBJECT_CLASS_LINE), this.point1 = this.board.select(i2), this.point2 = this.board.select(r2), this.ticks = [], this.defaultTicks = null, this.parentPolygon = null, this.id = this.board.setId(this, "L"), this.board.renderer.drawLine(this), this.board.finalizeAdding(this), this.elType = "line", this.point1.addChild(this), this.point2.addChild(this), this.inherits.push(this.point1, this.point2), this.updateStdform(), this.createLabel(), this.methodMap = t.deepCopy(this.methodMap, {point1: "point1", point2: "point2", getSlope: "getSlope", getRise: "getRise", getYIntersect: "getRise", getAngle: "getAngle", L: "L", length: "L"});
        }, t.Line.prototype = new a(), t.extend(t.Line.prototype, {hasPoint: function(t2, r2) {
          var s2, a2, l2, c, d, u, p, f, m, g = [], b = [1, t2, r2], v = h.evaluate(this.visProp.strokewidth);
          return h.isObject(h.evaluate(this.visProp.precision)) ? (m = this.board._inputDevice, f = h.evaluate(this.visProp.precision[m])) : f = this.board.options.precision.hasPoint, f += 0.5 * v, g[0] = this.stdform[0] - this.stdform[1] * this.board.origin.scrCoords[1] / this.board.unitX + this.stdform[2] * this.board.origin.scrCoords[2] / this.board.unitY, g[1] = this.stdform[1] / this.board.unitX, g[2] = this.stdform[2] / -this.board.unitY, s2 = i.distPointLine(b, g), !(isNaN(s2) || s2 > f) && (!(!h.evaluate(this.visProp.straightfirst) || !h.evaluate(this.visProp.straightlast)) || (l2 = this.point1.coords, c = this.point2.coords, a2 = [0, g[1], g[2]], a2 = e2.crossProduct(a2, b), a2 = e2.crossProduct(a2, g), a2[1] /= a2[0], a2[2] /= a2[0], a2[0] = 1, a2 = new n(o.COORDS_BY_SCREEN, a2.slice(1), this.board).usrCoords, d = l2.distance(o.COORDS_BY_USER, c), l2 = l2.usrCoords.slice(0), c = c.usrCoords.slice(0), d < e2.eps ? u = 0 : (d === Number.POSITIVE_INFINITY && (d = 1 / e2.eps, Math.abs(c[0]) < e2.eps ? (d /= i.distance([0, 0, 0], c), c = [1, l2[1] + c[1] * d, l2[2] + c[2] * d]) : (d /= i.distance([0, 0, 0], l2), l2 = [1, c[1] + l2[1] * d, c[2] + l2[2] * d])), p = 1, d = c[p] - l2[p], Math.abs(d) < e2.eps && (p = 2, d = c[p] - l2[p]), u = (a2[p] - l2[p]) / d), !(!h.evaluate(this.visProp.straightfirst) && u < 0) && !(!h.evaluate(this.visProp.straightlast) && u > 1)));
        }, update: function() {
          var t2;
          return this.needsUpdate ? (this.constrained && (h.isFunction(this.funps) ? (t2 = this.funps()) && t2.length && t2.length === 2 && (this.point1 = t2[0], this.point2 = t2[1]) : (h.isFunction(this.funp1) && (t2 = this.funp1(), h.isPoint(t2) ? this.point1 = t2 : t2 && t2.length && t2.length === 2 && this.point1.setPositionDirectly(o.COORDS_BY_USER, t2)), h.isFunction(this.funp2) && (t2 = this.funp2(), h.isPoint(t2) ? this.point2 = t2 : t2 && t2.length && t2.length === 2 && this.point2.setPositionDirectly(o.COORDS_BY_USER, t2)))), this.updateSegmentFixedLength(), this.updateStdform(), h.evaluate(this.visProp.trace) && this.cloneToBackground(true), this) : this;
        }, updateSegmentFixedLength: function() {
          var t2, i2, r2, s2, n3, a2, l2, c;
          return this.hasFixedLength ? (t2 = this.point1.Dist(this.point2), i2 = this.fixedLength(), r2 = this.fixedLengthOldCoords[0].distance(o.COORDS_BY_USER, this.point1.coords), s2 = this.fixedLengthOldCoords[1].distance(o.COORDS_BY_USER, this.point2.coords), (r2 > e2.eps || s2 > e2.eps || t2 !== i2) && (n3 = this.point1.isDraggable && this.point1.type !== o.OBJECT_TYPE_GLIDER && !h.evaluate(this.point1.visProp.fixed), a2 = this.point2.isDraggable && this.point2.type !== o.OBJECT_TYPE_GLIDER && !h.evaluate(this.point2.visProp.fixed), t2 > e2.eps ? r2 > s2 && a2 || r2 <= s2 && a2 && !n3 ? (this.point2.setPositionDirectly(o.COORDS_BY_USER, [this.point1.X() + (this.point2.X() - this.point1.X()) * i2 / t2, this.point1.Y() + (this.point2.Y() - this.point1.Y()) * i2 / t2]), this.point2.fullUpdate()) : (r2 <= s2 && n3 || r2 > s2 && n3 && !a2) && (this.point1.setPositionDirectly(o.COORDS_BY_USER, [this.point2.X() + (this.point1.X() - this.point2.X()) * i2 / t2, this.point2.Y() + (this.point1.Y() - this.point2.Y()) * i2 / t2]), this.point1.fullUpdate()) : (l2 = Math.random() - 0.5, c = Math.random() - 0.5, t2 = Math.sqrt(l2 * l2 + c * c), a2 ? (this.point2.setPositionDirectly(o.COORDS_BY_USER, [this.point1.X() + l2 * i2 / t2, this.point1.Y() + c * i2 / t2]), this.point2.fullUpdate()) : n3 && (this.point1.setPositionDirectly(o.COORDS_BY_USER, [this.point2.X() + l2 * i2 / t2, this.point2.Y() + c * i2 / t2]), this.point1.fullUpdate())), this.fixedLengthOldCoords[0].setCoordinates(o.COORDS_BY_USER, this.point1.coords.usrCoords), this.fixedLengthOldCoords[1].setCoordinates(o.COORDS_BY_USER, this.point2.coords.usrCoords)), this) : this;
        }, updateStdform: function() {
          var t2 = e2.crossProduct(this.point1.coords.usrCoords, this.point2.coords.usrCoords);
          this.stdform[0] = t2[0], this.stdform[1] = t2[1], this.stdform[2] = t2[2], this.stdform[3] = 0, this.normalize();
        }, updateRenderer: function() {
          return this.needsUpdate ? (this.visPropCalc.visible && (this.isReal = !isNaN(this.point1.coords.usrCoords[1] + this.point1.coords.usrCoords[2] + this.point2.coords.usrCoords[1] + this.point2.coords.usrCoords[2]) && e2.innerProduct(this.stdform, this.stdform, 3) >= e2.eps * e2.eps, this.isReal || this.updateVisibility(false)), this.visPropCalc.visible && this.board.renderer.updateLine(this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
        }, generatePolynomial: function(t2) {
          var e3 = this.point1.symbolic.x, i2 = this.point1.symbolic.y, r2 = this.point2.symbolic.x, s2 = this.point2.symbolic.y, o2 = t2.symbolic.x, n3 = t2.symbolic.y;
          return [["(", i2, ")*(", o2, ")-(", i2, ")*(", r2, ")+(", n3, ")*(", r2, ")-(", e3, ")*(", n3, ")+(", e3, ")*(", s2, ")-(", o2, ")*(", s2, ")"].join("")];
        }, getRise: function() {
          return Math.abs(this.stdform[2]) >= e2.eps ? -this.stdform[0] / this.stdform[2] : 1 / 0;
        }, getSlope: function() {
          return Math.abs(this.stdform[2]) >= e2.eps ? -this.stdform[1] / this.stdform[2] : 1 / 0;
        }, getAngle: function() {
          return Math.atan2(-this.stdform[1], this.stdform[2]);
        }, setStraight: function(t2, e3) {
          return this.visProp.straightfirst = t2, this.visProp.straightlast = e3, this.board.renderer.updateLine(this), this;
        }, getTextAnchor: function() {
          return new n(o.COORDS_BY_USER, [0.5 * (this.point2.X() + this.point1.X()), 0.5 * (this.point2.Y() + this.point1.Y())], this.board);
        }, setLabelRelativeCoords: function(t2) {
          h.exists(this.label) && (this.label.relativeCoords = new n(o.COORDS_BY_SCREEN, [t2[0], -t2[1]], this.board));
        }, getLabelAnchor: function() {
          var t2, r2, s2 = 0, a2 = new n(o.COORDS_BY_USER, this.point1.coords.usrCoords, this.board), l2 = new n(o.COORDS_BY_USER, this.point2.coords.usrCoords, this.board), c = h.evaluate(this.visProp.straightfirst), d = h.evaluate(this.visProp.straightlast);
          if ((c || d) && i.calcStraight(this, a2, l2, 0), a2 = a2.scrCoords, l2 = l2.scrCoords, !h.exists(this.label))
            return new n(o.COORDS_BY_SCREEN, [NaN, NaN], this.board);
          switch (h.evaluate(this.label.visProp.position)) {
            case "lft":
            case "llft":
            case "ulft":
              a2[1] <= l2[1] ? (t2 = a2[1], r2 = a2[2]) : (t2 = l2[1], r2 = l2[2]);
              break;
            case "rt":
            case "lrt":
            case "urt":
              a2[1] > l2[1] ? (t2 = a2[1], r2 = a2[2]) : (t2 = l2[1], r2 = l2[2]);
              break;
            default:
              t2 = 0.5 * (a2[1] + l2[1]), r2 = 0.5 * (a2[2] + l2[2]);
          }
          return (c || d) && (h.exists(this.label) && (s2 = h.evaluate(this.label.visProp.fontsize)), Math.abs(t2) < e2.eps ? t2 = s2 : this.board.canvasWidth + e2.eps > t2 && t2 > this.board.canvasWidth - s2 - e2.eps && (t2 = this.board.canvasWidth - s2), e2.eps + s2 > r2 && r2 > -e2.eps ? r2 = s2 : this.board.canvasHeight + e2.eps > r2 && r2 > this.board.canvasHeight - s2 - e2.eps && (r2 = this.board.canvasHeight - s2)), new n(o.COORDS_BY_SCREEN, [t2, r2], this.board);
        }, cloneToBackground: function() {
          var t2, e3, i2, r2 = {};
          return r2.id = this.id + "T" + this.numTraces, r2.elementClass = o.OBJECT_CLASS_LINE, this.numTraces++, r2.point1 = this.point1, r2.point2 = this.point2, r2.stdform = this.stdform, r2.board = this.board, r2.visProp = h.deepCopy(this.visProp, this.visProp.traceattributes, true), r2.visProp.layer = this.board.options.layer.trace, h.clearVisPropOld(r2), r2.visPropCalc = {visible: h.evaluate(r2.visProp.visible)}, e3 = this.getSlope(), t2 = this.getRise(), r2.getSlope = function() {
            return e3;
          }, r2.getRise = function() {
            return t2;
          }, i2 = this.board.renderer.enhancedRendering, this.board.renderer.enhancedRendering = true, this.board.renderer.drawLine(r2), this.board.renderer.enhancedRendering = i2, this.traces[r2.id] = r2.rendNode, this;
        }, addTransform: function(t2) {
          var e3, i2 = h.isArray(t2) ? t2 : [t2], r2 = i2.length;
          for (e3 = 0; e3 < r2; e3++)
            this.point1.transformations.push(i2[e3]), this.point2.transformations.push(i2[e3]);
          return this;
        }, snapToGrid: function(t2) {
          var e3, r2, a2, l2, c, d, u, p, f;
          return h.evaluate(this.visProp.snaptogrid) ? this.parents.length < 3 ? (this.point1.handleSnapToGrid(true, true), this.point2.handleSnapToGrid(true, true)) : h.exists(t2) && (p = h.evaluate(this.visProp.snapsizex), f = h.evaluate(this.visProp.snapsizey), e3 = new n(o.COORDS_BY_SCREEN, [t2.Xprev, t2.Yprev], this.board), d = e3.usrCoords[1], u = e3.usrCoords[2], p <= 0 && this.board.defaultAxes && this.board.defaultAxes.x.defaultTicks && (c = this.board.defaultAxes.x.defaultTicks, p = c.ticksDelta * (h.evaluate(c.visProp.minorticks) + 1)), f <= 0 && this.board.defaultAxes && this.board.defaultAxes.y.defaultTicks && (c = this.board.defaultAxes.y.defaultTicks, f = c.ticksDelta * (h.evaluate(c.visProp.minorticks) + 1)), p > 0 && f > 0 && (r2 = i.projectPointToLine({coords: e3}, this, this.board), a2 = s.subtract([1, Math.round(d / p) * p, Math.round(u / f) * f], r2.usrCoords), l2 = this.board.create("transform", a2.slice(1), {type: "translate"}), l2.applyOnce([this.point1, this.point2]))) : (this.point1.handleSnapToGrid(false, true), this.point2.handleSnapToGrid(false, true)), this;
        }, snapToPoints: function() {
          var t2 = h.evaluate(this.visProp.snaptopoints);
          return this.parents.length < 3 && (this.point1.handleSnapToPoints(t2), this.point2.handleSnapToPoints(t2)), this;
        }, X: function(t2) {
          var i2, r2 = this.stdform[2];
          return i2 = Math.abs(this.point1.coords.usrCoords[0]) > e2.eps ? this.point1.coords.usrCoords[1] : this.point2.coords.usrCoords[1], t2 = 2 * (t2 - 0.5), (1 - Math.abs(t2)) * i2 - t2 * r2;
        }, Y: function(t2) {
          var i2, r2 = this.stdform[1];
          return i2 = Math.abs(this.point1.coords.usrCoords[0]) > e2.eps ? this.point1.coords.usrCoords[2] : this.point2.coords.usrCoords[2], t2 = 2 * (t2 - 0.5), (1 - Math.abs(t2)) * i2 + t2 * r2;
        }, Z: function(t2) {
          var i2 = Math.abs(this.point1.coords.usrCoords[0]) > e2.eps ? this.point1.coords.usrCoords[0] : this.point2.coords.usrCoords[0];
          return t2 = 2 * (t2 - 0.5), (1 - Math.abs(t2)) * i2;
        }, L: function() {
          return this.point1.Dist(this.point2);
        }, minX: function() {
          return 0;
        }, maxX: function() {
          return 1;
        }, bounds: function() {
          var t2 = this.point1.coords.usrCoords, e3 = this.point2.coords.usrCoords;
          return [Math.min(t2[1], e3[1]), Math.max(t2[2], e3[2]), Math.max(t2[1], e3[1]), Math.min(t2[2], e3[2])];
        }, remove: function() {
          this.removeAllTicks(), a.prototype.remove.call(this);
        }}), t.createLine = function(e3, i2, r2) {
          var s2, o2, n3, a2, c, d, u, p = [], f = false, m = false;
          if (i2.length === 2) {
            if (h.isArray(i2[0]) && i2[0].length > 1)
              d = h.copyAttributes(r2, e3.options, "line", "point1"), n3 = e3.create("point", i2[0], d);
            else if (h.isString(i2[0]) || h.isPoint(i2[0]))
              n3 = e3.select(i2[0]);
            else if (h.isFunction(i2[0]) && h.isPoint(i2[0]()))
              n3 = i2[0](), m = true;
            else if (h.isFunction(i2[0]) && i2[0]().length && i2[0]().length >= 2)
              d = h.copyAttributes(r2, e3.options, "line", "point1"), n3 = l.createPoint(e3, i2[0](), d), m = true;
            else {
              if (!h.isObject(i2[0]) || !h.isTransformationOrArray(i2[1]))
                throw new Error("JSXGraph: Can't create line with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]");
              f = true, d = h.copyAttributes(r2, e3.options, "line", "point1"), n3 = e3.create("point", [i2[0].point1, i2[1]], d);
            }
            if (f)
              d = h.copyAttributes(r2, e3.options, "line", "point2"), a2 = e3.create("point", [i2[0].point2, i2[1]], d);
            else if (h.isArray(i2[1]) && i2[1].length > 1)
              d = h.copyAttributes(r2, e3.options, "line", "point2"), a2 = e3.create("point", i2[1], d);
            else if (h.isString(i2[1]) || h.isPoint(i2[1]))
              a2 = e3.select(i2[1]);
            else if (h.isFunction(i2[1]) && h.isPoint(i2[1]()))
              a2 = i2[1](), m = true;
            else {
              if (!(h.isFunction(i2[1]) && i2[1]().length && i2[1]().length >= 2))
                throw new Error("JSXGraph: Can't create line with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]");
              d = h.copyAttributes(r2, e3.options, "line", "point2"), a2 = l.createPoint(e3, i2[1](), d), m = true;
            }
            d = h.copyAttributes(r2, e3.options, "line"), o2 = new t.Line(e3, n3, a2, d), m ? (o2.constrained = true, o2.funp1 = i2[0], o2.funp2 = i2[1]) : f || (o2.isDraggable = true), o2.setParents([n3.id, a2.id]);
          } else if (i2.length === 3) {
            for (u = true, c = 0; c < 3; c++)
              if (h.isNumber(i2[c]))
                p[c] = h.createFunction(i2[c]);
              else {
                if (!h.isFunction(i2[c]))
                  throw new Error("JSXGraph: Can't create line with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "' and '" + typeof i2[2] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]");
                p[c] = i2[c], u = false;
              }
            d = h.copyAttributes(r2, e3.options, "line", "point1"), n3 = u ? e3.create("point", [p[2]() * p[2]() + p[1]() * p[1](), p[2]() - p[1]() * p[0]() + p[2](), -p[1]() - p[2]() * p[0]() - p[1]()], d) : e3.create("point", [function() {
              return 0.5 * (p[2]() * p[2]() + p[1]() * p[1]());
            }, function() {
              return 0.5 * (p[2]() - p[1]() * p[0]() + p[2]());
            }, function() {
              return 0.5 * (-p[1]() - p[2]() * p[0]() - p[1]());
            }], d), d = h.copyAttributes(r2, e3.options, "line", "point2"), a2 = u ? e3.create("point", [p[2]() * p[2]() + p[1]() * p[1](), -p[1]() * p[0]() + p[2](), -p[2]() * p[0]() - p[1]()], d) : e3.create("point", [function() {
              return p[2]() * p[2]() + p[1]() * p[1]();
            }, function() {
              return -p[1]() * p[0]() + p[2]();
            }, function() {
              return -p[2]() * p[0]() - p[1]();
            }], d), n3.prepareUpdate().update(), a2.prepareUpdate().update(), d = h.copyAttributes(r2, e3.options, "line"), o2 = new t.Line(e3, n3, a2, d), o2.isDraggable = u, o2.setParents([n3, a2]);
          } else if (i2.length === 1 && h.isFunction(i2[0]) && i2[0]().length === 2 && h.isPoint(i2[0]()[0]) && h.isPoint(i2[0]()[1]))
            s2 = i2[0](), d = h.copyAttributes(r2, e3.options, "line"), o2 = new t.Line(e3, s2[0], s2[1], d), o2.constrained = true, o2.funps = i2[0], o2.setParents(s2);
          else {
            if (!(i2.length === 1 && h.isFunction(i2[0]) && i2[0]().length === 3 && h.isNumber(i2[0]()[0]) && h.isNumber(i2[0]()[1]) && h.isNumber(i2[0]()[2])))
              throw new Error("JSXGraph: Can't create line with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]");
            s2 = i2[0], d = h.copyAttributes(r2, e3.options, "line", "point1"), n3 = e3.create("point", [function() {
              var t2 = s2();
              return [0.5 * (t2[2] * t2[2] + t2[1] * t2[1]), 0.5 * (t2[2] - t2[1] * t2[0] + t2[2]), 0.5 * (-t2[1] - t2[2] * t2[0] - t2[1])];
            }], d), d = h.copyAttributes(r2, e3.options, "line", "point2"), a2 = e3.create("point", [function() {
              var t2 = s2();
              return [t2[2] * t2[2] + t2[1] * t2[1], -t2[1] * t2[0] + t2[2], -t2[2] * t2[0] - t2[1]];
            }], d), d = h.copyAttributes(r2, e3.options, "line"), o2 = new t.Line(e3, n3, a2, d), o2.constrained = true, o2.funps = i2[0], o2.setParents([n3, a2]);
          }
          return o2;
        }, t.registerElement("line", t.createLine), t.createSegment = function(t2, e3, i2) {
          var r2, s2;
          if (i2.straightFirst = false, i2.straightLast = false, s2 = h.copyAttributes(i2, t2.options, "segment"), r2 = t2.create("line", e3.slice(0, 2), s2), e3.length === 3) {
            if (r2.hasFixedLength = true, h.isNumber(e3[2]))
              r2.fixedLength = function() {
                return e3[2];
              };
            else {
              if (!h.isFunction(e3[2]))
                throw new Error("JSXGraph: Can't create segment with third parent type '" + typeof e3[2] + "'.\nPossible third parent types: number or function");
              r2.fixedLength = e3[2];
            }
            r2.getParents = function() {
              return this.parents.concat(this.fixedLength());
            }, r2.fixedLengthOldCoords = [], r2.fixedLengthOldCoords[0] = new n(o.COORDS_BY_USER, r2.point1.coords.usrCoords.slice(1, 3), t2), r2.fixedLengthOldCoords[1] = new n(o.COORDS_BY_USER, r2.point2.coords.usrCoords.slice(1, 3), t2);
          }
          return r2.elType = "segment", r2;
        }, t.registerElement("segment", t.createSegment), t.createArrow = function(t2, e3, i2) {
          var r2, s2;
          return i2.straightFirst = false, i2.straightLast = false, s2 = h.copyAttributes(i2, t2.options, "arrow"), r2 = t2.create("line", e3, s2), r2.type = o.OBJECT_TYPE_VECTOR, r2.elType = "arrow", r2;
        }, t.registerElement("arrow", t.createArrow), t.createAxis = function(t2, e3, i2) {
          var r2, s2, n3, a2, l2;
          if (!h.isArray(e3[0]) && !h.isPoint(e3[0]) || !h.isArray(e3[1]) && !h.isPoint(e3[1]))
            throw new Error("JSXGraph: Can't create axis with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]");
          r2 = h.copyAttributes(i2, t2.options, "axis"), n3 = t2.create("line", e3, r2), n3.type = o.OBJECT_TYPE_AXIS, n3.isDraggable = false, n3.point1.isDraggable = false, n3.point2.isDraggable = false;
          for (a2 in n3.ancestors)
            n3.ancestors.hasOwnProperty(a2) && (n3.ancestors[a2].type = o.OBJECT_TYPE_AXISPOINT);
          return s2 = h.copyAttributes(i2, t2.options, "axis", "ticks"), l2 = h.exists(s2.ticksdistance) ? s2.ticksdistance : h.isArray(s2.ticks) ? s2.ticks : 1, n3.defaultTicks = t2.create("ticks", [n3, l2], s2), n3.defaultTicks.dump = false, n3.elType = "axis", n3.subs = {ticks: n3.defaultTicks}, n3.inherits.push(n3.defaultTicks), n3;
        }, t.registerElement("axis", t.createAxis), t.createTangent = function(t2, i2, s2) {
          var n3, a2, l2, c, d;
          if (i2.length === 1)
            n3 = i2[0], a2 = n3.slideObject;
          else {
            if (i2.length !== 2)
              throw new Error("JSXGraph: Can't create tangent with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [glider], [point,line|curve|circle|conic]");
            if (h.isPoint(i2[0]))
              n3 = i2[0], a2 = i2[1];
            else {
              if (!h.isPoint(i2[1]))
                throw new Error("JSXGraph: Can't create tangent with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [glider], [point,line|curve|circle|conic]");
              a2 = i2[0], n3 = i2[1];
            }
          }
          if (a2.elementClass === o.OBJECT_CLASS_LINE ? (d = t2.create("line", [a2.point1, a2.point2], s2), d.glider = n3) : a2.elementClass === o.OBJECT_CLASS_CURVE && a2.type !== o.OBJECT_TYPE_CONIC ? h.evaluate(a2.visProp.curvetype) !== "plot" ? (d = t2.create("line", [function() {
            var t3 = a2.X, e3 = a2.Y;
            return -n3.X() * r.D(e3)(n3.position) + n3.Y() * r.D(t3)(n3.position);
          }, function() {
            return r.D(a2.Y)(n3.position);
          }, function() {
            return -r.D(a2.X)(n3.position);
          }], s2), n3.addChild(d), d.glider = n3) : (d = t2.create("line", [function() {
            var t3, e3, i3 = Math.floor(n3.position);
            return i3 === a2.numberPoints - 1 && i3--, i3 < 0 ? 1 : (t3 = a2.points[i3].usrCoords, e3 = a2.points[i3 + 1].usrCoords, t3[2] * e3[1] - t3[1] * e3[2]);
          }, function() {
            var t3, e3, i3 = Math.floor(n3.position);
            return i3 === a2.numberPoints - 1 && i3--, i3 < 0 ? 0 : (t3 = a2.points[i3].usrCoords, e3 = a2.points[i3 + 1].usrCoords, e3[2] - t3[2]);
          }, function() {
            var t3, e3, i3 = Math.floor(n3.position);
            return i3 === a2.numberPoints - 1 && i3--, i3 < 0 ? 0 : (t3 = a2.points[i3].usrCoords, e3 = a2.points[i3 + 1].usrCoords, t3[1] - e3[1]);
          }], s2), n3.addChild(d), d.glider = n3) : a2.type === o.OBJECT_TYPE_TURTLE ? (d = t2.create("line", [function() {
            var t3 = Math.floor(n3.position);
            for (l2 = 0; l2 < a2.objects.length; l2++)
              if (c = a2.objects[l2], c.type === o.OBJECT_TYPE_CURVE) {
                if (t3 < c.numberPoints)
                  break;
                t3 -= c.numberPoints;
              }
            return t3 === c.numberPoints - 1 && t3--, t3 < 0 ? 1 : c.Y(t3) * c.X(t3 + 1) - c.X(t3) * c.Y(t3 + 1);
          }, function() {
            var t3 = Math.floor(n3.position);
            for (l2 = 0; l2 < a2.objects.length; l2++)
              if (c = a2.objects[l2], c.type === o.OBJECT_TYPE_CURVE) {
                if (t3 < c.numberPoints)
                  break;
                t3 -= c.numberPoints;
              }
            return t3 === c.numberPoints - 1 && t3--, t3 < 0 ? 0 : c.Y(t3 + 1) - c.Y(t3);
          }, function() {
            var t3 = Math.floor(n3.position);
            for (l2 = 0; l2 < a2.objects.length; l2++)
              if (c = a2.objects[l2], c.type === o.OBJECT_TYPE_CURVE) {
                if (t3 < c.numberPoints)
                  break;
                t3 -= c.numberPoints;
              }
            return t3 === c.numberPoints - 1 && t3--, t3 < 0 ? 0 : c.X(t3) - c.X(t3 + 1);
          }], s2), n3.addChild(d), d.glider = n3) : a2.elementClass !== o.OBJECT_CLASS_CIRCLE && a2.type !== o.OBJECT_TYPE_CONIC || (d = t2.create("line", [function() {
            return e2.matVecMult(a2.quadraticform, n3.coords.usrCoords)[0];
          }, function() {
            return e2.matVecMult(a2.quadraticform, n3.coords.usrCoords)[1];
          }, function() {
            return e2.matVecMult(a2.quadraticform, n3.coords.usrCoords)[2];
          }], s2), n3.addChild(d), d.glider = n3), !h.exists(d))
            throw new Error("JSXGraph: Couldn't create tangent with the given parents.");
          return d.elType = "tangent", d.type = o.OBJECT_TYPE_TANGENT, d.setParents(i2), d;
        }, t.createRadicalAxis = function(t2, i2, r2) {
          var s2, n3, a2;
          if (i2.length !== 2 || i2[0].elementClass !== o.OBJECT_CLASS_CIRCLE || i2[1].elementClass !== o.OBJECT_CLASS_CIRCLE)
            throw new Error("JSXGraph: Can't create 'radical axis' with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent type: [circle,circle]");
          return n3 = t2.select(i2[0]), a2 = t2.select(i2[1]), s2 = t2.create("line", [function() {
            var t3 = n3.stdform, i3 = a2.stdform;
            return e2.matVecMult(e2.transpose([t3.slice(0, 3), i3.slice(0, 3)]), [i3[3], -t3[3]]);
          }], r2), s2.elType = "radicalaxis", s2.setParents([n3.id, a2.id]), n3.addChild(s2), a2.addChild(s2), s2;
        }, t.createPolarLine = function(t2, e3, i2) {
          var r2, s2, n3, a2, l2, c, d;
          if (e3.length > 1 && (a2 = e3[0].type === o.OBJECT_TYPE_CONIC || e3[0].elementClass === o.OBJECT_CLASS_CIRCLE, l2 = e3[1].type === o.OBJECT_TYPE_CONIC || e3[1].elementClass === o.OBJECT_CLASS_CIRCLE, c = h.isPoint(e3[0]), d = h.isPoint(e3[1])), e3.length !== 2 || !(a2 && d || c && l2))
            throw new Error("JSXGraph: Can't create 'polar line' with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent type: [conic|circle,point], [point,conic|circle]");
          return d ? (s2 = t2.select(e3[0]), n3 = t2.select(e3[1])) : (s2 = t2.select(e3[1]), n3 = t2.select(e3[0])), r2 = t2.create("tangent", [s2, n3], i2), r2.elType = "polarline", r2;
        }, t.registerElement("tangent", t.createTangent), t.registerElement("polar", t.createTangent), t.registerElement("radicalaxis", t.createRadicalAxis), t.registerElement("polarline", t.createPolarLine), {Line: t.Line, createLine: t.createLine, createTangent: t.createTangent, createPolar: t.createTangent, createSegment: t.createSegment, createAxis: t.createAxis, createArrow: t.createArrow, createRadicalAxis: t.createRadicalAxis, createPolarLine: t.createPolarLine};
      }), define("base/curve", ["jxg", "base/constants", "base/coords", "base/element", "math/math", "math/numerics", "math/plot", "math/geometry", "parser/geonext", "utils/type", "math/qdt"], function(t, e2, i, r, s, o, n, a, h, l, c) {
        "use strict";
        return t.Curve = function(t2, i2, r2) {
          this.constructor(t2, r2, e2.OBJECT_TYPE_CURVE, e2.OBJECT_CLASS_CURVE), this.points = [], this.numberPoints = l.evaluate(this.visProp.numberpointshigh), this.bezierDegree = 1, this.dataX = null, this.dataY = null, this.ticks = [], this.qdt = null, l.exists(i2[0]) ? this.varname = i2[0] : this.varname = "x", this.xterm = i2[1], this.yterm = i2[2], this.generateTerm(this.varname, this.xterm, this.yterm, i2[3], i2[4]), this.updateCurve(), this.id = this.board.setId(this, "G"), this.board.renderer.drawCurve(this), this.board.finalizeAdding(this), this.createGradient(), this.elType = "curve", this.createLabel(), l.isString(this.xterm) && this.notifyParents(this.xterm), l.isString(this.yterm) && this.notifyParents(this.yterm), this.methodMap = l.deepCopy(this.methodMap, {generateTerm: "generateTerm", setTerm: "generateTerm", move: "moveTo", moveTo: "moveTo"});
        }, t.Curve.prototype = new r(), t.extend(t.Curve.prototype, {minX: function() {
          var t2;
          return l.evaluate(this.visProp.curvetype) === "polar" ? 0 : (t2 = new i(e2.COORDS_BY_SCREEN, [0.1 * -this.board.canvasWidth, 0], this.board, false), t2.usrCoords[1]);
        }, maxX: function() {
          var t2;
          return l.evaluate(this.visProp.curvetype) === "polar" ? 2 * Math.PI : (t2 = new i(e2.COORDS_BY_SCREEN, [1.1 * this.board.canvasWidth, 0], this.board, false), t2.usrCoords[1]);
        }, X: function(t2) {
          return NaN;
        }, Y: function(t2) {
          return NaN;
        }, Z: function(t2) {
          return 1;
        }, hasPoint: function(t2, r2, o2) {
          var n3, h2, c2, d, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S = [], O = l.evaluate(this.visProp.numberpointslow), w = (this.maxX() - this.minX()) / O, T = 1 / 0;
          if (l.isObject(l.evaluate(this.visProp.precision)) ? (y = this.board._inputDevice, v = l.evaluate(this.visProp.precision[y])) : v = this.board.options.precision.hasPoint, h2 = new i(e2.COORDS_BY_SCREEN, [t2, r2], this.board, false), t2 = h2.usrCoords[1], r2 = h2.usrCoords[2], v += 0.5 * l.evaluate(this.visProp.strokewidth), v *= v, C = this.board.unitX * this.board.unitX, _4 = this.board.unitY * this.board.unitY, E = this.minX(), x = this.maxX(), l.exists(this._visibleArea) && (E = this._visibleArea[0], x = this._visibleArea[1], w = (x - E) / O), (P2 = l.evaluate(this.visProp.curvetype)) === "parameter" || P2 === "polar")
            for (this.transformations.length > 0 && (this.updateTransformMatrix(), d = s.inverse(this.transformMat), u = s.matVecMult(d, [1, t2, r2]), t2 = u[1], r2 = u[2]), p = 0, n3 = E; p < O; p++) {
              if (f = this.X(n3, true), m = this.Y(n3, true), (T = (t2 - f) * (t2 - f) * C + (r2 - m) * (r2 - m) * _4) <= v)
                return true;
              n3 += w;
            }
          else if (P2 === "plot" || P2 === "functiongraph") {
            for ((!l.exists(o2) || o2 < 0) && (o2 = 0), l.exists(this.qdt) && l.evaluate(this.visProp.useqdt) && this.bezierDegree !== 3 ? (b = this.qdt.query(new i(e2.COORDS_BY_USER, [t2, r2], this.board)), g = b.points, c2 = g.length) : (g = this.points, c2 = this.numberPoints - 1), p = o2; p < c2; p++)
              if (this.bezierDegree === 3 ? S.push(a.projectCoordsToBeziersegment([1, t2, r2], this, p)) : b ? (g[p].prev && (S = a.projectCoordsToSegment([1, t2, r2], g[p].prev.usrCoords, g[p].usrCoords)), g[p].next && g[p + 1] !== g[p].next && (S = a.projectCoordsToSegment([1, t2, r2], g[p].usrCoords, g[p].next.usrCoords))) : S = a.projectCoordsToSegment([1, t2, r2], g[p].usrCoords, g[p + 1].usrCoords), S[1] >= 0 && S[1] <= 1 && (t2 - S[0][1]) * (t2 - S[0][1]) * C + (r2 - S[0][2]) * (r2 - S[0][2]) * _4 <= v)
                return true;
            return false;
          }
          return T < v;
        }, allocatePoints: function() {
          var t2, r2;
          if (r2 = this.numberPoints, this.points.length < this.numberPoints)
            for (t2 = this.points.length; t2 < r2; t2++)
              this.points[t2] = new i(e2.COORDS_BY_USER, [0, 0], this.board, false);
        }, update: function() {
          return this.needsUpdate && (l.evaluate(this.visProp.trace) && this.cloneToBackground(true), this.updateCurve()), this;
        }, updateRenderer: function() {
          return this.needsUpdate ? (this.visPropCalc.visible && (this.isReal = n.checkReal(this.points), this.isReal || this.updateVisibility(false)), this.visPropCalc.visible && this.board.renderer.updateCurve(this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
        }, updateDataArray: function() {
        }, updateCurve: function() {
          var t2, i2, r2, s2, a2, h2, d = this.visProp.plotversion, u = false;
          if (this.updateTransformMatrix(), this.updateDataArray(), i2 = this.minX(), r2 = this.maxX(), l.exists(this.dataX))
            for (this.numberPoints = this.dataX.length, t2 = this.numberPoints, this.allocatePoints(), h2 = 0; h2 < t2; h2++)
              s2 = h2, l.exists(this.dataY) ? (a2 = h2, this.points[h2].setCoordinates(e2.COORDS_BY_USER, [this.dataX[h2], this.dataY[h2]], false)) : (a2 = this.X(s2), this.points[h2].setCoordinates(e2.COORDS_BY_USER, [this.dataX[h2], this.Y(a2, u)], false)), this.points[h2]._t = h2, u = true;
          else if (l.evaluate(this.visProp.doadvancedplot) ? d === 1 || l.evaluate(this.visProp.doadvancedplotold) ? n.updateParametricCurveOld(this, i2, r2) : d === 2 ? n.updateParametricCurve_v2(this, i2, r2) : d === 3 ? n.updateParametricCurve_v3(this, i2, r2) : d === 4 ? n.updateParametricCurve_v4(this, i2, r2) : n.updateParametricCurve_v2(this, i2, r2) : (this.board.updateQuality === this.board.BOARD_QUALITY_HIGH ? this.numberPoints = l.evaluate(this.visProp.numberpointshigh) : this.numberPoints = l.evaluate(this.visProp.numberpointslow), this.allocatePoints(), n.updateParametricCurveNaive(this, i2, r2, this.numberPoints)), t2 = this.numberPoints, l.evaluate(this.visProp.useqdt) && this.board.updateQuality === this.board.BOARD_QUALITY_HIGH)
            for (this.qdt = new c(this.board.getBoundingBox()), h2 = 0; h2 < this.points.length; h2++)
              this.qdt.insert(this.points[h2]), h2 > 0 && (this.points[h2].prev = this.points[h2 - 1]), h2 < t2 - 1 && (this.points[h2].next = this.points[h2 + 1]);
          for (l.evaluate(this.visProp.curvetype) !== "plot" && l.evaluate(this.visProp.rdpsmoothing) && (this.points = o.RamerDouglasPeucker(this.points, 0.2), this.numberPoints = this.points.length), t2 = this.numberPoints, h2 = 0; h2 < t2; h2++)
            this.updateTransform(this.points[h2]);
          return this;
        }, updateTransformMatrix: function() {
          var t2, e3, i2 = this.transformations.length;
          for (this.transformMat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], e3 = 0; e3 < i2; e3++)
            t2 = this.transformations[e3], t2.update(), this.transformMat = s.matMatMult(t2.matrix, this.transformMat);
          return this;
        }, updateTransform: function(t2) {
          var i2;
          return this.transformations.length > 0 && (i2 = s.matVecMult(this.transformMat, t2.usrCoords), t2.setCoordinates(e2.COORDS_BY_USER, i2, false, true)), t2;
        }, addTransform: function(t2) {
          var e3, i2 = l.isArray(t2) ? t2 : [t2], r2 = i2.length;
          for (e3 = 0; e3 < r2; e3++)
            this.transformations.push(i2[e3]);
          return this;
        }, interpolationFunctionFromArray: function(t2) {
          var e3 = "data" + t2, i2 = this;
          return function(t3, r2) {
            var s2, o2, n3, a2, h2, c2 = i2[e3], d = c2.length, u = [];
            if (isNaN(t3))
              return NaN;
            if (t3 < 0)
              return l.isFunction(c2[0]) ? c2[0]() : c2[0];
            if (i2.bezierDegree === 3) {
              if (h2 = (d - 1) / 3, t3 >= h2)
                return l.isFunction(c2[c2.length - 1]) ? c2[c2.length - 1]() : c2[c2.length - 1];
              for (s2 = 3 * Math.floor(t3), n3 = t3 % 1, a2 = 1 - n3, o2 = 0; o2 < 4; o2++)
                l.isFunction(c2[s2 + o2]) ? u[o2] = c2[s2 + o2]() : u[o2] = c2[s2 + o2];
              return a2 * a2 * (a2 * u[0] + 3 * n3 * u[1]) + (3 * a2 * u[2] + n3 * u[3]) * n3 * n3;
            }
            if ((s2 = t3 > d - 2 ? d - 2 : parseInt(Math.floor(t3), 10)) === t3)
              return l.isFunction(c2[s2]) ? c2[s2]() : c2[s2];
            for (o2 = 0; o2 < 2; o2++)
              l.isFunction(c2[s2 + o2]) ? u[o2] = c2[s2 + o2]() : u[o2] = c2[s2 + o2];
            return u[0] + (u[1] - u[0]) * (t3 - s2);
          };
        }, generateTerm: function(t2, e3, i2, r2, s2) {
          var o2, n3;
          l.isArray(e3) ? (this.dataX = e3, this.numberPoints = this.dataX.length, this.X = this.interpolationFunctionFromArray.apply(this, ["X"]), this.visProp.curvetype = "plot", this.isDraggable = true) : (this.X = l.createFunction(e3, this.board, t2), l.isString(e3) ? this.visProp.curvetype = "functiongraph" : (l.isFunction(e3) || l.isNumber(e3)) && (this.visProp.curvetype = "parameter"), this.isDraggable = true), l.isArray(i2) ? (this.dataY = i2, this.Y = this.interpolationFunctionFromArray.apply(this, ["Y"])) : this.Y = l.createFunction(i2, this.board, t2), l.isFunction(e3) && l.isArray(i2) && (o2 = l.createFunction(i2[0], this.board, ""), n3 = l.createFunction(i2[1], this.board, ""), this.X = function(t3) {
            return e3(t3) * Math.cos(t3) + o2();
          }, this.Y = function(t3) {
            return e3(t3) * Math.sin(t3) + n3();
          }, this.visProp.curvetype = "polar"), l.exists(r2) && (this.minX = l.createFunction(r2, this.board, "")), l.exists(s2) && (this.maxX = l.createFunction(s2, this.board, ""));
        }, notifyParents: function(t2) {
          var e3, i2, r2, s2 = false;
          r2 = {xterm: 1, yterm: 1};
          for (e3 in r2)
            if (r2.hasOwnProperty(e3) && this.hasOwnProperty(e3) && this[e3].origin) {
              s2 = true;
              for (i2 in this[e3].origin.deps)
                this[e3].origin.deps.hasOwnProperty(i2) && this[e3].origin.deps[i2].addChild(this);
            }
          s2 || h.findDependencies(this, t2, this.board);
        }, getLabelAnchor: function() {
          var t2, r2, s2, o2 = 0.05 * this.board.canvasWidth, n3 = 0.05 * this.board.canvasHeight, h2 = 0.95 * this.board.canvasWidth, c2 = 0.95 * this.board.canvasHeight;
          switch (l.evaluate(this.visProp.label.position)) {
            case "ulft":
              r2 = o2, s2 = n3;
              break;
            case "llft":
              r2 = o2, s2 = c2;
              break;
            case "rt":
              r2 = h2, s2 = 0.5 * c2;
              break;
            case "lrt":
              r2 = h2, s2 = c2;
              break;
            case "urt":
              r2 = h2, s2 = n3;
              break;
            case "top":
              r2 = 0.5 * h2, s2 = n3;
              break;
            case "bot":
              r2 = 0.5 * h2, s2 = c2;
              break;
            default:
              r2 = o2, s2 = 0.5 * c2;
          }
          return t2 = new i(e2.COORDS_BY_SCREEN, [r2, s2], this.board, false), a.projectCoordsToCurve(t2.usrCoords[1], t2.usrCoords[2], 0, this, this.board)[0];
        }, cloneToBackground: function() {
          var t2, i2 = {id: this.id + "T" + this.numTraces, elementClass: e2.OBJECT_CLASS_CURVE, points: this.points.slice(0), bezierDegree: this.bezierDegree, numberPoints: this.numberPoints, board: this.board, visProp: l.deepCopy(this.visProp, this.visProp.traceattributes, true)};
          return i2.visProp.layer = this.board.options.layer.trace, i2.visProp.curvetype = this.visProp.curvetype, this.numTraces++, l.clearVisPropOld(i2), i2.visPropCalc = {visible: l.evaluate(i2.visProp.visible)}, t2 = this.board.renderer.enhancedRendering, this.board.renderer.enhancedRendering = true, this.board.renderer.drawCurve(i2), this.board.renderer.enhancedRendering = t2, this.traces[i2.id] = i2.rendNode, this;
        }, bounds: function() {
          var t2, e3, i2, r2 = 1 / 0, s2 = -1 / 0, n3 = 1 / 0, a2 = -1 / 0, h2 = this.points.length;
          if (this.bezierDegree === 3) {
            for (t2 = 0; t2 < h2; t2++)
              this.points[t2].X = l.bind(function() {
                return this.usrCoords[1];
              }, this.points[t2]), this.points[t2].Y = l.bind(function() {
                return this.usrCoords[2];
              }, this.points[t2]);
            return e3 = o.bezier(this.points), i2 = e3[3](), r2 = o.fminbr(function(t3) {
              return e3[0](t3);
            }, [0, i2]), s2 = o.fminbr(function(t3) {
              return -e3[0](t3);
            }, [0, i2]), n3 = o.fminbr(function(t3) {
              return e3[1](t3);
            }, [0, i2]), a2 = o.fminbr(function(t3) {
              return -e3[1](t3);
            }, [0, i2]), r2 = e3[0](r2), s2 = e3[0](s2), n3 = e3[1](n3), a2 = e3[1](a2), [r2, a2, s2, n3];
          }
          for (t2 = 0; t2 < h2; t2++)
            r2 > this.points[t2].usrCoords[1] && (r2 = this.points[t2].usrCoords[1]), s2 < this.points[t2].usrCoords[1] && (s2 = this.points[t2].usrCoords[1]), n3 > this.points[t2].usrCoords[2] && (n3 = this.points[t2].usrCoords[2]), a2 < this.points[t2].usrCoords[2] && (a2 = this.points[t2].usrCoords[2]);
          return [r2, a2, s2, n3];
        }, getParents: function() {
          var t2 = [this.xterm, this.yterm, this.minX(), this.maxX()];
          return this.parents.length !== 0 && (t2 = this.parents), t2;
        }, moveTo: function(t2) {
          var i2, r2 = [];
          return this.points.length > 0 && !l.evaluate(this.visProp.fixed) && (i2 = this.points[0], r2 = t2.length === 3 ? [t2[0] - i2.usrCoords[0], t2[1] - i2.usrCoords[1], t2[2] - i2.usrCoords[2]] : [t2[0] - i2.usrCoords[1], t2[1] - i2.usrCoords[2]], this.setPosition(e2.COORDS_BY_USER, r2)), this;
        }, getTransformationSource: function() {
          var t2, i2;
          return l.exists(this._transformationSource) && (i2 = this._transformationSource, i2.elementClass === e2.OBJECT_CLASS_CURVE && (t2 = true)), [t2, i2];
        }}), t.createCurve = function(i2, r2, s2) {
          var o2, n3, a2 = l.copyAttributes(s2, i2.options, "curve");
          return o2 = i2.select(r2[0], true), l.isObject(o2) && (o2.type === e2.OBJECT_TYPE_CURVE || o2.type === e2.OBJECT_TYPE_ANGLE || o2.type === e2.OBJECT_TYPE_ARC || o2.type === e2.OBJECT_TYPE_CONIC || o2.type === e2.OBJECT_TYPE_SECTOR) && l.isTransformationOrArray(r2[1]) ? (o2.type === e2.OBJECT_TYPE_SECTOR ? a2 = l.copyAttributes(s2, i2.options, "sector") : o2.type === e2.OBJECT_TYPE_ARC ? a2 = l.copyAttributes(s2, i2.options, "arc") : o2.type === e2.OBJECT_TYPE_ANGLE ? (l.exists(s2.withLabel) || (s2.withLabel = false), a2 = l.copyAttributes(s2, i2.options, "angle")) : a2 = l.copyAttributes(s2, i2.options, "curve"), a2 = l.copyAttributes(a2, i2.options, "curve"), n3 = new t.Curve(i2, ["x", [], []], a2), n3.updateDataArray = function() {
            var t2, e3 = o2.numberPoints;
            for (this.bezierDegree = o2.bezierDegree, this.dataX = [], this.dataY = [], t2 = 0; t2 < e3; t2++)
              this.dataX.push(o2.points[t2].usrCoords[1]), this.dataY.push(o2.points[t2].usrCoords[2]);
            return this;
          }, n3.addTransform(r2[1]), o2.addChild(n3), n3.setParents([o2]), n3._transformationSource = o2, n3) : (a2 = l.copyAttributes(s2, i2.options, "curve"), new t.Curve(i2, ["x"].concat(r2), a2));
        }, t.registerElement("curve", t.createCurve), t.createFunctiongraph = function(e3, i2, r2) {
          var s2, o2 = ["x", "x"].concat(i2);
          return s2 = l.copyAttributes(r2, e3.options, "curve"), s2.curvetype = "functiongraph", new t.Curve(e3, o2, s2);
        }, t.registerElement("functiongraph", t.createFunctiongraph), t.registerElement("plot", t.createFunctiongraph), t.createSpline = function(e3, i2, r2) {
          var s2, n3, a2;
          return n3 = function() {
            var t2, e4 = [], r3 = [];
            return [function(s3, n4) {
              var a3, h2, c2;
              if (!n4) {
                if (e4 = [], r3 = [], i2.length === 2 && l.isArray(i2[0]) && l.isArray(i2[1]) && i2[0].length === i2[1].length)
                  for (a3 = 0; a3 < i2[0].length; a3++)
                    l.isFunction(i2[0][a3]) ? e4.push(i2[0][a3]()) : e4.push(i2[0][a3]), l.isFunction(i2[1][a3]) ? r3.push(i2[1][a3]()) : r3.push(i2[1][a3]);
                else
                  for (a3 = 0; a3 < i2.length; a3++)
                    if (l.isPoint(i2[a3]))
                      e4.push(i2[a3].X()), r3.push(i2[a3].Y());
                    else if (l.isArray(i2[a3]) && i2[a3].length === 2)
                      for (h2 = 0; h2 < i2.length; h2++)
                        l.isFunction(i2[h2][0]) ? e4.push(i2[h2][0]()) : e4.push(i2[h2][0]), l.isFunction(i2[h2][1]) ? r3.push(i2[h2][1]()) : r3.push(i2[h2][1]);
                    else
                      l.isFunction(i2[a3]) && i2[a3]().length === 2 && (c2 = i2[a3](), e4.push(c2[0]), r3.push(c2[1]));
                t2 = o.splineDef(e4, r3);
              }
              return o.splineEval(s3, e4, r3, t2);
            }, function() {
              return e4[0];
            }, function() {
              return e4[e4.length - 1];
            }];
          }, r2 = l.copyAttributes(r2, e3.options, "curve"), r2.curvetype = "functiongraph", a2 = n3(), s2 = new t.Curve(e3, ["x", "x", a2[0], a2[1], a2[2]], r2), s2.setParents(i2), s2.elType = "spline", s2;
        }, t.registerElement("spline", t.createSpline), t.createCardinalSpline = function(e3, i2, r2) {
          var s2, n3, a2, h2, c2, d, u, p, f, m = "\nPossible parent types: [points:array, tau:number|function, type:string]";
          if (!l.exists(i2[0]) || !l.isArray(i2[0]))
            throw new Error("JSXGraph: JXG.createCardinalSpline: argument 1 'points' has to be array of points or coordinate pairs" + m);
          if (!l.exists(i2[1]) || !l.isNumber(i2[1]) && !l.isFunction(i2[1]))
            throw new Error("JSXGraph: JXG.createCardinalSpline: argument 2 'tau' has to be number between [0,1] or function'" + m);
          if (!l.exists(i2[2]) || !l.isString(i2[2]))
            throw new Error("JSXGraph: JXG.createCardinalSpline: argument 3 'type' has to be string 'uniform' or 'centripetal'" + m);
          if (r2 = l.copyAttributes(r2, e3.options, "curve"), r2 = l.copyAttributes(r2, e3.options, "cardinalspline"), r2.curvetype = "parameter", c2 = i2[0], d = [], !r2.isarrayofcoordinates && c2.length === 2 && l.isArray(c2[0]) && l.isArray(c2[1]) && c2[0].length === c2[1].length)
            for (u = 0; u < c2[0].length; u++)
              d[u] = [], l.isFunction(c2[0][u]) ? d[u].push(c2[0][u]()) : d[u].push(c2[0][u]), l.isFunction(c2[1][u]) ? d[u].push(c2[1][u]()) : d[u].push(c2[1][u]);
          else
            for (u = 0; u < c2.length; u++)
              l.isString(c2[u]) ? d.push(e3.select(c2[u])) : l.isPoint(c2[u]) ? d.push(c2[u]) : l.isArray(c2[u]) && c2[u].length === 2 ? (d[u] = [], l.isFunction(c2[u][0]) ? d[u].push(c2[u][0]()) : d[u].push(c2[u][0]), l.isFunction(c2[u][1]) ? d[u].push(c2[u][1]()) : d[u].push(c2[u][1])) : l.isFunction(c2[u]) && c2[u]().length === 2 && d.push(i2[u]());
          if (r2.createpoints === true)
            n3 = l.providePoints(e3, d, r2, "cardinalspline", ["points"]);
          else
            for (n3 = [], u = 0; u < d.length; u++)
              l.isPoint(d[u]) ? n3.push(d[u]) : n3.push(function(t2) {
                return {X: function() {
                  return d[t2][0];
                }, Y: function() {
                  return d[t2][1];
                }, Dist: function(t3) {
                  var e4 = this.X() - t3.X(), i3 = this.Y() - t3.Y();
                  return Math.sqrt(e4 * e4 + i3 * i3);
                }};
              }(u));
          for (a2 = i2[1], h2 = i2[2], f = ["x"].concat(o.CardinalSpline(n3, a2, h2)), s2 = new t.Curve(e3, f, r2), p = n3.length, s2.setParents(n3), u = 0; u < p; u++)
            l.isPoint(n3[u]) && n3[u].addChild(s2);
          return s2.elType = "cardinalspline", s2;
        }, t.registerElement("cardinalspline", t.createCardinalSpline), t.createMetapostSpline = function(e3, i2, r2) {
          var s2, o2, n3, a2, h2, c2, d, u = "\nPossible parent types: [points:array, controls:object";
          if (!l.exists(i2[0]) || !l.isArray(i2[0]))
            throw new Error("JSXGraph: JXG.createMetapostSpline: argument 1 'points' has to be array of points or coordinate pairs" + u);
          if (!l.exists(i2[1]) || !l.isObject(i2[1]))
            throw new Error("JSXGraph: JXG.createMetapostSpline: argument 2 'controls' has to be a JavaScript object'" + u);
          if (r2 = l.copyAttributes(r2, e3.options, "curve"), r2 = l.copyAttributes(r2, e3.options, "metapostspline"), r2.curvetype = "parameter", a2 = i2[0], h2 = [], !r2.isarrayofcoordinates && a2.length === 2 && l.isArray(a2[0]) && l.isArray(a2[1]) && a2[0].length === a2[1].length)
            for (c2 = 0; c2 < a2[0].length; c2++)
              h2[c2] = [], l.isFunction(a2[0][c2]) ? h2[c2].push(a2[0][c2]()) : h2[c2].push(a2[0][c2]), l.isFunction(a2[1][c2]) ? h2[c2].push(a2[1][c2]()) : h2[c2].push(a2[1][c2]);
          else
            for (c2 = 0; c2 < a2.length; c2++)
              l.isString(a2[c2]) ? h2.push(e3.select(a2[c2])) : l.isPoint(a2[c2]) ? h2.push(a2[c2]) : l.isArray(a2[c2]) && a2[c2].length === 2 ? (h2[c2] = [], l.isFunction(a2[c2][0]) ? h2[c2].push(a2[c2][0]()) : h2[c2].push(a2[c2][0]), l.isFunction(a2[c2][1]) ? h2[c2].push(a2[c2][1]()) : h2[c2].push(a2[c2][1])) : l.isFunction(a2[c2]) && a2[c2]().length === 2 && h2.push(i2[c2]());
          if (r2.createpoints === true)
            o2 = l.providePoints(e3, h2, r2, "metapostspline", ["points"]);
          else
            for (o2 = [], c2 = 0; c2 < h2.length; c2++)
              l.isPoint(h2[c2]) ? o2.push(h2[c2]) : o2.push(function(t2) {
                return {X: function() {
                  return h2[t2][0];
                }, Y: function() {
                  return h2[t2][1];
                }};
              }(c2));
          for (n3 = i2[1], s2 = new t.Curve(e3, ["t", [], [], 0, a2.length - 1], r2), s2.updateDataArray = function() {
            var e4, i3, r3 = o2.length, s3 = [];
            for (i3 = 0; i3 < r3; i3++)
              s3.push([o2[i3].X(), o2[i3].Y()]);
            e4 = t.Math.Metapost.curve(s3, n3), this.dataX = e4[0], this.dataY = e4[1];
          }, s2.bezierDegree = 3, d = o2.length, s2.setParents(o2), c2 = 0; c2 < d; c2++)
            l.isPoint(o2[c2]) && o2[c2].addChild(s2);
          return s2.elType = "metapostspline", s2;
        }, t.registerElement("metapostspline", t.createMetapostSpline), t.createRiemannsum = function(t2, e3, i2) {
          var r2, s2, n3, a2, h2, c2;
          if (c2 = l.copyAttributes(i2, t2.options, "riemannsum"), c2.curvetype = "plot", n3 = e3[0], r2 = l.createFunction(e3[1], t2, ""), !l.exists(r2))
            throw new Error("JSXGraph: JXG.createRiemannsum: argument '2' n has to be number or function.\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]");
          if (s2 = l.createFunction(e3[2], t2, "", false), !l.exists(s2))
            throw new Error("JSXGraph: JXG.createRiemannsum: argument 3 'type' has to be string or function.\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]");
          return a2 = [[0], [0]].concat(e3.slice(3)), h2 = t2.create("curve", a2, c2), h2.sum = 0, h2.Value = function() {
            return this.sum;
          }, h2.updateDataArray = function() {
            var t3 = o.riemann(n3, r2(), s2(), this.minX(), this.maxX());
            this.dataX = t3[0], this.dataY = t3[1], this.sum = t3[2];
          }, h2;
        }, t.registerElement("riemannsum", t.createRiemannsum), t.createTracecurve = function(t2, i2, r2) {
          var s2, o2, n3, a2;
          if (i2.length !== 2)
            throw new Error("JSXGraph: Can't create trace curve with given parent'\nPossible parent types: [glider, point]");
          if (o2 = t2.select(i2[0]), n3 = t2.select(i2[1]), o2.type !== e2.OBJECT_TYPE_GLIDER || !l.isPoint(n3))
            throw new Error("JSXGraph: Can't create trace curve with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [glider, point]");
          return a2 = l.copyAttributes(r2, t2.options, "tracecurve"), a2.curvetype = "plot", s2 = t2.create("curve", [[0], [0]], a2), s2.updateDataArray = function() {
            var t3, i3, r3, s3, h2, l2, c2, d, u, p = a2.numberpoints, f = o2.position, m = o2.slideObject, g = m.minX(), b = m.maxX();
            for (i3 = (b - g) / p, this.dataX = [], this.dataY = [], m.elementClass !== e2.OBJECT_CLASS_CURVE && p++, t3 = 0; t3 < p; t3++) {
              r3 = g + t3 * i3, l2 = m.X(r3) / m.Z(r3), c2 = m.Y(r3) / m.Z(r3), o2.setPositionDirectly(e2.COORDS_BY_USER, [l2, c2]), d = false;
              for (s3 in this.board.objects)
                if (this.board.objects.hasOwnProperty(s3) && (h2 = this.board.objects[s3], h2 === o2 && (d = true), d && h2.needsRegularUpdate && (u = h2.visProp.trace, h2.visProp.trace = false, h2.needsUpdate = true, h2.update(true), h2.visProp.trace = u, h2 === n3)))
                  break;
              this.dataX[t3] = n3.X(), this.dataY[t3] = n3.Y();
            }
            o2.position = f, d = false;
            for (s3 in this.board.objects)
              if (this.board.objects.hasOwnProperty(s3) && (h2 = this.board.objects[s3], h2 === o2 && (d = true), d && h2.needsRegularUpdate && (u = h2.visProp.trace, h2.visProp.trace = false, h2.needsUpdate = true, h2.update(true), h2.visProp.trace = u, h2 === n3)))
                break;
          }, s2;
        }, t.registerElement("tracecurve", t.createTracecurve), t.createStepfunction = function(t2, e3, i2) {
          var r2, s2;
          if (e3.length !== 2)
            throw new Error("JSXGraph: Can't create step function with given parent'\nPossible parent types: [array, array|function]");
          return s2 = l.copyAttributes(i2, t2.options, "stepfunction"), r2 = t2.create("curve", e3, s2), r2.updateDataArray = function() {
            var t3, e4 = 0, i3 = this.xterm.length;
            if (this.dataX = [], this.dataY = [], i3 !== 0)
              for (this.dataX[e4] = this.xterm[0], this.dataY[e4] = this.yterm[0], ++e4, t3 = 1; t3 < i3; ++t3)
                this.dataX[e4] = this.xterm[t3], this.dataY[e4] = this.dataY[e4 - 1], ++e4, this.dataX[e4] = this.xterm[t3], this.dataY[e4] = this.yterm[t3], ++e4;
          }, r2;
        }, t.registerElement("stepfunction", t.createStepfunction), t.createDerivative = function(t2, i2, r2) {
          var s2, n3, a2, h2, c2;
          if (i2.length !== 1 && i2[0].class !== e2.OBJECT_CLASS_CURVE)
            throw new Error("JSXGraph: Can't create derivative curve with given parent'\nPossible parent types: [curve]");
          return c2 = l.copyAttributes(r2, t2.options, "curve"), n3 = i2[0], a2 = o.D(n3.X), h2 = o.D(n3.Y), s2 = t2.create("curve", [function(t3) {
            return n3.X(t3);
          }, function(t3) {
            return h2(t3) / a2(t3);
          }, n3.minX(), n3.maxX()], c2), s2.setParents(n3), s2;
        }, t.registerElement("derivative", t.createDerivative), {Curve: t.Curve, createCurve: t.createCurve, createFunctiongraph: t.createFunctiongraph, createPlot: t.createPlot, createSpline: t.createSpline, createRiemannsum: t.createRiemannsum, createTracecurve: t.createTracecurve, createStepfunction: t.createStepfunction};
      }), define("element/conic", ["jxg", "base/constants", "base/coords", "math/math", "math/numerics", "math/geometry", "utils/type", "base/point", "base/curve"], function(t, e2, i, r, s, o, n, a, h) {
        "use strict";
        return t.createEllipse = function(t2, r2, s2) {
          var o2, a2, h2, l, c, d, u, p = [], f = n.copyAttributes(s2, t2.options, "conic", "foci"), m = n.copyAttributes(s2, t2.options, "conic", "center"), g = n.copyAttributes(s2, t2.options, "conic");
          for (d = 0; d < 2; d++)
            if (r2[d].length > 1)
              p[d] = t2.create("point", r2[d], f);
            else if (n.isPoint(r2[d]))
              p[d] = t2.select(r2[d]);
            else if (n.isFunction(r2[d]) && n.isPoint(r2[d]()))
              p[d] = r2[d]();
            else {
              if (!n.isString(r2[d]))
                throw new Error("JSXGraph: Can't create Ellipse with parent types '" + typeof r2[0] + "' and '" + typeof r2[1] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]");
              p[d] = t2.select(r2[d]);
            }
          if (n.isNumber(r2[2]))
            c = n.createFunction(r2[2], t2);
          else if (n.isFunction(r2[2]) && n.isNumber(r2[2]()))
            c = r2[2];
          else {
            if (n.isPoint(r2[2]))
              l = t2.select(r2[2]);
            else if (r2[2].length > 1)
              l = t2.create("point", r2[2], f);
            else if (n.isFunction(r2[2]) && n.isPoint(r2[2]()))
              l = r2[2]();
            else {
              if (!n.isString(r2[2]))
                throw new Error("JSXGraph: Can't create Ellipse with parent types '" + typeof r2[0] + "' and '" + typeof r2[1] + "' and '" + typeof r2[2] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]");
              l = t2.select(r2[2]);
            }
            c = function() {
              return l.Dist(p[0]) + l.Dist(p[1]);
            };
          }
          for (n.exists(r2[4]) || (r2[4] = 2 * Math.PI), n.exists(r2[3]) || (r2[3] = 0), h2 = t2.create("point", [function() {
            return 0.5 * (p[0].X() + p[1].X());
          }, function() {
            return 0.5 * (p[0].Y() + p[1].Y());
          }], m), a2 = t2.create("curve", [function(t3) {
            return 0;
          }, function(t3) {
            return 0;
          }, r2[3], r2[4]], g), a2.majorAxis = c, u = a2.hasPoint, o2 = function(t3, e3) {
            var i2, r3, s3, o3, n3, h3, l2, d2, u2;
            e3 || (i2 = c(), r3 = i2 * i2, s3 = p[0].X(), o3 = p[0].Y(), n3 = p[1].X(), h3 = p[1].Y(), l2 = s3 - n3, d2 = o3 - h3, u2 = (r3 - s3 * s3 - o3 * o3 + n3 * n3 + h3 * h3) / (2 * i2), a2.quadraticform = [[u2 * u2 - n3 * n3 - h3 * h3, u2 * l2 / i2 + n3, u2 * d2 / i2 + h3], [u2 * l2 / i2 + n3, l2 * l2 / r3 - 1, l2 * d2 / r3], [u2 * d2 / i2 + h3, l2 * d2 / r3, d2 * d2 / r3 - 1]]);
          }, a2.X = function(t3, e3) {
            var i2 = c(), r3 = p[1].Dist(p[0]), s3 = 0.5 * (r3 * r3 - i2 * i2) / (r3 * Math.cos(t3) - i2), n3 = Math.atan2(p[1].Y() - p[0].Y(), p[1].X() - p[0].X());
            return e3 || o2(t3, e3), p[0].X() + Math.cos(n3 + t3) * s3;
          }, a2.Y = function(t3, e3) {
            var i2 = c(), r3 = p[1].Dist(p[0]), s3 = 0.5 * (r3 * r3 - i2 * i2) / (r3 * Math.cos(t3) - i2), o3 = Math.atan2(p[1].Y() - p[0].Y(), p[1].X() - p[0].X());
            return p[0].Y() + Math.sin(o3 + t3) * s3;
          }, a2.midpoint = a2.center = h2, a2.type = e2.OBJECT_TYPE_CONIC, a2.subs = {center: a2.center}, a2.inherits.push(a2.center, p[0], p[1]), n.isPoint(l) && a2.inherits.push(l), a2.hasPoint = function(t3, r3) {
            var s3, o3, a3, h3;
            return n.evaluate(this.visProp.hasinnerpoints) ? (s3 = p[0].coords, o3 = p[1].coords, a3 = this.majorAxis(), h3 = new i(e2.COORDS_BY_SCREEN, [t3, r3], this.board), h3.distance(e2.COORDS_BY_USER, s3) + h3.distance(e2.COORDS_BY_USER, o3) <= a3) : u.apply(this, arguments);
          }, h2.addChild(a2), d = 0; d < 2; d++)
            n.isPoint(p[d]) && p[d].addChild(a2);
          return n.isPoint(l) && l.addChild(a2), a2.setParents(r2), a2;
        }, t.createHyperbola = function(t2, i2, r2) {
          var s2, o2, a2, h2, l, c, d = [], u = n.copyAttributes(r2, t2.options, "conic", "foci"), p = n.copyAttributes(r2, t2.options, "conic", "center"), f = n.copyAttributes(r2, t2.options, "conic");
          for (c = 0; c < 2; c++)
            if (i2[c].length > 1)
              d[c] = t2.create("point", i2[c], u);
            else if (n.isPoint(i2[c]))
              d[c] = t2.select(i2[c]);
            else if (n.isFunction(i2[c]) && n.isPoint(i2[c]()))
              d[c] = i2[c]();
            else {
              if (!n.isString(i2[c]))
                throw new Error("JSXGraph: Can't create Hyperbola with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]");
              d[c] = t2.select(i2[c]);
            }
          if (n.isNumber(i2[2]))
            l = n.createFunction(i2[2], t2);
          else if (n.isFunction(i2[2]) && n.isNumber(i2[2]()))
            l = i2[2];
          else {
            if (n.isPoint(i2[2]))
              h2 = t2.select(i2[2]);
            else if (i2[2].length > 1)
              h2 = t2.create("point", i2[2], u);
            else if (n.isFunction(i2[2]) && n.isPoint(i2[2]()))
              h2 = i2[2]();
            else {
              if (!n.isString(i2[2]))
                throw new Error("JSXGraph: Can't create Hyperbola with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "' and '" + typeof i2[2] + "'.\nPossible parent types: [point,point,point], [point,point,number|function]");
              h2 = t2.select(i2[2]);
            }
            l = function() {
              return h2.Dist(d[0]) - h2.Dist(d[1]);
            };
          }
          for (n.exists(i2[4]) || (i2[4] = 1.0001 * Math.PI), n.exists(i2[3]) || (i2[3] = -1.0001 * Math.PI), a2 = t2.create("point", [function() {
            return 0.5 * (d[0].X() + d[1].X());
          }, function() {
            return 0.5 * (d[0].Y() + d[1].Y());
          }], p), o2 = t2.create("curve", [function(t3) {
            return 0;
          }, function(t3) {
            return 0;
          }, i2[3], i2[4]], f), o2.majorAxis = l, s2 = function(t3, e3) {
            var i3, r3, s3, n3, a3, h3, c2, u2, p2;
            e3 || (i3 = l(), r3 = i3 * i3, s3 = d[0].X(), n3 = d[0].Y(), a3 = d[1].X(), h3 = d[1].Y(), c2 = s3 - a3, u2 = n3 - h3, p2 = (r3 - s3 * s3 - n3 * n3 + a3 * a3 + h3 * h3) / (2 * i3), o2.quadraticform = [[p2 * p2 - a3 * a3 - h3 * h3, p2 * c2 / i3 + a3, p2 * u2 / i3 + h3], [p2 * c2 / i3 + a3, c2 * c2 / r3 - 1, c2 * u2 / r3], [p2 * u2 / i3 + h3, c2 * u2 / r3, u2 * u2 / r3 - 1]]);
          }, o2.X = function(t3, e3) {
            var i3 = l(), r3 = d[1].Dist(d[0]), o3 = 0.5 * (r3 * r3 - i3 * i3) / (r3 * Math.cos(t3) + i3), n3 = Math.atan2(d[1].Y() - d[0].Y(), d[1].X() - d[0].X());
            return e3 || s2(t3, e3), d[0].X() + Math.cos(n3 + t3) * o3;
          }, o2.Y = function(t3, e3) {
            var i3 = l(), r3 = d[1].Dist(d[0]), s3 = 0.5 * (r3 * r3 - i3 * i3) / (r3 * Math.cos(t3) + i3), o3 = Math.atan2(d[1].Y() - d[0].Y(), d[1].X() - d[0].X());
            return d[0].Y() + Math.sin(o3 + t3) * s3;
          }, o2.midpoint = o2.center = a2, o2.subs = {center: o2.center}, o2.inherits.push(o2.center, d[0], d[1]), n.isPoint(h2) && o2.inherits.push(h2), o2.type = e2.OBJECT_TYPE_CONIC, a2.addChild(o2), c = 0; c < 2; c++)
            n.isPoint(d[c]) && d[c].addChild(o2);
          return n.isPoint(h2) && h2.addChild(o2), o2.setParents(i2), o2;
        }, t.createParabola = function(t2, i2, r2) {
          var s2, a2, h2, l, c = i2[0], d = i2[1], u = n.copyAttributes(r2, t2.options, "conic", "foci"), p = n.copyAttributes(r2, t2.options, "conic", "center"), f = n.copyAttributes(r2, t2.options, "conic");
          if (i2[0].length > 1)
            c = t2.create("point", i2[0], u);
          else if (n.isPoint(i2[0]))
            c = t2.select(i2[0]);
          else if (n.isFunction(i2[0]) && n.isPoint(i2[0]()))
            c = i2[0]();
          else {
            if (!n.isString(i2[0]))
              throw new Error("JSXGraph: Can't create Parabola with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,line]");
            c = t2.select(i2[0]);
          }
          return n.isArray(d) && d.length == 2 && (l = n.copyAttributes(r2, t2.options, "conic", "line"), d = t2.create("line", d, l)), n.exists(i2[3]) || (i2[3] = 10), n.exists(i2[2]) || (i2[2] = -10), h2 = t2.create("point", [function() {
            return o.projectPointToLine(c, d, t2).usrCoords;
          }], p), a2 = t2.create("curve", [function(t3) {
            return 0;
          }, function(t3) {
            return 0;
          }, i2[2], i2[3]], f), a2.midpoint = a2.center = h2, a2.subs = {center: a2.center}, a2.inherits.push(a2.center), s2 = function(t3, e3) {
            var i3, r3, s3, o2, n3, h3;
            e3 || (i3 = d.stdform[1], r3 = d.stdform[2], s3 = d.stdform[0], o2 = i3 * i3 + r3 * r3, n3 = c.X(), h3 = c.Y(), a2.quadraticform = [[s3 * s3 - o2 * (n3 * n3 + h3 * h3), s3 * i3 + o2 * n3, s3 * r3 + o2 * h3], [s3 * i3 + o2 * n3, -r3 * r3, i3 * r3], [s3 * r3 + o2 * h3, i3 * r3, -i3 * i3]]);
          }, a2.X = function(t3, e3) {
            var i3, r3, n3 = d.getAngle(), a3 = o.distPointLine(c.coords.usrCoords, d.stdform), h3 = d.point1.coords.usrCoords, l2 = d.point2.coords.usrCoords, u2 = c.coords.usrCoords;
            return h3[0] === 0 ? h3 = [1, l2[1] + d.stdform[2], l2[2] - d.stdform[1]] : l2[0] === 0 && (l2 = [1, h3[1] + d.stdform[2], h3[2] - d.stdform[1]]), r3 = (l2[1] - h3[1]) * (u2[2] - h3[2]) - (l2[2] - h3[2]) * (u2[1] - h3[1]) >= 0 ? 1 : -1, i3 = r3 * a3 / (1 - Math.sin(t3)), e3 || s2(t3, e3), c.X() + Math.cos(t3 + n3) * i3;
          }, a2.Y = function(t3, e3) {
            var i3, r3, s3 = d.getAngle(), n3 = o.distPointLine(c.coords.usrCoords, d.stdform), a3 = d.point1.coords.usrCoords, h3 = d.point2.coords.usrCoords, l2 = c.coords.usrCoords;
            return a3[0] === 0 ? a3 = [1, h3[1] + d.stdform[2], h3[2] - d.stdform[1]] : h3[0] === 0 && (h3 = [1, a3[1] + d.stdform[2], a3[2] - d.stdform[1]]), r3 = (h3[1] - a3[1]) * (l2[2] - a3[2]) - (h3[2] - a3[2]) * (l2[1] - a3[1]) >= 0 ? 1 : -1, i3 = r3 * n3 / (1 - Math.sin(t3)), c.Y() + Math.sin(t3 + s3) * i3;
          }, a2.type = e2.OBJECT_TYPE_CONIC, h2.addChild(a2), n.isPoint(c) && (c.addChild(a2), a2.inherits.push(c)), d.addChild(a2), a2.setParents(i2), a2;
        }, t.createConic = function(t2, i2, o2) {
          var a2, h2, l, c, d, u, p, f, m, g, b, v, y, C, _4 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], P2 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], E = [], x = [], S = n.copyAttributes(o2, t2.options, "conic", "point"), O = n.copyAttributes(o2, t2.options, "conic", "center"), w = n.copyAttributes(o2, t2.options, "conic");
          if (i2.length === 5)
            C = true;
          else {
            if (i2.length !== 6)
              throw new Error("JSXGraph: Can't create generic Conic with " + i2.length + " parameters.");
            C = false;
          }
          if (C)
            for (v = 0; v < 5; v++)
              if (i2[v].length > 1)
                E[v] = t2.create("point", i2[v], S);
              else if (n.isPoint(i2[v]))
                E[v] = t2.select(i2[v]);
              else if (n.isFunction(i2[v]) && n.isPoint(i2[v]()))
                E[v] = i2[v]();
              else {
                if (!n.isString(i2[v]))
                  throw new Error("JSXGraph: Can't create Conic section with parent types '" + typeof i2[v] + "'.\nPossible parent types: [point,point,point,point,point], [a00,a11,a22,a01,a02,a12]");
                E[v] = t2.select(i2[v]);
              }
          else
            y = [[0, 0, 0], [0, 0, 0], [0, 0, 0]], y[0][0] = n.isFunction(i2[2]) ? function() {
              return i2[2]();
            } : function() {
              return i2[2];
            }, y[0][1] = n.isFunction(i2[4]) ? function() {
              return i2[4]();
            } : function() {
              return i2[4];
            }, y[0][2] = n.isFunction(i2[5]) ? function() {
              return i2[5]();
            } : function() {
              return i2[5];
            }, y[1][1] = n.isFunction(i2[0]) ? function() {
              return i2[0]();
            } : function() {
              return i2[0];
            }, y[1][2] = n.isFunction(i2[3]) ? function() {
              return i2[3]();
            } : function() {
              return i2[3];
            }, y[2][2] = n.isFunction(i2[1]) ? function() {
              return i2[1]();
            } : function() {
              return i2[1];
            };
          if (d = function(t3) {
            var e3, i3;
            for (e3 = 0; e3 < 3; e3++)
              for (i3 = e3; i3 < 3; i3++)
                t3[e3][i3] += t3[i3][e3];
            for (e3 = 0; e3 < 3; e3++)
              for (i3 = 0; i3 < e3; i3++)
                t3[e3][i3] = t3[i3][e3];
            return t3;
          }, c = function(t3, e3) {
            var i3, r2, s2 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
            for (i3 = 0; i3 < 3; i3++)
              for (r2 = 0; r2 < 3; r2++)
                s2[i3][r2] = t3[i3] * e3[r2];
            return d(s2);
          }, l = function(t3, e3, i3) {
            var s2, o3, n3, a3, h3, l2 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
            for (h3 = r.matVecMult(e3, i3), n3 = r.innerProduct(i3, h3), h3 = r.matVecMult(t3, i3), a3 = r.innerProduct(i3, h3), s2 = 0; s2 < 3; s2++)
              for (o3 = 0; o3 < 3; o3++)
                l2[s2][o3] = n3 * t3[s2][o3] - a3 * e3[s2][o3];
            return l2;
          }, h2 = t2.create("curve", [function(t3) {
            return 0;
          }, function(t3) {
            return 0;
          }, 0, 2 * Math.PI], w), a2 = function(t3, e3) {
            var i3, o3, a3, d2;
            if (!e3) {
              if (C) {
                for (i3 = 0; i3 < 5; i3++)
                  x[i3] = E[i3].coords.usrCoords;
                g = c(r.crossProduct(x[0], x[1]), r.crossProduct(x[2], x[3])), b = c(r.crossProduct(x[0], x[2]), r.crossProduct(x[1], x[3])), P2 = l(g, b, x[4]);
              } else
                for (i3 = 0; i3 < 3; i3++)
                  for (o3 = i3; o3 < 3; o3++)
                    P2[i3][o3] = y[i3][o3](), o3 > i3 && (P2[o3][i3] = P2[i3][o3]);
              for (h2.quadraticform = P2, u = s.Jacobi(P2), u[0][0][0] < 0 && (u[0][0][0] *= -1, u[0][1][1] *= -1, u[0][2][2] *= -1), i3 = 0; i3 < 3; i3++) {
                for (a3 = 0, o3 = 0; o3 < 3; o3++)
                  a3 += u[1][o3][i3] * u[1][o3][i3];
                a3 = Math.sqrt(a3);
              }
              _4 = u[1], m = Math.sqrt(Math.abs(u[0][0][0])), p = Math.sqrt(Math.abs(u[0][1][1])), f = Math.sqrt(Math.abs(u[0][2][2]));
            }
            return u[0][1][1] <= 0 && u[0][2][2] <= 0 ? d2 = r.matVecMult(_4, [1 / m, Math.cos(t3) / p, Math.sin(t3) / f]) : u[0][1][1] <= 0 && u[0][2][2] > 0 ? d2 = r.matVecMult(_4, [Math.cos(t3) / m, 1 / p, Math.sin(t3) / f]) : u[0][2][2] < 0 && (d2 = r.matVecMult(_4, [Math.sin(t3) / m, Math.cos(t3) / p, 1 / f])), n.exists(d2) ? (d2[1] /= d2[0], d2[2] /= d2[0], d2[0] = 1) : d2 = [1, NaN, NaN], d2;
          }, h2.X = function(t3, e3) {
            return a2(t3, e3)[1];
          }, h2.Y = function(t3, e3) {
            return a2(t3, e3)[2];
          }, h2.midpoint = t2.create("point", [function() {
            var t3 = h2.quadraticform;
            return [t3[1][1] * t3[2][2] - t3[1][2] * t3[1][2], t3[1][2] * t3[0][2] - t3[2][2] * t3[0][1], t3[0][1] * t3[1][2] - t3[1][1] * t3[0][2]];
          }], O), h2.type = e2.OBJECT_TYPE_CONIC, h2.center = h2.midpoint, h2.subs = {center: h2.center}, h2.inherits.push(h2.center), h2.inherits = h2.inherits.concat(E), C) {
            for (v = 0; v < 5; v++)
              n.isPoint(E[v]) && E[v].addChild(h2);
            h2.setParents(i2);
          }
          return h2.addChild(h2.center), h2;
        }, t.registerElement("ellipse", t.createEllipse), t.registerElement("hyperbola", t.createHyperbola), t.registerElement("parabola", t.createParabola), t.registerElement("conic", t.createConic), {createEllipse: t.createEllipse, createHyperbola: t.createHyperbola, createParabola: t.createParabola, createConic: t.createConic};
      }), define("base/circle", ["jxg", "base/element", "base/coords", "base/constants", "element/conic", "parser/geonext", "utils/type"], function(t, e2, i, r, s, o, n) {
        "use strict";
        return t.Circle = function(t2, e3, i2, s2, o2) {
          this.constructor(t2, o2, r.OBJECT_TYPE_CIRCLE, r.OBJECT_CLASS_CIRCLE), this.method = e3, this.midpoint = this.board.select(i2), this.center = this.board.select(i2), this.point2 = null, this.radius = 0, this.line = null, this.circle = null, e3 === "twoPoints" ? (this.point2 = t2.select(s2), this.radius = this.Radius()) : e3 === "pointRadius" ? (this.gxtterm = s2, this.updateRadius = n.createFunction(s2, this.board, null, true), this.updateRadius()) : e3 === "pointLine" ? (this.line = t2.select(s2), this.radius = this.line.point1.coords.distance(r.COORDS_BY_USER, this.line.point2.coords)) : e3 === "pointCircle" && (this.circle = t2.select(s2), this.radius = this.circle.Radius()), this.id = this.board.setId(this, "C"), this.board.renderer.drawEllipse(this), this.board.finalizeAdding(this), this.createGradient(), this.elType = "circle", this.createLabel(), this.center.addChild(this), e3 === "pointRadius" ? this.notifyParents(s2) : e3 === "pointLine" ? this.line.addChild(this) : e3 === "pointCircle" ? this.circle.addChild(this) : e3 === "twoPoints" && this.point2.addChild(this), this.methodMap = n.deepCopy(this.methodMap, {setRadius: "setRadius", getRadius: "getRadius", Area: "Area", area: "Area", radius: "Radius", center: "center", line: "line", point2: "point2"});
        }, t.Circle.prototype = new e2(), t.extend(t.Circle.prototype, {hasPoint: function(t2, e3) {
          var s2, o2, a, h, l, c = this.center.coords.usrCoords, d = new i(r.COORDS_BY_SCREEN, [t2, e3], this.board), u = this.Radius();
          return n.isObject(n.evaluate(this.visProp.precision)) ? (o2 = this.board._inputDevice, s2 = n.evaluate(this.visProp.precision[o2])) : s2 = this.board.options.precision.hasPoint, a = c[1] - d.usrCoords[1], h = c[2] - d.usrCoords[2], l = Math.sqrt(a * a + h * h), s2 += 0.5 * n.evaluate(this.visProp.strokewidth), s2 /= Math.sqrt(this.board.unitX * this.board.unitY), n.evaluate(this.visProp.hasinnerpoints) ? l < u + s2 : Math.abs(l - u) < s2;
        }, generatePolynomial: function(t2) {
          var e3 = this.center.symbolic.x, i2 = this.center.symbolic.y, r2 = t2.symbolic.x, s2 = t2.symbolic.y, o2 = this.generateRadiusSquared();
          return o2 === "" ? [] : ["((" + r2 + ")-(" + e3 + "))^2 + ((" + s2 + ")-(" + i2 + "))^2 - (" + o2 + ")"];
        }, generateRadiusSquared: function() {
          var t2, e3, i2, r2, s2, o2, a = "";
          return this.method === "twoPoints" ? (t2 = this.center.symbolic.x, e3 = this.center.symbolic.y, i2 = this.point2.symbolic.x, r2 = this.point2.symbolic.y, a = "((" + i2 + ")-(" + t2 + "))^2 + ((" + r2 + ")-(" + e3 + "))^2") : this.method === "pointRadius" ? n.isNumber(this.radius) && (a = (this.radius * this.radius).toString()) : this.method === "pointLine" ? (i2 = this.line.point1.symbolic.x, r2 = this.line.point1.symbolic.y, s2 = this.line.point2.symbolic.x, o2 = this.line.point2.symbolic.y, a = "((" + i2 + ")-(" + s2 + "))^2 + ((" + r2 + ")-(" + o2 + "))^2") : this.method === "pointCircle" && (a = this.circle.Radius()), a;
        }, update: function() {
          return this.needsUpdate && (n.evaluate(this.visProp.trace) && this.cloneToBackground(true), this.method === "pointLine" ? this.radius = this.line.point1.coords.distance(r.COORDS_BY_USER, this.line.point2.coords) : this.method === "pointCircle" ? this.radius = this.circle.Radius() : this.method === "pointRadius" && (this.radius = this.updateRadius()), this.updateStdform(), this.updateQuadraticform()), this;
        }, updateQuadraticform: function() {
          var t2 = this.center, e3 = t2.X(), i2 = t2.Y(), r2 = this.Radius();
          this.quadraticform = [[e3 * e3 + i2 * i2 - r2 * r2, -e3, -i2], [-e3, 1, 0], [-i2, 0, 1]];
        }, updateStdform: function() {
          this.stdform[3] = 0.5, this.stdform[4] = this.Radius(), this.stdform[1] = -this.center.coords.usrCoords[1], this.stdform[2] = -this.center.coords.usrCoords[2], isFinite(this.stdform[4]) || (this.stdform[0] = n.exists(this.point2) ? -(this.stdform[1] * this.point2.coords.usrCoords[1] + this.stdform[2] * this.point2.coords.usrCoords[2]) : 0), this.normalize();
        }, updateRenderer: function() {
          return this.needsUpdate ? (this.visPropCalc.visible && (this.isReal = !isNaN(this.center.coords.usrCoords[1] + this.center.coords.usrCoords[2] + this.Radius()) && this.center.isReal, this.isReal || this.updateVisibility(false)), this.visPropCalc.visible && this.board.renderer.updateEllipse(this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
        }, notifyParents: function(t2) {
          n.isString(t2) && o.findDependencies(this, t2, this.board);
        }, setRadius: function(t2) {
          return this.updateRadius = n.createFunction(t2, this.board, null, true), this.board.update(), this;
        }, Radius: function(t2) {
          return n.exists(t2) ? (this.setRadius(t2), this.Radius()) : this.method === "twoPoints" ? n.cmpArrays(this.point2.coords.usrCoords, [0, 0, 0]) || n.cmpArrays(this.center.coords.usrCoords, [0, 0, 0]) ? NaN : this.center.Dist(this.point2) : this.method === "pointLine" || this.method === "pointCircle" ? this.radius : this.method === "pointRadius" ? this.updateRadius() : NaN;
        }, getRadius: function() {
          return t.deprecated("Circle.getRadius()", "Circle.Radius()"), this.Radius();
        }, getTextAnchor: function() {
          return this.center.coords;
        }, getLabelAnchor: function() {
          var t2, e3, s2 = this.Radius(), o2 = this.center.coords.usrCoords;
          switch (n.evaluate(this.visProp.label.position)) {
            case "lft":
              t2 = o2[1] - s2, e3 = o2[2];
              break;
            case "llft":
              t2 = o2[1] - Math.sqrt(0.5) * s2, e3 = o2[2] - Math.sqrt(0.5) * s2;
              break;
            case "rt":
              t2 = o2[1] + s2, e3 = o2[2];
              break;
            case "lrt":
              t2 = o2[1] + Math.sqrt(0.5) * s2, e3 = o2[2] - Math.sqrt(0.5) * s2;
              break;
            case "urt":
              t2 = o2[1] + Math.sqrt(0.5) * s2, e3 = o2[2] + Math.sqrt(0.5) * s2;
              break;
            case "top":
              t2 = o2[1], e3 = o2[2] + s2;
              break;
            case "bot":
              t2 = o2[1], e3 = o2[2] - s2;
              break;
            default:
              t2 = o2[1] - Math.sqrt(0.5) * s2, e3 = o2[2] + Math.sqrt(0.5) * s2;
          }
          return new i(r.COORDS_BY_USER, [t2, e3], this.board);
        }, cloneToBackground: function() {
          var t2, e3 = this.Radius(), i2 = {id: this.id + "T" + this.numTraces, elementClass: r.OBJECT_CLASS_CIRCLE, center: {coords: this.center.coords}, Radius: function() {
            return e3;
          }, getRadius: function() {
            return e3;
          }, board: this.board, visProp: n.deepCopy(this.visProp, this.visProp.traceattributes, true)};
          return i2.visProp.layer = this.board.options.layer.trace, this.numTraces++, n.clearVisPropOld(i2), i2.visPropCalc = {visible: n.evaluate(i2.visProp.visible)}, t2 = this.board.renderer.enhancedRendering, this.board.renderer.enhancedRendering = true, this.board.renderer.drawEllipse(i2), this.board.renderer.enhancedRendering = t2, this.traces[i2.id] = i2.rendNode, this;
        }, addTransform: function(t2) {
          var e3, i2 = n.isArray(t2) ? t2 : [t2], r2 = i2.length;
          for (e3 = 0; e3 < r2; e3++)
            this.center.transformations.push(i2[e3]), this.method === "twoPoints" && this.point2.transformations.push(i2[e3]);
          return this;
        }, snapToGrid: function() {
          var t2 = n.evaluate(this.visProp.snaptogrid);
          return this.center.handleSnapToGrid(t2, true), this.method === "twoPoints" && this.point2.handleSnapToGrid(t2, true), this;
        }, snapToPoints: function() {
          var t2 = n.evaluate(this.visProp.snaptopoints);
          return this.center.handleSnapToPoints(t2), this.method === "twoPoints" && this.point2.handleSnapToPoints(t2), this;
        }, X: function(t2) {
          return this.Radius() * Math.cos(2 * t2 * Math.PI) + this.center.coords.usrCoords[1];
        }, Y: function(t2) {
          return this.Radius() * Math.sin(2 * t2 * Math.PI) + this.center.coords.usrCoords[2];
        }, Z: function(t2) {
          return 1;
        }, minX: function() {
          return 0;
        }, maxX: function() {
          return 1;
        }, Area: function() {
          var t2 = this.Radius();
          return t2 * t2 * Math.PI;
        }, bounds: function() {
          var t2 = this.center.coords.usrCoords, e3 = this.Radius();
          return [t2[1] - e3, t2[2] + e3, t2[1] + e3, t2[2] - e3];
        }, getParents: function() {
          return this.parents.length === 1 ? this.parents.concat(this.radius) : this.parents;
        }}), t.createCircle = function(e3, i2, o2) {
          var a, h, l, c, d;
          if (h = [], d = e3.select(i2[0]), n.isObject(d) && d.elementClass === r.OBJECT_CLASS_CIRCLE && n.isTransformationOrArray(i2[1]))
            return c = n.copyAttributes(o2, e3.options, "circle"), a = s.createEllipse(e3, [d.center, d.center, function() {
              return 2 * d.Radius();
            }], c), a.addTransform(i2[1]), a;
          for (l = 0; l < i2.length; l++)
            if (n.isPointType(e3, i2[l])) {
              if (h = h.concat(n.providePoints(e3, [i2[l]], o2, "circle", ["center"])), h[h.length - 1] === false)
                throw new Error("JSXGraph: Can't create circle from this type. Please provide a point type.");
            } else
              h.push(i2[l]);
          if (c = n.copyAttributes(o2, e3.options, "circle"), h.length === 2 && n.isPoint(h[0]) && n.isPoint(h[1]))
            a = new t.Circle(e3, "twoPoints", h[0], h[1], c);
          else if ((n.isNumber(h[0]) || n.isFunction(h[0]) || n.isString(h[0])) && n.isPoint(h[1]))
            a = new t.Circle(e3, "pointRadius", h[1], h[0], c);
          else if ((n.isNumber(h[1]) || n.isFunction(h[1]) || n.isString(h[1])) && n.isPoint(h[0]))
            a = new t.Circle(e3, "pointRadius", h[0], h[1], c);
          else if (h[0].elementClass === r.OBJECT_CLASS_CIRCLE && n.isPoint(h[1]))
            a = new t.Circle(e3, "pointCircle", h[1], h[0], c);
          else if (h[1].elementClass === r.OBJECT_CLASS_CIRCLE && n.isPoint(h[0]))
            a = new t.Circle(e3, "pointCircle", h[0], h[1], c);
          else if (h[0].elementClass === r.OBJECT_CLASS_LINE && n.isPoint(h[1]))
            a = new t.Circle(e3, "pointLine", h[1], h[0], c);
          else if (h[1].elementClass === r.OBJECT_CLASS_LINE && n.isPoint(h[0]))
            a = new t.Circle(e3, "pointLine", h[0], h[1], c);
          else {
            if (!(i2.length === 3 && n.isPoint(h[0]) && n.isPoint(h[1]) && n.isPoint(h[2])))
              throw new Error("JSXGraph: Can't create circle with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,point], [point,number], [point,function], [point,circle], [point,point,point], [circle,transformation]");
            if (!t.elements.circumcircle)
              throw new Error("JSXGraph: Can't create circle with three points. Please include the circumcircle element (element/composition).");
            a = t.elements.circumcircle(e3, h, c);
          }
          for (a.isDraggable = true, a.setParents(h), a.elType = "circle", l = 0; l < h.length; l++)
            n.isPoint(h[l]) && a.inherits.push(h[l]);
          return a;
        }, t.registerElement("circle", t.createCircle), {Circle: t.Circle, createCircle: t.createCircle};
      }), define("base/composition", ["jxg", "utils/type"], function(t, e2) {
        "use strict";
        return t.Composition = function(t2) {
          var i, r = this, s = ["setAttribute", "setParents", "prepareUpdate", "updateRenderer", "update", "fullUpdate", "highlight", "noHighlight"];
          for (i = 0; i < s.length; i++)
            this[s[i]] = function(t3) {
              return function() {
                var i2;
                for (i2 in r.elements)
                  r.elements.hasOwnProperty(i2) && e2.exists(r.elements[i2][t3]) && r.elements[i2][t3].apply(r.elements[i2], arguments);
                return r;
              };
            }(s[i]);
          this.elements = {}, this.objects = this.elements, this.elementsByName = {}, this.objectsList = [], this.groups = {}, this.methodMap = {setAttribute: "setAttribute", setProperty: "setAttribute", setParents: "setParents", add: "add", remove: "remove", select: "select"};
          for (i in t2)
            t2.hasOwnProperty(i) && this.add(i, t2[i]);
          this.dump = true, this.subs = {};
        }, t.extend(t.Composition.prototype, {add: function(t2, i) {
          return !(e2.exists(this[t2]) || !e2.exists(i)) && (e2.exists(i.id) ? this.elements[i.id] = i : this.elements[t2] = i, e2.exists(i.name) && (this.elementsByName[i.name] = i), i.on("attribute:name", this.nameListener, this), this.objectsList.push(i), this[t2] = i, this.methodMap[t2] = i, true);
        }, remove: function(t2) {
          var e3, i = false;
          for (e3 in this.elements)
            if (this.elements.hasOwnProperty(e3) && this.elements[e3].id === this[t2].id) {
              i = true;
              break;
            }
          return i && (delete this.elements[this[t2].id], delete this[t2]), i;
        }, nameListener: function(t2, e3, i) {
          delete this.elementsByName[t2], this.elementsByName[e3] = i;
        }, select: function(i) {
          return e2.exists(t.Board) ? t.Board.prototype.select.call(this, i) : new t.Composition();
        }, getParents: function() {
          return this.parents;
        }, getType: function() {
          return this.elType;
        }, getAttributes: function() {
          var t2, e3 = {};
          for (t2 in this.subs)
            this.subs.hasOwnProperty(t2) && (e3[t2] = this.subs[t2].visProp);
          return this.attr;
        }}), t.Composition;
      }), define("base/polygon", ["jxg", "base/constants", "base/coords", "math/statistics", "math/geometry", "utils/type", "base/element", "base/line", "base/transformation"], function(t, e2, i, r, s, o, n, a, h) {
        "use strict";
        return t.Polygon = function(i2, r2, s2) {
          this.constructor(i2, s2, e2.OBJECT_TYPE_POLYGON, e2.OBJECT_CLASS_AREA);
          var n3, a2, h2, l, c = o.copyAttributes(s2, i2.options, "polygon", "borders");
          for (this.withLines = s2.withlines, this.attr_line = c, this.vertices = [], n3 = 0; n3 < r2.length; n3++)
            this.vertices[n3] = this.board.select(r2[n3]);
          if (this.vertices.length > 0 && this.vertices[this.vertices.length - 1].id !== this.vertices[0].id && this.vertices.push(this.vertices[0]), this.borders = [], this.withLines)
            for (h2 = this.vertices.length - 1, l = 0; l < h2; l++)
              n3 = (l + 1) % h2, c.id = c.ids && c.ids[n3], c.name = c.names && c.names[n3], c.strokecolor = o.isArray(c.colors) && c.colors[n3 % c.colors.length] || c.strokecolor, c.visible = o.exists(s2.borders.visible) ? s2.borders.visible : s2.visible, c.strokecolor === false && (c.strokecolor = "none"), a2 = i2.create("segment", [this.vertices[n3], this.vertices[n3 + 1]], c), a2.dump = false, this.borders[n3] = a2, a2.parentPolygon = this;
          for (this.inherits.push(this.vertices, this.borders), this.id = this.board.setId(this, "Py"), n3 = 0; n3 < this.vertices.length - 1; n3++)
            this.board.select(this.vertices[n3]).addChild(this);
          this.board.renderer.drawPolygon(this), this.board.finalizeAdding(this), this.createGradient(), this.elType = "polygon", this.createLabel(), this.methodMap = t.deepCopy(this.methodMap, {borders: "borders", vertices: "vertices", A: "Area", Area: "Area", Perimeter: "Perimeter", L: "Perimeter", Length: "Perimeter", boundingBox: "boundingBox", bounds: "bounds", addPoints: "addPoints", insertPoints: "insertPoints", removePoints: "removePoints"});
        }, t.Polygon.prototype = new n(), t.extend(t.Polygon.prototype, {hasPoint: function(t2, e3) {
          var i2, r2, s2, n3 = false;
          if (o.evaluate(this.visProp.hasinnerpoints)) {
            for (s2 = this.vertices.length, i2 = 0, r2 = s2 - 2; i2 < s2 - 1; r2 = i2++)
              this.vertices[i2].coords.scrCoords[2] > e3 != this.vertices[r2].coords.scrCoords[2] > e3 && t2 < (this.vertices[r2].coords.scrCoords[1] - this.vertices[i2].coords.scrCoords[1]) * (e3 - this.vertices[i2].coords.scrCoords[2]) / (this.vertices[r2].coords.scrCoords[2] - this.vertices[i2].coords.scrCoords[2]) + this.vertices[i2].coords.scrCoords[1] && (n3 = !n3);
            if (n3)
              return true;
          }
          for (s2 = this.borders.length, i2 = 0; i2 < s2; i2++)
            if (this.borders[i2].hasPoint(t2, e3)) {
              n3 = true;
              break;
            }
          return n3;
        }, updateRenderer: function() {
          var t2, e3;
          if (!this.needsUpdate)
            return this;
          if (this.visPropCalc.visible) {
            for (e3 = this.vertices.length, this.isReal = true, t2 = 0; t2 < e3; ++t2)
              if (!this.vertices[t2].isReal) {
                this.isReal = false;
                break;
              }
            this.isReal || this.updateVisibility(false);
          }
          return this.visPropCalc.visible && this.board.renderer.updatePolygon(this), this.hasLabel && this.visPropCalc.visible && this.label && this.label.visPropCalc.visible && this.isReal && (this.label.update(), this.board.renderer.updateText(this.label)), this.setDisplayRendNode(), this.needsUpdate = false, this;
        }, getTextAnchor: function() {
          var t2, r2, s2, o2, n3;
          if (this.vertices.length === 0)
            return new i(e2.COORDS_BY_USER, [1, 0, 0], this.board);
          for (t2 = this.vertices[0].X(), r2 = this.vertices[0].Y(), s2 = t2, o2 = r2, n3 = 0; n3 < this.vertices.length; n3++)
            this.vertices[n3].X() < t2 && (t2 = this.vertices[n3].X()), this.vertices[n3].X() > s2 && (s2 = this.vertices[n3].X()), this.vertices[n3].Y() > r2 && (r2 = this.vertices[n3].Y()), this.vertices[n3].Y() < o2 && (o2 = this.vertices[n3].Y());
          return new i(e2.COORDS_BY_USER, [0.5 * (t2 + s2), 0.5 * (r2 + o2)], this.board);
        }, getLabelAnchor: t.shortcut(t.Polygon.prototype, "getTextAnchor"), cloneToBackground: function() {
          var t2, e3 = {};
          return e3.id = this.id + "T" + this.numTraces, this.numTraces++, e3.vertices = this.vertices, e3.visProp = o.deepCopy(this.visProp, this.visProp.traceattributes, true), e3.visProp.layer = this.board.options.layer.trace, e3.board = this.board, o.clearVisPropOld(e3), e3.visPropCalc = {visible: o.evaluate(e3.visProp.visible)}, t2 = this.board.renderer.enhancedRendering, this.board.renderer.enhancedRendering = true, this.board.renderer.drawPolygon(e3), this.board.renderer.enhancedRendering = t2, this.traces[e3.id] = e3.rendNode, this;
        }, hideElement: function(e3) {
          var i2;
          if (t.deprecated("Element.hideElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = false, this.board.renderer.display(this, false), !e3)
            for (i2 = 0; i2 < this.borders.length; i2++)
              this.borders[i2].hideElement();
          this.hasLabel && o.exists(this.label) && (this.label.hiddenByParent = true, this.label.visPropCalc.visible && this.label.hideElement());
        }, showElement: function(e3) {
          var i2;
          if (t.deprecated("Element.showElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = true, this.board.renderer.display(this, true), !e3)
            for (i2 = 0; i2 < this.borders.length; i2++)
              this.borders[i2].showElement().updateRenderer();
          return o.exists(this.label) && this.hasLabel && this.label.hiddenByParent && (this.label.hiddenByParent = false, this.label.visPropCalc.visible || this.label.showElement().updateRenderer()), this;
        }, Area: function() {
          return Math.abs(s.signedPolygon(this.vertices, true));
        }, Perimeter: function() {
          var t2, e3 = this.vertices.length, i2 = 0;
          for (t2 = 1; t2 < e3; ++t2)
            i2 += this.vertices[t2].Dist(this.vertices[t2 - 1]);
          return i2;
        }, boundingBox: function() {
          var t2, e3, i2 = [0, 0, 0, 0], r2 = this.vertices.length - 1;
          if (r2 === 0)
            return i2;
          for (i2[0] = this.vertices[0].X(), i2[2] = i2[0], i2[1] = this.vertices[0].Y(), i2[3] = i2[1], t2 = 1; t2 < r2; ++t2)
            e3 = this.vertices[t2].X(), e3 < i2[0] ? i2[0] = e3 : e3 > i2[2] && (i2[2] = e3), e3 = this.vertices[t2].Y(), e3 > i2[1] ? i2[1] = e3 : e3 < i2[3] && (i2[3] = e3);
          return i2;
        }, bounds: function() {
          return this.boundingBox();
        }, remove: function() {
          var t2;
          for (t2 = 0; t2 < this.borders.length; t2++)
            this.board.removeObject(this.borders[t2]);
          n.prototype.remove.call(this);
        }, findPoint: function(t2) {
          var e3;
          if (!o.isPoint(t2))
            return -1;
          for (e3 = 0; e3 < this.vertices.length; e3++)
            if (this.vertices[e3].id === t2.id)
              return e3;
          return -1;
        }, addPoints: function(t2) {
          var e3 = Array.prototype.slice.call(arguments);
          return this.insertPoints.apply(this, [this.vertices.length - 2].concat(e3));
        }, insertPoints: function(t2, e3) {
          var i2, r2, s2 = [];
          if (arguments.length === 0)
            return this;
          if (t2 < 0 || t2 > this.vertices.length - 2)
            return this;
          for (i2 = 1; i2 < arguments.length; i2++)
            o.isPoint(arguments[i2]) && s2.push(arguments[i2]);
          if (r2 = this.vertices.slice(0, t2 + 1).concat(s2), this.vertices = r2.concat(this.vertices.slice(t2 + 1)), this.withLines) {
            for (r2 = this.borders.slice(0, t2), this.board.removeObject(this.borders[t2]), i2 = 0; i2 < s2.length; i2++)
              r2.push(this.board.create("segment", [this.vertices[t2 + i2], this.vertices[t2 + i2 + 1]], this.attr_line));
            r2.push(this.board.create("segment", [this.vertices[t2 + s2.length], this.vertices[t2 + s2.length + 1]], this.attr_line)), this.borders = r2.concat(this.borders.slice(t2 + 1));
          }
          return this.board.update(), this;
        }, removePoints: function(t2) {
          var e3, i2, r2, s2 = [], n3 = [], a2 = [], h2 = [];
          for (this.vertices = this.vertices.slice(0, this.vertices.length - 1), e3 = 0; e3 < arguments.length; e3++)
            r2 = arguments[e3], o.isPoint(r2) && (r2 = this.findPoint(r2)), o.isNumber(r2) && r2 > -1 && r2 < this.vertices.length && o.indexOf(a2, r2) === -1 && a2.push(r2);
          for (e3 = 0; e3 < a2.length; e3++)
            this.vertices[a2[e3]].removeChild(this);
          for (a2 = a2.sort(), s2 = this.vertices.slice(), n3 = this.borders.slice(), this.withLines && h2.push([a2[a2.length - 1]]), e3 = a2.length - 1; e3 > -1; e3--)
            s2[a2[e3]] = -1, this.withLines && a2[e3] - 1 > a2[e3 - 1] && (h2[h2.length - 1][1] = a2[e3], h2.push([a2[e3 - 1]]));
          for (this.withLines && (h2[h2.length - 1][1] = a2[0]), this.vertices = [], e3 = 0; e3 < s2.length; e3++)
            o.isPoint(s2[e3]) && this.vertices.push(s2[e3]);
          if (this.vertices[this.vertices.length - 1].id !== this.vertices[0].id && this.vertices.push(this.vertices[0]), this.withLines) {
            for (e3 = 0; e3 < h2.length; e3++) {
              for (i2 = h2[e3][1] - 1; i2 < h2[e3][0] + 1; i2++)
                i2 < 0 ? (i2 = 0, this.board.removeObject(this.borders[n3.length - 1]), n3[n3.length - 1] = -1) : i2 > n3.length - 1 && (i2 = n3.length - 1), this.board.removeObject(this.borders[i2]), n3[i2] = -1;
              h2[e3][1] !== 0 && h2[e3][0] !== s2.length - 1 && (n3[h2[e3][0] - 1] = this.board.create("segment", [s2[Math.max(h2[e3][1] - 1, 0)], s2[Math.min(h2[e3][0] + 1, this.vertices.length - 1)]], this.attr_line));
            }
            for (this.borders = [], e3 = 0; e3 < n3.length; e3++)
              n3[e3] !== -1 && this.borders.push(n3[e3]);
            h2[0][1] !== this.vertices.length - 1 && h2[h2.length - 1][1] !== 0 || this.borders.push(this.board.create("segment", [this.vertices[0], this.vertices[this.vertices.length - 2]], this.attr_line));
          }
          return this.board.update(), this;
        }, getParents: function() {
          return this.setParents(this.vertices), this.parents;
        }, getAttributes: function() {
          var t2, e3 = n.prototype.getAttributes.call(this);
          if (this.withLines)
            for (e3.lines = e3.lines || {}, e3.lines.ids = [], e3.lines.colors = [], t2 = 0; t2 < this.borders.length; t2++)
              e3.lines.ids.push(this.borders[t2].id), e3.lines.colors.push(this.borders[t2].visProp.strokecolor);
          return e3;
        }, snapToGrid: function() {
          var t2, e3;
          for (e3 = !!o.evaluate(this.visProp.snaptogrid), t2 = 0; t2 < this.vertices.length; t2++)
            this.vertices[t2].handleSnapToGrid(e3, true);
        }, setPositionDirectly: function(t2, e3, s2) {
          var o2, n3, a2, h2, l = new i(t2, e3, this.board), c = new i(t2, s2, this.board);
          for (h2 = this.vertices.length - 1, a2 = 0; a2 < h2; a2++)
            if (!this.vertices[a2].draggable())
              return this;
          return o2 = r.subtract(l.usrCoords, c.usrCoords), n3 = this.board.create("transform", o2.slice(1), {type: "translate"}), n3.applyOnce(this.vertices.slice(0, -1)), this;
        }, sutherlandHodgman: function(e3) {
          var i2, r2, s2, o2, n3, a2, h2, l = t.Math.Geometry.sortVertices(this.vertices), c = t.Math.Geometry.sortVertices(e3.vertices), d = l.length - 1, u = c.length - 1, p = [], f = function(t2, e4, i3) {
            return (e4[1] - t2[1]) * (i3[2] - t2[2]) - (e4[2] - t2[2]) * (i3[1] - t2[1]) >= 0;
          };
          for (s2 = 0; s2 < u; s2++)
            p.push(c[s2]);
          for (s2 = 0; s2 < d; s2++)
            for (r2 = p.slice(0), i2 = r2.length, p = [], n3 = r2[i2 - 1], o2 = 0; o2 < i2; o2++)
              a2 = r2[o2], f(l[s2], l[s2 + 1], a2) ? (f(l[s2], l[s2 + 1], n3) || (h2 = t.Math.Geometry.meetSegmentSegment(n3, a2, l[s2], l[s2 + 1]), h2[0][1] /= h2[0][0], h2[0][2] /= h2[0][0], h2[0][0] = 1, p.push(h2[0])), p.push(a2)) : f(l[s2], l[s2 + 1], n3) && (h2 = t.Math.Geometry.meetSegmentSegment(n3, a2, l[s2], l[s2 + 1]), h2[0][1] /= h2[0][0], h2[0][2] /= h2[0][0], h2[0][0] = 1, p.push(h2[0])), n3 = a2;
          return p;
        }, intersect: function(t2) {
          return this.sutherlandHodgman(t2);
        }}), t.createPolygon = function(i2, r2, s2) {
          var n3, a2, h2, l, c, d, u = [], p = false;
          if (c = o.copyAttributes(s2, i2.options, "polygon"), l = i2.select(r2[0]), l === null && (l = r2[0]), o.isObject(l) && l.type === e2.OBJECT_TYPE_POLYGON && o.isTransformationOrArray(r2[1]))
            for (p = true, h2 = l.vertices.length - 1, d = o.copyAttributes(s2, i2.options, "polygon", "vertices"), a2 = 0; a2 < h2; a2++)
              d.withlabel && (d.name = l.vertices[a2].name === "" ? "" : l.vertices[a2].name + "'"), u.push(i2.create("point", [l.vertices[a2], r2[1]], d));
          else if ((u = o.providePoints(i2, r2, s2, "polygon", ["vertices"])) === false)
            throw new Error("JSXGraph: Can't create polygon with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates. Alternatively, a polygon and a transformation can be supplied");
          if (c = o.copyAttributes(s2, i2.options, "polygon"), n3 = new t.Polygon(i2, u, c), n3.isDraggable = true, p)
            for (n3.prepareUpdate().update().updateVisibility().updateRenderer(), h2 = l.vertices.length - 1, a2 = 0; a2 < h2; a2++)
              u[a2].prepareUpdate().update().updateVisibility().updateRenderer();
          return n3;
        }, t.createRegularPolygon = function(t2, i2, r2) {
          var s2, n3, a2, h2, l, c, d, u = [];
          if (l = i2.length, a2 = i2[l - 1], o.isNumber(a2) && (i2.length !== 3 || a2 < 3))
            throw new Error("JSXGraph: A regular polygon needs two point types and a number > 2 as input.");
          if (o.isNumber(t2.select(a2)) ? (l--, c = false) : (a2 = l, c = true), (u = o.providePoints(t2, i2.slice(0, l), r2, "regularpolygon", ["vertices"])) === false)
            throw new Error("JSXGraph: Can't create regular polygon with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates");
          for (d = o.copyAttributes(r2, t2.options, "regularpolygon", "vertices"), n3 = 2; n3 < a2; n3++)
            h2 = t2.create("transform", [Math.PI * (2 - (a2 - 2) / a2), u[n3 - 1]], {type: "rotate"}), c ? (u[n3].addTransform(u[n3 - 2], h2), u[n3].fullUpdate()) : (o.isArray(d.ids) && d.ids.length >= a2 - 2 && (d.id = d.ids[n3 - 2]), u[n3] = t2.create("point", [u[n3 - 2], h2], d), u[n3].type = e2.OBJECT_TYPE_CAS, u[n3].isDraggable = true, u[n3].visProp.fixed = false);
          return d = o.copyAttributes(r2, t2.options, "regularpolygon"), s2 = t2.create("polygon", u, d), s2.elType = "regularpolygon", s2;
        }, t.createPolygonalChain = function(t2, e3, i2) {
          var r2, s2;
          return r2 = o.copyAttributes(i2, t2.options, "polygonalchain"), s2 = t2.create("polygon", e3, r2), s2.elType = "polygonalchain", s2.vertices.pop(), t2.removeObject(s2.borders[s2.borders.length - 1]), s2.borders.pop(), s2;
        }, t.registerElement("polygon", t.createPolygon), t.registerElement("regularpolygon", t.createRegularPolygon), t.registerElement("polygonalchain", t.createPolygonalChain), {Polygon: t.Polygon, createPolygon: t.createPolygon, createRegularPolygon: t.createRegularPolygon};
      }), define("element/composition", ["jxg", "math/math", "math/geometry", "math/numerics", "base/coords", "utils/type", "base/constants", "base/point", "base/line", "base/circle", "base/transformation", "base/composition", "base/curve", "base/polygon"], function(t, e2, i, r, s, o, n, a, h, l, c, d, u, p) {
        "use strict";
        return t.createOrthogonalProjection = function(t2, e3, r2) {
          var s2, a2, h2, l2;
          if (e3[0] = t2.select(e3[0]), e3[1] = t2.select(e3[1]), o.isPointType(t2, e3[0]) && e3[1].elementClass === n.OBJECT_CLASS_LINE)
            a2 = o.providePoints(t2, [e3[0]], r2, "point")[0], s2 = e3[1];
          else {
            if (!o.isPointType(t2, e3[1]) || e3[0].elementClass !== n.OBJECT_CLASS_LINE)
              throw new Error("JSXGraph: Can't create perpendicular point with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [point,line]");
            a2 = o.providePoints(t2, [e3[1]], r2, "point")[0], s2 = e3[0];
          }
          return l2 = o.copyAttributes(r2, t2.options, "orthogonalprojection"), h2 = t2.create("point", [function() {
            return i.projectPointToLine(a2, s2, t2);
          }], l2), a2.addChild(h2), s2.addChild(h2), h2.elType = "orthogonalprojection", h2.setParents([a2.id, h2.id]), h2.update(), h2.generatePolynomial = function() {
            var t3 = s2.point1.symbolic.x, e4 = s2.point1.symbolic.y, i2 = s2.point2.symbolic.x, r3 = s2.point2.symbolic.y, o2 = a2.symbolic.x, n3 = a2.symbolic.y, l3 = h2.symbolic.x, c2 = h2.symbolic.y;
            return ["(" + e4 + ")*(" + l3 + ")-(" + e4 + ")*(" + i2 + ")+(" + c2 + ")*(" + i2 + ")-(" + t3 + ")*(" + c2 + ")+(" + t3 + ")*(" + r3 + ")-(" + l3 + ")*(" + r3 + ")", "(" + n3 + ")*(" + e4 + ")-(" + n3 + ")*(" + r3 + ")-(" + c2 + ")*(" + e4 + ")+(" + c2 + ")*(" + r3 + ")+(" + o2 + ")*(" + t3 + ")-(" + o2 + ")*(" + i2 + ")-(" + l3 + ")*(" + t3 + ")+(" + l3 + ")*(" + i2 + ")"];
          }, h2;
        }, t.createPerpendicular = function(t2, e3, i2) {
          var r2, s2, a2, l2;
          if (e3[0] = t2.select(e3[0]), e3[1] = t2.select(e3[1]), o.isPointType(t2, e3[0]) && e3[1].elementClass === n.OBJECT_CLASS_LINE)
            s2 = e3[1], r2 = o.providePoints(t2, [e3[0]], i2, "point")[0];
          else {
            if (!o.isPointType(t2, e3[1]) || e3[0].elementClass !== n.OBJECT_CLASS_LINE)
              throw new Error("JSXGraph: Can't create perpendicular with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [line,point]");
            s2 = e3[0], r2 = o.providePoints(t2, [e3[1]], i2, "point")[0];
          }
          return l2 = o.copyAttributes(i2, t2.options, "perpendicular"), a2 = h.createLine(t2, [function() {
            return s2.stdform[2] * r2.X() - s2.stdform[1] * r2.Y();
          }, function() {
            return -s2.stdform[2] * r2.Z();
          }, function() {
            return s2.stdform[1] * r2.Z();
          }], l2), a2.elType = "perpendicular", a2.setParents([s2.id, r2.id]), a2;
        }, t.createPerpendicularPoint = function(t2, e3, r2) {
          var s2, a2, h2;
          if (e3[0] = t2.select(e3[0]), e3[1] = t2.select(e3[1]), o.isPointType(t2, e3[0]) && e3[1].elementClass === n.OBJECT_CLASS_LINE)
            a2 = o.providePoints(t2, [e3[0]], r2, "point")[0], s2 = e3[1];
          else {
            if (!o.isPointType(t2, e3[1]) || e3[0].elementClass !== n.OBJECT_CLASS_LINE)
              throw new Error("JSXGraph: Can't create perpendicular point with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [point,line]");
            a2 = o.providePoints(t2, [e3[1]], r2, "point")[0], s2 = e3[0];
          }
          return h2 = t2.create("point", [function() {
            return i.perpendicular(s2, a2, t2)[0];
          }], r2), a2.addChild(h2), s2.addChild(h2), h2.elType = "perpendicularpoint", h2.setParents([a2.id, s2.id]), h2.update(), h2.generatePolynomial = function() {
            var t3 = s2.point1.symbolic.x, e4 = s2.point1.symbolic.y, i2 = s2.point2.symbolic.x, r3 = s2.point2.symbolic.y, o2 = a2.symbolic.x, n3 = a2.symbolic.y, l2 = h2.symbolic.x, c2 = h2.symbolic.y;
            return ["(" + e4 + ")*(" + l2 + ")-(" + e4 + ")*(" + i2 + ")+(" + c2 + ")*(" + i2 + ")-(" + t3 + ")*(" + c2 + ")+(" + t3 + ")*(" + r3 + ")-(" + l2 + ")*(" + r3 + ")", "(" + n3 + ")*(" + e4 + ")-(" + n3 + ")*(" + r3 + ")-(" + c2 + ")*(" + e4 + ")+(" + c2 + ")*(" + r3 + ")+(" + o2 + ")*(" + t3 + ")-(" + o2 + ")*(" + i2 + ")-(" + l2 + ")*(" + t3 + ")+(" + l2 + ")*(" + i2 + ")"];
          }, h2;
        }, t.createPerpendicularSegment = function(e3, r2, s2) {
          var a2, l2, c2, d2, u2;
          if (r2[0] = e3.select(r2[0]), r2[1] = e3.select(r2[1]), o.isPointType(e3, r2[0]) && r2[1].elementClass === n.OBJECT_CLASS_LINE)
            l2 = r2[1], a2 = o.providePoints(e3, [r2[0]], s2, "point")[0];
          else {
            if (!o.isPointType(e3, r2[1]) || r2[0].elementClass !== n.OBJECT_CLASS_LINE)
              throw new Error("JSXGraph: Can't create perpendicular with parent types '" + typeof r2[0] + "' and '" + typeof r2[1] + "'.\nPossible parent types: [line,point]");
            l2 = r2[0], a2 = o.providePoints(e3, [r2[1]], s2, "point")[0];
          }
          return u2 = o.copyAttributes(s2, e3.options, "perpendicularsegment", "point"), d2 = t.createPerpendicularPoint(e3, [l2, a2], u2), d2.dump = false, o.exists(s2.layer) || (s2.layer = e3.options.layer.line), u2 = o.copyAttributes(s2, e3.options, "perpendicularsegment"), c2 = h.createLine(e3, [function() {
            return i.perpendicular(l2, a2, e3)[1] ? [d2, a2] : [a2, d2];
          }], u2), c2.point = d2, c2.elType = "perpendicularsegment", c2.setParents([a2.id, l2.id]), c2.subs = {point: d2}, c2.inherits.push(d2), c2;
        }, t.createMidpoint = function(t2, i2, r2) {
          var s2, a2, h2, l2, c2;
          for (l2 = 0; l2 < i2.length; ++l2)
            i2[l2] = t2.select(i2[l2]);
          if (i2.length === 2 && o.isPointType(t2, i2[0]) && o.isPointType(t2, i2[1]))
            i2 = o.providePoints(t2, i2, r2, "point"), s2 = i2[0], a2 = i2[1];
          else {
            if (i2.length !== 1 || i2[0].elementClass !== n.OBJECT_CLASS_LINE)
              throw new Error("JSXGraph: Can't create midpoint.\nPossible parent types: [point,point], [line]");
            s2 = i2[0].point1, a2 = i2[0].point2;
          }
          return c2 = o.copyAttributes(r2, t2.options, "midpoint"), h2 = t2.create("point", [function() {
            var t3 = s2.coords.usrCoords[1] + a2.coords.usrCoords[1];
            return isNaN(t3) || Math.abs(s2.coords.usrCoords[0]) < e2.eps || Math.abs(a2.coords.usrCoords[0]) < e2.eps ? NaN : 0.5 * t3;
          }, function() {
            var t3 = s2.coords.usrCoords[2] + a2.coords.usrCoords[2];
            return isNaN(t3) || Math.abs(s2.coords.usrCoords[0]) < e2.eps || Math.abs(a2.coords.usrCoords[0]) < e2.eps ? NaN : 0.5 * t3;
          }], c2), s2.addChild(h2), a2.addChild(h2), h2.elType = "midpoint", h2.setParents([s2.id, a2.id]), h2.prepareUpdate().update(), h2.generatePolynomial = function() {
            var t3 = s2.symbolic.x, e3 = s2.symbolic.y, i3 = a2.symbolic.x, r3 = a2.symbolic.y, o2 = h2.symbolic.x, n3 = h2.symbolic.y;
            return ["(" + e3 + ")*(" + o2 + ")-(" + e3 + ")*(" + i3 + ")+(" + n3 + ")*(" + i3 + ")-(" + t3 + ")*(" + n3 + ")+(" + t3 + ")*(" + r3 + ")-(" + o2 + ")*(" + r3 + ")", "(" + t3 + ")^2 - 2*(" + t3 + ")*(" + o2 + ")+(" + e3 + ")^2-2*(" + e3 + ")*(" + n3 + ")-(" + i3 + ")^2+2*(" + i3 + ")*(" + o2 + ")-(" + r3 + ")^2+2*(" + r3 + ")*(" + n3 + ")"];
          }, h2;
        }, t.createParallelPoint = function(t2, e3, i2) {
          var r2, s2, a2, h2, l2;
          for (l2 = 0; l2 < e3.length; ++l2)
            e3[l2] = t2.select(e3[l2]);
          if (e3.length === 3 && o.isPointType(t2, e3[0]) && o.isPointType(t2, e3[1]) && o.isPointType(t2, e3[2]))
            e3 = o.providePoints(t2, e3, i2, "point"), r2 = e3[0], s2 = e3[1], a2 = e3[2];
          else if (o.isPointType(t2, e3[0]) && e3[1].elementClass === n.OBJECT_CLASS_LINE)
            a2 = o.providePoints(t2, [e3[0]], i2, "point")[0], r2 = e3[1].point1, s2 = e3[1].point2;
          else {
            if (!o.isPointType(t2, e3[1]) || e3[0].elementClass !== n.OBJECT_CLASS_LINE)
              throw new Error("JSXGraph: Can't create parallel point with parent types '" + typeof e3[0] + "', '" + typeof e3[1] + "' and '" + typeof e3[2] + "'.\nPossible parent types: [line,point], [point,point,point]");
            a2 = o.providePoints(t2, [e3[1]], i2, "point")[0], r2 = e3[0].point1, s2 = e3[0].point2;
          }
          return h2 = t2.create("point", [function() {
            return a2.coords.usrCoords[1] + s2.coords.usrCoords[1] - r2.coords.usrCoords[1];
          }, function() {
            return a2.coords.usrCoords[2] + s2.coords.usrCoords[2] - r2.coords.usrCoords[2];
          }], i2), r2.addChild(h2), s2.addChild(h2), a2.addChild(h2), h2.elType = "parallelpoint", h2.setParents([r2.id, s2.id, a2.id]), h2.prepareUpdate().update(), h2.generatePolynomial = function() {
            var t3 = r2.symbolic.x, e4 = r2.symbolic.y, i3 = s2.symbolic.x, o2 = s2.symbolic.y, n3 = a2.symbolic.x, l3 = a2.symbolic.y, c2 = h2.symbolic.x, d2 = h2.symbolic.y;
            return ["(" + o2 + ")*(" + c2 + ")-(" + o2 + ")*(" + n3 + ")-(" + e4 + ")*(" + c2 + ")+(" + e4 + ")*(" + n3 + ")-(" + d2 + ")*(" + i3 + ")+(" + d2 + ")*(" + t3 + ")+(" + l3 + ")*(" + i3 + ")-(" + l3 + ")*(" + t3 + ")", "(" + d2 + ")*(" + t3 + ")-(" + d2 + ")*(" + n3 + ")-(" + o2 + ")*(" + t3 + ")+(" + o2 + ")*(" + n3 + ")-(" + c2 + ")*(" + e4 + ")+(" + c2 + ")*(" + l3 + ")+(" + i3 + ")*(" + e4 + ")-(" + i3 + ")*(" + l3 + ")"];
          }, h2;
        }, t.createParallel = function(t2, i2, r2) {
          var s2, n3, a2, h2, l2, c2;
          for (l2 = 0; l2 < i2.length; ++l2)
            i2[l2] = t2.select(i2[l2]);
          return s2 = null, i2.length === 3 ? (i2 = o.providePoints(t2, i2, r2, "point"), s2 = i2[2], h2 = function() {
            return e2.crossProduct(i2[0].coords.usrCoords, i2[1].coords.usrCoords);
          }) : o.isPointType(t2, i2[0]) ? (s2 = o.providePoints(t2, [i2[0]], r2, "point")[0], h2 = function() {
            return i2[1].stdform;
          }) : o.isPointType(t2, i2[1]) && (s2 = o.providePoints(t2, [i2[1]], r2, "point")[0], h2 = function() {
            return i2[0].stdform;
          }), o.exists(r2.layer) || (r2.layer = t2.options.layer.line), c2 = o.copyAttributes(r2, t2.options, "parallel", "point"), n3 = t2.create("point", [function() {
            return e2.crossProduct([1, 0, 0], h2());
          }], c2), n3.isDraggable = true, c2 = o.copyAttributes(r2, t2.options, "parallel"), a2 = t2.create("line", [s2, n3], c2), a2.elType = "parallel", a2.subs = {point: n3}, a2.inherits.push(n3), a2.setParents([i2[0].id, i2[1].id]), i2.length === 3 && a2.addParents(i2[2].id), a2.point = n3, a2;
        }, t.createArrowParallel = function(e3, i2, r2) {
          var s2;
          try {
            return r2.firstArrow = false, r2.lastArrow = true, s2 = t.createParallel(e3, i2, r2).setAttribute({straightFirst: false, straightLast: false}), s2.elType = "arrowparallel", s2;
          } catch (t2) {
            throw new Error("JSXGraph: Can't create arrowparallel with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [line,point], [point,point,point]");
          }
        }, t.createNormal = function(t2, i2, s2) {
          var a2, h2, l2, c2, d2, u2, p2, f, m;
          for (c2 = 0; c2 < i2.length; ++c2)
            i2[c2] = t2.select(i2[c2]);
          if (i2.length === 1)
            a2 = i2[0], h2 = a2.slideObject;
          else {
            if (i2.length !== 2)
              throw new Error("JSXGraph: Can't create normal with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]");
            if (o.isPointType(t2, i2[0]))
              a2 = o.providePoints(t2, [i2[0]], s2, "point")[0], h2 = i2[1];
            else {
              if (!o.isPointType(t2, i2[1]))
                throw new Error("JSXGraph: Can't create normal with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]");
              h2 = i2[0], a2 = o.providePoints(t2, [i2[1]], s2, "point")[0];
            }
          }
          if (p2 = o.copyAttributes(s2, t2.options, "normal"), h2.elementClass === n.OBJECT_CLASS_LINE)
            m = o.copyAttributes(s2, t2.options, "normal", "point"), f = t2.create("point", [function() {
              var t3 = e2.crossProduct([1, 0, 0], h2.stdform);
              return [t3[0], -t3[2], t3[1]];
            }], m), f.isDraggable = true, l2 = t2.create("line", [a2, f], p2), l2.point = f, l2.subs = {point: f}, l2.inherits.push(f);
          else if (h2.elementClass === n.OBJECT_CLASS_CIRCLE)
            l2 = t2.create("line", [h2.midpoint, a2], p2);
          else if (h2.elementClass === n.OBJECT_CLASS_CURVE)
            o.evaluate(h2.visProp.curvetype) !== "plot" ? (d2 = h2.X, u2 = h2.Y, l2 = t2.create("line", [function() {
              return -a2.X() * r.D(d2)(a2.position) - a2.Y() * r.D(u2)(a2.position);
            }, function() {
              return r.D(d2)(a2.position);
            }, function() {
              return r.D(u2)(a2.position);
            }], p2)) : l2 = t2.create("line", [function() {
              var t3 = Math.floor(a2.position), e3 = a2.position - t3;
              return t3 === h2.numberPoints - 1 && (t3 -= 1, e3 = 1), t3 < 0 ? 1 : (h2.Y(t3) + e3 * (h2.Y(t3 + 1) - h2.Y(t3))) * (h2.Y(t3) - h2.Y(t3 + 1)) - (h2.X(t3) + e3 * (h2.X(t3 + 1) - h2.X(t3))) * (h2.X(t3 + 1) - h2.X(t3));
            }, function() {
              var t3 = Math.floor(a2.position);
              return t3 === h2.numberPoints - 1 && (t3 -= 1), t3 < 0 ? 0 : h2.X(t3 + 1) - h2.X(t3);
            }, function() {
              var t3 = Math.floor(a2.position);
              return t3 === h2.numberPoints - 1 && (t3 -= 1), t3 < 0 ? 0 : h2.Y(t3 + 1) - h2.Y(t3);
            }], p2);
          else {
            if (h2.type !== n.OBJECT_TYPE_TURTLE)
              throw new Error("JSXGraph: Can't create normal with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [point,line], [point,circle], [glider]");
            l2 = t2.create("line", [function() {
              var t3, e3, i3 = Math.floor(a2.position), r2 = a2.position - i3;
              for (e3 = 0; e3 < h2.objects.length; e3++)
                if (t3 = h2.objects[e3], t3.type === n.OBJECT_TYPE_CURVE) {
                  if (i3 < t3.numberPoints)
                    break;
                  i3 -= t3.numberPoints;
                }
              return i3 === t3.numberPoints - 1 && (i3 -= 1, r2 = 1), i3 < 0 ? 1 : (t3.Y(i3) + r2 * (t3.Y(i3 + 1) - t3.Y(i3))) * (t3.Y(i3) - t3.Y(i3 + 1)) - (t3.X(i3) + r2 * (t3.X(i3 + 1) - t3.X(i3))) * (t3.X(i3 + 1) - t3.X(i3));
            }, function() {
              var t3, e3, i3 = Math.floor(a2.position);
              for (e3 = 0; e3 < h2.objects.length; e3++)
                if (t3 = h2.objects[e3], t3.type === n.OBJECT_TYPE_CURVE) {
                  if (i3 < t3.numberPoints)
                    break;
                  i3 -= t3.numberPoints;
                }
              return i3 === t3.numberPoints - 1 && (i3 -= 1), i3 < 0 ? 0 : t3.X(i3 + 1) - t3.X(i3);
            }, function() {
              var t3, e3, i3 = Math.floor(a2.position);
              for (e3 = 0; e3 < h2.objects.length; e3++)
                if (t3 = h2.objects[e3], t3.type === n.OBJECT_TYPE_CURVE) {
                  if (i3 < t3.numberPoints)
                    break;
                  i3 -= t3.numberPoints;
                }
              return i3 === t3.numberPoints - 1 && (i3 -= 1), i3 < 0 ? 0 : t3.Y(i3 + 1) - t3.Y(i3);
            }], p2);
          }
          return l2.elType = "normal", l2.setParents(i2), l2;
        }, t.createBisector = function(t2, e3, r2) {
          var s2, n3, a2, l2;
          if (e3 = o.providePoints(t2, e3, r2, "point"), o.isPoint(e3[0]) && o.isPoint(e3[1]) && o.isPoint(e3[2])) {
            for (l2 = o.copyAttributes(r2, t2.options, "bisector", "point"), l2.snapToGrid = false, s2 = t2.create("point", [function() {
              return i.angleBisector(e3[0], e3[1], e3[2], t2);
            }], l2), s2.dump = false, a2 = 0; a2 < 3; a2++)
              e3[a2].addChild(s2);
            return o.exists(r2.layer) || (r2.layer = t2.options.layer.line), l2 = o.copyAttributes(r2, t2.options, "bisector"), n3 = h.createLine(t2, [e3[1], s2], l2), n3.point = s2, n3.elType = "bisector", n3.setParents(e3), n3.subs = {point: s2}, n3.inherits.push(s2), n3;
          }
          throw new Error("JSXGraph: Can't create angle bisector with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [point,point,point]");
        }, t.createAngularBisectorsOfTwoLines = function(t2, e3, i2) {
          var r2, s2, a2, h2, l2 = t2.select(e3[0]), c2 = t2.select(e3[1]);
          if (l2.elementClass !== n.OBJECT_CLASS_LINE || c2.elementClass !== n.OBJECT_CLASS_LINE)
            throw new Error("JSXGraph: Can't create angle bisectors of two lines with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [line,line]");
          return o.exists(i2.layer) || (i2.layer = t2.options.layer.line), a2 = o.copyAttributes(i2, t2.options, "bisectorlines", "line1"), r2 = t2.create("line", [function() {
            var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e4 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
            return l2.stdform[0] / t3 - c2.stdform[0] / e4;
          }, function() {
            var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e4 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
            return l2.stdform[1] / t3 - c2.stdform[1] / e4;
          }, function() {
            var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e4 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
            return l2.stdform[2] / t3 - c2.stdform[2] / e4;
          }], a2), o.exists(i2.layer) || (i2.layer = t2.options.layer.line), a2 = o.copyAttributes(i2, t2.options, "bisectorlines", "line2"), s2 = t2.create("line", [function() {
            var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e4 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
            return l2.stdform[0] / t3 + c2.stdform[0] / e4;
          }, function() {
            var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e4 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
            return l2.stdform[1] / t3 + c2.stdform[1] / e4;
          }, function() {
            var t3 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]), e4 = Math.sqrt(c2.stdform[1] * c2.stdform[1] + c2.stdform[2] * c2.stdform[2]);
            return l2.stdform[2] / t3 + c2.stdform[2] / e4;
          }], a2), h2 = new d({line1: r2, line2: s2}), r2.dump = false, s2.dump = false, h2.elType = "bisectorlines", h2.setParents([l2.id, c2.id]), h2.subs = {line1: r2, line2: s2}, h2;
        }, t.createCircumcenter = function(t2, e3, r2) {
          var s2, n3, h2, l2, c2;
          if (e3 = o.providePoints(t2, e3, r2, "point"), o.isPoint(e3[0]) && o.isPoint(e3[1]) && o.isPoint(e3[2])) {
            for (h2 = e3[0], l2 = e3[1], c2 = e3[2], s2 = a.createPoint(t2, [function() {
              return i.circumcenter(h2, l2, c2, t2);
            }], r2), n3 = 0; n3 < 3; n3++)
              e3[n3].addChild(s2);
            return s2.elType = "circumcenter", s2.setParents(e3), s2.generatePolynomial = function() {
              var t3 = h2.symbolic.x, e4 = h2.symbolic.y, i2 = l2.symbolic.x, r3 = l2.symbolic.y, o2 = c2.symbolic.x, n4 = c2.symbolic.y, a2 = s2.symbolic.x, d2 = s2.symbolic.y;
              return [["((", a2, ")-(", t3, "))^2+((", d2, ")-(", e4, "))^2-((", a2, ")-(", i2, "))^2-((", d2, ")-(", r3, "))^2"].join(""), ["((", a2, ")-(", t3, "))^2+((", d2, ")-(", e4, "))^2-((", a2, ")-(", o2, "))^2-((", d2, ")-(", n4, "))^2"].join("")];
            }, s2;
          }
          throw new Error("JSXGraph: Can't create circumcircle midpoint with parent types '" + typeof e3[0] + "', '" + typeof e3[1] + "' and '" + typeof e3[2] + "'.\nPossible parent types: [point,point,point]");
        }, t.createIncenter = function(t2, e3, i2) {
          var r2, a2, h2, l2;
          if (e3 = o.providePoints(t2, e3, i2, "point"), !(e3.length >= 3 && o.isPoint(e3[0]) && o.isPoint(e3[1]) && o.isPoint(e3[2])))
            throw new Error("JSXGraph: Can't create incenter with parent types '" + typeof e3[0] + "', '" + typeof e3[1] + "' and '" + typeof e3[2] + "'.\nPossible parent types: [point,point,point]");
          return a2 = e3[0], h2 = e3[1], l2 = e3[2], r2 = t2.create("point", [function() {
            var e4, i3, r3;
            return e4 = Math.sqrt((h2.X() - l2.X()) * (h2.X() - l2.X()) + (h2.Y() - l2.Y()) * (h2.Y() - l2.Y())), i3 = Math.sqrt((a2.X() - l2.X()) * (a2.X() - l2.X()) + (a2.Y() - l2.Y()) * (a2.Y() - l2.Y())), r3 = Math.sqrt((h2.X() - a2.X()) * (h2.X() - a2.X()) + (h2.Y() - a2.Y()) * (h2.Y() - a2.Y())), new s(n.COORDS_BY_USER, [(e4 * a2.X() + i3 * h2.X() + r3 * l2.X()) / (e4 + i3 + r3), (e4 * a2.Y() + i3 * h2.Y() + r3 * l2.Y()) / (e4 + i3 + r3)], t2);
          }], i2), r2.elType = "incenter", r2.setParents(e3), r2;
        }, t.createCircumcircle = function(e3, i2, r2) {
          var s2, n3, a2;
          if ((i2 = o.providePoints(e3, i2, r2, "point")) === false)
            throw new Error("JSXGraph: Can't create circumcircle with parent types '" + typeof i2[0] + "', '" + typeof i2[1] + "' and '" + typeof i2[2] + "'.\nPossible parent types: [point,point,point]");
          try {
            a2 = o.copyAttributes(r2, e3.options, "circumcircle", "center"), s2 = t.createCircumcenter(e3, i2, a2), s2.dump = false, o.exists(r2.layer) || (r2.layer = e3.options.layer.circle), a2 = o.copyAttributes(r2, e3.options, "circumcircle"), n3 = l.createCircle(e3, [s2, i2[0]], a2), n3.elType = "circumcircle", n3.setParents(i2), n3.subs = {center: s2}, n3.inherits.push(n3);
          } catch (t2) {
            throw new Error("JSXGraph: Can't create circumcircle with parent types '" + typeof i2[0] + "', '" + typeof i2[1] + "' and '" + typeof i2[2] + "'.\nPossible parent types: [point,point,point]");
          }
          return n3;
        }, t.createIncircle = function(e3, i2, r2) {
          var s2, n3, a2;
          if ((i2 = o.providePoints(e3, i2, r2, "point")) === false)
            throw new Error("JSXGraph: Can't create circumcircle with parent types '" + typeof i2[0] + "', '" + typeof i2[1] + "' and '" + typeof i2[2] + "'.\nPossible parent types: [point,point,point]");
          try {
            a2 = o.copyAttributes(r2, e3.options, "incircle", "center"), s2 = t.createIncenter(e3, i2, a2), s2.dump = false, o.exists(r2.layer) || (r2.layer = e3.options.layer.circle), a2 = o.copyAttributes(r2, e3.options, "incircle"), n3 = l.createCircle(e3, [s2, function() {
              var t2 = Math.sqrt((i2[1].X() - i2[2].X()) * (i2[1].X() - i2[2].X()) + (i2[1].Y() - i2[2].Y()) * (i2[1].Y() - i2[2].Y())), e4 = Math.sqrt((i2[0].X() - i2[2].X()) * (i2[0].X() - i2[2].X()) + (i2[0].Y() - i2[2].Y()) * (i2[0].Y() - i2[2].Y())), r3 = Math.sqrt((i2[1].X() - i2[0].X()) * (i2[1].X() - i2[0].X()) + (i2[1].Y() - i2[0].Y()) * (i2[1].Y() - i2[0].Y())), s3 = (t2 + e4 + r3) / 2;
              return Math.sqrt((s3 - t2) * (s3 - e4) * (s3 - r3) / s3);
            }], a2), n3.elType = "incircle", n3.setParents(i2), n3.center = s2, n3.subs = {center: n3.center}, n3.inherits.push(s2);
          } catch (t2) {
            throw new Error("JSXGraph: Can't create circumcircle with parent types '" + typeof i2[0] + "', '" + typeof i2[1] + "' and '" + typeof i2[2] + "'.\nPossible parent types: [point,point,point]");
          }
          return n3;
        }, t.createReflection = function(t2, e3, i2) {
          var r2, s2, d2, f, m, g, b, v, y = "\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, line]";
          for (g = 0; g < e3.length; ++g)
            e3[g] = t2.select(e3[g]);
          if (b = o.copyAttributes(i2, t2.options, "reflection"), o.isPoint(e3[0]))
            s2 = o.providePoints(t2, [e3[0]], v)[0];
          else {
            if (e3[0].elementClass !== n.OBJECT_CLASS_CURVE && e3[0].elementClass !== n.OBJECT_CLASS_LINE && e3[0].type !== n.OBJECT_TYPE_POLYGON && e3[0].elementClass !== n.OBJECT_CLASS_CIRCLE)
              throw new Error("JSXGraph: Can't create reflection element with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'." + y);
            s2 = e3[0];
          }
          if (e3[1].elementClass !== n.OBJECT_CLASS_LINE)
            throw new Error("JSXGraph: Can't create reflected element with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'." + y);
          if (r2 = e3[1], m = c.createTransform(t2, [r2], {type: "reflect"}), o.isPoint(s2))
            d2 = a.createPoint(t2, [s2, m], b);
          else if (s2.elementClass === n.OBJECT_CLASS_CURVE)
            d2 = u.createCurve(t2, [s2, m], b);
          else if (s2.elementClass === n.OBJECT_CLASS_LINE)
            d2 = h.createLine(t2, [s2, m], b);
          else if (s2.type === n.OBJECT_TYPE_POLYGON)
            d2 = p.createPolygon(t2, [s2, m], b);
          else {
            if (s2.elementClass !== n.OBJECT_CLASS_CIRCLE)
              throw new Error("JSXGraph: Can't create reflected element with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'." + y);
            b.type.toLowerCase() === "euclidean" ? (v = o.copyAttributes(i2, t2.options, "reflection", "center"), f = a.createPoint(t2, [s2.center, m], v), f.prepareUpdate().update().updateVisibility(o.evaluate(f.visProp.visible)).updateRenderer(), d2 = l.createCircle(t2, [f, function() {
              return s2.Radius();
            }], b)) : d2 = l.createCircle(t2, [s2, m], b);
          }
          return r2.addChild(d2), d2.elType = "reflection", d2.addParents(r2), d2.prepareUpdate().update(), o.isPoint(d2) && (d2.generatePolynomial = function() {
            var t3 = r2.point1.symbolic.x, e4 = r2.point1.symbolic.y, i3 = r2.point2.symbolic.x, o2 = r2.point2.symbolic.y, n3 = s2.symbolic.x, a2 = s2.symbolic.y, h2 = d2.symbolic.x, l2 = d2.symbolic.y;
            return [["((", l2, ")-(", a2, "))*((", e4, ")-(", o2, "))+((", t3, ")-(", i3, "))*((", h2, ")-(", n3, "))"].join(""), ["((", h2, ")-(", t3, "))^2+((", l2, ")-(", e4, "))^2-((", n3, ")-(", t3, "))^2-((", a2, ")-(", e4, "))^2"].join("")];
          }), d2;
        }, t.createMirrorElement = function(t2, e3, i2) {
          var r2, s2, d2, f, m, g, b, v, y = "\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, point]";
          for (s2 = 0; s2 < e3.length; ++s2)
            e3[s2] = t2.select(e3[s2]);
          if (b = o.copyAttributes(i2, t2.options, "mirrorelement"), o.isPoint(e3[0]))
            r2 = o.providePoints(t2, [e3[0]], b)[0];
          else {
            if (e3[0].elementClass !== n.OBJECT_CLASS_CURVE && e3[0].elementClass !== n.OBJECT_CLASS_LINE && e3[0].type !== n.OBJECT_TYPE_POLYGON && e3[0].elementClass !== n.OBJECT_CLASS_CIRCLE)
              throw new Error("JSXGraph: Can't create mirror element with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'." + y);
            r2 = e3[0];
          }
          if (!o.isPoint(e3[1]))
            throw new Error("JSXGraph: Can't create mirror element with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'." + y);
          if (v = o.copyAttributes(i2, t2.options, "mirrorelement", "point"), d2 = o.providePoints(t2, [e3[1]], v)[0], g = c.createTransform(t2, [Math.PI, d2], {type: "rotate"}), o.isPoint(r2))
            f = a.createPoint(t2, [r2, g], b);
          else if (r2.elementClass === n.OBJECT_CLASS_CURVE)
            f = u.createCurve(t2, [r2, g], b);
          else if (r2.elementClass === n.OBJECT_CLASS_LINE)
            f = h.createLine(t2, [r2, g], b);
          else if (r2.type === n.OBJECT_TYPE_POLYGON)
            f = p.createPolygon(t2, [r2, g], b);
          else {
            if (r2.elementClass !== n.OBJECT_CLASS_CIRCLE)
              throw new Error("JSXGraph: Can't create mirror element with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'." + y);
            b.type.toLowerCase() === "euclidean" ? (v = o.copyAttributes(i2, t2.options, "mirrorelement", "center"), m = a.createPoint(t2, [r2.center, g], v), m.prepareUpdate().update().updateVisibility(o.evaluate(m.visProp.visible)).updateRenderer(), f = l.createCircle(t2, [m, function() {
              return r2.Radius();
            }], b)) : f = l.createCircle(t2, [r2, g], b);
          }
          return d2.addChild(f), f.elType = "mirrorelement", f.addParents(d2), f.prepareUpdate().update(), f;
        }, t.createMirrorPoint = function(e3, i2, r2) {
          var s2 = t.createMirrorElement(e3, i2, r2);
          return s2.elType = "mirrorpoint", s2;
        }, t.createIntegral = function(e3, i2, a2) {
          var h2, l2, c2, d2, u2, p2, f, m, g, b, v, y, C, _4, P2 = null;
          if (o.isArray(i2[0]) && i2[1].elementClass === n.OBJECT_CLASS_CURVE)
            h2 = i2[0], l2 = i2[1];
          else {
            if (!o.isArray(i2[1]) || i2[0].elementClass !== n.OBJECT_CLASS_CURVE)
              throw new Error("JSXGraph: Can't create integral with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [[number|function,number|function],curve]");
            h2 = i2[1], l2 = i2[0];
          }
          return c2 = o.copyAttributes(a2, e3.options, "integral"), c2.withLabel = false, _4 = e3.create("curve", [[0], [0]], c2), d2 = h2[0], u2 = h2[1], o.isFunction(d2) ? (p2 = d2, f = function() {
            return l2.Y(p2());
          }, d2 = p2()) : (p2 = d2, f = l2.Y(d2)), o.isFunction(u2) ? (m = u2, g = function() {
            return l2.Y(m());
          }, u2 = m()) : (m = u2, g = l2.Y(u2)), c2 = o.copyAttributes(a2, e3.options, "integral", "curveLeft"), b = e3.create("glider", [p2, f, l2], c2), o.isFunction(p2) && b.hideElement(), c2 = o.copyAttributes(a2, e3.options, "integral", "baseLeft"), v = e3.create("point", [function() {
            return o.evaluate(_4.visProp.axis) === "y" ? 0 : b.X();
          }, function() {
            return o.evaluate(_4.visProp.axis) === "y" ? b.Y() : 0;
          }], c2), c2 = o.copyAttributes(a2, e3.options, "integral", "curveRight"), y = e3.create("glider", [m, g, l2], c2), o.isFunction(m) && y.hideElement(), c2 = o.copyAttributes(a2, e3.options, "integral", "baseRight"), C = e3.create("point", [function() {
            return o.evaluate(_4.visProp.axis) === "y" ? 0 : y.X();
          }, function() {
            return o.evaluate(_4.visProp.axis) === "y" ? y.Y() : 0;
          }], c2), c2 = o.copyAttributes(a2, e3.options, "integral"), c2.withlabel !== false && c2.axis !== "y" && (c2 = o.copyAttributes(a2, e3.options, "integral", "label"), c2 = o.copyAttributes(c2, e3.options, "label"), P2 = e3.create("text", [function() {
            var t2 = new s(n.COORDS_BY_SCREEN, [o.evaluate(this.visProp.offset[0]) + this.board.origin.scrCoords[1], 0], this.board, false), e4 = this.board.getBoundingBox(), i3 = 0.1 * (e4[2] - e4[0]), r2 = y.X();
            return r2 < e4[0] ? r2 = e4[0] + i3 : r2 > e4[2] && (r2 = e4[2] - i3), r2 + t2.usrCoords[1];
          }, function() {
            var t2 = new s(n.COORDS_BY_SCREEN, [0, o.evaluate(this.visProp.offset[1]) + this.board.origin.scrCoords[2]], this.board, false), e4 = this.board.getBoundingBox(), i3 = 0.1 * (e4[1] - e4[3]), r2 = y.Y();
            return r2 > e4[1] ? r2 = e4[1] - i3 : r2 < e4[3] && (r2 = e4[3] + i3), r2 + t2.usrCoords[2];
          }, function() {
            var t2 = r.NewtonCotes([v.X(), C.X()], l2.Y);
            return "&int; = " + o.toFixed(t2, 4);
          }], c2), P2.dump = false, b.addChild(P2), y.addChild(P2)), b.dump = false, v.dump = false, y.dump = false, C.dump = false, _4.elType = "integral", _4.setParents([l2.id, h2]), _4.subs = {curveLeft: b, baseLeft: v, curveRight: y, baseRight: C}, _4.inherits.push(b, v, y, C), c2.withLabel && (_4.subs.label = P2, _4.inherits.push(P2)), _4.Value = function() {
            return r.I([v.X(), C.X()], l2.Y);
          }, _4.updateDataArray = function() {
            var t2, e4, i3, r2, s2, n3, a3, h3, c3;
            if (o.evaluate(this.visProp.axis) === "y") {
              for (b.Y() < y.Y() ? (n3 = b.X(), h3 = b.Y(), a3 = y.X(), c3 = y.Y()) : (n3 = y.X(), h3 = y.Y(), a3 = b.X(), c3 = b.Y()), r2 = Math.min(n3, a3), s2 = Math.max(n3, a3), t2 = [0, n3], e4 = [h3, h3], i3 = 0; i3 < l2.numberPoints; i3++)
                h3 <= l2.points[i3].usrCoords[2] && r2 <= l2.points[i3].usrCoords[1] && l2.points[i3].usrCoords[2] <= c3 && l2.points[i3].usrCoords[1] <= s2 && (t2.push(l2.points[i3].usrCoords[1]), e4.push(l2.points[i3].usrCoords[2]));
              t2.push(a3), e4.push(c3), t2.push(0), e4.push(c3), t2.push(0), e4.push(h3);
            } else {
              for (v.X() < C.X() ? (r2 = v.X(), s2 = C.X()) : (r2 = C.X(), s2 = v.X()), t2 = [r2, r2], e4 = [0, l2.Y(r2)], i3 = 0; i3 < l2.numberPoints; i3++)
                r2 <= l2.points[i3].usrCoords[1] && l2.points[i3].usrCoords[1] <= s2 && (t2.push(l2.points[i3].usrCoords[1]), e4.push(l2.points[i3].usrCoords[2]));
              t2.push(s2), e4.push(l2.Y(s2)), t2.push(s2), e4.push(0), t2.push(r2), e4.push(0);
            }
            this.dataX = t2, this.dataY = e4;
          }, b.addChild(_4), y.addChild(_4), v.addChild(_4), C.addChild(_4), _4.baseLeft = v, _4.baseRight = C, _4.curveLeft = b, _4.curveRight = y, _4.methodMap = t.deepCopy(_4.methodMap, {curveLeft: "curveLeft", baseLeft: "baseLeft", curveRight: "curveRight", baseRight: "baseRight", Value: "Value"}), _4.label = P2, _4;
        }, t.createGrid = function(t2, e3, i2) {
          var r2, a2;
          return a2 = o.copyAttributes(i2, t2.options, "grid"), r2 = t2.create("curve", [[null], [null]], a2), r2.elType = "grid", r2.type = n.OBJECT_TYPE_GRID, r2.updateDataArray = function() {
            var e4, i3, a3, h2, l2, c2 = o.evaluate(this.visProp.gridx), d2 = o.evaluate(this.visProp.gridy);
            for (h2 = o.isArray(this.visProp.topleft) ? new s(o.evaluate(this.visProp.tltype) || n.COORDS_BY_USER, this.visProp.topleft, t2) : new s(n.COORDS_BY_SCREEN, [0, 0], t2), l2 = o.isArray(this.visProp.bottomright) ? new s(o.evaluate(this.visProp.brtype) || n.COORDS_BY_USER, this.visProp.bottomright, t2) : new s(n.COORDS_BY_SCREEN, [t2.canvasWidth, t2.canvasHeight], t2), t2.options.grid.hasGrid = true, r2.dataX = [], r2.dataY = [], e4 = Math.floor(h2.usrCoords[2] / d2) * d2, i3 = Math.ceil(l2.usrCoords[2] / d2) * d2, h2.usrCoords[2] < l2.usrCoords[2] && (e4 = Math.ceil(l2.usrCoords[2] / d2) * d2, i3 = Math.floor(h2.usrCoords[2] / d2) * d2), a3 = e4; a3 > i3 - d2; a3 -= d2)
              r2.dataX.push(h2.usrCoords[1], l2.usrCoords[1], NaN), r2.dataY.push(a3, a3, NaN);
            for (e4 = Math.ceil(h2.usrCoords[1] / c2) * c2, i3 = Math.floor(l2.usrCoords[1] / c2) * c2, h2.usrCoords[1] > l2.usrCoords[1] && (e4 = Math.floor(l2.usrCoords[1] / c2) * c2, i3 = Math.ceil(h2.usrCoords[1] / c2) * c2), a3 = e4; a3 < i3 + c2; a3 += c2)
              r2.dataX.push(a3, a3, NaN), r2.dataY.push(h2.usrCoords[2], l2.usrCoords[2], NaN);
          }, r2.hasPoint = function() {
            return false;
          }, t2.grids.push(r2), r2;
        }, t.createInequality = function(t2, r2, s2) {
          var a2, h2, l2;
          if (l2 = o.copyAttributes(s2, t2.options, "inequality"), r2[0].elementClass === n.OBJECT_CLASS_LINE)
            h2 = t2.create("curve", [[], []], l2), h2.hasPoint = function() {
              return false;
            }, h2.updateDataArray = function() {
              var s3, o2, a3, h3 = t2.getBoundingBox(), c2 = l2.inverse ? -1 : 1, d2 = 1.5 * Math.max(h3[2] - h3[0], h3[1] - h3[3]), u2 = {coords: {usrCoords: [1, (h3[0] + h3[2]) / 2, l2.inverse ? h3[1] : h3[3]]}}, p2 = r2[0].stdform.slice(1), f = p2;
              a3 = 1.5 * Math.max(i.perpendicular(r2[0], u2, t2)[0].distance(n.COORDS_BY_USER, u2.coords), d2), a3 *= c2, u2 = {coords: {usrCoords: [1, (h3[0] + h3[2]) / 2, (h3[1] + h3[3]) / 2]}}, u2 = Math.abs(e2.innerProduct(u2.coords.usrCoords, r2[0].stdform, 3)) >= e2.eps ? i.perpendicular(r2[0], u2, t2)[0].usrCoords : u2.coords.usrCoords, s3 = [1, u2[1] + p2[1] * d2, u2[2] - p2[0] * d2], o2 = [1, u2[1] - f[1] * d2, u2[2] + f[0] * d2], this.dataX = [s3[1], s3[1] + p2[0] * a3, o2[1] + f[0] * a3, o2[1], s3[1]], this.dataY = [s3[2], s3[2] + p2[1] * a3, o2[2] + f[1] * a3, o2[2], s3[2]];
            };
          else if (r2[0].elementClass === n.OBJECT_CLASS_CURVE && r2[0].visProp.curvetype === "functiongraph")
            h2 = t2.create("curve", [[], []], l2), h2.updateDataArray = function() {
              var t3, e3, i2, s3, n3, a3, h3, l3, c2, d2 = this.board.getBoundingBox(), u2 = [], p2 = r2[0].minX(), f = r2[0].maxX(), m = 0.3 * (d2[1] - d2[3]);
              if (t3 = o.evaluate(this.visProp.inverse) ? 1 : 3, this.dataX = [], this.dataY = [], (s3 = r2[0].points.length) != 0)
                for (d2[1] += m, d2[3] -= m, i2 = -1; i2 < s3 - 1; ) {
                  for (n3 = i2 + 1, e3 = s3; n3 < s3; n3++)
                    if (r2[0].points[n3].isReal()) {
                      e3 = n3;
                      break;
                    }
                  if (e3 >= s3)
                    break;
                  for (n3 = e3, i2 = s3 - 1; n3 < s3 - 1; n3++)
                    if (!r2[0].points[n3 + 1].isReal()) {
                      i2 = n3;
                      break;
                    }
                  for (l3 = r2[0].points[e3].usrCoords[1], c2 = r2[0].points[i2].usrCoords[1], a3 = d2[0] < p2 ? p2 : d2[0], h3 = d2[2] > f ? f : d2[2], a3 = e3 === 0 ? a3 : Math.max(a3, l3), h3 = i2 === s3 - 1 ? h3 : Math.min(h3, c2), a3 = e3 === 0 ? p2 : l3, h3 = i2 === s3 - 1 ? f : c2, u2 = [], u2.push([1, a3, d2[t3]]), u2.push([1, a3, r2[0].points[e3].usrCoords[2]]), n3 = e3; n3 <= i2; n3++)
                    u2.push(r2[0].points[n3].usrCoords);
                  for (u2.push([1, h3, r2[0].points[i2].usrCoords[2]]), u2.push([1, h3, d2[t3]]), u2.push(u2[0]), n3 = 0; n3 < u2.length; n3++)
                    this.dataX.push(u2[n3][1]), this.dataY.push(u2[n3][2]);
                  i2 < s3 - 1 && (this.dataX.push(NaN), this.dataY.push(NaN));
                }
            }, h2.hasPoint = function() {
              return false;
            };
          else if (a2 = o.createFunction(r2[0]), !o.exists(a2))
            throw new Error("JSXGraph: Can't create area with the given parents.\nPossible parent types: [line], [function]");
          return h2.addParents(r2[0]), h2;
        }, t.registerElement("arrowparallel", t.createArrowParallel), t.registerElement("bisector", t.createBisector), t.registerElement("bisectorlines", t.createAngularBisectorsOfTwoLines), t.registerElement("msector", t.createMsector), t.registerElement("circumcircle", t.createCircumcircle), t.registerElement("circumcirclemidpoint", t.createCircumcenter), t.registerElement("circumcenter", t.createCircumcenter), t.registerElement("incenter", t.createIncenter), t.registerElement("incircle", t.createIncircle), t.registerElement("integral", t.createIntegral), t.registerElement("midpoint", t.createMidpoint), t.registerElement("mirrorelement", t.createMirrorElement), t.registerElement("mirrorpoint", t.createMirrorPoint), t.registerElement("normal", t.createNormal), t.registerElement("orthogonalprojection", t.createOrthogonalProjection), t.registerElement("parallel", t.createParallel), t.registerElement("parallelpoint", t.createParallelPoint), t.registerElement("perpendicular", t.createPerpendicular), t.registerElement("perpendicularpoint", t.createPerpendicularPoint), t.registerElement("perpendicularsegment", t.createPerpendicularSegment), t.registerElement("reflection", t.createReflection), t.registerElement("grid", t.createGrid), t.registerElement("inequality", t.createInequality), {createArrowParallel: t.createArrowParallel, createBisector: t.createBisector, createAngularBisectorOfTwoLines: t.createAngularBisectorsOfTwoLines, createCircumcircle: t.createCircumcircle, createCircumcenter: t.createCircumcenter, createIncenter: t.createIncenter, createIncircle: t.createIncircle, createIntegral: t.createIntegral, createMidpoint: t.createMidpoint, createMirrorElement: t.createMirrorElement, createMirrorPoint: t.createMirrorPoint, createNormal: t.createNormal, createOrthogonalProjection: t.createOrthogonalProjection, createParallel: t.createParallel, createParallelPoint: t.createParallelPoint, createPerpendicular: t.createPerpendicular, createPerpendicularPoint: t.createPerpendicularPoint, createPerpendicularSegmen: t.createPerpendicularSegment, createReflection: t.createReflection, createGrid: t.createGrid, createInequality: t.createInequality};
      }), define("base/board", ["jxg", "base/constants", "base/coords", "options", "math/numerics", "math/math", "math/geometry", "math/complex", "math/statistics", "parser/jessiecode", "parser/geonext", "utils/color", "utils/type", "utils/event", "utils/env", "base/transformation", "base/point", "base/line", "base/text", "element/composition", "base/composition"], function(t, e2, i, r, s, o, n, a, h, l, c, d, u, p, f, m, g, b, v, y, C) {
        "use strict";
        return t.Board = function(i2, s2, o2, n3, a2, h2, c2, d2, m2, g2, b2) {
          if (this.BOARD_MODE_NONE = 0, this.BOARD_MODE_DRAG = 1, this.BOARD_MODE_MOVE_ORIGIN = 2, this.BOARD_QUALITY_LOW = 1, this.BOARD_QUALITY_HIGH = 2, this.BOARD_MODE_ZOOM = 17, u.exists(b2.document) && b2.document !== false ? this.document = b2.document : document !== void 0 && u.isObject(document) && (this.document = document), this.container = i2, this.containerObj = f.isBrowser ? this.document.getElementById(this.container) : null, f.isBrowser && s2.type !== "no" && this.containerObj === null)
            throw new Error("\nJSXGraph: HTML container element '" + i2 + "' not found.");
          this.renderer = s2, this.grids = [], this.options = u.deepCopy(r), this.attr = b2, this.dimension = 2, this.jc = new l(), this.jc.use(this), this.origin = {}, this.origin.usrCoords = [1, 0, 0], this.origin.scrCoords = [1, n3[0], n3[1]], this.zoomX = a2, this.zoomY = h2, this.unitX = c2 * this.zoomX, this.unitY = d2 * this.zoomY, this.keepaspectratio = false, this.canvasWidth = m2, this.canvasHeight = g2, u.exists(o2) && o2 !== "" && f.isBrowser && !u.exists(this.document.getElementById(o2)) ? this.id = o2 : this.id = this.generateId(), p.eventify(this), this.hooks = [], this.dependentBoards = [], this.inUpdate = false, this.objects = {}, this.objectsList = [], this.groups = {}, this.animationObjects = {}, this.highlightedObjects = {}, this.numObjects = 0, this.elementsByName = {}, this.mode = this.BOARD_MODE_NONE, this.updateQuality = this.BOARD_QUALITY_HIGH, this.isSuspendedRedraw = false, this.calculateSnapSizes(), this.drag_dx = 0, this.drag_dy = 0, this.drag_position = [0, 0], this.mouse = {}, this.touches = [], this.xmlString = "", this.cPos = [], this.touchMoveLast = 0, this.positionAccessLast = 0, this.downObjects = [], this.attr.showcopyright && this.renderer.displayCopyright(e2.licenseText, parseInt(this.options.text.fontSize, 10)), this.needsFullUpdate = false, this.reducedUpdate = false, this.currentCBDef = "none", this.geonextCompatibilityMode = false, this.options.text.useASCIIMathML && translateASCIIMath ? init() : this.options.text.useASCIIMathML = false, this.hasMouseHandlers = false, this.hasTouchHandlers = false, this.hasPointerHandlers = false, this.hasMouseUp = false, this.hasTouchEnd = false, this.hasPointerUp = false, this._drag_offset = [0, 0], this._inputDevice = "mouse", this._board_touches = [], this.selectingMode = false, this.isSelecting = false, this.selectingBox = [[0, 0], [0, 0]], this.mathLib = Math, this.mathLibJXG = t.Math, this.attr.registerevents && this.addEventHandlers(), this.methodMap = {update: "update", fullUpdate: "fullUpdate", on: "on", off: "off", trigger: "trigger", setView: "setBoundingBox", setBoundingBox: "setBoundingBox", migratePoint: "migratePoint", colorblind: "emulateColorblindness", suspendUpdate: "suspendUpdate", unsuspendUpdate: "unsuspendUpdate", clearTraces: "clearTraces", left: "clickLeftArrow", right: "clickRightArrow", up: "clickUpArrow", down: "clickDownArrow", zoomIn: "zoomIn", zoomOut: "zoomOut", zoom100: "zoom100", zoomElements: "zoomElements", remove: "removeObject", removeObject: "removeObject"};
        }, t.extend(t.Board.prototype, {generateName: function(t2) {
          var i2, r2, s2 = this.attr.maxnamelength, o2 = "", n3 = "", a2 = [], h2 = "";
          if (t2.type === e2.OBJECT_TYPE_TICKS)
            return "";
          for (i2 = u.isPoint(t2) ? ["", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"] : t2.type === e2.OBJECT_TYPE_ANGLE ? ["", "&alpha;", "&beta;", "&gamma;", "&delta;", "&epsilon;", "&zeta;", "&eta;", "&theta;", "&iota;", "&kappa;", "&lambda;", "&mu;", "&nu;", "&xi;", "&omicron;", "&pi;", "&rho;", "&sigma;", "&tau;", "&upsilon;", "&phi;", "&chi;", "&psi;", "&omega;"] : ["", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], u.isPoint(t2) || t2.elementClass === e2.OBJECT_CLASS_LINE || t2.type === e2.OBJECT_TYPE_ANGLE || (o2 = t2.type === e2.OBJECT_TYPE_POLYGON ? "P_{" : t2.elementClass === e2.OBJECT_CLASS_CIRCLE ? "k_{" : t2.elementClass === e2.OBJECT_CLASS_TEXT ? "t_{" : "s_{", n3 = "}"), r2 = 0; r2 < s2; r2++)
            a2[r2] = 0;
          for (; a2[s2 - 1] < i2.length; ) {
            for (a2[0] = 1; a2[0] < i2.length; a2[0]++) {
              for (h2 = o2, r2 = s2; r2 > 0; r2--)
                h2 += i2[a2[r2 - 1]];
              if (!u.exists(this.elementsByName[h2 + n3]))
                return h2 + n3;
            }
            for (a2[0] = i2.length, r2 = 1; r2 < s2; r2++)
              a2[r2 - 1] === i2.length && (a2[r2 - 1] = 1, a2[r2] += 1);
          }
          return "";
        }, generateId: function() {
          for (var e3 = 1; u.exists(t.boards["jxgBoard" + e3]); )
            e3 = Math.round(65535 * Math.random());
          return "jxgBoard" + e3;
        }, setId: function(t2, e3) {
          var i2, r2 = this.numObjects, s2 = t2.id;
          if (this.numObjects += 1, s2 === "" || !u.exists(s2))
            for (s2 = this.id + e3 + r2; u.exists(this.objects[s2]); )
              i2 = Math.round(65535 * Math.random()), s2 = this.id + e3 + r2 + "-" + i2;
          return t2.id = s2, this.objects[s2] = t2, t2._pos = this.objectsList.length, this.objectsList[this.objectsList.length] = t2, s2;
        }, finalizeAdding: function(t2) {
          u.evaluate(t2.visProp.visible) === false && this.renderer.display(t2, false);
        }, finalizeLabel: function(t2) {
          t2.hasLabel && !u.evaluate(t2.label.visProp.islabel) && u.evaluate(t2.label.visProp.visible) === false && this.renderer.display(t2.label, false);
        }, checkFrameRate: function(t2) {
          var e3 = new Date().getTime();
          return !((e3 - this.touchMoveLast) * this.attr.maxframerate < 1e3) && (this.touchMoveLast = e3, true);
        }, getCoordsTopLeftCorner: function() {
          var t2, e3, i2, r2, s2, o2 = this.document.documentElement || this.document.body.parentNode, n3 = this.document.body, a2 = this.containerObj;
          if (this.cPos.length > 0 && (this.mode === this.BOARD_MODE_DRAG || this.mode === this.BOARD_MODE_MOVE_ORIGIN || new Date().getTime() - this.positionAccessLast < 1e3))
            return this.cPos;
          if (this.positionAccessLast = new Date().getTime(), a2.getBoundingClientRect) {
            for (i2 = a2.getBoundingClientRect(), r2 = 1, s2 = a2; s2 && u.exists(s2.parentNode); )
              u.exists(s2.style) && u.exists(s2.style.zoom) && s2.style.zoom !== "" && (r2 *= parseFloat(s2.style.zoom)), s2 = s2.parentNode;
            return t2 = [i2.left * r2, i2.top * r2], t2[0] += f.getProp(a2, "border-left-width"), t2[1] += f.getProp(a2, "border-top-width"), this.renderer.type !== "vml" && (t2[0] += f.getProp(a2, "padding-left"), t2[1] += f.getProp(a2, "padding-top")), this.cPos = t2.slice(), this.cPos;
          }
          return t2 = f.getOffset(a2), e3 = this.document.documentElement.ownerDocument, !this.containerObj.currentStyle && e3.defaultView && (t2[0] += f.getProp(o2, "margin-left"), t2[1] += f.getProp(o2, "margin-top"), t2[0] += f.getProp(o2, "border-left-width"), t2[1] += f.getProp(o2, "border-top-width"), t2[0] += f.getProp(o2, "padding-left"), t2[1] += f.getProp(o2, "padding-top")), n3 && (t2[0] += f.getProp(n3, "left"), t2[1] += f.getProp(n3, "top")), typeof google == "object" && google.translate && (t2[0] += 10, t2[1] += 25), t2[0] += f.getProp(a2, "border-left-width"), t2[1] += f.getProp(a2, "border-top-width"), this.renderer.type !== "vml" && (t2[0] += f.getProp(a2, "padding-left"), t2[1] += f.getProp(a2, "padding-top")), t2[0] += this.attr.offsetx, t2[1] += this.attr.offsety, this.cPos = t2.slice(), this.cPos;
        }, getMousePosition: function(t2, e3) {
          var i2, r2, s2 = this.getCoordsTopLeftCorner();
          return i2 = f.getPosition(t2, e3, this.document), u.exists(this.cssTransMat) || this.updateCSSTransforms(), r2 = [1, i2[0] - s2[0], i2[1] - s2[1]], r2 = o.matVecMult(this.cssTransMat, r2), r2[1] /= r2[0], r2[2] /= r2[0], [r2[1], r2[2]];
        }, initMoveOrigin: function(t2, e3) {
          this.drag_dx = t2 - this.origin.scrCoords[1], this.drag_dy = e3 - this.origin.scrCoords[2], this.mode = this.BOARD_MODE_MOVE_ORIGIN, this.updateQuality = this.BOARD_QUALITY_LOW;
        }, initMoveObject: function(t2, i2, r2, s2) {
          var o2, n3, a2, l2 = [], c2 = [], d2 = this.objectsList.length, p2 = {visProp: {layer: -1e4}};
          for (n3 = 0; n3 < d2; n3++)
            o2 = this.objectsList[n3], a2 = o2.hasPoint && o2.hasPoint(t2, i2), o2.visPropCalc.visible && a2 && (o2.triggerEventHandlers([s2 + "down", "down"], [r2]), this.downObjects.push(o2)), a2 && o2.isDraggable && o2.visPropCalc.visible && (this.geonextCompatibilityMode && (u.isPoint(o2) || o2.elementClass === e2.OBJECT_CLASS_TEXT) || !this.geonextCompatibilityMode) && !u.evaluate(o2.visProp.fixed) && (o2.visProp.layer > p2.visProp.layer || o2.visProp.layer === p2.visProp.layer && o2.lastDragTime.getTime() >= p2.lastDragTime.getTime()) && (this.attr.ignorelabels && u.exists(p2.label) && o2 === p2.label || (p2 = o2, l2.push(p2), u.exists(p2.coords) ? c2.push(h.subtract(p2.coords.scrCoords.slice(1), [t2, i2])) : c2.push([0, 0])));
          return this.attr.drag.enabled && l2.length > 0 && (this.mode = this.BOARD_MODE_DRAG), this.attr.takefirst ? (l2.length = 1, this._drag_offset = c2[0]) : (l2 = l2.slice(-1), this._drag_offset = c2[c2.length - 1]), this._drag_offset || (this._drag_offset = [0, 0]), this.renderer.type === "svg" && u.exists(l2[0]) && u.evaluate(l2[0].visProp.dragtotopoflayer) && l2.length === 1 && u.exists(l2[0].rendNode) && l2[0].rendNode.parentNode.appendChild(l2[0].rendNode), this.previousRotation = 0, this.previousScale = 1, l2.length >= 1 && (l2[0].highlight(true), this.triggerEventHandlers(["mousehit", "hit"], [r2, l2[0]])), l2;
        }, moveObject: function(t2, r2, s2, o2, n3) {
          var a2, l2, c2, d2 = new i(e2.COORDS_BY_SCREEN, this.getScrCoordsOfMouse(t2, r2), this);
          s2 && s2.obj && (a2 = s2.obj, a2.coords && (l2 = a2.coords.scrCoords.slice()), this.drag_position = [d2.scrCoords[1], d2.scrCoords[2]], this.drag_position = h.add(this.drag_position, this._drag_offset), u.exists(a2.coords) ? a2.setPositionDirectly(e2.COORDS_BY_SCREEN, this.drag_position) : (this.displayInfobox(false), isNaN(s2.targets[0].Xprev + s2.targets[0].Yprev) || a2.setPositionDirectly(e2.COORDS_BY_SCREEN, [d2.scrCoords[1], d2.scrCoords[2]], [s2.targets[0].Xprev, s2.targets[0].Yprev]), s2.targets[0].Xprev = d2.scrCoords[1], s2.targets[0].Yprev = d2.scrCoords[2]), u.exists(a2.coords) && (a2.prepareUpdate().update(false).updateRenderer(), this.updateInfobox(a2), a2.prepareUpdate().update(true).updateRenderer()), a2.coords && (c2 = a2.coords.scrCoords), a2.coords && l2[1] === c2[1] && l2[2] === c2[2] || (a2.triggerEventHandlers([n3 + "drag", "drag"], [o2]), this.update()), a2.highlight(true), this.triggerEventHandlers(["mousehit", "hit"], [o2, a2]), a2.lastDragTime = new Date());
        }, twoFingerMove: function(t2, r2, s2, o2) {
          var n3, a2, h2;
          u.exists(s2) && u.exists(s2.obj) && (h2 = s2.obj, n3 = new i(e2.COORDS_BY_SCREEN, this.getScrCoordsOfMouse(t2[0], t2[1]), this), a2 = new i(e2.COORDS_BY_SCREEN, this.getScrCoordsOfMouse(r2[0], r2[1]), this), h2.elementClass === e2.OBJECT_CLASS_LINE || h2.type === e2.OBJECT_TYPE_POLYGON ? this.twoFingerTouchObject(n3, a2, s2, h2, o2) : h2.elementClass === e2.OBJECT_CLASS_CIRCLE && this.twoFingerTouchCircle(n3, a2, s2, h2), h2.triggerEventHandlers(["touchdrag", "drag"], [o2]), s2.targets[0].Xprev = n3.scrCoords[1], s2.targets[0].Yprev = n3.scrCoords[2], s2.targets[1].Xprev = a2.scrCoords[1], s2.targets[1].Yprev = a2.scrCoords[2]);
        }, twoFingerTouchObject: function(t2, r2, s2, a2, h2) {
          var l2, c2, d2, p2, f2, m2, g2, b2, v2, y2, C2, _4, P2, E, x, S, O, w, T;
          if (u.exists(s2.targets[0]) && u.exists(s2.targets[1]) && !isNaN(s2.targets[0].Xprev + s2.targets[0].Yprev + s2.targets[1].Xprev + s2.targets[1].Yprev)) {
            if (l2 = t2.usrCoords, c2 = r2.usrCoords, d2 = new i(e2.COORDS_BY_SCREEN, [s2.targets[0].Xprev, s2.targets[0].Yprev], this).usrCoords, p2 = new i(e2.COORDS_BY_SCREEN, [s2.targets[1].Xprev, s2.targets[1].Yprev], this).usrCoords, m2 = [1, 0.5 * (d2[1] + p2[1]), 0.5 * (d2[2] + p2[2])], f2 = [1, 0.5 * (l2[1] + c2[1]), 0.5 * (l2[2] + c2[2])], b2 = o.crossProduct(d2, p2), g2 = o.crossProduct(l2, c2), C2 = o.crossProduct(b2, g2), Math.abs(C2[0]) < o.eps)
              return;
            if (C2[1] /= C2[0], C2[2] /= C2[0], u.exists(h2.rotation) && h2.type !== "pointermove" ? (y2 = h2.rotation - this.previousRotation, this.previousRotation = h2.rotation, y2 *= -0.017453292519943295) : y2 = n.rad(m2.slice(1), C2.slice(1), f2.slice(1)), _4 = this.create("transform", [y2, C2[1], C2[2]], {type: "rotate"}), _4.update(), m2 = o.matVecMult(_4.matrix, m2), m2[1] /= m2[0], m2[2] /= m2[0], P2 = this.create("transform", [f2[1] - m2[1], f2[2] - m2[2]], {type: "translate"}), P2.update(), _4.melt(P2), u.evaluate(a2.visProp.scalable) && (u.exists(h2.scale) ? (v2 = h2.scale / this.previousScale, this.previousScale = h2.scale) : v2 = n.distance(l2, c2) / n.distance(d2, p2), E = this.create("transform", [-f2[1], -f2[2]], {type: "translate"}), x = this.create("transform", [v2, v2], {type: "scale"}), S = this.create("transform", [f2[1], f2[2]], {type: "translate"}), _4.melt(E).melt(x).melt(S)), a2.elementClass === e2.OBJECT_CLASS_LINE)
              O = [], a2.point1.draggable() && O.push(a2.point1), a2.point2.draggable() && O.push(a2.point2), _4.applyOnce(O);
            else if (a2.type === e2.OBJECT_TYPE_POLYGON) {
              for (O = [], T = a2.vertices.length - 1, w = 0; w < T; ++w)
                a2.vertices[w].draggable() && O.push(a2.vertices[w]);
              _4.applyOnce(O);
            }
            this.update(), a2.highlight(true);
          }
        }, twoFingerTouchCircle: function(t2, r2, s2, o2) {
          var a2, h2, l2, c2, d2, p2, f2, m2, g2, b2, v2;
          o2.method !== "pointCircle" && o2.method !== "pointLine" && u.exists(s2.targets[0]) && u.exists(s2.targets[1]) && !isNaN(s2.targets[0].Xprev + s2.targets[0].Yprev + s2.targets[1].Xprev + s2.targets[1].Yprev) && (a2 = t2.usrCoords, h2 = r2.usrCoords, l2 = new i(e2.COORDS_BY_SCREEN, [s2.targets[0].Xprev, s2.targets[0].Yprev], this).usrCoords, c2 = new i(e2.COORDS_BY_SCREEN, [s2.targets[1].Xprev, s2.targets[1].Yprev], this).usrCoords, f2 = this.create("transform", [a2[1] - l2[1], a2[2] - l2[2]], {type: "translate"}), p2 = n.rad(c2.slice(1), a2.slice(1), h2.slice(1)), m2 = this.create("transform", [-a2[1], -a2[2]], {type: "translate"}), g2 = this.create("transform", [p2], {type: "rotate"}), f2.melt(m2).melt(g2), u.evaluate(o2.visProp.scalable) && (d2 = n.distance(a2, h2) / n.distance(l2, c2), b2 = this.create("transform", [d2, d2], {type: "scale"}), f2.melt(b2)), v2 = this.create("transform", [a2[1], a2[2]], {type: "translate"}), f2.melt(v2), o2.center.draggable() && f2.applyOnce([o2.center]), o2.method === "twoPoints" ? o2.point2.draggable() && f2.applyOnce([o2.point2]) : o2.method === "pointRadius" && u.isNumber(o2.updateRadius.origin) && o2.setRadius(o2.radius * d2), this.update(o2.center), o2.highlight(true));
        }, highlightElements: function(t2, e3, i2, r2) {
          var s2, o2, n3, a2 = {}, h2 = this.objectsList.length;
          for (s2 = 0; s2 < h2; s2++)
            o2 = this.objectsList[s2], n3 = o2.id, u.exists(o2.hasPoint) && o2.visPropCalc.visible && o2.hasPoint(t2, e3) && (this.updateInfobox(o2), u.exists(this.highlightedObjects[n3]) || (a2[n3] = o2, o2.highlight(), this.triggerEventHandlers(["mousehit", "hit"], [i2, o2, r2])), o2.mouseover ? o2.triggerEventHandlers(["mousemove", "move"], [i2]) : (o2.triggerEventHandlers(["mouseover", "over"], [i2]), o2.mouseover = true));
          for (s2 = 0; s2 < h2; s2++)
            o2 = this.objectsList[s2], n3 = o2.id, o2.mouseover && (a2[n3] || (o2.triggerEventHandlers(["mouseout", "out"], [i2]), o2.mouseover = false));
        }, saveStartPos: function(i2, r2) {
          var s2, o2, n3 = [];
          if (i2.type === e2.OBJECT_TYPE_TICKS)
            n3.push([1, NaN, NaN]);
          else if (i2.elementClass === e2.OBJECT_CLASS_LINE)
            n3.push(i2.point1.coords.usrCoords), n3.push(i2.point2.coords.usrCoords);
          else if (i2.elementClass === e2.OBJECT_CLASS_CIRCLE)
            n3.push(i2.center.coords.usrCoords), i2.method === "twoPoints" && n3.push(i2.point2.coords.usrCoords);
          else if (i2.type === e2.OBJECT_TYPE_POLYGON)
            for (o2 = i2.vertices.length - 1, s2 = 0; s2 < o2; s2++)
              n3.push(i2.vertices[s2].coords.usrCoords);
          else if (i2.type === e2.OBJECT_TYPE_SECTOR)
            n3.push(i2.point1.coords.usrCoords), n3.push(i2.point2.coords.usrCoords), n3.push(i2.point3.coords.usrCoords);
          else if (u.isPoint(i2) || i2.type === e2.OBJECT_TYPE_GLIDER)
            n3.push(i2.coords.usrCoords);
          else if (i2.elementClass === e2.OBJECT_CLASS_CURVE)
            i2.points.length > 0 && n3.push(i2.points[0].usrCoords);
          else
            try {
              n3.push(i2.coords.usrCoords);
            } catch (e3) {
              t.debug("JSXGraph+ saveStartPos: obj.coords.usrCoords not available: " + e3);
            }
          for (o2 = n3.length, s2 = 0; s2 < o2; s2++)
            r2.Zstart.push(n3[s2][0]), r2.Xstart.push(n3[s2][1]), r2.Ystart.push(n3[s2][2]);
        }, mouseOriginMoveStart: function(t2) {
          var e3, i2;
          return e3 = this._isRequiredKeyPressed(t2, "pan"), e3 && (i2 = this.getMousePosition(t2), this.initMoveOrigin(i2[0], i2[1])), e3;
        }, mouseOriginMove: function(t2) {
          var e3, i2 = this.mode === this.BOARD_MODE_MOVE_ORIGIN;
          return i2 && (e3 = this.getMousePosition(t2), this.moveOrigin(e3[0], e3[1], true)), i2;
        }, touchOriginMoveStart: function(e3) {
          var i2, r2, s2 = e3[t.touchProperty];
          return i2 = this.attr.pan.enabled && !this.attr.pan.needtwofingers && s2.length === 1, i2 && (r2 = this.getMousePosition(e3, 0), this.initMoveOrigin(r2[0], r2[1])), i2;
        }, touchOriginMove: function(t2) {
          var e3, i2 = this.mode === this.BOARD_MODE_MOVE_ORIGIN;
          return i2 && (e3 = this.getMousePosition(t2, 0), this.moveOrigin(e3[0], e3[1], true)), i2;
        }, originMoveEnd: function() {
          this.updateQuality = this.BOARD_QUALITY_HIGH, this.mode = this.BOARD_MODE_NONE;
        }, addEventHandlers: function() {
          f.supportsPointerEvents() ? this.addPointerEventHandlers() : (this.addMouseEventHandlers(), this.addTouchEventHandlers()), this.containerObj !== null && (this.containerObj.oncontextmenu = function(t2) {
            return u.exists(t2) && t2.preventDefault(), false;
          }), this.addFullscreenEventHandlers();
        }, addPointerEventHandlers: function() {
          !this.hasPointerHandlers && f.isBrowser && (window.navigator.msPointerEnabled ? (f.addEvent(this.containerObj, "MSPointerDown", this.pointerDownListener, this), f.addEvent(this.containerObj, "MSPointerMove", this.pointerMoveListener, this)) : (f.addEvent(this.containerObj, "pointerdown", this.pointerDownListener, this), f.addEvent(this.containerObj, "pointermove", this.pointerMoveListener, this)), f.addEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this), f.addEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this), this.containerObj !== null && (this.containerObj.style.touchAction = "none"), this.hasPointerHandlers = true);
        }, addMouseEventHandlers: function() {
          !this.hasMouseHandlers && f.isBrowser && (f.addEvent(this.containerObj, "mousedown", this.mouseDownListener, this), f.addEvent(this.containerObj, "mousemove", this.mouseMoveListener, this), f.addEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this), f.addEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this), this.hasMouseHandlers = true);
        }, addTouchEventHandlers: function(t2) {
          !this.hasTouchHandlers && f.isBrowser && (f.addEvent(this.containerObj, "touchstart", this.touchStartListener, this), f.addEvent(this.containerObj, "touchmove", this.touchMoveListener, this), this.hasTouchHandlers = true);
        }, addFullscreenEventHandlers: function() {
          var t2, e3 = ["fullscreenchange", "mozfullscreenchange", "webkitfullscreenchange", "msfullscreenchange"], i2 = e3.length;
          for (t2 = 0; t2 < i2; t2++)
            f.addEvent(this.document, e3[t2], this.fullscreenListener, this);
          this.hasFullsceenEventHandlers = true;
        }, removeFullscreenEventHandlers: function() {
          var t2, e3 = ["fullscreenchange", "mozfullscreenchange", "webkitfullscreenchange", "msfullscreenchange"], i2 = e3.length;
          if (this.hasFullsceenEventHandlers && f.isBrowser)
            for (t2 = 0; t2 < i2; t2++)
              f.removeEvent(this.document, e3[t2], this.fullscreenListener, this);
        }, removePointerEventHandlers: function() {
          this.hasPointerHandlers && f.isBrowser && (window.navigator.msPointerEnabled ? (f.removeEvent(this.containerObj, "MSPointerDown", this.pointerDownListener, this), f.removeEvent(this.containerObj, "MSPointerMove", this.pointerMoveListener, this)) : (f.removeEvent(this.containerObj, "pointerdown", this.pointerDownListener, this), f.removeEvent(this.containerObj, "pointermove", this.pointerMoveListener, this)), f.removeEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this), f.removeEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this), this.hasPointerUp && (window.navigator.msPointerEnabled ? f.removeEvent(this.document, "MSPointerUp", this.pointerUpListener, this) : f.removeEvent(this.document, "pointerup", this.pointerUpListener, this), this.hasPointerUp = false), this.hasPointerHandlers = false);
        }, removeMouseEventHandlers: function() {
          this.hasMouseHandlers && f.isBrowser && (f.removeEvent(this.containerObj, "mousedown", this.mouseDownListener, this), f.removeEvent(this.containerObj, "mousemove", this.mouseMoveListener, this), this.hasMouseUp && (f.removeEvent(this.document, "mouseup", this.mouseUpListener, this), this.hasMouseUp = false), f.removeEvent(this.containerObj, "mousewheel", this.mouseWheelListener, this), f.removeEvent(this.containerObj, "DOMMouseScroll", this.mouseWheelListener, this), this.hasMouseHandlers = false);
        }, removeTouchEventHandlers: function() {
          this.hasTouchHandlers && f.isBrowser && (f.removeEvent(this.containerObj, "touchstart", this.touchStartListener, this), f.removeEvent(this.containerObj, "touchmove", this.touchMoveListener, this), this.hasTouchEnd && (f.removeEvent(this.document, "touchend", this.touchEndListener, this), this.hasTouchEnd = false), this.hasTouchHandlers = false);
        }, removeEventHandlers: function() {
          this.removeMouseEventHandlers(), this.removeTouchEventHandlers(), this.removePointerEventHandlers(), this.removeFullscreenEventHandlers();
        }, clickLeftArrow: function() {
          return this.moveOrigin(this.origin.scrCoords[1] + 0.1 * this.canvasWidth, this.origin.scrCoords[2]), this;
        }, clickRightArrow: function() {
          return this.moveOrigin(this.origin.scrCoords[1] - 0.1 * this.canvasWidth, this.origin.scrCoords[2]), this;
        }, clickUpArrow: function() {
          return this.moveOrigin(this.origin.scrCoords[1], this.origin.scrCoords[2] - 0.1 * this.canvasHeight), this;
        }, clickDownArrow: function() {
          return this.moveOrigin(this.origin.scrCoords[1], this.origin.scrCoords[2] + 0.1 * this.canvasHeight), this;
        }, gestureChangeListener: function(t2) {
          var r2, s2, o2, a2, h2, l2, c2, d2, p2, f2, m2 = [], g2 = [], b2 = false, v2 = this.attr.zoom.factorx, y2 = this.attr.zoom.factory;
          return this.mode !== this.BOARD_MODE_ZOOM || (t2.preventDefault(), a2 = n.distance([t2.touches[0].clientX, t2.touches[0].clientY], [t2.touches[1].clientX, t2.touches[1].clientY], 2), t2.scale === void 0 && (t2.scale = a2 / this.prevDist), !!u.exists(this.prevCoords) && (m2 = [t2.touches[0].clientX - this.prevCoords[0][0], t2.touches[0].clientY - this.prevCoords[0][1]], g2 = [t2.touches[1].clientX - this.prevCoords[1][0], t2.touches[1].clientY - this.prevCoords[1][1]], !(m2[0] * m2[0] + m2[1] * m2[1] < 100 && g2[0] * g2[0] + g2[1] * g2[1] < 100) && (s2 = n.rad(m2, [0, 0], g2), this.isPreviousGesture !== "pan" && Math.abs(s2) > 0.2 * Math.PI && Math.abs(s2) < 1.8 * Math.PI && (b2 = true), this.isPreviousGesture === "pan" || b2 || (Math.abs(t2.scale) < 0.77 || Math.abs(t2.scale) > 1.3) && (b2 = true), o2 = t2.scale / this.prevScale, this.prevScale = t2.scale, this.prevCoords = [[t2.touches[0].clientX, t2.touches[0].clientY], [t2.touches[1].clientX, t2.touches[1].clientY]], r2 = new i(e2.COORDS_BY_SCREEN, this.getMousePosition(t2, 0), this), this.attr.pan.enabled && this.attr.pan.needtwofingers && !b2 ? (this.isPreviousGesture = "pan", this.moveOrigin(r2.scrCoords[1], r2.scrCoords[2], true)) : this.attr.zoom.enabled && Math.abs(o2 - 1) < 0.5 && ((this.attr.zoom.pinchhorizontal || this.attr.zoom.pinchvertical) && (h2 = Math.abs(t2.touches[0].clientX - t2.touches[1].clientX), l2 = Math.abs(t2.touches[0].clientY - t2.touches[1].clientY), c2 = Math.abs(Math.atan2(l2, h2)), f2 = Math.PI * this.attr.zoom.pinchsensitivity / 90), this.attr.zoom.pinchhorizontal && c2 < f2 ? (this.attr.zoom.factorx = o2, this.attr.zoom.factory = 1, d2 = 0, p2 = 0) : this.attr.zoom.pinchvertical && Math.abs(c2 - 0.5 * Math.PI) < f2 ? (this.attr.zoom.factorx = 1, this.attr.zoom.factory = o2, d2 = 0, p2 = 0) : (this.attr.zoom.factorx = o2, this.attr.zoom.factory = o2, d2 = r2.usrCoords[1], p2 = r2.usrCoords[2]), this.zoomIn(d2, p2), this.attr.zoom.factorx = v2, this.attr.zoom.factory = y2), false)));
        }, gestureStartListener: function(t2) {
          var e3;
          return t2.preventDefault(), this.prevScale = 1, this.prevDist = n.distance([t2.touches[0].clientX, t2.touches[0].clientY], [t2.touches[1].clientX, t2.touches[1].clientY], 2), this.prevCoords = [[t2.touches[0].clientX, t2.touches[0].clientY], [t2.touches[1].clientX, t2.touches[1].clientY]], this.isPreviousGesture = "none", e3 = this.getMousePosition(t2, 0), this.initMoveOrigin(e3[0], e3[1]), this.mode = this.BOARD_MODE_ZOOM, false;
        }, _isRequiredKeyPressed: function(t2, e3) {
          var i2 = this.attr[e3];
          return !!i2.enabled && !(!(i2.needshift && t2.shiftKey || !i2.needshift && !t2.shiftKey) || !(i2.needctrl && t2.ctrlKey || !i2.needctrl && !t2.ctrlKey));
        }, _isPointerEventAlreadyThere: function(t2) {
          var e3;
          for (e3 = 0; e3 < this._board_touches.length; e3++)
            if (this._board_touches[e3].pointerId === t2.pointerId)
              return true;
          return false;
        }, _pointerIsTouchRegistered: function(t2) {
          var e3, i2 = this._board_touches.length;
          for (e3 = 0; e3 < i2; e3++)
            if (this._board_touches[e3].pointerId === t2.pointerId)
              return true;
          return false;
        }, _pointerAddBoardTouches: function(t2) {
          var e3, i2;
          for (e3 = 0, i2 = false; e3 < this._board_touches.length; e3++)
            if (this._board_touches[e3].pointerId === t2.pointerId) {
              this._board_touches[e3].clientX = t2.clientX, this._board_touches[e3].clientY = t2.clientY, i2 = true;
              break;
            }
          return i2 || this._board_touches.push({pointerId: t2.pointerId, clientX: t2.clientX, clientY: t2.clientY}), this;
        }, _pointerRemoveBoardTouches: function(t2) {
          var e3;
          for (e3 = 0; e3 < this._board_touches.length; e3++)
            if (this._board_touches[e3].pointerId === t2.pointerId) {
              this._board_touches.splice(e3, 1);
              break;
            }
          return this;
        }, _getPointerInputDevice: function(t2) {
          if (f.isBrowser) {
            if (t2.pointerType === "touch" || window.navigator.msMaxTouchPoints && window.navigator.msMaxTouchPoints > 1)
              return "touch";
            if (t2.pointerType === "mouse")
              return "mouse";
            if (t2.pointerType === "pen")
              return "pen";
          }
          return "mouse";
        }, pointerDownListener: function(t2, e3) {
          var i2, r2, s2, o2, n3, a2, h2, l2, c2 = "mouse";
          if (!e3 && this._isPointerEventAlreadyThere(t2))
            return false;
          if (this.hasPointerUp || (window.navigator.msPointerEnabled ? f.addEvent(this.document, "MSPointerUp", this.pointerUpListener, this) : f.addEvent(this.document, "pointerup", this.pointerUpListener, this), this.hasPointerUp = true), this.hasMouseHandlers && this.removeMouseEventHandlers(), this.hasTouchHandlers && this.removeTouchEventHandlers(), this.document.selection && u.isFunction(this.document.selection.empty))
            this.document.selection.empty();
          else if (window.getSelection && (a2 = window.getSelection(), a2.removeAllRanges))
            try {
              a2.removeAllRanges();
            } catch (t3) {
            }
          if (this._inputDevice = this._getPointerInputDevice(t2), c2 = this._inputDevice, this.options.precision.hasPoint = this.options.precision[c2], o2 = this.getMousePosition(t2), this._testForSelection(t2), this.selectingMode)
            return this._startSelecting(o2), void this.triggerEventHandlers(["touchstartselecting", "pointerstartselecting", "startselecting"], [t2]);
          if (this.attr.drag.enabled && e3 ? (n3 = [e3], this.mode = this.BOARD_MODE_DRAG) : n3 = this.initMoveObject(o2[0], o2[1], t2, c2), n3.length > 0) {
            for (l2 = n3[n3.length - 1], h2 = false, i2 = 0; i2 < this.touches.length; i2++)
              if (this.touches[i2].obj === l2) {
                r2 = i2, s2 = this.touches[i2].targets.push({num: t2.pointerId, X: o2[0], Y: o2[1], Xprev: NaN, Yprev: NaN, Xstart: [], Ystart: [], Zstart: []}) - 1, h2 = true;
                break;
              }
            h2 || (s2 = 0, r2 = this.touches.push({obj: l2, targets: [{num: t2.pointerId, X: o2[0], Y: o2[1], Xprev: NaN, Yprev: NaN, Xstart: [], Ystart: [], Zstart: []}]}) - 1), this.dehighlightAll(), l2.highlight(true), this.saveStartPos(l2, this.touches[r2].targets[s2]), t2 && t2.preventDefault ? t2.preventDefault() : window.event && (window.event.returnValue = false);
          }
          return this.touches.length > 0 && (t2.preventDefault(), t2.stopPropagation()), f.isBrowser && this._getPointerInputDevice(t2) !== "touch" ? this.mode === this.BOARD_MODE_NONE && this.mouseOriginMoveStart(t2) : (this._pointerAddBoardTouches(t2), t2.touches = this._board_touches, this.mode === this.BOARD_MODE_NONE && this.touchOriginMoveStart(t2) || this.mode !== this.BOARD_MODE_NONE && this.mode !== this.BOARD_MODE_MOVE_ORIGIN || t2.touches.length != 2 || (this.mode === this.BOARD_MODE_MOVE_ORIGIN && this.originMoveEnd(), this.gestureStartListener(t2))), this.triggerEventHandlers(["touchstart", "down", "pointerdown", "MSPointerDown"], [t2]), false;
        }, pointerOutListener: function(t2) {
          return (t2.target === this.containerObj || this.renderer.type === "svg" && t2.target === this.renderer.foreignObjLayer) && this.pointerUpListener(t2), this.mode === this.BOARD_MODE_NONE;
        }, pointerMoveListener: function(t2) {
          var e3, i2, r2, s2 = "mouse";
          if (this._getPointerInputDevice(t2) === "touch" && !this._pointerIsTouchRegistered(t2))
            return this.BOARD_MODE_NONE;
          if (!this.checkFrameRate(t2))
            return false;
          if (this.mode !== this.BOARD_MODE_DRAG && (this.dehighlightAll(), this.displayInfobox(false)), this.mode !== this.BOARD_MODE_NONE && (t2.preventDefault(), t2.stopPropagation()), this.updateQuality = this.BOARD_QUALITY_LOW, this._inputDevice = this._getPointerInputDevice(t2), s2 = this._inputDevice, this.options.precision.hasPoint = this.options.precision[s2], this.selectingMode)
            r2 = this.getMousePosition(t2), this._moveSelecting(r2), this.triggerEventHandlers(["touchmoveselecting", "moveselecting", "pointermoveselecting"], [t2, this.mode]);
          else if (!this.mouseOriginMove(t2))
            if (this.mode === this.BOARD_MODE_DRAG) {
              for (e3 = 0; e3 < this.touches.length; e3++)
                for (i2 = 0; i2 < this.touches[e3].targets.length; i2++)
                  if (this.touches[e3].targets[i2].num === t2.pointerId) {
                    this.touches[e3].targets.length === 1 ? (this.touches[e3].targets[i2].X = t2.pageX, this.touches[e3].targets[i2].Y = t2.pageY, r2 = this.getMousePosition(t2), this.moveObject(r2[0], r2[1], this.touches[e3], t2, s2)) : this.touches[e3].targets.length === 2 && (this.touches[e3].targets[i2].X = t2.pageX, this.touches[e3].targets[i2].Y = t2.pageY, this.twoFingerMove(this.getMousePosition({clientX: this.touches[e3].targets[0].X, clientY: this.touches[e3].targets[0].Y}), this.getMousePosition({clientX: this.touches[e3].targets[1].X, clientY: this.touches[e3].targets[1].Y}), this.touches[e3], t2));
                    break;
                  }
            } else
              this._getPointerInputDevice(t2) === "touch" && (this._pointerAddBoardTouches(t2), this._board_touches.length === 2 && (t2.touches = this._board_touches, this.gestureChangeListener(t2))), r2 = this.getMousePosition(t2), this.highlightElements(r2[0], r2[1], t2, -1);
          return this.triggerEventHandlers(["touchmove", "move", "pointermove", "MSPointerMove"], [t2, this.mode]), this.updateQuality = this.BOARD_QUALITY_HIGH, this.mode === this.BOARD_MODE_NONE;
        }, pointerUpListener: function(t2) {
          var e3, i2, r2;
          if (this.triggerEventHandlers(["touchend", "up", "pointerup", "MSPointerUp"], [t2]), this.displayInfobox(false), t2) {
            for (e3 = 0; e3 < this.touches.length; e3++)
              for (i2 = 0; i2 < this.touches[e3].targets.length; i2++)
                if (this.touches[e3].targets[i2].num === t2.pointerId) {
                  this.touches[e3].targets.splice(i2, 1), this.touches[e3].targets.length === 0 && this.touches.splice(e3, 1);
                  break;
                }
          }
          if (this.selectingMode)
            this._stopSelecting(t2), this.triggerEventHandlers(["touchstopselecting", "pointerstopselecting", "stopselecting"], [t2]);
          else
            for (e3 = this.downObjects.length - 1; e3 > -1; e3--) {
              for (r2 = false, i2 = 0; i2 < this.touches.length; i2++)
                this.touches[i2].obj.id === this.downObjects[e3].id && (r2 = true);
              r2 || (this.downObjects[e3].triggerEventHandlers(["touchend", "up", "pointerup", "MSPointerUp"], [t2]), this.downObjects[e3].snapToGrid(), this.downObjects[e3].snapToPoints(), this.downObjects.splice(e3, 1));
            }
          return this._pointerRemoveBoardTouches(t2), this._board_touches.length === 0 && (this.hasPointerUp && (window.navigator.msPointerEnabled ? f.removeEvent(this.document, "MSPointerUp", this.pointerUpListener, this) : f.removeEvent(this.document, "pointerup", this.pointerUpListener, this), this.hasPointerUp = false), this.dehighlightAll(), this.updateQuality = this.BOARD_QUALITY_HIGH, this.mode = this.BOARD_MODE_NONE, this.originMoveEnd(), this.update()), true;
        }, touchStartListener: function(i2) {
          var s2, o2, n3, a2, h2, l2, c2, d2, p2, m2 = this.options.precision.touch, g2 = i2[t.touchProperty];
          for (this.hasTouchEnd || (f.addEvent(this.document, "touchend", this.touchEndListener, this), this.hasTouchEnd = true), this.document.selection && u.isFunction(this.document.selection.empty) ? this.document.selection.empty() : window.getSelection && window.getSelection().removeAllRanges(), this._inputDevice = "touch", this.options.precision.hasPoint = this.options.precision.touch, s2 = 0; s2 < g2.length; s2++)
            g2[s2].jxg_isused = false;
          for (s2 = 0; s2 < this.touches.length; s2++)
            for (a2 = 0; a2 < this.touches[s2].targets.length; a2++) {
              this.touches[s2].targets[a2].num = -1, m2 = this.options.precision.touch;
              do {
                for (h2 = 0; h2 < g2.length; h2++)
                  if (Math.abs(Math.pow(g2[h2].screenX - this.touches[s2].targets[a2].X, 2) + Math.pow(g2[h2].screenY - this.touches[s2].targets[a2].Y, 2)) < m2 * m2) {
                    this.touches[s2].targets[a2].num = h2, this.touches[s2].targets[a2].X = g2[h2].screenX, this.touches[s2].targets[a2].Y = g2[h2].screenY, g2[h2].jxg_isused = true;
                    break;
                  }
                m2 *= 2;
              } while (this.touches[s2].targets[a2].num === -1 && m2 < this.options.precision.touchMax);
              this.touches[s2].targets[a2].num === -1 && (t.debug("i couldn't find a targettouches for target no " + a2 + " on " + this.touches[s2].obj.name + " (" + this.touches[s2].obj.id + "). Removed the target."), t.debug("eps = " + m2 + ", touchMax = " + r.precision.touchMax), this.touches[s2].targets.splice(s2, 1));
            }
          for (s2 = 0; s2 < g2.length; s2++)
            if (!g2[s2].jxg_isused) {
              if (o2 = this.getMousePosition(i2, s2), this.selectingMode)
                return this._startSelecting(o2), this.triggerEventHandlers(["touchstartselecting", "startselecting"], [i2]), i2.preventDefault(), i2.stopPropagation(), this.options.precision.hasPoint = this.options.precision.mouse, this.touches.length > 0;
              if (n3 = this.initMoveObject(o2[0], o2[1], i2, "touch"), n3.length !== 0) {
                if (l2 = n3[n3.length - 1], u.isPoint(l2) || l2.elementClass === e2.OBJECT_CLASS_TEXT || l2.type === e2.OBJECT_TYPE_TICKS || l2.type === e2.OBJECT_TYPE_IMAGE)
                  d2 = [{num: s2, X: g2[s2].screenX, Y: g2[s2].screenY, Xprev: NaN, Yprev: NaN, Xstart: [], Ystart: [], Zstart: []}], this.saveStartPos(l2, d2[0]), this.touches.push({obj: l2, targets: d2}), l2.highlight(true);
                else if (l2.elementClass === e2.OBJECT_CLASS_LINE || l2.elementClass === e2.OBJECT_CLASS_CIRCLE || l2.elementClass === e2.OBJECT_CLASS_CURVE || l2.type === e2.OBJECT_TYPE_POLYGON) {
                  for (c2 = false, a2 = 0; a2 < this.touches.length; a2++)
                    l2.id === this.touches[a2].obj.id && (c2 = true, this.touches[a2].targets.length === 1 && (p2 = {num: s2, X: g2[s2].screenX, Y: g2[s2].screenY, Xprev: NaN, Yprev: NaN, Xstart: [], Ystart: [], Zstart: []}, this.saveStartPos(l2, p2), this.touches[a2].targets.push(p2)), g2[s2].jxg_isused = true);
                  c2 || (d2 = [{num: s2, X: g2[s2].screenX, Y: g2[s2].screenY, Xprev: NaN, Yprev: NaN, Xstart: [], Ystart: [], Zstart: []}], this.saveStartPos(l2, d2[0]), this.touches.push({obj: l2, targets: d2}), l2.highlight(true));
                }
              }
              g2[s2].jxg_isused = true;
            }
          return this.touches.length > 0 && (i2.preventDefault(), i2.stopPropagation()), this.mode === this.BOARD_MODE_NONE && this.touchOriginMoveStart(i2) || g2.length !== 2 || this.mode !== this.BOARD_MODE_NONE && this.mode !== this.BOARD_MODE_MOVE_ORIGIN || (this.mode === this.BOARD_MODE_MOVE_ORIGIN && this.originMoveEnd(), this.gestureStartListener(i2)), this.options.precision.hasPoint = this.options.precision.mouse, this.triggerEventHandlers(["touchstart", "down"], [i2]), false;
        }, touchMoveListener: function(e3) {
          var i2, r2, s2, o2 = e3[t.touchProperty];
          if (!this.checkFrameRate(e3))
            return false;
          if (this.mode !== this.BOARD_MODE_NONE && (e3.preventDefault(), e3.stopPropagation()), this.mode !== this.BOARD_MODE_DRAG && (this.dehighlightAll(), this.displayInfobox(false)), this._inputDevice = "touch", this.options.precision.hasPoint = this.options.precision.touch, this.updateQuality = this.BOARD_QUALITY_LOW, this.selectingMode) {
            for (i2 = 0; i2 < o2.length; i2++)
              if (!o2[i2].jxg_isused) {
                r2 = this.getMousePosition(e3, i2), this._moveSelecting(r2), this.triggerEventHandlers(["touchmoves", "moveselecting"], [e3, this.mode]);
                break;
              }
          } else if (!this.touchOriginMove(e3))
            if (this.mode === this.BOARD_MODE_DRAG) {
              for (i2 = 0; i2 < this.touches.length; i2++)
                if (this.touches[i2].targets.length === 1) {
                  if (o2[this.touches[i2].targets[0].num]) {
                    if (r2 = this.getMousePosition(e3, this.touches[i2].targets[0].num), r2[0] < 0 || r2[0] > this.canvasWidth || r2[1] < 0 || r2[1] > this.canvasHeight)
                      return;
                    this.touches[i2].targets[0].X = o2[this.touches[i2].targets[0].num].screenX, this.touches[i2].targets[0].Y = o2[this.touches[i2].targets[0].num].screenY, this.moveObject(r2[0], r2[1], this.touches[i2], e3, "touch");
                  }
                } else if (this.touches[i2].targets.length === 2 && this.touches[i2].targets[0].num > -1 && this.touches[i2].targets[1].num > -1 && o2[this.touches[i2].targets[0].num] && o2[this.touches[i2].targets[1].num]) {
                  if (r2 = this.getMousePosition(e3, this.touches[i2].targets[0].num), s2 = this.getMousePosition(e3, this.touches[i2].targets[1].num), r2[0] < 0 || r2[0] > this.canvasWidth || r2[1] < 0 || r2[1] > this.canvasHeight || s2[0] < 0 || s2[0] > this.canvasWidth || s2[1] < 0 || s2[1] > this.canvasHeight)
                    return;
                  this.touches[i2].targets[0].X = o2[this.touches[i2].targets[0].num].screenX, this.touches[i2].targets[0].Y = o2[this.touches[i2].targets[0].num].screenY, this.touches[i2].targets[1].X = o2[this.touches[i2].targets[1].num].screenX, this.touches[i2].targets[1].Y = o2[this.touches[i2].targets[1].num].screenY, this.twoFingerMove(r2, s2, this.touches[i2], e3);
                }
            } else
              o2.length === 2 && this.gestureChangeListener(e3), r2 = this.getMousePosition(e3, 0), this.highlightElements(r2[0], r2[1], e3, -1);
          return this.mode !== this.BOARD_MODE_DRAG && this.displayInfobox(false), this.triggerEventHandlers(["touchmove", "move"], [e3, this.mode]), this.options.precision.hasPoint = this.options.precision.mouse, this.updateQuality = this.BOARD_QUALITY_HIGH, this.mode === this.BOARD_MODE_NONE;
        }, touchEndListener: function(i2) {
          var r2, s2, o2, n3, a2, h2 = this.options.precision.touch, l2 = [], c2 = i2 && i2[t.touchProperty];
          if (this.triggerEventHandlers(["touchend", "up"], [i2]), this.displayInfobox(false), this.selectingMode)
            this._stopSelecting(i2), this.triggerEventHandlers(["touchstopselecting", "stopselecting"], [i2]);
          else if (c2 && c2.length > 0) {
            for (r2 = 0; r2 < this.touches.length; r2++)
              l2[r2] = this.touches[r2];
            for (this.touches.length = 0, r2 = 0; r2 < c2.length; r2++)
              c2[r2].jxg_isused = false;
            for (r2 = 0; r2 < l2.length; r2++) {
              for (n3 = false, a2 = 0, s2 = 0; s2 < l2[r2].targets.length; s2++)
                for (l2[r2].targets[s2].found = false, o2 = 0; o2 < c2.length; o2++)
                  if (Math.abs(Math.pow(c2[o2].screenX - l2[r2].targets[s2].X, 2) + Math.pow(c2[o2].screenY - l2[r2].targets[s2].Y, 2)) < h2 * h2) {
                    l2[r2].targets[s2].found = true, l2[r2].targets[s2].num = o2, l2[r2].targets[s2].X = c2[o2].screenX, l2[r2].targets[s2].Y = c2[o2].screenY, a2 += 1;
                    break;
                  }
              if (u.isPoint(l2[r2].obj) ? n3 = l2[r2].targets[0] && l2[r2].targets[0].found : l2[r2].obj.elementClass === e2.OBJECT_CLASS_LINE ? n3 = l2[r2].targets[0] && l2[r2].targets[0].found || l2[r2].targets[1] && l2[r2].targets[1].found : l2[r2].obj.elementClass === e2.OBJECT_CLASS_CIRCLE && (n3 = a2 === 1 || a2 === 3), n3)
                for (this.touches.push({obj: l2[r2].obj, targets: []}), s2 = 0; s2 < l2[r2].targets.length; s2++)
                  l2[r2].targets[s2].found && this.touches[this.touches.length - 1].targets.push({num: l2[r2].targets[s2].num, X: l2[r2].targets[s2].screenX, Y: l2[r2].targets[s2].screenY, Xprev: NaN, Yprev: NaN, Xstart: l2[r2].targets[s2].Xstart, Ystart: l2[r2].targets[s2].Ystart, Zstart: l2[r2].targets[s2].Zstart});
              else
                l2[r2].obj.noHighlight();
            }
          } else
            this.touches.length = 0;
          for (r2 = this.downObjects.length - 1; r2 > -1; r2--) {
            for (n3 = false, s2 = 0; s2 < this.touches.length; s2++)
              this.touches[s2].obj.id === this.downObjects[r2].id && (n3 = true);
            n3 || (this.downObjects[r2].triggerEventHandlers(["touchup", "up"], [i2]), this.downObjects[r2].snapToGrid(), this.downObjects[r2].snapToPoints(), this.downObjects.splice(r2, 1));
          }
          return c2 && c2.length !== 0 || (this.hasTouchEnd && (f.removeEvent(this.document, "touchend", this.touchEndListener, this), this.hasTouchEnd = false), this.dehighlightAll(), this.updateQuality = this.BOARD_QUALITY_HIGH, this.originMoveEnd(), this.update()), true;
        }, mouseDownListener: function(t2) {
          var e3, i2, r2;
          if (this.document.selection && u.isFunction(this.document.selection.empty) ? this.document.selection.empty() : window.getSelection && window.getSelection().removeAllRanges(), !this.hasMouseUp)
            return f.addEvent(this.document, "mouseup", this.mouseUpListener, this), this.hasMouseUp = true, this._inputDevice = "mouse", this.options.precision.hasPoint = this.options.precision.mouse, e3 = this.getMousePosition(t2), this._testForSelection(t2), this.selectingMode ? (this._startSelecting(e3), void this.triggerEventHandlers(["mousestartselecting", "startselecting"], [t2])) : (i2 = this.initMoveObject(e3[0], e3[1], t2, "mouse"), i2.length === 0 ? (this.mode = this.BOARD_MODE_NONE, r2 = true) : (this.mouse = {obj: null, targets: [{X: e3[0], Y: e3[1], Xprev: NaN, Yprev: NaN}]}, this.mouse.obj = i2[i2.length - 1], this.dehighlightAll(), this.mouse.obj.highlight(true), this.mouse.targets[0].Xstart = [], this.mouse.targets[0].Ystart = [], this.mouse.targets[0].Zstart = [], this.saveStartPos(this.mouse.obj, this.mouse.targets[0]), t2 && t2.preventDefault ? t2.preventDefault() : window.event && (window.event.returnValue = false)), this.mode === this.BOARD_MODE_NONE && (r2 = this.mouseOriginMoveStart(t2)), this.triggerEventHandlers(["mousedown", "down"], [t2]), r2);
        }, mouseMoveListener: function(t2) {
          var e3;
          if (!this.checkFrameRate(t2))
            return false;
          e3 = this.getMousePosition(t2), this.updateQuality = this.BOARD_QUALITY_LOW, this.mode !== this.BOARD_MODE_DRAG && (this.dehighlightAll(), this.displayInfobox(false)), this.selectingMode ? (this._moveSelecting(e3), this.triggerEventHandlers(["mousemoveselecting", "moveselecting"], [t2, this.mode])) : this.mouseOriginMove(t2) || (this.mode === this.BOARD_MODE_DRAG ? this.moveObject(e3[0], e3[1], this.mouse, t2, "mouse") : this.highlightElements(e3[0], e3[1], t2, -1), this.triggerEventHandlers(["mousemove", "move"], [t2, this.mode])), this.updateQuality = this.BOARD_QUALITY_HIGH;
        }, mouseUpListener: function(t2) {
          var e3;
          if (this.selectingMode === false && this.triggerEventHandlers(["mouseup", "up"], [t2]), this.updateQuality = this.BOARD_QUALITY_HIGH, this.mouse && this.mouse.obj && (this.mouse.obj.snapToGrid(this.mouse.targets[0]), this.mouse.obj.snapToPoints()), this.originMoveEnd(), this.dehighlightAll(), this.update(), this.selectingMode)
            this._stopSelecting(t2), this.triggerEventHandlers(["mousestopselecting", "stopselecting"], [t2]);
          else
            for (e3 = 0; e3 < this.downObjects.length; e3++)
              this.downObjects[e3].triggerEventHandlers(["mouseup", "up"], [t2]);
          this.downObjects.length = 0, this.hasMouseUp && (f.removeEvent(this.document, "mouseup", this.mouseUpListener, this), this.hasMouseUp = false), this.mouse = null;
        }, mouseWheelListener: function(t2) {
          if (!this.attr.zoom.wheel || !this._isRequiredKeyPressed(t2, "zoom"))
            return true;
          t2 = t2 || window.event;
          var r2 = t2.detail ? -t2.detail : t2.wheelDelta / 40, s2 = new i(e2.COORDS_BY_SCREEN, this.getMousePosition(t2), this);
          return r2 > 0 ? this.zoomIn(s2.usrCoords[1], s2.usrCoords[2]) : this.zoomOut(s2.usrCoords[1], s2.usrCoords[2]), this.triggerEventHandlers(["mousewheel"], [t2]), t2.preventDefault(), false;
        }, initInfobox: function() {
          var t2 = u.copyAttributes({}, this.options, "infobox");
          return t2.id = this.id + "_infobox", this.infobox = this.create("text", [0, 0, "0,0"], t2), this.infobox.distanceX = -20, this.infobox.distanceY = 25, this.infobox.dump = false, this.displayInfobox(false), this;
        }, updateInfobox: function(t2) {
          var e3, i2, r2, s2, o2, n3 = u.evaluate(t2.visProp.showinfobox);
          return !u.evaluate(this.attr.showinfobox) && n3 === "inherit" || !n3 ? this : (u.isPoint(t2) && (r2 = t2.coords.usrCoords[1], s2 = t2.coords.usrCoords[2], o2 = u.evaluate(t2.visProp.infoboxdigits), this.infobox.setCoords(r2 + this.infobox.distanceX / this.unitX, s2 + this.infobox.distanceY / this.unitY), typeof t2.infoboxText != "string" ? (o2 === "auto" ? (e3 = u.autoDigits(r2), i2 = u.autoDigits(s2)) : u.isNumber(o2) ? (e3 = u.toFixed(r2, o2), i2 = u.toFixed(s2, o2)) : (e3 = r2, i2 = s2), this.highlightInfobox(e3, i2, t2)) : this.highlightCustomInfobox(t2.infoboxText, t2), this.displayInfobox(true)), this);
        }, displayInfobox: function(t2) {
          return this.infobox.hiddenByParent == t2 && (this.infobox.hiddenByParent = !t2, this.infobox.prepareUpdate().updateVisibility(t2).updateRenderer()), this;
        }, showInfobox: function(t2) {
          return this.displayInfobox(t2);
        }, highlightInfobox: function(t2, e3, i2) {
          return this.highlightCustomInfobox("(" + t2 + ", " + e3 + ")", i2), this;
        }, highlightCustomInfobox: function(t2, e3) {
          return this.infobox.setText(t2), this;
        }, dehighlightAll: function() {
          var t2, e3, i2 = false;
          for (t2 in this.highlightedObjects)
            this.highlightedObjects.hasOwnProperty(t2) && (e3 = this.highlightedObjects[t2], (this.hasMouseHandlers || this.hasPointerHandlers) && e3.noHighlight(), i2 = true);
          return this.highlightedObjects = {}, this.renderer.type === "canvas" && i2 && (this.prepareUpdate(), this.renderer.suspendRedraw(this), this.updateRenderer(), this.renderer.unsuspendRedraw()), this;
        }, getScrCoordsOfMouse: function(t2, e3) {
          return [t2, e3];
        }, getUsrCoordsOfMouse: function(t2) {
          var r2 = this.getCoordsTopLeftCorner(), s2 = f.getPosition(t2, null, this.document), o2 = s2[0] - r2[0], n3 = s2[1] - r2[1];
          return new i(e2.COORDS_BY_SCREEN, [o2, n3], this).usrCoords.slice(1);
        }, getAllUnderMouse: function(t2) {
          var e3 = this.getAllObjectsUnderMouse(t2);
          return e3.push(this.getUsrCoordsOfMouse(t2)), e3;
        }, getAllObjectsUnderMouse: function(t2) {
          var e3, i2, r2 = this.getCoordsTopLeftCorner(), s2 = f.getPosition(t2, null, this.document), o2 = s2[0] - r2[0], n3 = s2[1] - r2[1], a2 = [], h2 = this.objectsList.length;
          for (e3 = 0; e3 < h2; e3++)
            i2 = this.objectsList[e3], i2.visPropCalc.visible && i2.hasPoint && i2.hasPoint(o2, n3) && (a2[a2.length] = i2);
          return a2;
        }, updateCoords: function() {
          var t2, e3, i2 = this.objectsList.length;
          for (e3 = 0; e3 < i2; e3++)
            t2 = this.objectsList[e3], u.exists(t2.coords) && (u.evaluate(t2.visProp.frozen) ? t2.coords.screen2usr() : t2.coords.usr2screen());
          return this;
        }, moveOrigin: function(t2, r2, s2) {
          var o2, n3, a2, h2;
          return u.exists(t2) && u.exists(r2) && (o2 = this.origin.scrCoords[1], n3 = this.origin.scrCoords[2], this.origin.scrCoords[1] = t2, this.origin.scrCoords[2] = r2, s2 && (this.origin.scrCoords[1] -= this.drag_dx, this.origin.scrCoords[2] -= this.drag_dy), a2 = new i(e2.COORDS_BY_SCREEN, [0, 0], this).usrCoords, h2 = new i(e2.COORDS_BY_SCREEN, [this.canvasWidth, this.canvasHeight], this).usrCoords, (a2[1] < this.maxboundingbox[0] || a2[2] > this.maxboundingbox[1] || h2[1] > this.maxboundingbox[2] || h2[2] < this.maxboundingbox[3]) && (this.origin.scrCoords[1] = o2, this.origin.scrCoords[2] = n3)), this.updateCoords().clearTraces().fullUpdate(), this.triggerEventHandlers(["boundingbox"]), this;
        }, addConditions: function(i2) {
          var r2, s2, o2, n3, a2, h2, l2, c2 = [], p2 = "var el, x, y, c, rgbo;\n", f2 = i2.indexOf("<data>"), m2 = i2.indexOf("</data>"), g2 = function(t2, i3, r3, s3) {
            return function() {
              var o3, n4;
              o3 = t2.select(i3.id), n4 = o3.coords.usrCoords[s3], s3 === 2 ? o3.setPositionDirectly(e2.COORDS_BY_USER, [r3(), n4]) : o3.setPositionDirectly(e2.COORDS_BY_USER, [n4, r3()]), o3.prepareUpdate().update();
            };
          }, b2 = function(t2, e3, i3, r3) {
            return function() {
              var s3, o3;
              s3 = t2.select(e3.id), o3 = i3(), r3 === "strokewidth" ? s3.visProp.strokewidth = o3 : (o3 = d.rgba2rgbo(o3), s3.visProp[r3 + "color"] = o3[0], s3.visProp[r3 + "opacity"] = o3[1]);
            };
          };
          if (!(f2 < 0)) {
            for (; f2 >= 0; ) {
              if (r2 = i2.slice(f2 + 6, m2), s2 = r2.indexOf("="), o2 = r2.slice(0, s2), n3 = r2.slice(s2 + 1), s2 = o2.indexOf("."), a2 = o2.slice(0, s2), h2 = this.elementsByName[u.unescapeHTML(a2)], l2 = o2.slice(s2 + 1).replace(/\s+/g, "").toLowerCase(), n3 = u.createFunction(n3, this, "", true), u.exists(this.elementsByName[a2]))
                switch (p2 += 'el = this.objects["' + h2.id + '"];\n', l2) {
                  case "x":
                    c2.push(g2(this, h2, n3, 2));
                    break;
                  case "y":
                    c2.push(g2(this, h2, n3, 1));
                    break;
                  case "visible":
                    c2.push(function(t2, e3, i3) {
                      return function() {
                        var r3, s3;
                        r3 = t2.select(e3.id), s3 = i3(), r3.setAttribute({visible: s3});
                      };
                    }(this, h2, n3));
                    break;
                  case "position":
                    c2.push(function(t2, e3, i3) {
                      return function() {
                        t2.select(e3.id).position = i3();
                      };
                    }(this, h2, n3));
                    break;
                  case "stroke":
                    c2.push(b2(this, h2, n3, "stroke"));
                    break;
                  case "style":
                    c2.push(function(t2, e3, i3) {
                      return function() {
                        t2.select(e3.id).setStyle(i3());
                      };
                    }(this, h2, n3));
                    break;
                  case "strokewidth":
                    c2.push(b2(this, h2, n3, "strokewidth"));
                    break;
                  case "fill":
                    c2.push(b2(this, h2, n3, "fill"));
                    break;
                  case "label":
                    break;
                  default:
                    t.debug("property '" + l2 + "' in conditions not yet implemented:" + n3);
                }
              else
                t.debug("debug conditions: |" + a2 + "| undefined");
              i2 = i2.slice(m2 + 7), f2 = i2.indexOf("<data>"), m2 = i2.indexOf("</data>");
            }
            this.updateConditions = function() {
              var t2;
              for (t2 = 0; t2 < c2.length; t2++)
                c2[t2]();
              return this.prepareUpdate().updateElements(), true;
            }, this.updateConditions();
          }
        }, updateConditions: function() {
          return false;
        }, calculateSnapSizes: function() {
          var t2 = new i(e2.COORDS_BY_USER, [0, 0], this), r2 = new i(e2.COORDS_BY_USER, [this.options.grid.gridX, this.options.grid.gridY], this), s2 = t2.scrCoords[1] - r2.scrCoords[1], o2 = t2.scrCoords[2] - r2.scrCoords[2];
          for (this.options.grid.snapSizeX = this.options.grid.gridX; Math.abs(s2) > 25; )
            this.options.grid.snapSizeX *= 2, s2 /= 2;
          for (this.options.grid.snapSizeY = this.options.grid.gridY; Math.abs(o2) > 25; )
            this.options.grid.snapSizeY *= 2, o2 /= 2;
          return this;
        }, applyZoom: function() {
          return this.updateCoords().calculateSnapSizes().clearTraces().fullUpdate(), this;
        }, zoomIn: function(t2, e3) {
          var i2 = this.getBoundingBox(), r2 = this.attr.zoom.factorx, s2 = this.attr.zoom.factory, o2 = (i2[2] - i2[0]) * (1 - 1 / r2), n3 = (i2[1] - i2[3]) * (1 - 1 / s2), a2 = 0.5, h2 = 0.5, l2 = this.attr.zoom.eps || this.attr.zoom.min || 1e-3;
          return this.zoomX > this.attr.zoom.max && r2 > 1 || this.zoomY > this.attr.zoom.max && s2 > 1 || this.zoomX < l2 && r2 < 1 || this.zoomY < l2 && s2 < 1 ? this : (u.isNumber(t2) && u.isNumber(e3) && (a2 = (t2 - i2[0]) / (i2[2] - i2[0]), h2 = (i2[1] - e3) / (i2[1] - i2[3])), this.setBoundingBox([i2[0] + o2 * a2, i2[1] - n3 * h2, i2[2] - o2 * (1 - a2), i2[3] + n3 * (1 - h2)], false), this.zoomX *= r2, this.zoomY *= s2, this.applyZoom());
        }, zoomOut: function(t2, e3) {
          var i2 = this.getBoundingBox(), r2 = this.attr.zoom.factorx, s2 = this.attr.zoom.factory, o2 = (i2[2] - i2[0]) * (1 - r2), n3 = (i2[1] - i2[3]) * (1 - s2), a2 = 0.5, h2 = 0.5, l2 = this.attr.zoom.eps || this.attr.zoom.min || 1e-3;
          return this.zoomX < l2 || this.zoomY < l2 ? this : (u.isNumber(t2) && u.isNumber(e3) && (a2 = (t2 - i2[0]) / (i2[2] - i2[0]), h2 = (i2[1] - e3) / (i2[1] - i2[3])), this.setBoundingBox([i2[0] + o2 * a2, i2[1] - n3 * h2, i2[2] - o2 * (1 - a2), i2[3] + n3 * (1 - h2)], false), this.zoomX /= r2, this.zoomY /= s2, this.applyZoom());
        }, zoom100: function() {
          var t2 = this.getBoundingBox(), e3 = (t2[2] - t2[0]) * (1 - this.zoomX) * 0.5, i2 = (t2[1] - t2[3]) * (1 - this.zoomY) * 0.5;
          return this.setBoundingBox([t2[0] + e3, t2[1] - i2, t2[2] - e3, t2[3] + i2], false), this.zoomX = 1, this.zoomY = 1, this.applyZoom();
        }, zoomAllPoints: function() {
          var t2, e3, i2, r2, s2, o2 = 0, n3 = 0, a2 = 0, h2 = 0, l2 = this.objectsList.length;
          for (t2 = 0; t2 < l2; t2++)
            s2 = this.objectsList[t2], u.isPoint(s2) && s2.visPropCalc.visible && (s2.coords.usrCoords[1] < o2 ? o2 = s2.coords.usrCoords[1] : s2.coords.usrCoords[1] > n3 && (n3 = s2.coords.usrCoords[1]), s2.coords.usrCoords[2] > h2 ? h2 = s2.coords.usrCoords[2] : s2.coords.usrCoords[2] < a2 && (a2 = s2.coords.usrCoords[2]));
          return e3 = 50, i2 = e3 / this.unitX, r2 = e3 / this.unitY, this.zoomX = 1, this.zoomY = 1, this.setBoundingBox([o2 - i2, h2 + r2, n3 + i2, a2 - r2], true), this.applyZoom();
        }, zoomElements: function(t2) {
          var e3, i2, r2, s2, o2, n3, a2, h2, l2 = [1 / 0, -1 / 0, -1 / 0, 1 / 0];
          if (!u.isArray(t2) || t2.length === 0)
            return this;
          for (e3 = 0; e3 < t2.length; e3++)
            i2 = this.select(t2[e3]), r2 = i2.bounds(), u.isArray(r2) && (r2[0] < l2[0] && (l2[0] = r2[0]), r2[1] > l2[1] && (l2[1] = r2[1]), r2[2] > l2[2] && (l2[2] = r2[2]), r2[3] < l2[3] && (l2[3] = r2[3]));
          return u.isArray(l2) && (this.zoomX = 1, this.zoomY = 1, s2 = 0.5 * (l2[0] + l2[2]), o2 = 0.5 * (l2[1] + l2[3]), n3 = 1.5 * (l2[2] - l2[0]) * 0.5, a2 = 1.5 * (l2[1] - l2[3]) * 0.5, h2 = Math.max(n3, a2), this.setBoundingBox([s2 - h2, o2 + h2, s2 + h2, o2 - h2], true)), this;
        }, zoomElementsOld: function(t2) {
          var e3, i2, r2, s2, o2 = [0, 0, 0, 0], n3 = [1, -1, -1, 1];
          if (!u.isArray(t2) || t2.length === 0)
            return this;
          for (e3 = 0; e3 < t2.length; e3++)
            if (r2 = this.select(t2[e3]), s2 = r2.bounds(), u.isArray(s2))
              if (u.isArray(o2))
                for (i2 = 0; i2 < 4; i2++)
                  n3[i2] * s2[i2] < n3[i2] * o2[i2] && (o2[i2] = s2[i2]);
              else
                o2 = s2;
          if (u.isArray(o2)) {
            for (i2 = 0; i2 < 4; i2++)
              o2[i2] -= n3[i2];
            this.zoomX = 1, this.zoomY = 1, this.setBoundingBox(o2, true);
          }
          return this;
        }, setZoom: function(t2, e3) {
          var i2 = this.attr.zoom.factorx, r2 = this.attr.zoom.factory;
          return this.attr.zoom.factorx = t2 / this.zoomX, this.attr.zoom.factory = e3 / this.zoomY, this.zoomIn(), this.attr.zoom.factorx = i2, this.attr.zoom.factory = r2, this;
        }, removeObject: function(i2, r2) {
          var s2, o2;
          if (u.isArray(i2)) {
            for (o2 = 0; o2 < i2.length; o2++)
              this.removeObject(i2[o2]);
            return this;
          }
          if (i2 = this.select(i2), !u.exists(i2) || u.isString(i2))
            return this;
          try {
            for (s2 in i2.childElements)
              i2.childElements.hasOwnProperty(s2) && i2.childElements[s2].board.removeObject(i2.childElements[s2]);
            for (s2 in i2.objects)
              i2.objects.hasOwnProperty(s2) && i2.objects[s2].board.removeObject(i2.objects[s2]);
            if (r2)
              for (s2 in this.objects)
                this.objects.hasOwnProperty(s2) && u.exists(this.objects[s2].childElements) && u.exists(this.objects[s2].childElements.hasOwnProperty(i2.id)) && (delete this.objects[s2].childElements[i2.id], delete this.objects[s2].descendants[i2.id]);
            else if (u.exists(i2.ancestors))
              for (s2 in i2.ancestors)
                i2.ancestors.hasOwnProperty(s2) && u.exists(i2.ancestors[s2].childElements) && u.exists(i2.ancestors[s2].childElements.hasOwnProperty(i2.id)) && (delete i2.ancestors[s2].childElements[i2.id], delete i2.ancestors[s2].descendants[i2.id]);
            if (i2._pos > -1)
              for (this.objectsList.splice(i2._pos, 1), s2 = i2._pos; s2 < this.objectsList.length; s2++)
                this.objectsList[s2]._pos--;
            else
              i2.type !== e2.OBJECT_TYPE_TURTLE && t.debug("Board.removeObject: object " + i2.id + " not found in list.");
            delete this.objects[i2.id], delete this.elementsByName[i2.name], i2.visProp && u.evaluate(i2.visProp.trace) && i2.clearTrace(), u.exists(i2.remove) && i2.remove();
          } catch (e3) {
            t.debug(i2.id + ": Could not be removed: " + e3);
          }
          return this.update(), this;
        }, removeAncestors: function(t2) {
          var e3;
          for (e3 in t2.ancestors)
            t2.ancestors.hasOwnProperty(e3) && this.removeAncestors(t2.ancestors[e3]);
          return this.removeObject(t2), this;
        }, initGeonextBoard: function() {
          var t2, e3, i2;
          return t2 = this.create("point", [0, 0], {id: this.id + "g00e0", name: "Ursprung", withLabel: false, visible: false, fixed: true}), e3 = this.create("point", [1, 0], {id: this.id + "gX0e0", name: "Punkt_1_0", withLabel: false, visible: false, fixed: true}), i2 = this.create("point", [0, 1], {id: this.id + "gY0e0", name: "Punkt_0_1", withLabel: false, visible: false, fixed: true}), this.create("line", [t2, e3], {id: this.id + "gXLe0", name: "X-Achse", withLabel: false, visible: false}), this.create("line", [t2, i2], {id: this.id + "gYLe0", name: "Y-Achse", withLabel: false, visible: false}), this;
        }, resizeContainer: function(t2, e3, i2, r2) {
          var s2;
          return r2 || (s2 = this.getBoundingBox()), this.canvasWidth = parseInt(t2, 10), this.canvasHeight = parseInt(e3, 10), i2 || (this.containerObj.style.width = this.canvasWidth + "px", this.containerObj.style.height = this.canvasHeight + "px"), this.renderer.resize(this.canvasWidth, this.canvasHeight), r2 || this.setBoundingBox(s2, this.keepaspectratio), this;
        }, showDependencies: function() {
          var t2, e3, i2, r2, s2;
          e3 = "<p>\n";
          for (t2 in this.objects)
            if (this.objects.hasOwnProperty(t2)) {
              s2 = 0;
              for (i2 in this.objects[t2].childElements)
                this.objects[t2].childElements.hasOwnProperty(i2) && (s2 += 1);
              s2 >= 0 && (e3 += "<strong>" + this.objects[t2].id + ":</strong> ");
              for (i2 in this.objects[t2].childElements)
                this.objects[t2].childElements.hasOwnProperty(i2) && (e3 += this.objects[t2].childElements[i2].id + "(" + this.objects[t2].childElements[i2].name + "), ");
              e3 += "<p>\n";
            }
          return e3 += "</p>\n", r2 = window.open(), r2.document.open(), r2.document.write(e3), r2.document.close(), this;
        }, showXML: function() {
          var t2 = window.open("");
          return t2.document.open(), t2.document.write("<pre>" + u.escapeHTML(this.xmlString) + "</pre>"), t2.document.close(), this;
        }, prepareUpdate: function() {
          var t2, e3, i2 = this.objectsList.length;
          for (t2 = 0; t2 < i2; t2++)
            e3 = this.objectsList[t2], e3.needsUpdate = e3.needsRegularUpdate || this.needsFullUpdate;
          for (t2 in this.groups)
            this.groups.hasOwnProperty(t2) && (e3 = this.groups[t2], e3.needsUpdate = e3.needsRegularUpdate || this.needsFullUpdate);
          return this;
        }, updateElements: function(t2) {
          var e3, i2;
          for (t2 = this.select(t2), e3 = 0; e3 < this.objectsList.length; e3++)
            i2 = this.objectsList[e3], i2.update(!u.exists(t2) || i2.id !== t2.id).updateVisibility();
          for (e3 in this.groups)
            this.groups.hasOwnProperty(e3) && this.groups[e3].update(t2);
          return this;
        }, updateRenderer: function() {
          var t2, e3 = this.objectsList.length;
          if (this.renderer.type === "canvas")
            this.updateRendererCanvas();
          else
            for (t2 = 0; t2 < e3; t2++)
              this.objectsList[t2].updateRenderer();
          return this;
        }, updateRendererCanvas: function() {
          var t2, e3, i2, r2, s2, o2 = this.objectsList.length, n3 = this.options.layer, a2 = this.options.layer.numlayers, h2 = Number.NEGATIVE_INFINITY;
          for (i2 = 0; i2 < a2; i2++) {
            r2 = Number.POSITIVE_INFINITY;
            for (s2 in n3)
              n3.hasOwnProperty(s2) && n3[s2] > h2 && n3[s2] < r2 && (r2 = n3[s2]);
            for (h2 = r2, t2 = 0; t2 < o2; t2++)
              e3 = this.objectsList[t2], e3.visProp.layer === r2 && e3.prepareUpdate().updateRenderer();
          }
          return this;
        }, addHook: function(e3, i2, r2) {
          return t.deprecated("Board.addHook()", "Board.on()"), i2 = u.def(i2, "update"), r2 = u.def(r2, this), this.hooks.push([i2, e3]), this.on(i2, e3, r2), this.hooks.length - 1;
        }, addEvent: t.shortcut(t.Board.prototype, "on"), removeHook: function(e3) {
          return t.deprecated("Board.removeHook()", "Board.off()"), this.hooks[e3] && (this.off(this.hooks[e3][0], this.hooks[e3][1]), this.hooks[e3] = null), this;
        }, removeEvent: t.shortcut(t.Board.prototype, "off"), updateHooks: function(e3) {
          var i2 = Array.prototype.slice.call(arguments, 0);
          return t.deprecated("Board.updateHooks()", "Board.triggerEventHandlers()"), i2[0] = u.def(i2[0], "update"), this.triggerEventHandlers([i2[0]], arguments), this;
        }, addChild: function(t2) {
          return u.exists(t2) && u.exists(t2.containerObj) && (this.dependentBoards.push(t2), this.update()), this;
        }, removeChild: function(t2) {
          var e3;
          for (e3 = this.dependentBoards.length - 1; e3 >= 0; e3--)
            this.dependentBoards[e3] === t2 && this.dependentBoards.splice(e3, 1);
          return this;
        }, update: function(t2) {
          var e3, i2, r2, s2;
          if (this.inUpdate || this.isSuspendedUpdate)
            return this;
          for (this.inUpdate = true, this.attr.minimizereflow === "all" && this.containerObj && this.renderer.type !== "vml" && (s2 = this.renderer.removeToInsertLater(this.containerObj)), this.attr.minimizereflow === "svg" && this.renderer.type === "svg" && (s2 = this.renderer.removeToInsertLater(this.renderer.svgRoot)), this.prepareUpdate().updateElements(t2).updateConditions(), this.renderer.suspendRedraw(this), this.updateRenderer(), this.renderer.unsuspendRedraw(), this.triggerEventHandlers(["update"], []), s2 && s2(), i2 = this.dependentBoards.length, e3 = 0; e3 < i2; e3++)
            r2 = this.dependentBoards[e3], u.exists(r2) && r2 !== this && (r2.updateQuality = this.updateQuality, r2.prepareUpdate().updateElements().updateConditions(), r2.renderer.suspendRedraw(), r2.updateRenderer(), r2.renderer.unsuspendRedraw(), r2.triggerEventHandlers(["update"], []));
          return this.inUpdate = false, this;
        }, fullUpdate: function() {
          return this.needsFullUpdate = true, this.update(), this.needsFullUpdate = false, this;
        }, addGrid: function() {
          return this.create("grid", []), this;
        }, removeGrids: function() {
          var t2;
          for (t2 = 0; t2 < this.grids.length; t2++)
            this.removeObject(this.grids[t2]);
          return this.grids.length = 0, this.update(), this;
        }, create: function(e3, i2, r2) {
          var s2, o2;
          for (e3 = e3.toLowerCase(), u.exists(i2) || (i2 = []), u.exists(r2) || (r2 = {}), o2 = 0; o2 < i2.length; o2++)
            !u.isString(i2[o2]) || e3 === "text" && o2 === 2 || !(e3 !== "input" && e3 !== "checkbox" && e3 !== "button" || o2 !== 2 && o2 !== 3) || e3 === "curve" && o2 > 0 || (i2[o2] = this.select(i2[o2]));
          if (!u.isFunction(t.elements[e3]))
            throw new Error("JSXGraph: create: Unknown element type given: " + e3);
          return s2 = t.elements[e3](this, i2, r2), u.exists(s2) ? (s2.prepareUpdate && s2.update && s2.updateRenderer && s2.fullUpdate(), s2) : (t.debug("JSXGraph: create: failure creating " + e3), s2);
        }, createElement: function() {
          return t.deprecated("Board.createElement()", "Board.create()"), this.create.apply(this, arguments);
        }, clearTraces: function() {
          var t2;
          for (t2 = 0; t2 < this.objectsList.length; t2++)
            this.objectsList[t2].clearTrace();
          return this.numTraces = 0, this;
        }, suspendUpdate: function() {
          return this.inUpdate || (this.isSuspendedUpdate = true), this;
        }, unsuspendUpdate: function() {
          return this.isSuspendedUpdate && (this.isSuspendedUpdate = false, this.fullUpdate()), this;
        }, setBoundingBox: function(t2, e3) {
          var i2, r2, s2 = f.getDimensions(this.container, this.document);
          return u.isArray(t2) ? t2[0] < this.maxboundingbox[0] || t2[1] > this.maxboundingbox[1] || t2[2] > this.maxboundingbox[2] || t2[3] < this.maxboundingbox[3] ? this : (this.plainBB = t2, this.canvasWidth = parseInt(s2.width, 10), this.canvasHeight = parseInt(s2.height, 10), r2 = this.canvasWidth, i2 = this.canvasHeight, e3 ? (this.unitX = r2 / (t2[2] - t2[0]), this.unitY = i2 / (t2[1] - t2[3]), Math.abs(this.unitX) < Math.abs(this.unitY) ? this.unitY = Math.abs(this.unitX) * this.unitY / Math.abs(this.unitY) : this.unitX = Math.abs(this.unitY) * this.unitX / Math.abs(this.unitX), this.keepaspectratio = true) : (this.unitX = r2 / (t2[2] - t2[0]), this.unitY = i2 / (t2[1] - t2[3]), this.keepaspectratio = false), this.moveOrigin(-this.unitX * t2[0], this.unitY * t2[1]), this) : this;
        }, getBoundingBox: function() {
          var t2 = new i(e2.COORDS_BY_SCREEN, [0, 0], this).usrCoords, r2 = new i(e2.COORDS_BY_SCREEN, [this.canvasWidth, this.canvasHeight], this).usrCoords;
          return [t2[1], t2[2], r2[1], r2[2]];
        }, addAnimation: function(t2) {
          var e3 = this;
          return this.animationObjects[t2.id] = t2, this.animationIntervalCode || (this.animationIntervalCode = window.setInterval(function() {
            e3.animate();
          }, t2.board.attr.animationdelay)), this;
        }, stopAllAnimation: function() {
          var t2;
          for (t2 in this.animationObjects)
            this.animationObjects.hasOwnProperty(t2) && u.exists(this.animationObjects[t2]) && (this.animationObjects[t2] = null, delete this.animationObjects[t2]);
          return window.clearInterval(this.animationIntervalCode), delete this.animationIntervalCode, this;
        }, animate: function() {
          var t2, i2, r2, s2, o2, n3, a2, h2, l2 = 0, c2 = null;
          for (i2 in this.animationObjects)
            if (this.animationObjects.hasOwnProperty(i2) && u.exists(this.animationObjects[i2])) {
              if (l2 += 1, r2 = this.animationObjects[i2], r2.animationPath && (s2 = u.isFunction(r2.animationPath) ? r2.animationPath(new Date().getTime() - r2.animationStart) : r2.animationPath.pop(), !u.exists(s2) || !u.isArray(s2) && isNaN(s2) ? delete r2.animationPath : (r2.setPositionDirectly(e2.COORDS_BY_USER, s2), r2.fullUpdate(), c2 = r2)), r2.animationData) {
                a2 = 0;
                for (o2 in r2.animationData)
                  r2.animationData.hasOwnProperty(o2) && (n3 = r2.animationData[o2].pop(), u.exists(n3) ? (a2 += 1, t2 = {}, t2[o2] = n3, r2.setAttribute(t2)) : delete r2.animationData[n3]);
                a2 === 0 && delete r2.animationData;
              }
              u.exists(r2.animationData) || u.exists(r2.animationPath) || (this.animationObjects[i2] = null, delete this.animationObjects[i2], u.exists(r2.animationCallback) && (h2 = r2.animationCallback, r2.animationCallback = null, h2()));
            }
          return l2 === 0 ? (window.clearInterval(this.animationIntervalCode), delete this.animationIntervalCode) : this.update(c2), this;
        }, migratePoint: function(t2, e3, i2) {
          var r2, s2, o2, n3, a2, h2, l2 = false;
          t2 = this.select(t2), e3 = this.select(e3), u.exists(t2.label) && (h2 = t2.label.id, l2 = true, this.removeObject(t2.label));
          for (s2 in t2.childElements)
            if (t2.childElements.hasOwnProperty(s2)) {
              r2 = t2.childElements[s2], n3 = false;
              for (o2 in r2)
                r2.hasOwnProperty(o2) && r2[o2] === t2 && (r2[o2] = e3, n3 = true);
              for (n3 && delete t2.childElements[s2], a2 = 0; a2 < r2.parents.length; a2++)
                r2.parents[a2] === t2.id && (r2.parents[a2] = e3.id);
              e3.addChild(r2);
            }
          return i2 && (l2 && (delete e3.childElements[h2], delete e3.descendants[h2]), e3.label && this.removeObject(e3.label), delete this.elementsByName[e3.name], e3.name = t2.name, l2 && e3.createLabel()), this.removeObject(t2), u.exists(e3.name) && e3.name !== "" && (this.elementsByName[e3.name] = e3), this.fullUpdate(), this;
        }, emulateColorblindness: function(e3) {
          var i2, r2;
          if (u.exists(e3) || (e3 = "none"), this.currentCBDef === e3)
            return this;
          for (i2 in this.objects)
            this.objects.hasOwnProperty(i2) && (r2 = this.objects[i2], e3 !== "none" ? (this.currentCBDef === "none" && (r2.visPropOriginal = {strokecolor: r2.visProp.strokecolor, fillcolor: r2.visProp.fillcolor, highlightstrokecolor: r2.visProp.highlightstrokecolor, highlightfillcolor: r2.visProp.highlightfillcolor}), r2.setAttribute({strokecolor: d.rgb2cb(u.evaluate(r2.visPropOriginal.strokecolor), e3), fillcolor: d.rgb2cb(u.evaluate(r2.visPropOriginal.fillcolor), e3), highlightstrokecolor: d.rgb2cb(u.evaluate(r2.visPropOriginal.highlightstrokecolor), e3), highlightfillcolor: d.rgb2cb(u.evaluate(r2.visPropOriginal.highlightfillcolor), e3)})) : u.exists(r2.visPropOriginal) && t.extend(r2.visProp, r2.visPropOriginal));
          return this.currentCBDef = e3, this.update(), this;
        }, select: function(t2, e3) {
          var i2, r2, s2, o2, n3 = t2;
          if (n3 === null)
            return n3;
          if (u.isString(n3) && n3 !== "")
            u.exists(this.objects[n3]) ? n3 = this.objects[n3] : u.exists(this.elementsByName[n3]) ? n3 = this.elementsByName[n3] : u.exists(this.groups[n3]) && (n3 = this.groups[n3]);
          else if (!e3 && (u.isFunction(n3) || u.isObject(n3) && !u.isFunction(n3.setAttribute))) {
            for (i2 = u.filterElements(this.objectsList, n3), r2 = {}, o2 = i2.length, s2 = 0; s2 < o2; s2++)
              r2[i2[s2].id] = i2[s2];
            n3 = new C(r2);
          } else
            u.isObject(n3) && u.exists(n3.id) && !u.exists(this.objects[n3.id]) && (n3 = null);
          return n3;
        }, hasPoint: function(t2, e3) {
          var i2 = t2, r2 = e3, s2 = this.getBoundingBox();
          return u.exists(t2) && u.isArray(t2.usrCoords) && (i2 = t2.usrCoords[1], r2 = t2.usrCoords[2]), !!(u.isNumber(i2) && u.isNumber(r2) && s2[0] < i2 && i2 < s2[2] && s2[1] > r2 && r2 > s2[3]);
        }, updateCSSTransforms: function() {
          var t2 = this.containerObj, e3 = t2, i2 = t2;
          for (this.cssTransMat = f.getCSSTransformMatrix(e3), e3 = e3.offsetParent; e3; ) {
            for (this.cssTransMat = o.matMatMult(f.getCSSTransformMatrix(e3), this.cssTransMat), i2 = i2.parentNode; i2 !== e3; )
              this.cssTransMat = o.matMatMult(f.getCSSTransformMatrix(e3), this.cssTransMat), i2 = i2.parentNode;
            e3 = e3.offsetParent;
          }
          return this.cssTransMat = o.inverse(this.cssTransMat), this;
        }, startSelectionMode: function() {
          this.selectingMode = true, this.selectionPolygon.setAttribute({visible: true}), this.selectingBox = [[0, 0], [0, 0]], this._setSelectionPolygonFromBox(), this.selectionPolygon.fullUpdate();
        }, stopSelectionMode: function() {
          return this.selectingMode = false, this.selectionPolygon.setAttribute({visible: false}), [this.selectionPolygon.vertices[0].coords, this.selectionPolygon.vertices[2].coords];
        }, _startSelecting: function(t2) {
          this.isSelecting = true, this.selectingBox = [[t2[0], t2[1]], [t2[0], t2[1]]], this._setSelectionPolygonFromBox();
        }, _moveSelecting: function(t2) {
          this.isSelecting && (this.selectingBox[1] = [t2[0], t2[1]], this._setSelectionPolygonFromBox(), this.selectionPolygon.fullUpdate());
        }, _stopSelecting: function(t2) {
          var e3 = this.getMousePosition(t2);
          this.isSelecting = false, this.selectingBox[1] = [e3[0], e3[1]], this._setSelectionPolygonFromBox();
        }, _setSelectionPolygonFromBox: function() {
          var e3 = this.selectingBox[0], i2 = this.selectingBox[1];
          this.selectionPolygon.vertices[0].setPositionDirectly(t.COORDS_BY_SCREEN, [e3[0], e3[1]]), this.selectionPolygon.vertices[1].setPositionDirectly(t.COORDS_BY_SCREEN, [e3[0], i2[1]]), this.selectionPolygon.vertices[2].setPositionDirectly(t.COORDS_BY_SCREEN, [i2[0], i2[1]]), this.selectionPolygon.vertices[3].setPositionDirectly(t.COORDS_BY_SCREEN, [i2[0], e3[1]]);
        }, _testForSelection: function(t2) {
          this._isRequiredKeyPressed(t2, "selection") && (u.exists(this.selectionPolygon) || this._createSelectionPolygon(this.attr), this.startSelectionMode());
        }, _createSelectionPolygon: function(t2) {
          var e3;
          return u.exists(this.selectionPolygon) || (e3 = u.copyAttributes(t2, r, "board", "selection"), e3.enabled === true && (this.selectionPolygon = this.create("polygon", [[0, 0], [0, 0], [0, 0], [0, 0]], e3))), this;
        }, __evt__down: function(t2) {
        }, __evt__mousedown: function(t2) {
        }, __evt__pendown: function(t2) {
        }, __evt__pointerdown: function(t2) {
        }, __evt__touchstart: function(t2) {
        }, __evt__up: function(t2) {
        }, __evt__mouseup: function(t2) {
        }, __evt__pointerup: function(t2) {
        }, __evt__touchend: function(t2) {
        }, __evt__move: function(t2, e3) {
        }, __evt__mousemove: function(t2, e3) {
        }, __evt__penmove: function(t2, e3) {
        }, __evt__pointermove: function(t2, e3) {
        }, __evt__touchmove: function(t2, e3) {
        }, __evt__hit: function(t2, e3, i2) {
        }, __evt__mousehit: function(t2, e3, i2) {
        }, __evt__update: function() {
        }, __evt__boundingbox: function() {
        }, __evt__startselecting: function() {
        }, __evt__mousestartselecting: function() {
        }, __evt__pointerstartselecting: function() {
        }, __evt__touchstartselecting: function() {
        }, __evt__stopselecting: function() {
        }, __evt__mousestopselecting: function() {
        }, __evt__pointerstopselecting: function() {
        }, __evt__touchstopselecting: function() {
        }, __evt__moveselecting: function() {
        }, __evt__mousemoveselecting: function() {
        }, __evt__pointermoveselecting: function() {
        }, __evt__touchmoveselecting: function() {
        }, __evt: function() {
        }, toFullscreen: function() {
          var t2, e3 = this.container, i2 = "fullscreenwrap_" + e3, r2 = document.createElement("div");
          return this.document.getElementById(i2) || (r2.classList.add("JXG_wrap_private"), r2.setAttribute("id", i2), t2 = this.containerObj, t2.parentNode.insertBefore(r2, t2), r2.appendChild(t2)), f.toFullscreen(i2, e3), this;
        }, fullscreenListener: function(t2) {
          this.updateCSSTransforms();
        }, createRoulette: function(t2, e3, i2, r2, o2, n3, h2) {
          var l2 = this;
          return new function() {
            var c2, d2 = 0, u2 = 0, p2 = 0, f2 = i2, m2 = s.root(function(i3) {
              var r3 = t2.X(f2), s2 = t2.Y(f2), o3 = e3.X(i3), n4 = e3.Y(i3);
              return (r3 - o3) * (r3 - o3) + (s2 - n4) * (s2 - n4);
            }, [0, 2 * Math.PI]), g2 = 0, b2 = 0, v2 = l2.create("transform", [function() {
              return d2;
            }], {type: "rotate"}), y2 = l2.create("transform", [function() {
              return d2;
            }, function() {
              return t2.X(f2);
            }, function() {
              return t2.Y(f2);
            }], {type: "rotate"}), C2 = l2.create("transform", [function() {
              return u2;
            }, function() {
              return p2;
            }], {type: "translate"}), _4 = function(t3, e4, i3) {
              var r3 = s.D(t3.X)(e4), o3 = s.D(t3.Y)(e4), n4 = s.D(t3.X)(i3), a2 = s.D(t3.Y)(i3), h3 = s.D(t3.X)(0.5 * (e4 + i3)), l3 = s.D(t3.Y)(0.5 * (e4 + i3)), c3 = Math.sqrt(r3 * r3 + o3 * o3), d3 = Math.sqrt(n4 * n4 + a2 * a2);
              return (c3 + 4 * Math.sqrt(h3 * h3 + l3 * l3) + d3) * (i3 - e4) / 6;
            }, P2 = function(t3) {
              return c2 - _4(e3, m2, t3);
            }, E = Math.PI / 18, x = 9 * E, S = null;
            return this.rolling = function() {
              var i3, n4, S2, O, w;
              g2 = f2 + o2 * r2, c2 = _4(t2, f2, g2), b2 = s.root(P2, m2), i3 = new a(t2.X(g2), t2.Y(g2)), n4 = new a(e3.X(b2), e3.Y(b2)), S2 = new a(s.D(t2.X)(g2), s.D(t2.Y)(g2)), O = new a(s.D(e3.X)(b2), s.D(e3.Y)(b2)), w = a.C.div(S2, O), d2 = Math.atan2(w.imaginary, w.real), w.div(a.C.abs(w)), w.mult(n4), u2 = i3.real - w.real, p2 = i3.imaginary - w.imaginary, d2 < -E && d2 > -x ? (d2 = -E, y2.applyOnce(h2)) : d2 > E && d2 < x ? (d2 = E, y2.applyOnce(h2)) : (v2.applyOnce(h2), C2.applyOnce(h2), f2 = g2, m2 = b2), l2.update();
            }, this.start = function() {
              return n3 > 0 && (S = window.setInterval(this.rolling, n3)), this;
            }, this.stop = function() {
              return window.clearInterval(S), this;
            }, this;
          }();
        }}), t.Board;
      }), define("renderer/svg", ["jxg", "options", "renderer/abstract", "base/constants", "utils/type", "utils/color", "utils/base64", "math/numerics"], function(t, e2, i, r, s, o, n, a) {
        "use strict";
        return t.SVGRenderer = function(t2, i2) {
          var r2;
          for (this.type = "svg", this.isIE = navigator.appVersion.indexOf("MSIE") !== -1 || navigator.userAgent.match(/Trident\//), this.svgRoot = null, this.svgNamespace = "http://www.w3.org/2000/svg", this.xlinkNamespace = "http://www.w3.org/1999/xlink", this.container = t2, this.container.style.MozUserSelect = "none", this.container.style.userSelect = "none", this.container.style.overflow = "hidden", this.container.style.position === "" && (this.container.style.position = "relative"), this.svgRoot = this.container.ownerDocument.createElementNS(this.svgNamespace, "svg"), this.svgRoot.style.overflow = "hidden", this.resize(i2.width, i2.height), this.container.appendChild(this.svgRoot), this.defs = this.container.ownerDocument.createElementNS(this.svgNamespace, "defs"), this.svgRoot.appendChild(this.defs), this.filter = this.container.ownerDocument.createElementNS(this.svgNamespace, "filter"), this.filter.setAttributeNS(null, "id", this.container.id + "_f1"), this.filter.setAttributeNS(null, "width", "300%"), this.filter.setAttributeNS(null, "height", "300%"), this.filter.setAttributeNS(null, "filterUnits", "userSpaceOnUse"), this.feOffset = this.container.ownerDocument.createElementNS(this.svgNamespace, "feOffset"), this.feOffset.setAttributeNS(null, "result", "offOut"), this.feOffset.setAttributeNS(null, "in", "SourceAlpha"), this.feOffset.setAttributeNS(null, "dx", "5"), this.feOffset.setAttributeNS(null, "dy", "5"), this.filter.appendChild(this.feOffset), this.feGaussianBlur = this.container.ownerDocument.createElementNS(this.svgNamespace, "feGaussianBlur"), this.feGaussianBlur.setAttributeNS(null, "result", "blurOut"), this.feGaussianBlur.setAttributeNS(null, "in", "offOut"), this.feGaussianBlur.setAttributeNS(null, "stdDeviation", "3"), this.filter.appendChild(this.feGaussianBlur), this.feBlend = this.container.ownerDocument.createElementNS(this.svgNamespace, "feBlend"), this.feBlend.setAttributeNS(null, "in", "SourceGraphic"), this.feBlend.setAttributeNS(null, "in2", "blurOut"), this.feBlend.setAttributeNS(null, "mode", "normal"), this.filter.appendChild(this.feBlend), this.defs.appendChild(this.filter), this.layer = [], r2 = 0; r2 < e2.layer.numlayers; r2++)
            this.layer[r2] = this.container.ownerDocument.createElementNS(this.svgNamespace, "g"), this.svgRoot.appendChild(this.layer[r2]);
          this.supportsForeignObject = document.implementation.hasFeature("http://w3.org/TR/SVG11/feature#Extensibility", "1.1"), this.supportsForeignObject && (this.foreignObjLayer = this.container.ownerDocument.createElementNS(this.svgNamespace, "foreignObject"), this.foreignObjLayer.setAttribute("x", 0), this.foreignObjLayer.setAttribute("y", 0), this.foreignObjLayer.setAttribute("width", "100%"), this.foreignObjLayer.setAttribute("height", "100%"), this.foreignObjLayer.setAttribute("id", this.container.id + "_foreignObj"), this.svgRoot.appendChild(this.foreignObjLayer)), this.dashArray = ["2, 2", "5, 5", "10, 10", "20, 20", "20, 10, 10, 10", "20, 5, 10, 5"];
        }, t.SVGRenderer.prototype = new i(), t.extend(t.SVGRenderer.prototype, {_createArrowHead: function(e3, i2) {
          var o2, n3, a2, h, l = e3.id + "Triangle", c = null, d = s.evaluate(e3.visProp.firstarrow), u = s.evaluate(e3.visProp.lastarrow);
          return s.exists(i2) && (l += i2), o2 = this.createPrim("marker", l), o2.setAttributeNS(null, "stroke", s.evaluate(e3.visProp.strokecolor)), o2.setAttributeNS(null, "stroke-opacity", s.evaluate(e3.visProp.strokeopacity)), o2.setAttributeNS(null, "fill", s.evaluate(e3.visProp.strokecolor)), o2.setAttributeNS(null, "fill-opacity", s.evaluate(e3.visProp.strokeopacity)), o2.setAttributeNS(null, "stroke-width", 0), o2.setAttributeNS(null, "orient", "auto"), o2.setAttributeNS(null, "markerUnits", "strokeWidth"), n3 = this.container.ownerDocument.createElementNS(this.svgNamespace, "path"), h = 5, i2 === "End" ? (t.exists(d.type) && (c = s.evaluate(d.type)), a2 = 0, c === 2 ? n3.setAttributeNS(null, "d", "M 10,0 L 0,5 L 10,10 L 5,5 z") : c === 3 ? n3.setAttributeNS(null, "d", "M 0,0 L 3.33,0 L 3.33,10 L 0,10 z") : c === 4 ? (h = 3.31, n3.setAttributeNS(null, "d", "M 0.00,3.31 C 3.53,3.84 7.13,4.50 10.00,6.63 C 9.33,5.52 8.67,4.42 8.00,3.31 C 8.67,2.21 9.33,1.10 10.00,0.00 C 7.13,2.13 3.53,2.79 0.00,3.31")) : c === 5 ? (h = 3.28, n3.setAttributeNS(null, "d", "M 0.00,3.28 C 3.39,4.19 6.81,5.07 10.00,6.55 C 9.38,5.56 9.00,4.44 9.00,3.28 C 9.00,2.11 9.38,0.99 10.00,0.00 C 6.81,1.49 3.39,2.37 0.00,3.28")) : c === 6 ? (h = 2.84, n3.setAttributeNS(null, "d", "M 0.00,2.84 C 3.39,3.59 6.79,4.35 10.00,5.68 C 9.67,4.73 9.33,3.78 9.00,2.84 C 9.33,1.89 9.67,0.95 10.00,0.00 C 6.79,1.33 3.39,2.09 0.00,2.84")) : n3.setAttributeNS(null, "d", "M 10,0 L 0,5 L 10,10 z"), e3.elementClass === r.OBJECT_CLASS_LINE && (a2 = c === 2 ? 4.9 : c === 3 ? 3.3 : c === 4 || c === 5 || c === 6 ? 6.66 : 10)) : (t.exists(u.type) && (c = s.evaluate(u.type)), a2 = 10, c === 2 ? n3.setAttributeNS(null, "d", "M 0,0 L 10,5 L 0,10 L 5,5 z") : c === 3 ? (a2 = 3.3, n3.setAttributeNS(null, "d", "M 0,0 L 3.33,0 L 3.33,10 L 0,10 z")) : c === 4 ? (h = 3.31, n3.setAttributeNS(null, "d", "M 10.00,3.31 C 6.47,3.84 2.87,4.50 0.00,6.63 C 0.67,5.52 1.33,4.42 2.00,3.31 C 1.33,2.21 0.67,1.10 0.00,0.00 C 2.87,2.13 6.47,2.79 10.00,3.31")) : c === 5 ? (h = 3.28, n3.setAttributeNS(null, "d", "M 10.00,3.28 C 6.61,4.19 3.19,5.07 0.00,6.55 C 0.62,5.56 1.00,4.44 1.00,3.28 C 1.00,2.11 0.62,0.99 0.00,0.00 C 3.19,1.49 6.61,2.37 10.00,3.28")) : c === 6 ? (h = 2.84, n3.setAttributeNS(null, "d", "M 10.00,2.84 C 6.61,3.59 3.21,4.35 0.00,5.68 C 0.33,4.73 0.67,3.78 1.00,2.84 C 0.67,1.89 0.33,0.95 0.00,0.00 C 3.21,1.33 6.61,2.09 10.00,2.84")) : n3.setAttributeNS(null, "d", "M 0,0 L 10,5 L 0,10 z"), e3.elementClass === r.OBJECT_CLASS_LINE && (a2 = c === 2 ? 5.1 : c === 3 ? 0.02 : c === 4 || c === 5 || c === 6 ? 3.33 : 0.05)), o2.setAttributeNS(null, "refY", h), o2.setAttributeNS(null, "refX", a2), o2.appendChild(n3), o2;
        }, _setArrowColor: function(t2, e3, i2, r2) {
          t2 && (s.isString(e3) && this._setAttribute(function() {
            t2.setAttributeNS(null, "stroke", e3), t2.setAttributeNS(null, "fill", e3), t2.setAttributeNS(null, "stroke-opacity", i2), t2.setAttributeNS(null, "fill-opacity", i2);
          }, r2.visPropOld.fillcolor), this.isIE && r2.rendNode.parentNode.insertBefore(r2.rendNode, r2.rendNode));
        }, _setArrowWidth: function(t2, e3, i2, r2) {
          var s2, o2;
          t2 && (s2 = e3, o2 = s2 * r2, t2.setAttributeNS(null, "viewBox", "0 0 " + 10 * s2 + " " + 10 * s2), t2.setAttributeNS(null, "markerHeight", o2), t2.setAttributeNS(null, "markerWidth", o2), t2.setAttributeNS(null, "display", "inherit"), this.isIE && i2.parentNode.insertBefore(i2, i2));
        }, shortenPath: function(t2, e3, i2) {
          var r2, o2;
          if ((e3 !== 0 || i2 !== 0) && s.exists(t2.getTotalLength))
            try {
              r2 = t2.getTotalLength(), o2 = r2 - e3 - i2, t2.style.strokeDasharray = o2 + " " + e3 + " " + o2 + " " + i2, t2.style.strokeDashoffset = o2;
            } catch (t3) {
            }
        }, updateTicks: function(t2) {
          var e3, i2, r2, o2, n3, a2, h, l, c = "", d = t2.ticks.length, u = true;
          for (e3 = 0; e3 < d; e3++) {
            for (r2 = t2.ticks[e3], n3 = r2[0], a2 = r2[1], h = n3.length, l = " M " + n3[0] + " " + a2[0], s.isNumber(n3[0]) || (u = false), i2 = 1; u && i2 < h; ++i2)
              s.isNumber(n3[i2]) ? l += " L " + n3[i2] + " " + a2[i2] : u = false;
            u && (c += l);
          }
          o2 = t2.rendNode, s.exists(o2) || (o2 = this.createPrim("path", t2.id), this.appendChildPrim(o2, s.evaluate(t2.visProp.layer)), t2.rendNode = o2), o2.setAttributeNS(null, "stroke", s.evaluate(t2.visProp.strokecolor)), o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "stroke-opacity", s.evaluate(t2.visProp.strokeopacity)), o2.setAttributeNS(null, "stroke-width", s.evaluate(t2.visProp.strokewidth)), this.updatePathPrim(o2, c, t2.board);
        }, displayCopyright: function(t2, e3) {
          var i2, r2 = this.createPrim("text", "licenseText");
          r2.setAttributeNS(null, "x", "20px"), r2.setAttributeNS(null, "y", 2 + e3 + "px"), r2.setAttributeNS(null, "style", "font-family:Arial,Helvetica,sans-serif; font-size:" + e3 + "px; fill:#356AA0;  opacity:0.3;"), i2 = this.container.ownerDocument.createTextNode(t2), r2.appendChild(i2), this.appendChildPrim(r2, 0);
        }, drawInternalText: function(t2) {
          var e3 = this.createPrim("text", t2.id);
          return e3.style.whiteSpace = "nowrap", t2.rendNodeText = this.container.ownerDocument.createTextNode(""), e3.appendChild(t2.rendNodeText), this.appendChildPrim(e3, s.evaluate(t2.visProp.layer)), e3;
        }, updateInternalText: function(t2) {
          var e3, i2 = t2.plaintext, r2 = t2.getAnchorX(), o2 = t2.getAnchorY();
          t2.rendNode.getAttributeNS(null, "class") !== t2.visProp.cssclass && (t2.rendNode.setAttributeNS(null, "class", s.evaluate(t2.visProp.cssclass)), t2.needsSizeUpdate = true), isNaN(t2.coords.scrCoords[1] + t2.coords.scrCoords[2]) || (e3 = t2.coords.scrCoords[1], t2.visPropOld.left !== r2 + e3 && (t2.rendNode.setAttributeNS(null, "x", e3 + "px"), r2 === "left" ? t2.rendNode.setAttributeNS(null, "text-anchor", "start") : r2 === "right" ? t2.rendNode.setAttributeNS(null, "text-anchor", "end") : r2 === "middle" && t2.rendNode.setAttributeNS(null, "text-anchor", "middle"), t2.visPropOld.left = r2 + e3), e3 = t2.coords.scrCoords[2], t2.visPropOld.top !== o2 + e3 && (t2.rendNode.setAttributeNS(null, "y", e3 + 0.5 * this.vOffsetText + "px"), o2 === "bottom" ? t2.rendNode.setAttributeNS(null, "dominant-baseline", "text-after-edge") : o2 === "top" ? t2.rendNode.setAttributeNS(null, "dy", "1.6ex") : o2 === "middle" && t2.rendNode.setAttributeNS(null, "dy", "0.6ex"), t2.visPropOld.top = o2 + e3)), t2.htmlStr !== i2 && (t2.rendNodeText.data = i2, t2.htmlStr = i2), this.transformImage(t2, t2.transformations);
        }, updateInternalTextStyle: function(t2, e3, i2, r2) {
          this.setObjectFillColor(t2, e3, i2);
        }, drawImage: function(t2) {
          var e3 = this.createPrim("image", t2.id);
          e3.setAttributeNS(null, "preserveAspectRatio", "none"), this.appendChildPrim(e3, s.evaluate(t2.visProp.layer)), t2.rendNode = e3, this.updateImage(t2);
        }, transformImage: function(t2, e3) {
          var i2, r2, s2 = t2.rendNode, o2 = "";
          e3.length > 0 && (r2 = this.joinTransforms(t2, e3), i2 = [r2[1][1], r2[2][1], r2[1][2], r2[2][2], r2[1][0], r2[2][0]].join(","), o2 += " matrix(" + i2 + ") ", s2.setAttributeNS(null, "transform", o2));
        }, updateImageURL: function(t2) {
          var e3 = s.evaluate(t2.url);
          return t2._src !== e3 && (t2.imgIsLoaded = false, t2.rendNode.setAttributeNS(this.xlinkNamespace, "xlink:href", e3), t2._src = e3, true);
        }, updateImageStyle: function(t2, e3) {
          var i2 = s.evaluate(e3 ? t2.visProp.highlightcssclass : t2.visProp.cssclass);
          t2.rendNode.setAttributeNS(null, "class", i2);
        }, appendChildPrim: function(t2, i2) {
          return s.exists(i2) ? i2 >= e2.layer.numlayers && (i2 = e2.layer.numlayers - 1) : i2 = 0, this.layer[i2].appendChild(t2), t2;
        }, createPrim: function(t2, e3) {
          var i2 = this.container.ownerDocument.createElementNS(this.svgNamespace, t2);
          return i2.setAttributeNS(null, "id", this.container.id + "_" + e3), i2.style.position = "absolute", t2 === "path" && (i2.setAttributeNS(null, "stroke-linecap", "round"), i2.setAttributeNS(null, "stroke-linejoin", "round")), i2;
        }, remove: function(t2) {
          s.exists(t2) && s.exists(t2.parentNode) && t2.parentNode.removeChild(t2);
        }, setLayer: function(t2, i2) {
          s.exists(i2) ? i2 >= e2.layer.numlayers && (i2 = e2.layer.numlayers - 1) : i2 = 0, this.layer[i2].appendChild(t2.rendNode);
        }, makeArrows: function(t2) {
          var e3, i2 = s.evaluate(t2.visProp.firstarrow), r2 = s.evaluate(t2.visProp.lastarrow);
          if (t2.visPropOld.firstarrow === i2 && t2.visPropOld.lastarrow === r2)
            return void (this.isIE && t2.visPropCalc.visible && (i2 || r2) && t2.rendNode.parentNode.insertBefore(t2.rendNode, t2.rendNode));
          i2 ? (e3 = t2.rendNodeTriangleStart, s.exists(e3) ? this.defs.appendChild(e3) : (e3 = this._createArrowHead(t2, "End"), this.defs.appendChild(e3), t2.rendNodeTriangleStart = e3, t2.rendNode.setAttributeNS(null, "marker-start", "url(#" + this.container.id + "_" + t2.id + "TriangleEnd)"))) : (e3 = t2.rendNodeTriangleStart, s.exists(e3) && this.remove(e3)), r2 ? (e3 = t2.rendNodeTriangleEnd, s.exists(e3) ? this.defs.appendChild(e3) : (e3 = this._createArrowHead(t2, "Start"), this.defs.appendChild(e3), t2.rendNodeTriangleEnd = e3, t2.rendNode.setAttributeNS(null, "marker-end", "url(#" + this.container.id + "_" + t2.id + "TriangleStart)"))) : (e3 = t2.rendNodeTriangleEnd, s.exists(e3) && this.remove(e3)), t2.visPropOld.firstarrow = i2, t2.visPropOld.lastarrow = r2;
        }, updateEllipsePrim: function(t2, e3, i2, r2, s2) {
          var o2 = 1e6;
          o2 = 2e5, e3 = Math.abs(e3) < o2 ? e3 : o2 * e3 / Math.abs(e3), i2 = Math.abs(i2) < o2 ? i2 : o2 * i2 / Math.abs(i2), r2 = Math.abs(r2) < o2 ? r2 : o2 * r2 / Math.abs(r2), s2 = Math.abs(s2) < o2 ? s2 : o2 * s2 / Math.abs(s2), t2.setAttributeNS(null, "cx", e3), t2.setAttributeNS(null, "cy", i2), t2.setAttributeNS(null, "rx", Math.abs(r2)), t2.setAttributeNS(null, "ry", Math.abs(s2));
        }, updateLinePrim: function(t2, e3, i2, r2, s2) {
          var o2 = 1e6;
          o2 = 2e5, isNaN(e3 + i2 + r2 + s2) || (e3 = Math.abs(e3) < o2 ? e3 : o2 * e3 / Math.abs(e3), i2 = Math.abs(i2) < o2 ? i2 : o2 * i2 / Math.abs(i2), r2 = Math.abs(r2) < o2 ? r2 : o2 * r2 / Math.abs(r2), s2 = Math.abs(s2) < o2 ? s2 : o2 * s2 / Math.abs(s2), t2.setAttributeNS(null, "x1", e3), t2.setAttributeNS(null, "y1", i2), t2.setAttributeNS(null, "x2", r2), t2.setAttributeNS(null, "y2", s2));
        }, updatePathPrim: function(t2, e3) {
          e3 === "" && (e3 = "M 0 0"), t2.setAttributeNS(null, "d", e3);
        }, updatePathStringPoint: function(t2, e3, i2) {
          var r2 = "", s2 = t2.coords.scrCoords, o2 = e3 * Math.sqrt(3) * 0.5, n3 = 0.5 * e3;
          return i2 === "x" ? r2 = " M " + (s2[1] - e3) + " " + (s2[2] - e3) + " L " + (s2[1] + e3) + " " + (s2[2] + e3) + " M " + (s2[1] + e3) + " " + (s2[2] - e3) + " L " + (s2[1] - e3) + " " + (s2[2] + e3) : i2 === "+" ? r2 = " M " + (s2[1] - e3) + " " + s2[2] + " L " + (s2[1] + e3) + " " + s2[2] + " M " + s2[1] + " " + (s2[2] - e3) + " L " + s2[1] + " " + (s2[2] + e3) : i2 === "<>" ? r2 = " M " + (s2[1] - e3) + " " + s2[2] + " L " + s2[1] + " " + (s2[2] + e3) + " L " + (s2[1] + e3) + " " + s2[2] + " L " + s2[1] + " " + (s2[2] - e3) + " Z " : i2 === "^" ? r2 = " M " + s2[1] + " " + (s2[2] - e3) + " L " + (s2[1] - o2) + " " + (s2[2] + n3) + " L " + (s2[1] + o2) + " " + (s2[2] + n3) + " Z " : i2 === "v" ? r2 = " M " + s2[1] + " " + (s2[2] + e3) + " L " + (s2[1] - o2) + " " + (s2[2] - n3) + " L " + (s2[1] + o2) + " " + (s2[2] - n3) + " Z " : i2 === ">" ? r2 = " M " + (s2[1] + e3) + " " + s2[2] + " L " + (s2[1] - n3) + " " + (s2[2] - o2) + " L " + (s2[1] - n3) + " " + (s2[2] + o2) + " Z " : i2 === "<" && (r2 = " M " + (s2[1] - e3) + " " + s2[2] + " L " + (s2[1] + n3) + " " + (s2[2] - o2) + " L " + (s2[1] + n3) + " " + (s2[2] + o2) + " Z "), r2;
        }, updatePathStringPrim: function(t2) {
          var e3, i2, r2, s2 = " M ", o2 = "";
          if (t2.numberPoints <= 0)
            return "";
          if (r2 = Math.min(t2.points.length, t2.numberPoints), t2.bezierDegree === 1)
            for (e3 = 0; e3 < r2; e3++)
              i2 = t2.points[e3].scrCoords, isNaN(i2[1]) || isNaN(i2[2]) ? s2 = " M " : (i2[1] = Math.max(Math.min(i2[1], 5e3), -5e3), i2[2] = Math.max(Math.min(i2[2], 5e3), -5e3), o2 += s2 + i2[1] + " " + i2[2], s2 = " L ");
          else if (t2.bezierDegree === 3)
            for (e3 = 0; e3 < r2; )
              i2 = t2.points[e3].scrCoords, isNaN(i2[1]) || isNaN(i2[2]) ? s2 = " M " : (o2 += s2 + i2[1] + " " + i2[2], s2 === " C " && (e3 += 1, i2 = t2.points[e3].scrCoords, o2 += " " + i2[1] + " " + i2[2], e3 += 1, i2 = t2.points[e3].scrCoords, o2 += " " + i2[1] + " " + i2[2]), s2 = " C "), e3 += 1;
          return o2;
        }, updatePathStringBezierPrim: function(t2) {
          var e3, i2, r2, o2, n3, h, l, c = " M ", d = "", u = s.evaluate(t2.visProp.strokewidth), p = s.evaluate(t2.visProp.curvetype) !== "plot";
          if (t2.numberPoints <= 0)
            return "";
          for (p && t2.board.options.curve.RDPsmoothing && (t2.points = a.RamerDouglasPeucker(t2.points, 0.5)), l = Math.min(t2.points.length, t2.numberPoints), i2 = 1; i2 < 3; i2++)
            for (c = " M ", e3 = 0; e3 < l; e3++)
              o2 = t2.points[e3].scrCoords, isNaN(o2[1]) || isNaN(o2[2]) ? c = " M " : (o2[1] = Math.max(Math.min(o2[1], 5e3), -5e3), o2[2] = Math.max(Math.min(o2[2], 5e3), -5e3), c === " M " ? d += c + o2[1] + " " + o2[2] : (r2 = 2 * i2, d += [c, n3 + 0.333 * (o2[1] - n3) + u * (r2 * Math.random() - i2), " ", h + 0.333 * (o2[2] - h) + u * (r2 * Math.random() - i2), " ", n3 + 0.666 * (o2[1] - n3) + u * (r2 * Math.random() - i2), " ", h + 0.666 * (o2[2] - h) + u * (r2 * Math.random() - i2), " ", o2[1], " ", o2[2]].join("")), c = " C ", n3 = o2[1], h = o2[2]);
          return d;
        }, updatePolygonPrim: function(t2, e3) {
          var i2, r2, s2 = "", o2 = e3.vertices.length;
          for (t2.setAttributeNS(null, "stroke", "none"), e3.elType === "polygonalchain" && o2++, i2 = 0; i2 < o2 - 1; i2++) {
            if (!e3.vertices[i2].isReal)
              return void t2.setAttributeNS(null, "points", "");
            r2 = e3.vertices[i2].coords.scrCoords, s2 = s2 + r2[1] + "," + r2[2], i2 < o2 - 2 && (s2 += " ");
          }
          s2.indexOf("NaN") === -1 && t2.setAttributeNS(null, "points", s2);
        }, updateRectPrim: function(t2, e3, i2, r2, s2) {
          t2.setAttributeNS(null, "x", e3), t2.setAttributeNS(null, "y", i2), t2.setAttributeNS(null, "width", r2), t2.setAttributeNS(null, "height", s2);
        }, setPropertyPrim: function(t2, e3, i2) {
          e3 !== "stroked" && t2.setAttributeNS(null, e3, i2);
        }, display: function(t2, e3) {
          var i2;
          t2 && t2.rendNode && (t2.visPropOld.visible = e3, i2 = t2.rendNode, e3 ? (i2.setAttributeNS(null, "display", "inline"), i2.style.visibility = "inherit") : (i2.setAttributeNS(null, "display", "none"), i2.style.visibility = "hidden"));
        }, show: function(e3) {
          t.deprecated("Board.renderer.show()", "Board.renderer.display()"), this.display(e3, true);
        }, hide: function(e3) {
          t.deprecated("Board.renderer.hide()", "Board.renderer.display()"), this.display(e3, false);
        }, setBuffering: function(t2, e3) {
          t2.rendNode.setAttribute("buffered-rendering", e3);
        }, setDashStyle: function(t2) {
          var e3 = s.evaluate(t2.visProp.dash), i2 = t2.rendNode;
          e3 > 0 ? i2.setAttributeNS(null, "stroke-dasharray", this.dashArray[e3 - 1]) : i2.hasAttributeNS(null, "stroke-dasharray") && i2.removeAttributeNS(null, "stroke-dasharray");
        }, setGradient: function(t2) {
          var e3, i2, r2, o2 = t2.rendNode, n3 = s.evaluate(t2.visProp.gradient);
          n3 === "linear" || n3 === "radial" ? (e3 = this.createPrim(n3 + "Gradient", t2.id + "_gradient"), i2 = this.createPrim("stop", t2.id + "_gradient1"), r2 = this.createPrim("stop", t2.id + "_gradient2"), e3.appendChild(i2), e3.appendChild(r2), this.defs.appendChild(e3), o2.setAttributeNS(null, "style", "fill:url(#" + this.container.id + "_" + t2.id + "_gradient)"), t2.gradNode1 = i2, t2.gradNode2 = r2, t2.gradNode = e3) : o2.removeAttributeNS(null, "style");
        }, updateGradientAngle: function(t2, e3) {
          var i2 = 1, r2 = Math.cos(e3), s2 = Math.sin(e3);
          Math.abs(r2) > Math.abs(s2) ? i2 /= Math.abs(r2) : i2 /= Math.abs(s2), r2 >= 0 ? (t2.setAttributeNS(null, "x1", 0), t2.setAttributeNS(null, "x2", r2 * i2)) : (t2.setAttributeNS(null, "x1", -r2 * i2), t2.setAttributeNS(null, "x2", 0)), s2 >= 0 ? (t2.setAttributeNS(null, "y1", 0), t2.setAttributeNS(null, "y2", s2 * i2)) : (t2.setAttributeNS(null, "y1", -s2 * i2), t2.setAttributeNS(null, "y2", 0));
        }, updateGradientCircle: function(t2, e3, i2, r2, s2, o2, n3) {
          t2.setAttributeNS(null, "cx", 100 * e3 + "%"), t2.setAttributeNS(null, "cy", 100 * i2 + "%"), t2.setAttributeNS(null, "r", 100 * r2 + "%"), t2.setAttributeNS(null, "fx", 100 * s2 + "%"), t2.setAttributeNS(null, "fy", 100 * o2 + "%"), t2.setAttributeNS(null, "fr", 100 * n3 + "%");
        }, updateGradient: function(t2) {
          var e3, i2, r2 = t2.gradNode1, o2 = t2.gradNode2, n3 = s.evaluate(t2.visProp.gradient);
          s.exists(r2) && s.exists(o2) && (i2 = s.evaluate(t2.visProp.fillopacity), i2 = i2 > 0 ? i2 : 0, e3 = s.evaluate(t2.visProp.fillcolor), r2.setAttributeNS(null, "style", "stop-color:" + e3 + ";stop-opacity:" + i2), o2.setAttributeNS(null, "style", "stop-color:" + s.evaluate(t2.visProp.gradientsecondcolor) + ";stop-opacity:" + s.evaluate(t2.visProp.gradientsecondopacity)), r2.setAttributeNS(null, "offset", 100 * s.evaluate(t2.visProp.gradientstartoffset) + "%"), o2.setAttributeNS(null, "offset", 100 * s.evaluate(t2.visProp.gradientendoffset) + "%"), n3 === "linear" ? this.updateGradientAngle(t2.gradNode, s.evaluate(t2.visProp.gradientangle)) : n3 === "radial" && this.updateGradientCircle(t2.gradNode, s.evaluate(t2.visProp.gradientcx), s.evaluate(t2.visProp.gradientcy), s.evaluate(t2.visProp.gradientr), s.evaluate(t2.visProp.gradientfx), s.evaluate(t2.visProp.gradientfy), s.evaluate(t2.visProp.gradientfr)));
        }, setObjectTransition: function(t2, e3) {
          var i2, o2, n3, a2, h = ["rendNode", "rendNodeTriangleStart", "rendNodeTriangleEnd"];
          if (e3 === void 0 && (e3 = s.evaluate(t2.visProp.transitionduration)), e3 !== t2.visPropOld.transitionduration) {
            for (o2 = t2.elementClass === r.OBJECT_CLASS_TEXT && s.evaluate(t2.visProp.display) === "html" ? " color " + e3 + "ms, opacity " + e3 + "ms" : " fill " + e3 + "ms, fill-opacity " + e3 + "ms, stroke " + e3 + "ms, stroke-opacity " + e3 + "ms", a2 = h.length, n3 = 0; n3 < a2; ++n3)
              t2[h[n3]] && (i2 = t2[h[n3]], i2.style.transition = o2);
            t2.visPropOld.transitionduration = e3;
          }
        }, _setAttribute: function(t2, e3) {
          e3 === "" ? t2() : window.setTimeout(t2, 1);
        }, setObjectFillColor: function(e3, i2, r2, n3) {
          var a2, h, l, c, d = s.evaluate(i2), u = s.evaluate(r2), p = s.evaluate(e3.visProp.gradient);
          u = u > 0 ? u : 0, e3.visPropOld.fillcolor === d && e3.visPropOld.fillopacity === u && p === null || (s.exists(d) && d !== false && (d.length !== 9 ? (h = d, c = u) : (l = o.rgba2rgbo(d), h = l[0], c = u * l[1]), a2 = n3 === void 0 ? e3.rendNode : n3, h !== "none" && this._setAttribute(function() {
            a2.setAttributeNS(null, "fill", h);
          }, e3.visPropOld.fillcolor), e3.type === t.OBJECT_TYPE_IMAGE ? this._setAttribute(function() {
            a2.setAttributeNS(null, "opacity", c);
          }, e3.visPropOld.fillopacity) : (h === "none" && (c = 0), this._setAttribute(function() {
            a2.setAttributeNS(null, "fill-opacity", c);
          }, e3.visPropOld.fillopacity)), p !== "linear" && p !== "radial" || this.updateGradient(e3)), e3.visPropOld.fillcolor = d, e3.visPropOld.fillopacity = u);
        }, setObjectStrokeColor: function(t2, e3, i2) {
          var n3, a2, h, l, c = s.evaluate(e3), d = s.evaluate(i2);
          d = d > 0 ? d : 0, t2.visPropOld.strokecolor === c && t2.visPropOld.strokeopacity === d || (s.exists(c) && c !== false && (c.length !== 9 ? (n3 = c, h = d) : (a2 = o.rgba2rgbo(c), n3 = a2[0], h = d * a2[1]), l = t2.rendNode, t2.elementClass === r.OBJECT_CLASS_TEXT ? s.evaluate(t2.visProp.display) === "html" ? this._setAttribute(function() {
            l.style.color = n3, l.style.opacity = h;
          }, t2.visPropOld.strokecolor) : this._setAttribute(function() {
            l.setAttributeNS(null, "style", "fill:" + n3), l.setAttributeNS(null, "style", "fill-opacity:" + h);
          }, t2.visPropOld.strokecolor) : this._setAttribute(function() {
            l.setAttributeNS(null, "stroke", n3), l.setAttributeNS(null, "stroke-opacity", h);
          }, t2.visPropOld.strokecolor), t2.elementClass !== r.OBJECT_CLASS_CURVE && t2.elementClass !== r.OBJECT_CLASS_LINE || (s.evaluate(t2.visProp.firstarrow) && this._setArrowColor(t2.rendNodeTriangleStart, n3, h, t2), s.evaluate(t2.visProp.lastarrow) && this._setArrowColor(t2.rendNodeTriangleEnd, n3, h, t2))), t2.visPropOld.strokecolor = c, t2.visPropOld.strokeopacity = d);
        }, setObjectStrokeWidth: function(t2, e3) {
          var i2, r2 = s.evaluate(e3);
          isNaN(r2) || t2.visPropOld.strokewidth === r2 || (i2 = t2.rendNode, this.setPropertyPrim(i2, "stroked", "true"), s.exists(r2) && this.setPropertyPrim(i2, "stroke-width", r2 + "px"), t2.visPropOld.strokewidth = r2);
        }, setLineCap: function(t2) {
          var e3 = s.evaluate(t2.visProp.linecap);
          e3 !== void 0 && e3 !== "" && t2.visPropOld.linecap !== e3 && s.exists(t2.rendNode) && (this.setPropertyPrim(t2.rendNode, "stroke-linecap", e3), t2.visPropOld.linecap = e3);
        }, setShadow: function(t2) {
          var e3 = s.evaluate(t2.visProp.shadow);
          t2.visPropOld.shadow !== e3 && (s.exists(t2.rendNode) && (e3 ? t2.rendNode.setAttributeNS(null, "filter", "url(#" + this.container.id + "_f1)") : t2.rendNode.removeAttributeNS(null, "filter")), t2.visPropOld.shadow = e3);
        }, suspendRedraw: function() {
        }, unsuspendRedraw: function() {
        }, resize: function(t2, e3) {
          this.svgRoot.style.width = parseFloat(t2) + "px", this.svgRoot.style.height = parseFloat(e3) + "px", this.svgRoot.setAttribute("width", parseFloat(t2)), this.svgRoot.setAttribute("height", parseFloat(e3));
        }, createTouchpoints: function(t2) {
          var e3, i2, r2, s2;
          for (this.touchpoints = [], e3 = 0; e3 < t2; e3++)
            i2 = "touchpoint1_" + e3, s2 = this.createPrim("path", i2), this.appendChildPrim(s2, 19), s2.setAttributeNS(null, "d", "M 0 0"), this.touchpoints.push(s2), this.setPropertyPrim(s2, "stroked", "true"), this.setPropertyPrim(s2, "stroke-width", "1px"), s2.setAttributeNS(null, "stroke", "#000000"), s2.setAttributeNS(null, "stroke-opacity", 1), s2.setAttributeNS(null, "display", "none"), r2 = "touchpoint2_" + e3, s2 = this.createPrim("ellipse", r2), this.appendChildPrim(s2, 19), this.updateEllipsePrim(s2, 0, 0, 0, 0), this.touchpoints.push(s2), this.setPropertyPrim(s2, "stroked", "true"), this.setPropertyPrim(s2, "stroke-width", "1px"), s2.setAttributeNS(null, "stroke", "#000000"), s2.setAttributeNS(null, "stroke-opacity", 1), s2.setAttributeNS(null, "fill", "#ffffff"), s2.setAttributeNS(null, "fill-opacity", 0), s2.setAttributeNS(null, "display", "none");
        }, showTouchpoint: function(t2) {
          this.touchpoints && t2 >= 0 && 2 * t2 < this.touchpoints.length && (this.touchpoints[2 * t2].setAttributeNS(null, "display", "inline"), this.touchpoints[2 * t2 + 1].setAttributeNS(null, "display", "inline"));
        }, hideTouchpoint: function(t2) {
          this.touchpoints && t2 >= 0 && 2 * t2 < this.touchpoints.length && (this.touchpoints[2 * t2].setAttributeNS(null, "display", "none"), this.touchpoints[2 * t2 + 1].setAttributeNS(null, "display", "none"));
        }, updateTouchpoint: function(t2, e3) {
          var i2, r2;
          this.touchpoints && t2 >= 0 && 2 * t2 < this.touchpoints.length && (i2 = e3[0], r2 = e3[1], this.touchpoints[2 * t2].setAttributeNS(null, "d", "M " + (i2 - 37) + " " + r2 + " L " + (i2 + 37) + " " + r2 + " M " + i2 + " " + (r2 - 37) + " L " + i2 + " " + (r2 + 37)), this.updateEllipsePrim(this.touchpoints[2 * t2 + 1], e3[0], e3[1], 25, 25));
        }, _getValuesOfDOMElements: function(t2) {
          var e3 = [];
          if (t2.nodeType === 1)
            for (t2 = t2.firstChild; t2; )
              t2.id !== void 0 && t2.value !== void 0 && e3.push([t2.id, t2.value]), e3 = e3.concat(this._getValuesOfDOMElements(t2)), t2 = t2.nextSibling;
          return e3;
        }, _getDataUri: function(t2, e3) {
          var i2 = new Image();
          i2.onload = function() {
            var t3 = document.createElement("canvas");
            t3.width = this.naturalWidth, t3.height = this.naturalHeight, t3.getContext("2d").drawImage(this, 0, 0), e3(t3.toDataURL("image/png")), t3.remove();
          }, i2.src = t2;
        }, _getImgDataURL: function(t2) {
          var e3, i2, r2, s2, o2, n3;
          if (e3 = t2.getElementsByTagName("image"), (i2 = e3.length) > 0)
            for (r2 = document.createElement("canvas"), n3 = 0; n3 < i2; n3++) {
              e3[n3].setAttribute("crossorigin", "anonymous"), s2 = r2.getContext("2d"), r2.width = e3[n3].getAttribute("width"), r2.height = e3[n3].getAttribute("height");
              try {
                s2.drawImage(e3[n3], 0, 0, r2.width, r2.height), o2 = r2.toDataURL(), e3[n3].setAttribute("xlink:href", o2);
              } catch (t3) {
                console.log("CORS problem! Image can not be used", t3);
              }
            }
          return true;
        }, dumpToDataURI: function(t2) {
          var e3, i2, r2, o2, a2, h = this.svgRoot, l = window.btoa || n.encode, c = [];
          if (this.container.hasChildNodes() && s.exists(this.foreignObjLayer)) {
            for (; h.nextSibling; )
              c = c.concat(this._getValuesOfDOMElements(h.nextSibling)), this.foreignObjLayer.appendChild(h.nextSibling);
            t2 === true && (r2 = this.container.ownerDocument, i2 = r2.createElement("div"), i2.appendChild(this.foreignObjLayer));
          }
          if (this._getImgDataURL(h), h.setAttribute("xmlns", "http://www.w3.org/2000/svg"), e3 = new XMLSerializer().serializeToString(h), t2 !== true)
            for (a2 = c.length, o2 = 0; o2 < a2; o2++)
              e3 = e3.replace('id="' + c[o2][0] + '"', 'id="' + c[o2][0] + '" value="' + c[o2][1] + '"');
          if ((e3.match(/xmlns=\"http:\/\/www.w3.org\/2000\/svg\"/g) || []).length > 1 && (e3 = e3.replace(/xmlns=\"http:\/\/www.w3.org\/2000\/svg\"/g, "")), e3 = e3.replace(/&nbsp;/g, " "), s.exists(this.foreignObjLayer) && this.foreignObjLayer.hasChildNodes())
            for (t2 === true && h.appendChild(this.foreignObjLayer); this.foreignObjLayer.firstChild; )
              this.container.appendChild(this.foreignObjLayer.firstChild);
          return "data:image/svg+xml;base64," + l(unescape(encodeURIComponent(e3)));
        }, dumpToCanvas: function(t2, e3, i2, r2) {
          var s2, o2, n3, a2;
          return n3 = document.getElementById(t2), n3.width = n3.width, a2 = n3.getContext("2d"), e3 !== void 0 && i2 !== void 0 && (n3.style.width = parseFloat(e3) + "px", n3.style.height = parseFloat(i2) + "px", n3.setAttribute("width", parseFloat(e3)), n3.setAttribute("height", parseFloat(i2))), o2 = new Image(), s2 = this.dumpToDataURI(r2), o2.src = s2, "Promise" in window ? new Promise(function(t3, r3) {
            try {
              o2.onload = function() {
                a2.drawImage(o2, 0, 0, e3, i2), t3();
              };
            } catch (t4) {
              r3(t4);
            }
          }) : (o2.onload = function() {
            window.setTimeout(function() {
              try {
                a2.drawImage(o2, 0, 0, e3, i2);
              } catch (t3) {
                console.log("screenshots not longer supported on IE");
              }
            }, 200);
          }, this);
        }, screenshot: function(t2, e3, i2) {
          var r2, o2, n3, a2, h, l, c, d, u, p, f, m = this.container.ownerDocument, g = this.container.parentNode, b = t2.attr.screenshot, v = false;
          return this.type === "no" ? this : (c = b.scale * parseFloat(this.container.style.width), d = b.scale * parseFloat(this.container.style.height), e3 === void 0 || e3 === "" ? (v = true, a2 = new Image(), a2.style.width = c + "px", a2.style.height = d + "px") : (v = false, a2 = m.getElementById(e3)), v && (r2 = m.createElement("div"), r2.style.cssText = b.css, r2.style.width = c + "px", r2.style.height = d + "px", r2.style.zIndex = this.container.style.zIndex + 120, r2.style.position = "absolute", r2.style.top = this.container.offsetTop + "px", r2.style.left = this.container.offsetLeft + "px"), o2 = m.createElement("canvas"), n3 = Math.random().toString(36).substr(2, 5), o2.setAttribute("id", n3), o2.setAttribute("width", c), o2.setAttribute("height", d), o2.style.width = c + "px", o2.style.height = c + "px", o2.style.display = "none", g.appendChild(o2), v && (h = m.createElement("span"), l = m.createTextNode("\u2716"), h.style.cssText = b.cssButton, h.appendChild(l), h.onclick = function() {
            r2.parentNode.removeChild(r2);
          }, r2.appendChild(a2), r2.appendChild(h), g.insertBefore(r2, this.container.nextSibling)), u = document.getElementById(this.container.id + "_navigationbar"), s.exists(u) && (p = u.style.display, u.style.display = "none"), f = function() {
            a2.src = o2.toDataURL("image/png"), g.removeChild(o2);
          }, "Promise" in window ? this.dumpToCanvas(n3, c, d, i2).then(f) : (this.dumpToCanvas(n3, c, d, i2), window.setTimeout(f, 200)), s.exists(u) && (u.style.display = p), this);
        }}), t.SVGRenderer;
      }), define("renderer/vml", ["jxg", "renderer/abstract", "base/constants", "utils/type", "utils/color", "math/math", "math/numerics"], function(t, e2, i, r, s, o, n) {
        "use strict";
        return t.VMLRenderer = function(e3) {
          this.type = "vml", this.container = e3, this.container.style.overflow = "hidden", this.container.style.position === "" && (this.container.style.position = "relative"), this.container.onselectstart = function() {
            return false;
          }, this.resolution = 10, r.exists(t.vmlStylesheet) || (e3.ownerDocument.namespaces.add("jxgvml", "urn:schemas-microsoft-com:vml"), t.vmlStylesheet = this.container.ownerDocument.createStyleSheet(), t.vmlStylesheet.addRule(".jxgvml", "behavior:url(#default#VML)"));
          try {
            e3.ownerDocument.namespaces.jxgvml || e3.ownerDocument.namespaces.add("jxgvml", "urn:schemas-microsoft-com:vml"), this.createNode = function(t2) {
              return e3.ownerDocument.createElement("<jxgvml:" + t2 + ' class="jxgvml">');
            };
          } catch (t2) {
            this.createNode = function(t3) {
              return e3.ownerDocument.createElement("<" + t3 + ' xmlns="urn:schemas-microsoft.com:vml" class="jxgvml">');
            };
          }
          this.dashArray = ["Solid", "1 1", "ShortDash", "Dash", "LongDash", "ShortDashDot", "LongDashDot"];
        }, t.VMLRenderer.prototype = new e2(), t.extend(t.VMLRenderer.prototype, {_setAttr: function(e3, i2, r2, s2) {
          try {
            this.container.ownerDocument.documentMode === 8 ? e3[i2] = r2 : e3.setAttribute(i2, r2, s2);
          } catch (e4) {
            t.debug("_setAttr: " + i2 + " " + r2 + "<br>\n");
          }
        }, updateTicks: function(t2) {
          var e3, i2, s2, o2, n3, a = this.resolution, h = [];
          for (i2 = t2.ticks.length, e3 = 0; e3 < i2; e3++)
            s2 = t2.ticks[e3], o2 = s2[0], n3 = s2[1], r.isNumber(o2[0]) && r.isNumber(o2[1]) && h.push(" m " + Math.round(a * o2[0]) + ", " + Math.round(a * n3[0]) + " l " + Math.round(a * o2[1]) + ", " + Math.round(a * n3[1]) + " ");
          r.exists(t2.rendNode) || (t2.rendNode = this.createPrim("path", t2.id), this.appendChildPrim(t2.rendNode, r.evaluate(t2.visProp.layer))), this._setAttr(t2.rendNode, "stroked", "true"), this._setAttr(t2.rendNode, "strokecolor", r.evaluate(t2.visProp.strokecolor), 1), this._setAttr(t2.rendNode, "strokeweight", r.evaluate(t2.visProp.strokewidth)), this._setAttr(t2.rendNodeStroke, "opacity", 100 * r.evaluate(t2.visProp.strokeopacity) + "%"), this.updatePathPrim(t2.rendNode, h, t2.board);
        }, displayCopyright: function(t2, e3) {
          var i2, r2;
          i2 = this.createNode("textbox"), i2.style.position = "absolute", this._setAttr(i2, "id", this.container.id + "_licenseText"), i2.style.left = 20, i2.style.top = 2, i2.style.fontSize = e3, i2.style.color = "#356AA0", i2.style.fontFamily = "Arial,Helvetica,sans-serif", this._setAttr(i2, "opacity", "30%"), i2.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand', enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 30, enabled = true)", r2 = this.container.ownerDocument.createTextNode(t2), i2.appendChild(r2), this.appendChildPrim(i2, 0);
        }, drawInternalText: function(t2) {
          var e3;
          return e3 = this.createNode("textbox"), e3.style.position = "absolute", t2.rendNodeText = this.container.ownerDocument.createTextNode(""), e3.appendChild(t2.rendNodeText), this.appendChildPrim(e3, 9), e3.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand', enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)", e3;
        }, updateInternalText: function(t2) {
          var e3, i2, r2, s2, n3, a, h = t2.plaintext, l = this.joinTransforms(t2, t2.transformations), c = [0, 0], d = t2.rendNode, u = [], p = t2.getAnchorX(), f = t2.getAnchorY();
          if (!isNaN(t2.coords.scrCoords[1] + t2.coords.scrCoords[2])) {
            for (p === "right" ? c[0] = 1 : p === "middle" && (c[0] = 0.5), f === "bottom" ? c[1] = 1 : f === "middle" && (c[1] = 0.5), u[0] = o.matVecMult(l, [1, t2.coords.scrCoords[1] - c[0] * t2.size[0], t2.coords.scrCoords[2] + (1 - c[1]) * t2.size[1] + this.vOffsetText]), u[0][1] /= u[0][0], u[0][2] /= u[0][0], u[1] = o.matVecMult(l, [1, t2.coords.scrCoords[1] + (1 - c[0]) * t2.size[0], t2.coords.scrCoords[2] + (1 - c[1]) * t2.size[1] + this.vOffsetText]), u[1][1] /= u[1][0], u[1][2] /= u[1][0], u[2] = o.matVecMult(l, [1, t2.coords.scrCoords[1] + (1 - c[0]) * t2.size[0], t2.coords.scrCoords[2] - c[1] * t2.size[1] + this.vOffsetText]), u[2][1] /= u[2][0], u[2][2] /= u[2][0], u[3] = o.matVecMult(l, [1, t2.coords.scrCoords[1] - c[0] * t2.size[0], t2.coords.scrCoords[2] - c[1] * t2.size[1] + this.vOffsetText]), u[3][1] /= u[3][0], u[3][2] /= u[3][0], i2 = u[0][1], s2 = u[0][1], r2 = u[0][2], n3 = u[0][2], a = 1; a < 4; a++)
              i2 = Math.max(i2, u[a][1]), s2 = Math.min(s2, u[a][1]), r2 = Math.max(r2, u[a][2]), n3 = Math.min(n3, u[a][2]);
            e3 = c[0] === 1 ? Math.floor(t2.board.canvasWidth - i2) : Math.floor(s2), t2.visPropOld.left !== p + e3 && (c[0] === 1 ? (t2.rendNode.style.right = e3 + "px", t2.rendNode.style.left = "auto") : (t2.rendNode.style.left = e3 + "px", t2.rendNode.style.right = "auto"), t2.visPropOld.left = p + e3), e3 = c[1] === 1 ? Math.floor(t2.board.canvasHeight - r2) : Math.floor(n3), t2.visPropOld.top !== f + e3 && (c[1] === 1 ? (t2.rendNode.style.bottom = e3 + "px", t2.rendNode.style.top = "auto") : (t2.rendNode.style.top = e3 + "px", t2.rendNode.style.bottom = "auto"), t2.visPropOld.top = f + e3);
          }
          t2.htmlStr !== h && (t2.rendNodeText.data = h, t2.htmlStr = h), d.filters.item(0).M11 = l[1][1], d.filters.item(0).M12 = l[1][2], d.filters.item(0).M21 = l[2][1], d.filters.item(0).M22 = l[2][2], d.filters.item(0).enabled = true;
        }, drawImage: function(t2) {
          var e3;
          e3 = this.container.ownerDocument.createElement("img"), e3.style.position = "absolute", this._setAttr(e3, "id", this.container.id + "_" + t2.id), this.container.appendChild(e3), this.appendChildPrim(e3, r.evaluate(t2.visProp.layer)), e3.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand') progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)", t2.rendNode = e3, this.updateImage(t2);
        }, transformImage: function(t2, e3) {
          var i2, r2, s2, n3, a, h, l = t2.rendNode, c = [];
          if (e3.length > 0) {
            for (i2 = this.joinTransforms(t2, e3), c[0] = o.matVecMult(i2, t2.coords.scrCoords), c[0][1] /= c[0][0], c[0][2] /= c[0][0], c[1] = o.matVecMult(i2, [1, t2.coords.scrCoords[1] + t2.size[0], t2.coords.scrCoords[2]]), c[1][1] /= c[1][0], c[1][2] /= c[1][0], c[2] = o.matVecMult(i2, [1, t2.coords.scrCoords[1] + t2.size[0], t2.coords.scrCoords[2] - t2.size[1]]), c[2][1] /= c[2][0], c[2][2] /= c[2][0], c[3] = o.matVecMult(i2, [1, t2.coords.scrCoords[1], t2.coords.scrCoords[2] - t2.size[1]]), c[3][1] /= c[3][0], c[3][2] /= c[3][0], r2 = c[0][1], n3 = c[0][1], s2 = c[0][2], a = c[0][2], h = 1; h < 4; h++)
              r2 = Math.max(r2, c[h][1]), n3 = Math.min(n3, c[h][1]), s2 = Math.max(s2, c[h][2]), a = Math.min(a, c[h][2]);
            l.style.left = Math.floor(n3) + "px", l.style.top = Math.floor(a) + "px", l.filters.item(0).M11 = i2[1][1], l.filters.item(0).M12 = i2[1][2], l.filters.item(0).M21 = i2[2][1], l.filters.item(0).M22 = i2[2][2], l.filters.item(0).enabled = true;
          }
        }, updateImageURL: function(t2) {
          var e3 = r.evaluate(t2.url);
          this._setAttr(t2.rendNode, "src", e3);
        }, appendChildPrim: function(t2, e3) {
          return r.exists(e3) || (e3 = 0), t2.style.zIndex = e3, this.container.appendChild(t2), t2;
        }, appendNodesToElement: function(t2, e3) {
          e3 !== "shape" && e3 !== "path" && e3 !== "polygon" || (t2.rendNodePath = this.getElementById(t2.id + "_path")), t2.rendNodeFill = this.getElementById(t2.id + "_fill"), t2.rendNodeStroke = this.getElementById(t2.id + "_stroke"), t2.rendNodeShadow = this.getElementById(t2.id + "_shadow"), t2.rendNode = this.getElementById(t2.id);
        }, createPrim: function(t2, e3) {
          var i2, r2, s2 = this.createNode("fill"), o2 = this.createNode("stroke"), n3 = this.createNode("shadow");
          return this._setAttr(s2, "id", this.container.id + "_" + e3 + "_fill"), this._setAttr(o2, "id", this.container.id + "_" + e3 + "_stroke"), this._setAttr(n3, "id", this.container.id + "_" + e3 + "_shadow"), t2 === "circle" || t2 === "ellipse" ? (i2 = this.createNode("oval"), i2.appendChild(s2), i2.appendChild(o2), i2.appendChild(n3)) : t2 === "polygon" || t2 === "path" || t2 === "shape" || t2 === "line" ? (i2 = this.createNode("shape"), i2.appendChild(s2), i2.appendChild(o2), i2.appendChild(n3), r2 = this.createNode("path"), this._setAttr(r2, "id", this.container.id + "_" + e3 + "_path"), i2.appendChild(r2)) : (i2 = this.createNode(t2), i2.appendChild(s2), i2.appendChild(o2), i2.appendChild(n3)), i2.style.position = "absolute", i2.style.left = "0px", i2.style.top = "0px", this._setAttr(i2, "id", this.container.id + "_" + e3), i2;
        }, remove: function(t2) {
          r.exists(t2) && t2.removeNode(true);
        }, makeArrows: function(t2) {
          var e3, i2 = r.evaluate(t2.visProp.firstarrow), s2 = r.evaluate(t2.visProp.lastarrow);
          t2.visPropOld.firstarrow === i2 && t2.visPropOld.lastarrow === s2 || (i2 ? (e3 = t2.rendNodeStroke, this._setAttr(e3, "startarrow", "block"), this._setAttr(e3, "startarrowlength", "long")) : (e3 = t2.rendNodeStroke, r.exists(e3) && this._setAttr(e3, "startarrow", "none")), s2 ? (e3 = t2.rendNodeStroke, this._setAttr(e3, "id", this.container.id + "_" + t2.id + "stroke"), this._setAttr(e3, "endarrow", "block"), this._setAttr(e3, "endarrowlength", "long")) : (e3 = t2.rendNodeStroke, r.exists(e3) && this._setAttr(e3, "endarrow", "none")), t2.visPropOld.firstarrow = i2, t2.visPropOld.lastarrow = s2);
        }, updateEllipsePrim: function(t2, e3, i2, r2, s2) {
          t2.style.left = Math.floor(e3 - r2) + "px", t2.style.top = Math.floor(i2 - s2) + "px", t2.style.width = Math.floor(2 * Math.abs(r2)) + "px", t2.style.height = Math.floor(2 * Math.abs(s2)) + "px";
        }, updateLinePrim: function(t2, e3, i2, r2, s2, o2) {
          var n3, a = this.resolution;
          isNaN(e3 + i2 + r2 + s2) || (n3 = ["m ", Math.floor(a * e3), ", ", Math.floor(a * i2), " l ", Math.floor(a * r2), ", ", Math.floor(a * s2)], this.updatePathPrim(t2, n3, o2));
        }, updatePathPrim: function(t2, e3, i2) {
          var r2 = i2.canvasWidth, s2 = i2.canvasHeight;
          e3.length <= 0 && (e3 = ["m 0,0"]), t2.style.width = r2, t2.style.height = s2, this._setAttr(t2, "coordsize", [Math.floor(this.resolution * r2), Math.floor(this.resolution * s2)].join(",")), this._setAttr(t2, "path", e3.join(""));
        }, updatePathStringPoint: function(t2, e3, i2) {
          var r2 = [], s2 = Math.round, o2 = t2.coords.scrCoords, n3 = e3 * Math.sqrt(3) * 0.5, a = 0.5 * e3, h = this.resolution;
          return i2 === "x" ? r2.push([" m ", s2(h * (o2[1] - e3)), ", ", s2(h * (o2[2] - e3)), " l ", s2(h * (o2[1] + e3)), ", ", s2(h * (o2[2] + e3)), " m ", s2(h * (o2[1] + e3)), ", ", s2(h * (o2[2] - e3)), " l ", s2(h * (o2[1] - e3)), ", ", s2(h * (o2[2] + e3))].join("")) : i2 === "+" ? r2.push([" m ", s2(h * (o2[1] - e3)), ", ", s2(h * o2[2]), " l ", s2(h * (o2[1] + e3)), ", ", s2(h * o2[2]), " m ", s2(h * o2[1]), ", ", s2(h * (o2[2] - e3)), " l ", s2(h * o2[1]), ", ", s2(h * (o2[2] + e3))].join("")) : i2 === "<>" ? r2.push([" m ", s2(h * (o2[1] - e3)), ", ", s2(h * o2[2]), " l ", s2(h * o2[1]), ", ", s2(h * (o2[2] + e3)), " l ", s2(h * (o2[1] + e3)), ", ", s2(h * o2[2]), " l ", s2(h * o2[1]), ", ", s2(h * (o2[2] - e3)), " x e "].join("")) : i2 === "^" ? r2.push([" m ", s2(h * o2[1]), ", ", s2(h * (o2[2] - e3)), " l ", s2(h * (o2[1] - n3)), ", ", s2(h * (o2[2] + a)), " l ", s2(h * (o2[1] + n3)), ", ", s2(h * (o2[2] + a)), " x e "].join("")) : i2 === "v" ? r2.push([" m ", s2(h * o2[1]), ", ", s2(h * (o2[2] + e3)), " l ", s2(h * (o2[1] - n3)), ", ", s2(h * (o2[2] - a)), " l ", s2(h * (o2[1] + n3)), ", ", s2(h * (o2[2] - a)), " x e "].join("")) : i2 === ">" ? r2.push([" m ", s2(h * (o2[1] + e3)), ", ", s2(h * o2[2]), " l ", s2(h * (o2[1] - a)), ", ", s2(h * (o2[2] - n3)), " l ", s2(h * (o2[1] - a)), ", ", s2(h * (o2[2] + n3)), " l ", s2(h * (o2[1] + e3)), ", ", s2(h * o2[2])].join("")) : i2 === "<" && r2.push([" m ", s2(h * (o2[1] - e3)), ", ", s2(h * o2[2]), " l ", s2(h * (o2[1] + a)), ", ", s2(h * (o2[2] - n3)), " l ", s2(h * (o2[1] + a)), ", ", s2(h * (o2[2] + n3)), " x e "].join("")), r2;
        }, updatePathStringPrim: function(t2) {
          var e3, i2, r2 = [], s2 = this.resolution, o2 = Math.round, n3 = " m ", a = Math.min(t2.numberPoints, 8192);
          if (t2.numberPoints <= 0)
            return "";
          if (a = Math.min(a, t2.points.length), t2.bezierDegree === 1)
            for (e3 = 0; e3 < a; e3++)
              i2 = t2.points[e3].scrCoords, isNaN(i2[1]) || isNaN(i2[2]) ? n3 = " m " : (i2[1] > 2e4 ? i2[1] = 2e4 : i2[1] < -2e4 && (i2[1] = -2e4), i2[2] > 2e4 ? i2[2] = 2e4 : i2[2] < -2e4 && (i2[2] = -2e4), r2.push([n3, o2(s2 * i2[1]), ", ", o2(s2 * i2[2])].join("")), n3 = " l ");
          else if (t2.bezierDegree === 3)
            for (e3 = 0; e3 < a; )
              i2 = t2.points[e3].scrCoords, isNaN(i2[1]) || isNaN(i2[2]) ? n3 = " m " : (r2.push([n3, o2(s2 * i2[1]), ", ", o2(s2 * i2[2])].join("")), n3 === " c " && (e3 += 1, i2 = t2.points[e3].scrCoords, r2.push([" ", o2(s2 * i2[1]), ", ", o2(s2 * i2[2])].join("")), e3 += 1, i2 = t2.points[e3].scrCoords, r2.push([" ", o2(s2 * i2[1]), ", ", o2(s2 * i2[2])].join(""))), n3 = " c "), e3 += 1;
          return r2.push(" e"), r2;
        }, updatePathStringBezierPrim: function(t2) {
          var e3, i2, s2, o2, a, h, l = [], c = r.evaluate(t2.visProp.strokewidth), d = this.resolution, u = Math.round, p = " m ", f = r.evaluate(t2.visProp.curvetype) !== "plot", m = Math.min(t2.numberPoints, 8192);
          if (t2.numberPoints <= 0)
            return "";
          for (f && t2.board.options.curve.RDPsmoothing && (t2.points = n.RamerDouglasPeucker(t2.points, 1)), m = Math.min(m, t2.points.length), i2 = 1; i2 < 3; i2++)
            for (p = " m ", e3 = 0; e3 < m; e3++)
              o2 = t2.points[e3].scrCoords, isNaN(o2[1]) || isNaN(o2[2]) ? p = " m " : (o2[1] > 2e4 ? o2[1] = 2e4 : o2[1] < -2e4 && (o2[1] = -2e4), o2[2] > 2e4 ? o2[2] = 2e4 : o2[2] < -2e4 && (o2[2] = -2e4), p === " m " ? l.push([p, u(d * o2[1]), " ", u(d * o2[2])].join("")) : (s2 = 2 * i2, l.push([p, u(d * (a + 0.333 * (o2[1] - a) + c * (s2 * Math.random() - i2))), " ", u(d * (h + 0.333 * (o2[2] - h) + c * (s2 * Math.random() - i2))), " ", u(d * (a + 0.666 * (o2[1] - a) + c * (s2 * Math.random() - i2))), " ", u(d * (h + 0.666 * (o2[2] - h) + c * (s2 * Math.random() - i2))), " ", u(d * o2[1]), " ", u(d * o2[2])].join(""))), p = " c ", a = o2[1], h = o2[2]);
          return l.push(" e"), l;
        }, updatePolygonPrim: function(t2, e3) {
          var i2, r2, s2 = e3.vertices.length, o2 = this.resolution, n3 = [];
          if (this._setAttr(t2, "stroked", "false"), r2 = e3.vertices[0].coords.scrCoords, !isNaN(r2[1] + r2[2])) {
            for (n3.push(["m ", Math.floor(o2 * r2[1]), ",", Math.floor(o2 * r2[2]), " l "].join("")), i2 = 1; i2 < s2 - 1; i2++) {
              if (!e3.vertices[i2].isReal)
                return void this.updatePathPrim(t2, "", e3.board);
              if (r2 = e3.vertices[i2].coords.scrCoords, isNaN(r2[1] + r2[2]))
                return;
              n3.push(Math.floor(o2 * r2[1]) + "," + Math.floor(o2 * r2[2])), i2 < s2 - 2 && n3.push(", ");
            }
            n3.push(" x e"), this.updatePathPrim(t2, n3, e3.board);
          }
        }, updateRectPrim: function(t2, e3, i2, r2, s2) {
          t2.style.left = Math.floor(e3) + "px", t2.style.top = Math.floor(i2) + "px", r2 >= 0 && (t2.style.width = r2 + "px"), s2 >= 0 && (t2.style.height = s2 + "px");
        }, setPropertyPrim: function(t2, e3, i2) {
          var s2, o2 = "";
          switch (e3) {
            case "stroke":
              o2 = "strokecolor";
              break;
            case "stroke-width":
              o2 = "strokeweight";
              break;
            case "stroke-dasharray":
              o2 = "dashstyle";
          }
          o2 !== "" && (s2 = r.evaluate(i2), this._setAttr(t2, o2, s2));
        }, display: function(t2, e3) {
          t2 && t2.rendNode && (t2.visPropOld.visible = e3, t2.rendNode.style.visibility = e3 ? "inherit" : "hidden");
        }, show: function(e3) {
          t.deprecated("Board.renderer.show()", "Board.renderer.display()"), e3 && e3.rendNode && (e3.rendNode.style.visibility = "inherit");
        }, hide: function(e3) {
          t.deprecated("Board.renderer.hide()", "Board.renderer.display()"), e3 && e3.rendNode && (e3.rendNode.style.visibility = "hidden");
        }, setDashStyle: function(t2, e3) {
          var i2;
          e3.dash >= 0 && (i2 = t2.rendNodeStroke, this._setAttr(i2, "dashstyle", this.dashArray[e3.dash]));
        }, setGradient: function(t2) {
          var e3 = t2.rendNodeFill, i2 = r.evaluate(t2.visProp.gradient);
          i2 === "linear" ? (this._setAttr(e3, "type", "gradient"), this._setAttr(e3, "color2", r.evaluate(t2.visProp.gradientsecondcolor)), this._setAttr(e3, "opacity2", r.evaluate(t2.visProp.gradientsecondopacity)), this._setAttr(e3, "angle", r.evaluate(t2.visProp.gradientangle))) : i2 === "radial" ? (this._setAttr(e3, "type", "gradientradial"), this._setAttr(e3, "color2", r.evaluate(t2.visProp.gradientsecondcolor)), this._setAttr(e3, "opacity2", r.evaluate(t2.visProp.gradientsecondopacity)), this._setAttr(e3, "focusposition", 100 * r.evaluate(t2.visProp.gradientpositionx) + "%," + 100 * r.evaluate(t2.visProp.gradientpositiony) + "%"), this._setAttr(e3, "focussize", "0,0")) : this._setAttr(e3, "type", "solid");
        }, setObjectFillColor: function(t2, e3, o2) {
          var n3, a, h, l = r.evaluate(e3), c = r.evaluate(o2), d = t2.rendNode;
          c = c > 0 ? c : 0, t2.visPropOld.fillcolor === l && t2.visPropOld.fillopacity === c || (r.exists(l) && l !== false && (l.length !== 9 ? (n3 = l, h = c) : (a = s.rgba2rgbo(l), n3 = a[0], h = c * a[1]), n3 === "none" || n3 === false ? this._setAttr(t2.rendNode, "filled", "false") : (this._setAttr(t2.rendNode, "filled", "true"), this._setAttr(t2.rendNode, "fillcolor", n3), r.exists(h) && t2.rendNodeFill && this._setAttr(t2.rendNodeFill, "opacity", 100 * h + "%")), t2.type === i.OBJECT_TYPE_IMAGE && d.filters.length > 1 && (d.filters.item(1).opacity = Math.round(100 * h), d.filters.item(1).enabled = true)), t2.visPropOld.fillcolor = l, t2.visPropOld.fillopacity = c);
        }, setObjectStrokeColor: function(t2, e3, s2) {
          var o2, n3, a, h, l = r.evaluate(e3), c = r.evaluate(s2), d = t2.rendNode;
          c = c > 0 ? c : 0, t2.visPropOld.strokecolor === l && t2.visPropOld.strokeopacity === c || (r.exists(l) && l !== false && (l.length !== 9 ? (o2 = l, a = c) : (n3 = e3.rgba2rgbo(l), o2 = n3[0], a = c * n3[1]), t2.elementClass === i.OBJECT_CLASS_TEXT ? (d.filters.length > 1 && (d.filters.item(1).opacity = Math.round(100 * a), d.filters.item(1).enabled = true), d.style.color = o2) : (o2 !== false && (this._setAttr(d, "stroked", "true"), this._setAttr(d, "strokecolor", o2)), h = t2.rendNodeStroke, r.exists(a) && t2.type !== i.OBJECT_TYPE_IMAGE && this._setAttr(h, "opacity", 100 * a + "%"))), t2.visPropOld.strokecolor = l, t2.visPropOld.strokeopacity = c);
        }, setObjectStrokeWidth: function(t2, e3) {
          var i2, s2 = r.evaluate(e3);
          isNaN(s2) || t2.visPropOld.strokewidth === s2 || (i2 = t2.rendNode, this.setPropertyPrim(i2, "stroked", "true"), r.exists(s2) && (this.setPropertyPrim(i2, "stroke-width", s2), s2 === 0 && r.exists(t2.rendNodeStroke) && this._setAttr(i2, "stroked", "false")), t2.visPropOld.strokewidth = s2);
        }, setShadow: function(t2) {
          var e3 = t2.rendNodeShadow, i2 = r.evaluate(t2.visProp.shadow);
          e3 && t2.visPropOld.shadow !== i2 && (i2 ? (this._setAttr(e3, "On", "True"), this._setAttr(e3, "Offset", "3pt,3pt"), this._setAttr(e3, "Opacity", "60%"), this._setAttr(e3, "Color", "#aaaaaa")) : this._setAttr(e3, "On", "False"), t2.visPropOld.shadow = i2);
        }, suspendRedraw: function() {
          this.container.style.display = "none";
        }, unsuspendRedraw: function() {
          this.container.style.display = "";
        }}), t.VMLRenderer;
      }), define("renderer/canvas", ["jxg", "renderer/abstract", "base/constants", "utils/env", "utils/type", "utils/uuid", "utils/color", "base/coords", "math/math", "math/geometry", "math/numerics"], function(t, e2, i, r, s, o, n, a, h, l, c) {
        "use strict";
        return t.CanvasRenderer = function(t2, e3) {
          this.type = "canvas", this.canvasRoot = null, this.suspendHandle = null, this.canvasId = o.genUUID(), this.canvasNamespace = null, r.isBrowser ? (this.container = t2, this.container.style.MozUserSelect = "none", this.container.style.userSelect = "none", this.container.style.overflow = "hidden", this.container.style.position === "" && (this.container.style.position = "relative"), this.container.innerHTML = ['<canvas id="', this.canvasId, '" width="', e3.width, 'px" height="', e3.height, 'px"><', "/canvas>"].join(""), this.canvasRoot = this.container.ownerDocument.getElementById(this.canvasId), this.context = this.canvasRoot.getContext("2d")) : r.isNode() && (this.canvasId = typeof module == "object" ? require_browser() : require("canvas"), this.canvasRoot = new this.canvasId(500, 500), this.context = this.canvasRoot.getContext("2d")), this.dashArray = [[2, 2], [5, 5], [10, 10], [20, 20], [20, 10, 10, 10], [20, 5, 10, 5]];
        }, t.CanvasRenderer.prototype = new e2(), t.extend(t.CanvasRenderer.prototype, {_drawFilledPolygon: function(t2, e3) {
          var i2, r2 = t2.length, s2 = this.context;
          if (r2 > 0) {
            if (s2.beginPath(), s2.moveTo(t2[0][0], t2[0][1]), e3 == 1)
              for (i2 = 1; i2 < r2; i2++)
                s2.lineTo(t2[i2][0], t2[i2][1]);
            else
              for (i2 = 1; i2 < r2; i2 += 3)
                s2.bezierCurveTo(t2[i2][0], t2[i2][1], t2[i2 + 1][0], t2[i2 + 1][1], t2[i2 + 2][0], t2[i2 + 2][1]);
            s2.lineTo(t2[0][0], t2[0][1]), s2.closePath(), s2.fill(), s2.stroke();
          }
        }, _fill: function(t2) {
          var e3 = this.context;
          e3.save(), this._setColor(t2, "fill") && e3.fill(), e3.restore();
        }, _rotatePoint: function(t2, e3, i2) {
          return [e3 * Math.cos(t2) - i2 * Math.sin(t2), e3 * Math.sin(t2) + i2 * Math.cos(t2)];
        }, _rotateShape: function(t2, e3) {
          var i2, r2 = [], s2 = t2.length;
          if (s2 <= 0)
            return t2;
          for (i2 = 0; i2 < s2; i2++)
            r2.push(this._rotatePoint(e3, t2[i2][0], t2[i2][1]));
          return r2;
        }, updateGradientAngle: function(t2, e3) {
          var r2, s2, o2, n3, h2, l2, c2, d, u, p, f, m, g = 1, b = Math.cos(-e3), v = Math.sin(-e3), y = t2.getBoundingBox();
          return Math.abs(b) > Math.abs(v) ? g /= Math.abs(b) : g /= Math.abs(v), b >= 0 ? (o2 = 0, n3 = b * g) : (o2 = -b * g, n3 = 0), v >= 0 ? (h2 = 0, l2 = v * g) : (h2 = -v * g, l2 = 0), r2 = new a(i.COORDS_BY_USER, [y[0], y[1]], t2.board), s2 = new a(i.COORDS_BY_USER, [y[2], y[3]], t2.board), f = s2.scrCoords[1] - r2.scrCoords[1], m = s2.scrCoords[2] - r2.scrCoords[2], c2 = r2.scrCoords[1] + f * o2, u = r2.scrCoords[2] + m * h2, d = r2.scrCoords[1] + f * n3, p = r2.scrCoords[2] + m * l2, this.context.createLinearGradient(c2, u, d, p);
        }, updateGradientCircle: function(t2, e3, r2, s2, o2, n3, h2) {
          var l2, c2, d, u, p, f, m, g, b, v, y = t2.getBoundingBox();
          return l2 = new a(i.COORDS_BY_USER, [y[0], y[1]], t2.board), c2 = new a(i.COORDS_BY_USER, [y[2], y[3]], t2.board), b = c2.scrCoords[1] - l2.scrCoords[1], v = l2.scrCoords[2] - c2.scrCoords[2], d = l2.scrCoords[1] + b * e3, u = c2.scrCoords[2] + v * r2, f = l2.scrCoords[1] + b * o2, m = c2.scrCoords[2] + v * n3, p = s2 * (b + v) * 0.5, g = h2 * (b + v) * 0.5, this.context.createRadialGradient(f, m, g, d, u, p);
        }, updateGradient: function(t2) {
          var e3, i2, r2, o2 = s.evaluate(t2.visProp.gradient);
          return i2 = s.evaluate(t2.visProp.fillopacity), i2 = i2 > 0 ? i2 : 0, e3 = s.evaluate(t2.visProp.fillcolor), o2 === "linear" ? r2 = this.updateGradientAngle(t2, s.evaluate(t2.visProp.gradientangle)) : o2 === "radial" && (r2 = this.updateGradientCircle(t2, s.evaluate(t2.visProp.gradientcx), s.evaluate(t2.visProp.gradientcy), s.evaluate(t2.visProp.gradientr), s.evaluate(t2.visProp.gradientfx), s.evaluate(t2.visProp.gradientfy), s.evaluate(t2.visProp.gradientfr))), r2.addColorStop(s.evaluate(t2.visProp.gradientstartoffset), e3), r2.addColorStop(s.evaluate(t2.visProp.gradientendoffset), s.evaluate(t2.visProp.gradientsecondcolor)), r2;
        }, _setColor: function(t2, e3, i2) {
          var r2, o2, a2, h2, l2, c2, d, u, p = true, f = t2.visProp;
          return e3 = e3 || "stroke", i2 = i2 || e3, r2 = this._getHighlighted(t2), (u = s.evaluate(t2.visProp.gradient)) === "linear" || u === "radial" ? (this.context[i2 + "Style"] = this.updateGradient(t2), p) : (a2 = s.evaluate(f[r2 + e3 + "color"]), a2 !== "none" && a2 !== false ? (c2 = s.evaluate(f[r2 + e3 + "opacity"]), c2 = c2 > 0 ? c2 : 0, a2.length !== 9 ? (l2 = a2, d = c2) : (h2 = n.rgba2rgbo(a2), l2 = h2[0], d = c2 * h2[1]), this.context.globalAlpha = d, this.context[i2 + "Style"] = l2) : p = false, o2 = parseFloat(s.evaluate(f[r2 + "strokewidth"])), e3 !== "stroke" || isNaN(o2) || (o2 === 0 ? this.context.globalAlpha = 0 : this.context.lineWidth = o2), e3 === "stroke" && f.linecap !== void 0 && f.linecap !== "" && (this.context.lineCap = f.linecap), p);
        }, _stroke: function(t2) {
          var e3 = this.context, i2 = s.evaluate(t2.visProp.dash);
          e3.save(), i2 > 0 ? e3.setLineDash && e3.setLineDash(this.dashArray[i2]) : this.context.lineDashArray = [], this._setColor(t2, "stroke") && e3.stroke(), e3.restore();
        }, _translateShape: function(t2, e3, i2) {
          var r2, s2 = [], o2 = t2.length;
          if (o2 <= 0)
            return t2;
          for (r2 = 0; r2 < o2; r2++)
            s2.push([t2[r2][0] + e3, t2[r2][1] + i2]);
          return s2;
        }, drawPoint: function(t2) {
          var e3 = s.evaluate(t2.visProp.face), i2 = s.evaluate(t2.visProp.size), r2 = t2.coords.scrCoords, o2 = i2 * Math.sqrt(3) * 0.5, n3 = 0.5 * i2, a2 = parseFloat(s.evaluate(t2.visProp.strokewidth)) / 2, h2 = this.context;
          if (t2.visPropCalc.visible)
            switch (e3) {
              case "cross":
              case "x":
                h2.beginPath(), h2.moveTo(r2[1] - i2, r2[2] - i2), h2.lineTo(r2[1] + i2, r2[2] + i2), h2.moveTo(r2[1] + i2, r2[2] - i2), h2.lineTo(r2[1] - i2, r2[2] + i2), h2.lineCap = "round", h2.lineJoin = "round", h2.closePath(), this._stroke(t2);
                break;
              case "circle":
              case "o":
                h2.beginPath(), h2.arc(r2[1], r2[2], i2 + 1 + a2, 0, 2 * Math.PI, false), h2.closePath(), this._fill(t2), this._stroke(t2);
                break;
              case "square":
              case "[]":
                if (i2 <= 0)
                  break;
                h2.save(), this._setColor(t2, "stroke", "fill") && h2.fillRect(r2[1] - i2 - a2, r2[2] - i2 - a2, 2 * i2 + 3 * a2, 2 * i2 + 3 * a2), h2.restore(), h2.save(), this._setColor(t2, "fill"), h2.fillRect(r2[1] - i2 + a2, r2[2] - i2 + a2, 2 * i2 - a2, 2 * i2 - a2), h2.restore();
                break;
              case "plus":
              case "+":
                h2.beginPath(), h2.moveTo(r2[1] - i2, r2[2]), h2.lineTo(r2[1] + i2, r2[2]), h2.moveTo(r2[1], r2[2] - i2), h2.lineTo(r2[1], r2[2] + i2), h2.lineCap = "round", h2.lineJoin = "round", h2.closePath(), this._stroke(t2);
                break;
              case "diamond":
              case "<>":
                h2.beginPath(), h2.moveTo(r2[1] - i2, r2[2]), h2.lineTo(r2[1], r2[2] + i2), h2.lineTo(r2[1] + i2, r2[2]), h2.lineTo(r2[1], r2[2] - i2), h2.closePath(), this._fill(t2), this._stroke(t2);
                break;
              case "triangleup":
              case "a":
              case "^":
                h2.beginPath(), h2.moveTo(r2[1], r2[2] - i2), h2.lineTo(r2[1] - o2, r2[2] + n3), h2.lineTo(r2[1] + o2, r2[2] + n3), h2.closePath(), this._fill(t2), this._stroke(t2);
                break;
              case "triangledown":
              case "v":
                h2.beginPath(), h2.moveTo(r2[1], r2[2] + i2), h2.lineTo(r2[1] - o2, r2[2] - n3), h2.lineTo(r2[1] + o2, r2[2] - n3), h2.closePath(), this._fill(t2), this._stroke(t2);
                break;
              case "triangleleft":
              case "<":
                h2.beginPath(), h2.moveTo(r2[1] - i2, r2[2]), h2.lineTo(r2[1] + n3, r2[2] - o2), h2.lineTo(r2[1] + n3, r2[2] + o2), h2.closePath(), this.fill(t2), this._stroke(t2);
                break;
              case "triangleright":
              case ">":
                h2.beginPath(), h2.moveTo(r2[1] + i2, r2[2]), h2.lineTo(r2[1] - n3, r2[2] - o2), h2.lineTo(r2[1] - n3, r2[2] + o2), h2.closePath(), this._fill(t2), this._stroke(t2);
            }
        }, updatePoint: function(t2) {
          this.drawPoint(t2);
        }, drawArrows: function(t2, e3, r2, o2) {
          var n3, a2, h2, l2, c2, d, u, p, f, m, g, b, v, y, C, _4, P2, E = this.context, x = 6, S = 1, O = 1, w = 1, T = s.evaluate(t2.visProp.firstarrow), N = s.evaluate(t2.visProp.lastarrow);
          if (s.evaluate(t2.visProp.strokecolor) !== "none" && (T || N)) {
            if (t2.elementClass === i.OBJECT_CLASS_LINE)
              n3 = e3.scrCoords[1], a2 = e3.scrCoords[2], h2 = r2.scrCoords[1], l2 = r2.scrCoords[2], _4 = P2 = Math.atan2(l2 - a2, h2 - n3);
            else {
              if (n3 = t2.points[0].scrCoords[1], a2 = t2.points[0].scrCoords[2], (C = t2.points.length - 1) < 1)
                return;
              h2 = t2.points[t2.points.length - 1].scrCoords[1], l2 = t2.points[t2.points.length - 1].scrCoords[2], g = t2.points[1].scrCoords[1] - t2.points[0].scrCoords[1], b = t2.points[1].scrCoords[2] - t2.points[0].scrCoords[2], v = t2.points[C].scrCoords[1] - t2.points[C - 1].scrCoords[1], y = t2.points[C].scrCoords[2] - t2.points[C - 1].scrCoords[2], T && (_4 = Math.atan2(b, g)), N && (P2 = Math.atan2(y, v));
            }
            if (c2 = s.evaluate(t2.visProp[o2 + "strokewidth"]), T)
              if (x = 6, s.exists(T.size) && (x = s.evaluate(T.size)), o2 !== "" && s.exists(T[o2 + "size"]) && (x = s.evaluate(T[o2 + "size"])), d = c2 * x, s.exists(T.type) && (S = s.evaluate(T.type)), S === 2)
                p = [[d, 0.5 * -d], [0, 0], [d, 0.5 * d], [0.5 * d, 0]];
              else if (S === 3)
                p = [[d / 3, 0.5 * -d], [0, 0.5 * -d], [0, 0.5 * d], [d / 3, 0.5 * d]];
              else if (S === 4)
                for (d /= 10, O = 3, p = [[10, 3.31], [6.47, 3.84], [2.87, 4.5], [0, 6.63], [0.67, 5.52], [1.33, 4.42], [2, 3.31], [1.33, 2.21], [0.67, 1.1], [0, 0], [2.87, 2.13], [6.47, 2.79], [10, 3.31]], m = p.length, f = 0; f < m; f++)
                  p[f][0] *= -d, p[f][1] *= d, p[f][0] += 10 * d, p[f][1] -= 3.31 * d;
              else if (S === 5)
                for (d /= 10, O = 3, p = [[10, 3.28], [6.61, 4.19], [3.19, 5.07], [0, 6.55], [0.62, 5.56], [1, 4.44], [1, 3.28], [1, 2.11], [0.62, 0.99], [0, 0], [3.19, 1.49], [6.61, 2.37], [10, 3.28]], m = p.length, f = 0; f < m; f++)
                  p[f][0] *= -d, p[f][1] *= d, p[f][0] += 10 * d, p[f][1] -= 3.28 * d;
              else if (S === 6)
                for (d /= 10, O = 3, p = [[10, 2.84], [6.61, 3.59], [3.21, 4.35], [0, 5.68], [0.33, 4.73], [0.67, 3.78], [1, 2.84], [0.67, 1.89], [0.33, 0.95], [0, 0], [3.21, 1.33], [6.61, 2.09], [10, 2.84]], m = p.length, f = 0; f < m; f++)
                  p[f][0] *= -d, p[f][1] *= d, p[f][0] += 10 * d, p[f][1] -= 2.84 * d;
              else
                p = [[d, 0.5 * -d], [0, 0], [d, 0.5 * d]];
            if (N)
              if (x = 6, s.exists(N.size) && (x = s.evaluate(N.size)), o2 !== "" && s.exists(N[o2 + "size"]) && (x = s.evaluate(N[o2 + "size"])), d = c2 * x, s.exists(N.type) && (S = s.evaluate(N.type)), S === 2)
                u = [[-d, 0.5 * -d], [0, 0], [-d, 0.5 * d], [0.5 * -d, 0]];
              else if (S === 3)
                u = [[-d / 3, 0.5 * -d], [0, 0.5 * -d], [0, 0.5 * d], [-d / 3, 0.5 * d]];
              else if (S === 4)
                for (d /= 10, w = 3, u = [[10, 3.31], [6.47, 3.84], [2.87, 4.5], [0, 6.63], [0.67, 5.52], [1.33, 4.42], [2, 3.31], [1.33, 2.21], [0.67, 1.1], [0, 0], [2.87, 2.13], [6.47, 2.79], [10, 3.31]], m = u.length, f = 0; f < m; f++)
                  u[f][0] *= d, u[f][1] *= d, u[f][0] -= 10 * d, u[f][1] -= 3.31 * d;
              else if (S === 5)
                for (d /= 10, w = 3, u = [[10, 3.28], [6.61, 4.19], [3.19, 5.07], [0, 6.55], [0.62, 5.56], [1, 4.44], [1, 3.28], [1, 2.11], [0.62, 0.99], [0, 0], [3.19, 1.49], [6.61, 2.37], [10, 3.28]], m = u.length, f = 0; f < m; f++)
                  u[f][0] *= d, u[f][1] *= d, u[f][0] -= 10 * d, u[f][1] -= 3.28 * d;
              else if (S === 6)
                for (d /= 10, w = 3, u = [[10, 2.84], [6.61, 3.59], [3.21, 4.35], [0, 5.68], [0.33, 4.73], [0.67, 3.78], [1, 2.84], [0.67, 1.89], [0.33, 0.95], [0, 0], [3.21, 1.33], [6.61, 2.09], [10, 2.84]], m = u.length, f = 0; f < m; f++)
                  u[f][0] *= d, u[f][1] *= d, u[f][0] -= 10 * d, u[f][1] -= 2.84 * d;
              else
                u = [[-d, 0.5 * -d], [0, 0], [-d, 0.5 * d]];
            E.save(), this._setColor(t2, "stroke", "fill") && (this._setColor(t2, "stroke"), T && this._drawFilledPolygon(this._translateShape(this._rotateShape(p, _4), n3, a2), O), N && this._drawFilledPolygon(this._translateShape(this._rotateShape(u, P2), h2, l2), w)), E.restore();
          }
        }, drawLine: function(t2) {
          var e3, r2, o2, n3, h2, c2 = new a(i.COORDS_BY_USER, t2.point1.coords.usrCoords, t2.board), d = new a(i.COORDS_BY_USER, t2.point2.coords.usrCoords, t2.board), u = null;
          t2.visPropCalc.visible && (o2 = this._getHighlighted(t2), n3 = s.evaluate(t2.visProp[o2 + "strokewidth"]), h2 = this.getArrowHeadData(t2, n3, o2), (h2.evFirst || h2.evLast) && (u = -4), l.calcStraight(t2, c2, d, u), e3 = new a(i.COORDS_BY_USER, c2.usrCoords, t2.board), r2 = new a(i.COORDS_BY_USER, d.usrCoords, t2.board), this.getPositionArrowHead(t2, c2, d, h2), this.context.beginPath(), this.context.moveTo(c2.scrCoords[1], c2.scrCoords[2]), this.context.lineTo(d.scrCoords[1], d.scrCoords[2]), this._stroke(t2), (h2.evFirst || h2.evLast) && this.drawArrows(t2, e3, r2, o2));
        }, updateLine: function(t2) {
          this.drawLine(t2);
        }, drawTicks: function() {
        }, updateTicks: function(t2) {
          var e3, i2, r2, s2, o2, n3, a2 = t2.ticks.length, h2 = this.context;
          for (h2.beginPath(), e3 = 0; e3 < a2; e3++)
            for (i2 = t2.ticks[e3], r2 = i2[0], s2 = i2[1], o2 = r2.length, h2.moveTo(r2[0], s2[0]), n3 = 1; n3 < o2; ++n3)
              h2.lineTo(r2[n3], s2[n3]);
          h2.lineCap = "round", this._stroke(t2);
        }, drawCurve: function(t2) {
          var e3;
          s.evaluate(t2.visProp.handdrawing) ? this.updatePathStringBezierPrim(t2) : this.updatePathStringPrim(t2), t2.numberPoints > 1 && (e3 = this._getHighlighted(t2), this.drawArrows(t2, null, null, e3));
        }, updateCurve: function(t2) {
          this.drawCurve(t2);
        }, drawEllipse: function(t2) {
          var e3 = t2.center.coords.scrCoords[1], i2 = t2.center.coords.scrCoords[2], r2 = t2.board.unitX, s2 = t2.board.unitY, o2 = 2 * t2.Radius(), n3 = 2 * t2.Radius(), a2 = o2 * r2, h2 = n3 * s2, l2 = e3 - a2 / 2, c2 = i2 - h2 / 2, d = a2 / 2 * 0.5522848, u = h2 / 2 * 0.5522848, p = l2 + a2, f = c2 + h2, m = l2 + a2 / 2, g = c2 + h2 / 2, b = this.context;
          o2 > 0 && n3 > 0 && !isNaN(e3 + i2) && (b.beginPath(), b.moveTo(l2, g), b.bezierCurveTo(l2, g - u, m - d, c2, m, c2), b.bezierCurveTo(m + d, c2, p, g - u, p, g), b.bezierCurveTo(p, g + u, m + d, f, m, f), b.bezierCurveTo(m - d, f, l2, g + u, l2, g), b.closePath(), this._fill(t2), this._stroke(t2));
        }, updateEllipse: function(t2) {
          return this.drawEllipse(t2);
        }, displayCopyright: function(t2, e3) {
          var i2 = this.context;
          i2.save(), i2.font = e3 + "px Arial", i2.fillStyle = "#aaa", i2.lineWidth = 0.5, i2.fillText(t2, 10, 2 + e3), i2.restore();
        }, drawInternalText: function(t2) {
          var e3 = s.evaluate(t2.visProp.fontsize), i2 = t2.getAnchorX(), r2 = t2.getAnchorY(), o2 = this.context;
          return o2.save(), this._setColor(t2, "stroke", "fill") && !isNaN(t2.coords.scrCoords[1] + t2.coords.scrCoords[2]) && (o2.font = (e3 > 0 ? e3 : 0) + "px Arial", this.transformImage(t2, t2.transformations), i2 === "left" ? o2.textAlign = "left" : i2 === "right" ? o2.textAlign = "right" : i2 === "middle" && (o2.textAlign = "center"), r2 === "bottom" ? o2.textBaseline = "bottom" : r2 === "top" ? o2.textBaseline = "top" : r2 === "middle" && (o2.textBaseline = "middle"), o2.fillText(t2.plaintext, t2.coords.scrCoords[1], t2.coords.scrCoords[2])), o2.restore(), null;
        }, updateInternalText: function(t2) {
          this.drawInternalText(t2);
        }, setObjectStrokeColor: function(t2, e3, r2) {
          var o2, a2, h2, l2, c2 = s.evaluate(e3), d = s.evaluate(r2);
          d = d > 0 ? d : 0, t2.visPropOld.strokecolor === c2 && t2.visPropOld.strokeopacity === d || (s.exists(c2) && c2 !== false && (c2.length !== 9 ? (o2 = c2, h2 = d) : (a2 = n.rgba2rgbo(c2), o2 = a2[0], h2 = d * a2[1]), l2 = t2.rendNode, t2.elementClass === i.OBJECT_CLASS_TEXT && s.evaluate(t2.visProp.display) === "html" && (l2.style.color = o2, l2.style.opacity = h2)), t2.visPropOld.strokecolor = c2, t2.visPropOld.strokeopacity = d);
        }, drawImage: function(t2) {
          t2.rendNode = new Image(), t2._src = "", this.updateImage(t2);
        }, updateImage: function(t2) {
          var e3 = this.context, i2 = s.evaluate(t2.visProp.fillopacity), r2 = s.bind(function() {
            t2.imgIsLoaded = true, t2.size[0] <= 0 || t2.size[1] <= 0 || (e3.save(), e3.globalAlpha = i2, this.transformImage(t2, t2.transformations), e3.drawImage(t2.rendNode, t2.coords.scrCoords[1], t2.coords.scrCoords[2] - t2.size[1], t2.size[0], t2.size[1]), e3.restore());
          }, this);
          this.updateImageURL(t2) ? t2.rendNode.onload = r2 : t2.imgIsLoaded && r2();
        }, transformImage: function(t2, e3) {
          var i2, r2 = e3.length, s2 = this.context;
          r2 > 0 && (i2 = this.joinTransforms(t2, e3), Math.abs(c.det(i2)) >= h.eps && s2.transform(i2[1][1], i2[2][1], i2[1][2], i2[2][2], i2[1][0], i2[2][0]));
        }, updateImageURL: function(t2) {
          var e3;
          return e3 = s.evaluate(t2.url), t2._src !== e3 && (t2.imgIsLoaded = false, t2.rendNode.src = e3, t2._src = e3, true);
        }, remove: function(t2) {
          s.exists(t2) && s.exists(t2.parentNode) && t2.parentNode.removeChild(t2);
        }, updatePathStringPrim: function(t2) {
          var e3, i2, r2, s2, o2, n3 = "M", a2 = this.context;
          if (!(t2.numberPoints <= 0)) {
            if (o2 = Math.min(t2.points.length, t2.numberPoints), a2.beginPath(), t2.bezierDegree === 1)
              for (e3 = 0; e3 < o2; e3++)
                i2 = t2.points[e3].scrCoords, isNaN(i2[1]) || isNaN(i2[2]) ? n3 = "M" : (i2[1] > 5e3 ? i2[1] = 5e3 : i2[1] < -5e3 && (i2[1] = -5e3), i2[2] > 5e3 ? i2[2] = 5e3 : i2[2] < -5e3 && (i2[2] = -5e3), n3 === "M" ? a2.moveTo(i2[1], i2[2]) : a2.lineTo(i2[1], i2[2]), n3 = "L");
            else if (t2.bezierDegree === 3)
              for (e3 = 0; e3 < o2; )
                i2 = t2.points[e3].scrCoords, isNaN(i2[1]) || isNaN(i2[2]) ? n3 = "M" : (n3 === "M" ? a2.moveTo(i2[1], i2[2]) : (e3 += 1, r2 = t2.points[e3].scrCoords, e3 += 1, s2 = t2.points[e3].scrCoords, a2.bezierCurveTo(i2[1], i2[2], r2[1], r2[2], s2[1], s2[2])), n3 = "C"), e3 += 1;
            a2.lineCap = "round", this._fill(t2), this._stroke(t2);
          }
        }, updatePathStringBezierPrim: function(t2) {
          var e3, i2, r2, o2, n3, a2, h2, l2 = "M", d = s.evaluate(t2.visProp.strokewidth), u = s.evaluate(t2.visProp.curvetype) !== "plot", p = this.context;
          if (!(t2.numberPoints <= 0)) {
            for (u && t2.board.options.curve.RDPsmoothing && (t2.points = c.RamerDouglasPeucker(t2.points, 0.5)), h2 = Math.min(t2.points.length, t2.numberPoints), p.beginPath(), i2 = 1; i2 < 3; i2++)
              for (l2 = "M", e3 = 0; e3 < h2; e3++)
                o2 = t2.points[e3].scrCoords, isNaN(o2[1]) || isNaN(o2[2]) ? l2 = "M" : (o2[1] > 5e3 ? o2[1] = 5e3 : o2[1] < -5e3 && (o2[1] = -5e3), o2[2] > 5e3 ? o2[2] = 5e3 : o2[2] < -5e3 && (o2[2] = -5e3), l2 === "M" ? p.moveTo(o2[1], o2[2]) : (r2 = 2 * i2, p.bezierCurveTo(n3 + 0.333 * (o2[1] - n3) + d * (r2 * Math.random() - i2), a2 + 0.333 * (o2[2] - a2) + d * (r2 * Math.random() - i2), n3 + 0.666 * (o2[1] - n3) + d * (r2 * Math.random() - i2), a2 + 0.666 * (o2[2] - a2) + d * (r2 * Math.random() - i2), o2[1], o2[2])), l2 = "C", n3 = o2[1], a2 = o2[2]);
            p.lineCap = "round", this._fill(t2), this._stroke(t2);
          }
        }, updatePolygonPrim: function(t2, e3) {
          var i2, r2, s2, o2 = e3.vertices.length, n3 = this.context, a2 = true;
          if (!(o2 <= 0) && e3.visPropCalc.visible) {
            for (e3.elType === "polygonalchain" && o2++, n3.beginPath(), r2 = 0; !e3.vertices[r2].isReal && r2 < o2 - 1; )
              r2++, a2 = false;
            for (i2 = e3.vertices[r2].coords.scrCoords, n3.moveTo(i2[1], i2[2]), s2 = r2; s2 < o2 - 1; s2++)
              e3.vertices[s2].isReal || (a2 = false), i2 = e3.vertices[s2].coords.scrCoords, n3.lineTo(i2[1], i2[2]);
            n3.closePath(), a2 && this._fill(e3);
          }
        }, display: function(t2, e3) {
          t2 && t2.rendNode && (t2.visPropOld.visible = e3, t2.rendNode.style.visibility = e3 ? "inherit" : "hidden");
        }, show: function(e3) {
          t.deprecated("Board.renderer.show()", "Board.renderer.display()"), s.exists(e3.rendNode) && (e3.rendNode.style.visibility = "inherit");
        }, hide: function(e3) {
          t.deprecated("Board.renderer.hide()", "Board.renderer.display()"), s.exists(e3.rendNode) && (e3.rendNode.style.visibility = "hidden");
        }, setGradient: function(t2) {
          var e3;
          e3 = s.evaluate(t2.visProp.fillopacity), e3 = e3 > 0 ? e3 : 0, s.evaluate(t2.visProp.fillcolor);
        }, setShadow: function(t2) {
          t2.visPropOld.shadow !== t2.visProp.shadow && (t2.visPropOld.shadow = t2.visProp.shadow);
        }, highlight: function(t2) {
          return t2.elementClass === i.OBJECT_CLASS_TEXT && s.evaluate(t2.visProp.display) === "html" ? this.updateTextStyle(t2, true) : (t2.board.prepareUpdate(), t2.board.renderer.suspendRedraw(t2.board), t2.board.updateRenderer(), t2.board.renderer.unsuspendRedraw()), this;
        }, noHighlight: function(t2) {
          return t2.elementClass === i.OBJECT_CLASS_TEXT && s.evaluate(t2.visProp.display) === "html" ? this.updateTextStyle(t2, false) : (t2.board.prepareUpdate(), t2.board.renderer.suspendRedraw(t2.board), t2.board.updateRenderer(), t2.board.renderer.unsuspendRedraw()), this;
        }, suspendRedraw: function(e3) {
          this.context.save(), this.context.clearRect(0, 0, this.canvasRoot.width, this.canvasRoot.height), e3 && e3.attr.showcopyright && this.displayCopyright(t.licenseText, 12);
        }, unsuspendRedraw: function() {
          this.context.restore();
        }, resize: function(t2, e3) {
          this.container ? (this.canvasRoot.style.width = parseFloat(t2) + "px", this.canvasRoot.style.height = parseFloat(e3) + "px", this.canvasRoot.setAttribute("width", 2 * parseFloat(t2) + "px"), this.canvasRoot.setAttribute("height", 2 * parseFloat(e3) + "px")) : (this.canvasRoot.width = 2 * parseFloat(t2), this.canvasRoot.height = 2 * parseFloat(e3)), this.context = this.canvasRoot.getContext("2d"), this.context.scale(2, 2);
        }, removeToInsertLater: function() {
          return function() {
          };
        }}), t.CanvasRenderer;
      }), define("renderer/no", ["jxg", "renderer/abstract"], function(t, e2) {
        "use strict";
        return t.NoRenderer = function() {
          this.enhancedRendering = false, this.type = "no";
        }, t.extend(t.NoRenderer.prototype, {drawPoint: function(t2) {
        }, updatePoint: function(t2) {
        }, changePointStyle: function(t2) {
        }, drawLine: function(t2) {
        }, updateLine: function(t2) {
        }, drawTicks: function(t2) {
        }, updateTicks: function(t2) {
        }, drawCurve: function(t2) {
        }, updateCurve: function(t2) {
        }, drawEllipse: function(t2) {
        }, updateEllipse: function(t2) {
        }, drawPolygon: function(t2) {
        }, updatePolygon: function(t2) {
        }, displayCopyright: function(t2, e3) {
        }, drawInternalText: function(t2) {
        }, updateInternalText: function(t2) {
        }, drawText: function(t2) {
        }, updateText: function(t2) {
        }, updateTextStyle: function(t2, e3) {
        }, updateInternalTextStyle: function(t2, e3, i) {
        }, drawImage: function(t2) {
        }, updateImage: function(t2) {
        }, transformImage: function(t2, e3) {
        }, updateImageURL: function(t2) {
        }, appendChildPrim: function(t2, e3) {
        }, appendNodesToElement: function(t2, e3) {
        }, createPrim: function(t2, e3) {
          return null;
        }, remove: function(t2) {
        }, makeArrows: function(t2) {
        }, updateEllipsePrim: function(t2, e3, i, r, s) {
        }, updateLinePrim: function(t2, e3, i, r, s, o) {
        }, updatePathPrim: function(t2, e3, i) {
        }, updatePathStringPoint: function(t2, e3, i) {
        }, updatePathStringPrim: function(t2) {
        }, updatePathStringBezierPrim: function(t2) {
        }, updatePolygonPrim: function(t2, e3) {
        }, updateRectPrim: function(t2, e3, i, r, s) {
        }, setPropertyPrim: function(t2, e3, i) {
        }, display: function(t2, e3) {
          t2 && (t2.visPropOld.visible = e3);
        }, show: function(t2) {
        }, hide: function(t2) {
        }, setBuffering: function(t2, e3) {
        }, setDashStyle: function(t2) {
        }, setDraft: function(t2) {
        }, removeDraft: function(t2) {
        }, setGradient: function(t2) {
        }, updateGradient: function(t2) {
        }, setObjectTransition: function(t2, e3) {
        }, setObjectFillColor: function(t2, e3, i) {
        }, setObjectStrokeColor: function(t2, e3, i) {
        }, setObjectStrokeWidth: function(t2, e3) {
        }, setShadow: function(t2) {
        }, highlight: function(t2) {
        }, noHighlight: function(t2) {
        }, suspendRedraw: function() {
        }, unsuspendRedraw: function() {
        }, drawZoomBar: function(t2) {
        }, getElementById: function(t2) {
          return null;
        }, resize: function(t2, e3) {
        }, removeToInsertLater: function() {
          return function() {
          };
        }}), t.NoRenderer.prototype = new e2(), t.NoRenderer;
      }), define("jsxgraph", ["jxg", "utils/env", "utils/type", "base/board", "reader/file", "options", "renderer/svg", "renderer/vml", "renderer/canvas", "renderer/no"], function(t, e2, i, r, s, o, n, a, h, l) {
        "use strict";
        return t.JSXGraph = {rendererType: function() {
          return o.board.renderer = "no", e2.supportsVML() && (o.board.renderer = "vml", document.onmousemove = function() {
            var t2;
            return document.body && (t2 = document.body.scrollLeft, t2 += document.body.scrollTop), t2;
          }), e2.supportsCanvas() && (o.board.renderer = "canvas"), e2.supportsSVG() && (o.board.renderer = "svg"), e2.isNode() && e2.supportsCanvas() && (o.board.renderer = "canvas"), (e2.isNode() || o.renderer === "no") && (o.text.display = "internal", o.infobox.display = "internal"), o.board.renderer;
        }(), initRenderer: function(t2, e3, r2, s2) {
          var o2;
          if (i.exists(r2) && r2 !== false || typeof document != "object" || (r2 = document), typeof r2 == "object" && t2 !== null)
            for (o2 = r2.getElementById(t2); o2.firstChild; )
              o2.removeChild(o2.firstChild);
          else
            o2 = t2;
          return s2 !== void 0 && s2 !== "auto" || (s2 = this.rendererType), s2 === "svg" ? new n(o2, e3) : s2 === "vml" ? new a(o2) : s2 === "canvas" ? new h(o2, e3) : new l();
        }, _setAttributes: function(t2) {
          var e3 = i.copyAttributes(t2, o, "board");
          return e3.zoom = i.copyAttributes(e3, o, "board", "zoom"), e3.pan = i.copyAttributes(e3, o, "board", "pan"), e3.drag = i.copyAttributes(e3, o, "board", "drag"), e3.selection = i.copyAttributes(e3, o, "board", "selection"), e3.navbar = i.copyAttributes(e3.navbar, o, "navbar"), e3.screenshot = i.copyAttributes(e3, o, "board", "screenshot"), e3;
        }, _fillBoard: function(e3, i2, r2) {
          e3.initInfobox(), e3.maxboundingbox = i2.maxboundingbox, e3.resizeContainer(r2.width, r2.height, true, true), e3._createSelectionPolygon(i2), e3.renderer.drawZoomBar(e3, i2.navbar), t.boards[e3.id] = e3;
        }, _setARIA: function(t2, e3) {
          var i2, r2, s2, o2, n3, a2 = e3.document || document;
          typeof a2 == "object" && (i2 = a2.getElementById(t2), s2 = i2.parentNode, o2 = t2 + "_ARIAlabel", n3 = t2 + "_ARIAdescription", r2 = a2.createElement("div"), r2.innerHTML = e3.title, r2.setAttribute("id", o2), r2.style.display = "none", s2.insertBefore(r2, i2), r2 = a2.createElement("div"), r2.innerHTML = e3.description, r2.setAttribute("id", n3), r2.style.display = "none", s2.insertBefore(r2, i2), i2.setAttribute("aria-labelledby", o2), i2.setAttribute("aria-describedby", n3));
        }, _removeARIANodes: function(t2) {
          var e3, i2, r2;
          typeof (r2 = t2.document || document) == "object" && (i2 = t2.containerObj.getAttribute("aria-labelledby"), e3 = document.getElementById(i2), e3 && e3.parentNode && e3.parentNode.removeChild(e3), i2 = t2.containerObj.getAttribute("aria-describedby"), (e3 = document.getElementById(i2)) && e3.parentNode && e3.parentNode.removeChild(e3));
        }, initBoard: function(t2, s2) {
          var n3, a2, h2, l2, c, d, u, p, f, m, g, b, v, y;
          return s2 = s2 || {}, m = this._setAttributes(s2), p = e2.getDimensions(t2, m.document), m.unitx || m.unity ? (n3 = i.def(m.originx, 150), a2 = i.def(m.originy, 150), h2 = i.def(m.unitx, 50), l2 = i.def(m.unity, 50)) : (f = m.boundingbox, f[0] < m.maxboundingbox[0] && (f[0] = m.maxboundingbox[0]), f[1] > m.maxboundingbox[1] && (f[1] = m.maxboundingbox[1]), f[2] > m.maxboundingbox[2] && (f[2] = m.maxboundingbox[2]), f[3] < m.maxboundingbox[3] && (f[3] = m.maxboundingbox[3]), d = parseInt(p.width, 10), u = parseInt(p.height, 10), i.exists(f) && m.keepaspectratio ? (h2 = d / (f[2] - f[0]), l2 = u / (f[1] - f[3]), Math.abs(h2) < Math.abs(l2) ? l2 = Math.abs(h2) * l2 / Math.abs(l2) : h2 = Math.abs(l2) * h2 / Math.abs(h2)) : (h2 = d / (f[2] - f[0]), l2 = u / (f[1] - f[3])), n3 = -h2 * f[0], a2 = l2 * f[1]), c = this.initRenderer(t2, p, m.document, m.renderer), this._setARIA(t2, m), y = new r(t2, c, m.id, [n3, a2], m.zoomfactor * m.zoomx, m.zoomfactor * m.zoomy, h2, l2, p.width, p.height, m), y.keepaspectratio = m.keepaspectratio, this._fillBoard(y, m, p), y.suspendUpdate(), m.axis && (g = typeof m.axis == "object" ? m.axis : {}, b = i.deepCopy(o.board.defaultAxes.x, g), v = i.deepCopy(o.board.defaultAxes.y, g), m.defaultaxes.x && (b = i.deepCopy(b, m.defaultaxes.x)), m.defaultaxes.y && (v = i.deepCopy(v, m.defaultaxes.y)), y.defaultAxes = {}, y.defaultAxes.x = y.create("axis", [[0, 0], [1, 0]], b), y.defaultAxes.y = y.create("axis", [[0, 0], [0, 1]], v)), m.grid && y.create("grid", [], typeof m.grid == "object" ? m.grid : {}), y.unsuspendUpdate(), y;
        }, loadBoardFromFile: function(t2, i2, o2, n3, a2) {
          var h2, l2, c, d, u;
          return n3 = n3 || {}, h2 = this._setAttributes(n3), d = e2.getDimensions(t2, h2.document), l2 = this.initRenderer(t2, d, h2.document, h2.renderer), this._setARIA(t2, h2), c = new r(t2, l2, "", [150, 150], 1, 1, 50, 50, d.width, d.height, h2), this._fillBoard(c, h2, d), u = h2.encoding || "iso-8859-1", s.parseFileContent(i2, c, o2, true, u, a2), c;
        }, loadBoardFromString: function(t2, i2, o2, n3, a2) {
          var h2, l2, c, d;
          return n3 = n3 || {}, h2 = this._setAttributes(n3), d = e2.getDimensions(t2, h2.document), l2 = this.initRenderer(t2, d, h2.document), this._setARIA(t2, h2), c = new r(t2, l2, "", [150, 150], 1, 1, 50, 50, d.width, d.height, h2), this._fillBoard(c, h2, d), s.parseString(i2, c, o2, true, a2), c;
        }, freeBoard: function(e3) {
          var i2;
          typeof e3 == "string" && (e3 = t.boards[e3]), this._removeARIANodes(e3), e3.removeEventHandlers(), e3.suspendUpdate();
          for (i2 in e3.objects)
            e3.objects.hasOwnProperty(i2) && e3.objects[i2].remove();
          for (; e3.containerObj.firstChild; )
            e3.containerObj.removeChild(e3.containerObj.firstChild);
          for (i2 in e3.objects)
            e3.objects.hasOwnProperty(i2) && delete e3.objects[i2];
          delete e3.renderer, e3.jc.creator.clearCache(), delete e3.jc, delete t.boards[e3.id];
        }, registerElement: function(e3, i2) {
          t.deprecated("JXG.JSXGraph.registerElement()", "JXG.registerElement()"), t.registerElement(e3, i2);
        }}, e2.isBrowser && typeof window == "object" && typeof document == "object" && e2.addEvent(window, "load", function() {
          var e3, r2, s2, o2, n3, a2, h2, l2, c, d, u, p, f = document.getElementsByTagName("script"), m = function(e4, i2, r3) {
            var s3 = t.JSXGraph.initBoard(n3, {boundingbox: r3, keepaspectratio: true, grid: u, axis: d, showReload: true});
            if (i2.toLowerCase().indexOf("script") > -1)
              s3.construct(e4);
            else
              try {
                s3.jc.parse(e4);
              } catch (e5) {
                t.debug(e5);
              }
            return s3;
          }, g = function(e4, i2, r3, s3) {
            return function() {
              var o3;
              t.JSXGraph.freeBoard(e4), o3 = m(i2, r3, s3), o3.reload = g(o3, i2, r3, s3);
            };
          };
          for (r2 = 0; r2 < f.length; r2++)
            if (e3 = f[r2].getAttribute("type", false), i.exists(e3) && (e3.toLowerCase() === "text/jessiescript" || e3.toLowerCase() === "jessiescript" || e3.toLowerCase() === "text/jessiecode" || e3.toLowerCase() === "jessiecode")) {
              if (h2 = f[r2].getAttribute("width", false) || "500px", l2 = f[r2].getAttribute("height", false) || "500px", c = f[r2].getAttribute("boundingbox", false) || "-5, 5, 5, -5", n3 = f[r2].getAttribute("container", false), c = c.split(","), c.length !== 4)
                c = [-5, 5, 5, -5];
              else
                for (s2 = 0; s2 < c.length; s2++)
                  c[s2] = parseFloat(c[s2]);
              if (d = i.str2Bool(f[r2].getAttribute("axis", false) || "false"), u = i.str2Bool(f[r2].getAttribute("grid", false) || "false"), i.exists(n3))
                o2 = document.getElementById(n3);
              else {
                n3 = "jessiescript_autgen_jxg_" + r2, o2 = document.createElement("div"), o2.setAttribute("id", n3), o2.setAttribute("style", "width:" + h2 + "; height:" + l2 + "; float:left"), o2.setAttribute("class", "jxgbox");
                try {
                  document.body.insertBefore(o2, f[r2]);
                } catch (t2) {
                  typeof jQuery == "object" && jQuery(o2).insertBefore(f[r2]);
                }
              }
              document.getElementById(n3) ? (p = f[r2].innerHTML, p = p.replace(/<!\[CDATA\[/g, "").replace(/\]\]>/g, ""), f[r2].innerHTML = p, a2 = m(p, e3, c), a2.reload = g(a2, p, e3, c)) : t.debug("JSXGraph: Apparently the div injection failed. Can't create a board, sorry.");
            }
        }, window), t.JSXGraph;
      }), define("base/group", ["jxg", "base/constants", "math/math", "math/geometry", "utils/type"], function(t, e2, i, r, s) {
        "use strict";
        return t.Group = function(t2, i2, r2, o, n) {
          var a, h, l, c;
          for (this.board = t2, this.objects = {}, a = this.board.numObjects, this.board.numObjects += 1, i2 !== "" && s.exists(i2) ? this.id = i2 : this.id = this.board.id + "Group" + a, this.board.groups[this.id] = this, this.type = e2.OBJECT_TYPE_POINT, this.elementClass = e2.OBJECT_CLASS_POINT, r2 !== "" && s.exists(r2) ? this.name = r2 : this.name = "group_" + this.board.generateName(this), delete this.type, this.coords = {}, this.needsRegularUpdate = n.needsregularupdate, this.rotationCenter = "centroid", this.scaleCenter = null, this.rotationPoints = [], this.translationPoints = [], this.scalePoints = [], this.scaleDirections = {}, this.parents = [], h = s.isArray(o) ? o : Array.prototype.slice.call(arguments, 3), l = 0; l < h.length; l++)
            c = this.board.select(h[l]), !s.evaluate(c.visProp.fixed) && s.exists(c.coords) && this.addPoint(c);
          this.methodMap = {ungroup: "ungroup", add: "addPoint", addPoint: "addPoint", addPoints: "addPoints", addGroup: "addGroup", remove: "removePoint", removePoint: "removePoint", setAttribute: "setAttribute", setProperty: "setAttribute"};
        }, t.extend(t.Group.prototype, {ungroup: function() {
          var t2, e3, i2;
          for (t2 in this.objects)
            this.objects.hasOwnProperty(t2) && (e3 = this.objects[t2].point, s.isArray(e3.groups) && (i2 = s.indexOf(e3.groups, this.id)) >= 0 && delete e3.groups[i2]);
          return this.objects = {}, this;
        }, addParents: function(t2) {
          var e3, i2, r2;
          for (r2 = s.isArray(t2) ? t2 : arguments, i2 = r2.length, e3 = 0; e3 < i2; ++e3)
            s.isId(this.board, r2[e3]) ? this.parents.push(r2[e3]) : s.exists(r2[e3].id) && this.parents.push(r2[e3].id);
          this.parents = s.uniqueArray(this.parents);
        }, setParents: function(t2) {
          this.parents = [], this.addParents(t2);
        }, getParents: function() {
          return s.isArray(this.parents) ? this.parents : [];
        }, _updateCoordsCache: function(t2) {
          var e3;
          t2 !== "" && s.exists(this.objects[t2]) && (e3 = this.objects[t2].point, this.coords[e3.id] = {usrCoords: e3.coords.usrCoords.slice(0)});
        }, update: function(t2) {
          var e3, o, n, a, h, l, c, d, u, p = null;
          if (!this.needsUpdate)
            return this;
          if (t2 = this._update_find_drag_type(), t2.action === "nothing")
            return this._updateCoordsCache(t2.id), this;
          if (p = this.objects[t2.id].point, t2.action === "translation")
            d = [p.coords.usrCoords[1] - this.coords[t2.id].usrCoords[1], p.coords.usrCoords[2] - this.coords[t2.id].usrCoords[2]];
          else if (t2.action === "rotation" || t2.action === "scaling") {
            if (o = t2.action === "rotation" ? "rotationCenter" : "scaleCenter", s.isPoint(this[o]))
              u = this[o].coords.usrCoords.slice(1);
            else if (this[o] === "centroid")
              u = this._update_centroid_center();
            else if (s.isArray(this[o]))
              u = this[o];
            else {
              if (!s.isFunction(this[o]))
                return this;
              u = this[o]();
            }
            if (t2.action === "rotation")
              c = r.rad(this.coords[t2.id].usrCoords.slice(1), u, this.objects[t2.id].point), d = this.board.create("transform", [c, u[0], u[1]], {type: "rotate"}), d.update();
            else {
              if (t2.action !== "scaling")
                return this;
              if (a = r.distance(this.coords[t2.id].usrCoords.slice(1), u), Math.abs(a) < i.eps)
                return this;
              a = r.distance(p.coords.usrCoords.slice(1), u) / a, h = this.scaleDirections[t2.id].indexOf("x") >= 0 ? a : 1, l = this.scaleDirections[t2.id].indexOf("y") >= 0 ? a : 1, d = this.board.create("transform", [1, 0, 0, u[0] * (1 - h), h, 0, u[1] * (1 - l), 0, l], {type: "generic"}), d.update();
            }
          }
          this._update_apply_transformation(t2, d), this.needsUpdate = false;
          for (e3 in this.objects)
            if (this.objects.hasOwnProperty(e3))
              for (n in this.objects[e3].descendants)
                this.objects[e3].descendants.hasOwnProperty(n) && (this.objects[e3].descendants.needsUpdate = this.objects[e3].descendants.needsRegularUpdate || this.board.needsFullUpdate);
          this.board.updateElements(t2);
          for (e3 in this.objects)
            this.objects.hasOwnProperty(e3) && this._updateCoordsCache(e3);
          return this;
        }, _update_find_drag_type: function() {
          var t2, r2, o, n = "nothing", a = [];
          for (t2 in this.objects)
            this.objects.hasOwnProperty(t2) && (r2 = this.objects[t2].point, r2.coords.distance(e2.COORDS_BY_USER, this.coords[t2]) > i.eps && a.push(r2.id));
          return a.length === 0 ? {action: n, id: "", changed: a} : (o = a[0], r2 = this.objects[o].point, a.length > 1 ? n = "translation" : s.isInArray(this.rotationPoints, r2) && s.exists(this.rotationCenter) ? n = "rotation" : s.isInArray(this.scalePoints, r2) && s.exists(this.scaleCenter) ? n = "scaling" : s.isInArray(this.translationPoints, r2) && (n = "translation"), {action: n, id: o, changed: a});
        }, _update_centroid_center: function() {
          var t2, e3, i2;
          t2 = [0, 0], e3 = 0;
          for (i2 in this.coords)
            this.coords.hasOwnProperty(i2) && (t2[0] += this.coords[i2].usrCoords[1], t2[1] += this.coords[i2].usrCoords[2], ++e3);
          return e3 > 0 && (t2[0] /= e3, t2[1] /= e3), t2;
        }, _update_apply_transformation: function(t2, r2) {
          var o, n;
          for (o in this.objects)
            this.objects.hasOwnProperty(o) && (s.exists(this.board.objects[o]) ? (n = this.objects[o].point, n.id !== t2.id ? t2.action === "translation" ? s.isInArray(t2.changed, n.id) || n.coords.setCoordinates(e2.COORDS_BY_USER, [this.coords[o].usrCoords[1] + r2[0], this.coords[o].usrCoords[2] + r2[1]]) : t2.action !== "rotation" && t2.action !== "scaling" || r2.applyOnce([n]) : t2.action !== "rotation" && t2.action !== "scaling" || n.coords.setCoordinates(e2.COORDS_BY_USER, i.matVecMult(r2.matrix, this.coords[n.id].usrCoords))) : delete this.objects[o]);
        }, addPoint: function(t2) {
          return this.objects[t2.id] = {point: this.board.select(t2)}, this._updateCoordsCache(t2.id), this.translationPoints.push(t2), t2.groups.push(this.id), t2.groups = s.uniqueArray(t2.groups), this;
        }, addPoints: function(t2) {
          var e3;
          for (e3 = 0; e3 < t2.length; e3++)
            this.addPoint(t2[e3]);
          return this;
        }, addGroup: function(t2) {
          var e3;
          for (e3 in t2.objects)
            t2.objects.hasOwnProperty(e3) && this.addPoint(t2.objects[e3].point);
          return this;
        }, removePoint: function(t2) {
          return delete this.objects[t2.id], this;
        }, setRotationCenter: function(t2) {
          return this.rotationCenter = t2, this;
        }, setRotationPoints: function(t2) {
          return this._setActionPoints("rotation", t2);
        }, addRotationPoint: function(t2) {
          return this._addActionPoint("rotation", t2);
        }, removeRotationPoint: function(t2) {
          return this._removeActionPoint("rotation", t2);
        }, setTranslationPoints: function(t2) {
          return this._setActionPoints("translation", t2);
        }, addTranslationPoint: function(t2) {
          return this._addActionPoint("translation", t2);
        }, removeTranslationPoint: function(t2) {
          return this._removeActionPoint("translation", t2);
        }, setScaleCenter: function(t2) {
          return this.scaleCenter = t2, this;
        }, setScalePoints: function(t2, e3) {
          var i2, r2, o;
          for (i2 = s.isArray(t2) ? t2 : arguments, o = i2.length, r2 = 0; r2 < o; ++r2)
            this.scaleDirections[this.board.select(i2[r2]).id] = e3 || "xy";
          return this._setActionPoints("scale", t2);
        }, addScalePoint: function(t2, e3) {
          return this._addActionPoint("scale", t2), this.scaleDirections[this.board.select(t2).id] = e3 || "xy", this;
        }, removeScalePoint: function(t2) {
          return this._removeActionPoint("scale", t2);
        }, _setActionPoints: function(t2, e3) {
          var i2, r2, o;
          for (i2 = s.isArray(e3) ? e3 : arguments, o = i2.length, this[t2 + "Points"] = [], r2 = 0; r2 < o; ++r2)
            this._addActionPoint(t2, i2[r2]);
          return this;
        }, _addActionPoint: function(t2, e3) {
          return this[t2 + "Points"].push(this.board.select(e3)), this;
        }, _removeActionPoint: function(t2, e3) {
          var i2 = this[t2 + "Points"].indexOf(this.board.select(e3));
          return i2 > -1 && this[t2 + "Points"].splice(i2, 1), this;
        }, setProperty: function() {
          t.deprecated("Group.setProperty", "Group.setAttribute()"), this.setAttribute.apply(this, arguments);
        }, setAttribute: function() {
          var t2;
          for (t2 in this.objects)
            this.objects.hasOwnProperty(t2) && this.objects[t2].point.setAttribute.apply(this.objects[t2].point, arguments);
          return this;
        }}), t.createGroup = function(e3, i2, r2) {
          var o = s.copyAttributes(r2, e3.options, "group"), n = new t.Group(e3, o.id, o.name, i2, o);
          return n.elType = "group", n.setParents(i2), n;
        }, t.registerElement("group", t.createGroup), {Group: t.Group, createGroup: t.createGroup};
      }), define("element/arc", ["jxg", "math/geometry", "math/math", "base/coords", "base/circle", "utils/type", "base/constants"], function(t, e2, i, r, s, o, n) {
        "use strict";
        return t.createArc = function(a, h, l) {
          var c, d, u;
          if ((u = o.providePoints(a, h, l, "arc", ["center", "radiusPoint", "anglePoint"])) === false || u.length < 3)
            throw new Error("JSXGraph: Can't create Arc with parent types '" + typeof h[0] + "' and '" + typeof h[1] + "' and '" + typeof h[2] + "'.\nPossible parent types: [point,point,point], [arc, transformation]");
          return d = o.copyAttributes(l, a.options, "arc"), c = a.create("curve", [[0], [0]], d), c.elType = "arc", c.setParents(u), c.type = n.OBJECT_TYPE_ARC, c.center = u[0], c.radiuspoint = u[1], c.point2 = c.radiuspoint, c.anglepoint = u[2], c.point3 = c.anglepoint, c.center.addChild(c), c.radiuspoint.addChild(c), c.anglepoint.addChild(c), c.useDirection = d.usedirection, c.updateDataArray = function() {
            var t2, i2, r2, s2, n3, a2, h2 = 1, l2 = this.radiuspoint, c2 = this.center, d2 = this.anglepoint, p = o.evaluate(this.visProp.selection);
            i2 = e2.rad(l2, c2, d2), (p === "minor" && i2 > Math.PI || p === "major" && i2 < Math.PI) && (h2 = -1), this.useDirection && (s2 = u[1].coords.usrCoords, n3 = u[3].coords.usrCoords, a2 = u[2].coords.usrCoords, r2 = (s2[1] - a2[1]) * (s2[2] - n3[2]) - (s2[2] - a2[2]) * (s2[1] - n3[1]), r2 < 0 ? (this.radiuspoint = u[1], this.anglepoint = u[2]) : (this.radiuspoint = u[2], this.anglepoint = u[1])), l2 = l2.coords.usrCoords, c2 = c2.coords.usrCoords, d2 = d2.coords.usrCoords, t2 = e2.bezierArc(l2, c2, d2, false, h2), this.dataX = t2[0], this.dataY = t2[1], this.bezierDegree = 3, this.updateStdform(), this.updateQuadraticform();
          }, c.Radius = function() {
            return this.radiuspoint.Dist(this.center);
          }, c.getRadius = function() {
            return t.deprecated("Arc.getRadius()", "Arc.Radius()"), this.Radius();
          }, c.Value = function() {
            return this.Radius() * e2.rad(this.radiuspoint, this.center, this.anglepoint);
          }, c.hasPoint = function(t2, s2) {
            var a2, h2, l2, c2, d2, u2, p, f, m, g, b = this.Radius(), v = o.evaluate(this.visProp.selection);
            return o.evaluate(this.visProp.hasinnerpoints) ? this.hasPointSector(t2, s2) : (o.isObject(o.evaluate(this.visProp.precision)) ? (g = this.board._inputDevice, m = o.evaluate(this.visProp.precision[g])) : m = this.board.options.precision.hasPoint, m /= Math.min(this.board.unitX, this.board.unitY), h2 = new r(n.COORDS_BY_SCREEN, [t2, s2], this.board), this.transformations.length > 0 && (this.updateTransformMatrix(), p = i.inverse(this.transformMat), f = i.matVecMult(p, h2.usrCoords), h2 = new r(n.COORDS_BY_USER, f, this.board)), a2 = this.center.coords.distance(n.COORDS_BY_USER, h2), l2 = Math.abs(a2 - b) < m, l2 && (c2 = e2.rad(this.radiuspoint, this.center, h2.usrCoords.slice(1)), d2 = 0, u2 = e2.rad(this.radiuspoint, this.center, this.anglepoint), (v === "minor" && u2 > Math.PI || v === "major" && u2 < Math.PI) && (d2 = u2, u2 = 2 * Math.PI), (c2 < d2 || c2 > u2) && (l2 = false)), l2);
          }, c.hasPointSector = function(t2, i2) {
            var s2, a2, h2, l2 = new r(n.COORDS_BY_SCREEN, [t2, i2], this.board), c2 = this.Radius(), d2 = this.center.coords.distance(n.COORDS_BY_USER, l2), u2 = d2 < c2, p = o.evaluate(this.visProp.selection);
            return u2 && (s2 = e2.rad(this.radiuspoint, this.center, l2.usrCoords.slice(1)), a2 = 0, h2 = e2.rad(this.radiuspoint, this.center, this.anglepoint), (p === "minor" && h2 > Math.PI || p === "major" && h2 < Math.PI) && (a2 = h2, h2 = 2 * Math.PI), (s2 < a2 || s2 > h2) && (u2 = false)), u2;
          }, c.getTextAnchor = function() {
            return this.center.coords;
          }, c.getLabelAnchor = function() {
            var t2, i2, s2, a2, h2, l2 = e2.rad(this.radiuspoint, this.center, this.anglepoint), c2 = 10 / this.board.unitX, d2 = 10 / this.board.unitY, u2 = this.point2.coords.usrCoords, p = this.center.coords.usrCoords, f = u2[1] - p[1], m = u2[2] - p[2], g = o.evaluate(this.visProp.selection), b = this.label ? this.label.visProp : this.visProp.label;
            return (g === "minor" && l2 > Math.PI || g === "major" && l2 < Math.PI) && (l2 = -(2 * Math.PI - l2)), t2 = new r(n.COORDS_BY_USER, [p[1] + Math.cos(0.5 * l2) * f - Math.sin(0.5 * l2) * m, p[2] + Math.sin(0.5 * l2) * f + Math.cos(0.5 * l2) * m], this.board), s2 = t2.usrCoords[1] - p[1], a2 = t2.usrCoords[2] - p[2], h2 = Math.sqrt(s2 * s2 + a2 * a2), s2 = s2 * (h2 + c2) / h2, a2 = a2 * (h2 + d2) / h2, i2 = [p[1] + s2, p[2] + a2], b.position = e2.calcLabelQuadrant(e2.rad([1, 0], [0, 0], i2)), new r(n.COORDS_BY_USER, i2, this.board);
          }, c.updateQuadraticform = s.Circle.prototype.updateQuadraticform, c.updateStdform = s.Circle.prototype.updateStdform, c.methodMap = t.deepCopy(c.methodMap, {getRadius: "getRadius", radius: "Radius", center: "center", radiuspoint: "radiuspoint", anglepoint: "anglepoint", Value: "Value"}), c.prepareUpdate().update(), c;
        }, t.registerElement("arc", t.createArc), t.createSemicircle = function(t2, e3, i2) {
          var r2, s2, n3, a;
          if ((a = o.providePoints(t2, e3, i2, "point")) === false || a.length !== 2)
            throw new Error("JSXGraph: Can't create Semicircle with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [point,point]");
          return n3 = o.copyAttributes(i2, t2.options, "semicircle", "center"), s2 = t2.create("midpoint", a, n3), s2.dump = false, n3 = o.copyAttributes(i2, t2.options, "semicircle"), r2 = t2.create("arc", [s2, a[1], a[0]], n3), r2.elType = "semicircle", r2.setParents([a[0].id, a[1].id]), r2.subs = {midpoint: s2}, r2.inherits.push(s2), r2.midpoint = r2.center = s2, r2;
        }, t.registerElement("semicircle", t.createSemicircle), t.createCircumcircleArc = function(t2, e3, i2) {
          var r2, s2, n3, a;
          if ((a = o.providePoints(t2, e3, i2, "point")) === false || a.length !== 3)
            throw new Error("JSXGraph: create Circumcircle Arc with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "' and '" + typeof e3[2] + "'.\nPossible parent types: [point,point,point]");
          return n3 = o.copyAttributes(i2, t2.options, "circumcirclearc", "center"), s2 = t2.create("circumcenter", a, n3), s2.dump = false, n3 = o.copyAttributes(i2, t2.options, "circumcirclearc"), n3.usedirection = true, r2 = t2.create("arc", [s2, a[0], a[2], a[1]], n3), r2.elType = "circumcirclearc", r2.setParents([a[0].id, a[1].id, a[2].id]), r2.subs = {center: s2}, r2.inherits.push(s2), r2.center = s2, r2;
        }, t.registerElement("circumcirclearc", t.createCircumcircleArc), t.createMinorArc = function(e3, i2, r2) {
          return r2.selection = "minor", t.createArc(e3, i2, r2);
        }, t.registerElement("minorarc", t.createMinorArc), t.createMajorArc = function(e3, i2, r2) {
          return r2.selection = "major", t.createArc(e3, i2, r2);
        }, t.registerElement("majorarc", t.createMajorArc), {createArc: t.createArc, createSemicircle: t.createSemicircle, createCircumcircleArc: t.createCircumcircleArc, createMinorArc: t.createMinorArc, createMajorArc: t.createMajorArc};
      }), define("element/sector", ["jxg", "math/geometry", "math/math", "math/statistics", "base/coords", "base/constants", "utils/type", "base/point", "base/curve", "base/transformation", "element/composition"], function(t, e2, i, r, s, o, n, a, h, l, c) {
        "use strict";
        return t.createSector = function(a2, h2, l2) {
          var c2, d, u, p, f, m = "invalid", g = ["center", "radiusPoint", "anglePoint"];
          if (h2[0].elementClass === o.OBJECT_CLASS_LINE && h2[1].elementClass === o.OBJECT_CLASS_LINE && (n.isArray(h2[2]) || n.isNumber(h2[2])) && (n.isArray(h2[3]) || n.isNumber(h2[3])) && (n.isNumber(h2[4]) || n.isFunction(h2[4])))
            m = "2lines";
          else {
            if ((f = n.providePoints(a2, h2, l2, "sector", g)) === false)
              throw new Error("JSXGraph: Can't create Sector with parent types '" + typeof h2[0] + "' and '" + typeof h2[1] + "' and '" + typeof h2[2] + "'.");
            m = "3points";
          }
          return d = n.copyAttributes(l2, a2.options, "sector"), c2 = a2.create("curve", [[0], [0]], d), c2.type = o.OBJECT_TYPE_SECTOR, c2.elType = "sector", m === "2lines" ? (c2.Radius = function() {
            return n.evaluate(h2[4]);
          }, c2.line1 = a2.select(h2[0]), c2.line2 = a2.select(h2[1]), c2.line1.addChild(c2), c2.line2.addChild(c2), c2.setParents(h2), c2.point1 = {visProp: {}}, c2.point2 = {visProp: {}}, c2.point3 = {visProp: {}}, u = e2.meetLineLine(c2.line1.stdform, c2.line2.stdform, 0, a2), n.isArray(h2[2]) ? (h2[2].length === 2 && (h2[2] = [1].concat(h2[2])), p = e2.projectPointToLine({coords: {usrCoords: h2[2]}}, c2.line1, a2), p = r.subtract(p.usrCoords, u.usrCoords), c2.direction1 = i.innerProduct(p, [0, c2.line1.stdform[2], -c2.line1.stdform[1]], 3) >= 0 ? 1 : -1) : c2.direction1 = h2[2] >= 0 ? 1 : -1, n.isArray(h2[3]) ? (h2[3].length === 2 && (h2[3] = [1].concat(h2[3])), p = e2.projectPointToLine({coords: {usrCoords: h2[3]}}, c2.line2, a2), p = r.subtract(p.usrCoords, u.usrCoords), c2.direction2 = i.innerProduct(p, [0, c2.line2.stdform[2], -c2.line2.stdform[1]], 3) >= 0 ? 1 : -1) : c2.direction2 = h2[3] >= 0 ? 1 : -1, c2.updateDataArray = function() {
            var t2, n3, a3, h3, l3 = [0, 0, 0], d2 = [0, 0, 0], u2 = [0, 0, 0];
            if (n3 = this.line1, a3 = this.line2, d2 = i.crossProduct(n3.stdform, a3.stdform), Math.abs(d2[0]) > i.eps * i.eps && (d2[1] /= d2[0], d2[2] /= d2[0], d2[0] /= d2[0]), t2 = this.direction1 * this.Radius(), l3 = r.add(d2, [0, t2 * n3.stdform[2], -t2 * n3.stdform[1]]), t2 = this.direction2 * this.Radius(), u2 = r.add(d2, [0, t2 * a3.stdform[2], -t2 * a3.stdform[1]]), this.point2.coords = new s(o.COORDS_BY_USER, l3, c2.board), this.point1.coords = new s(o.COORDS_BY_USER, d2, c2.board), this.point3.coords = new s(o.COORDS_BY_USER, u2, c2.board), Math.abs(l3[0]) < i.eps || Math.abs(d2[0]) < i.eps || Math.abs(u2[0]) < i.eps)
              return this.dataX = [NaN], void (this.dataY = [NaN]);
            h3 = e2.bezierArc(l3, d2, u2, true, 1), this.dataX = h3[0], this.dataY = h3[1], this.bezierDegree = 3;
          }, c2.methodMap = t.deepCopy(c2.methodMap, {radius: "getRadius", getRadius: "getRadius", setRadius: "setRadius"}), c2.prepareUpdate().update()) : m === "3points" && (c2.point1 = f[0], c2.point2 = f[1], c2.point3 = f[2], c2.point1.addChild(c2), c2.point2.addChild(c2), c2.point3.addChild(c2), c2.useDirection = l2.usedirection, c2.setParents(f), n.exists(f[3]) && (c2.point4 = f[3], c2.point4.addChild(c2)), c2.methodMap = t.deepCopy(c2.methodMap, {arc: "arc", center: "center", radiuspoint: "radiuspoint", anglepoint: "anglepoint", radius: "getRadius", getRadius: "getRadius", setRadius: "setRadius"}), c2.updateDataArray = function() {
            var t2, i2, r2, s2, o2, a3 = this.point2, h3 = this.point1, l3 = this.point3, c3 = 1, d2 = n.evaluate(this.visProp.selection);
            if (!a3.isReal || !h3.isReal || !l3.isReal)
              return this.dataX = [NaN], void (this.dataY = [NaN]);
            o2 = e2.rad(a3, h3, l3), (d2 === "minor" && o2 > Math.PI || d2 === "major" && o2 < Math.PI) && (c3 = -1), this.useDirection && n.exists(this.point4) && (i2 = this.point2.coords.usrCoords, r2 = this.point4.coords.usrCoords, s2 = this.point3.coords.usrCoords, (i2[1] - s2[1]) * (i2[2] - r2[2]) - (i2[2] - s2[2]) * (i2[1] - r2[1]) >= 0 && (l3 = this.point2, a3 = this.point3)), a3 = a3.coords.usrCoords, h3 = h3.coords.usrCoords, l3 = l3.coords.usrCoords, t2 = e2.bezierArc(a3, h3, l3, true, c3), this.dataX = t2[0], this.dataY = t2[1], this.bezierDegree = 3;
          }, c2.Radius = function() {
            return this.point2.Dist(this.point1);
          }, d = n.copyAttributes(l2, a2.options, "sector", "arc"), d.withLabel = false, d.name += "_arc", c2.arc = a2.create("arc", [c2.point1, c2.point2, c2.point3], d), c2.addChild(c2.arc)), c2.center = c2.point1, c2.radiuspoint = c2.point2, c2.anglepoint = c2.point3, c2.hasPointCurve = function(t2, i2) {
            var r2, a3, h3, l3, c3, d2, u2 = new s(o.COORDS_BY_SCREEN, [t2, i2], this.board), p2 = this.Radius(), f2 = this.center.coords.distance(o.COORDS_BY_USER, u2), m2 = n.evaluate(this.visProp.selection);
            return n.isObject(n.evaluate(this.visProp.precision)) ? (c3 = this.board._inputDevice, l3 = n.evaluate(this.visProp.precision[c3])) : l3 = this.board.options.precision.hasPoint, l3 /= Math.min(this.board.unitX, this.board.unitY), d2 = Math.abs(f2 - p2) < l3, d2 && (r2 = e2.rad(this.point2, this.center, u2.usrCoords.slice(1)), a3 = 0, h3 = e2.rad(this.point2, this.center, this.point3), (m2 === "minor" && h3 > Math.PI || m2 === "major" && h3 < Math.PI) && (a3 = h3, h3 = 2 * Math.PI), (r2 < a3 || r2 > h3) && (d2 = false)), d2;
          }, c2.hasPointSector = function(t2, i2) {
            var r2, a3, h3, l3 = new s(o.COORDS_BY_SCREEN, [t2, i2], this.board), c3 = this.Radius(), d2 = this.point1.coords.distance(o.COORDS_BY_USER, l3), u2 = d2 < c3, p2 = n.evaluate(this.visProp.selection);
            return u2 && (r2 = e2.rad(this.radiuspoint, this.center, l3.usrCoords.slice(1)), a3 = 0, h3 = e2.rad(this.radiuspoint, this.center, this.anglepoint), (p2 === "minor" && h3 > Math.PI || p2 === "major" && h3 < Math.PI) && (a3 = h3, h3 = 2 * Math.PI), (r2 < a3 || r2 > h3) && (u2 = false)), u2;
          }, c2.hasPoint = function(t2, e3) {
            return n.evaluate(this.visProp.highlightonsector) || n.evaluate(this.visProp.hasinnerpoints) ? this.hasPointSector(t2, e3) : this.hasPointCurve(t2, e3);
          }, c2.getTextAnchor = function() {
            return this.point1.coords;
          }, c2.getLabelAnchor = function() {
            var t2, i2, r2, a3, h3, l3 = e2.rad(this.point2, this.point1, this.point3), c3 = 13 / this.board.unitX, d2 = 13 / this.board.unitY, u2 = this.point2.coords.usrCoords, p2 = this.point1.coords.usrCoords, f2 = u2[1] - p2[1], m2 = u2[2] - p2[2], g2 = n.evaluate(this.visProp.selection), b = this.label ? this.label.visProp : this.visProp.label;
            return (g2 === "minor" && l3 > Math.PI || g2 === "major" && l3 < Math.PI) && (l3 = -(2 * Math.PI - l3)), t2 = new s(o.COORDS_BY_USER, [p2[1] + Math.cos(0.5 * l3) * f2 - Math.sin(0.5 * l3) * m2, p2[2] + Math.sin(0.5 * l3) * f2 + Math.cos(0.5 * l3) * m2], this.board), r2 = t2.usrCoords[1] - p2[1], a3 = t2.usrCoords[2] - p2[2], h3 = Math.sqrt(r2 * r2 + a3 * a3), r2 = r2 * (h3 + c3) / h3, a3 = a3 * (h3 + d2) / h3, i2 = [p2[1] + r2, p2[2] + a3], b.position = e2.calcLabelQuadrant(e2.rad([1, 0], [0, 0], i2)), new s(o.COORDS_BY_USER, i2, this.board);
          }, c2.setRadius = function(t2) {
            c2.Radius = function() {
              return n.evaluate(t2);
            };
          }, c2.getRadius = function() {
            return t.deprecated("Sector.getRadius()", "Sector.Radius()"), this.Radius();
          }, m === "3points" && (c2.setPositionDirectly = function(t2, e3, i2) {
            var o2, n3, a3 = new s(t2, e3, this.board), h3 = new s(t2, i2, this.board);
            return c2.point1.draggable() && c2.point2.draggable() && c2.point3.draggable() ? (o2 = r.subtract(a3.usrCoords, h3.usrCoords), n3 = this.board.create("transform", o2.slice(1), {type: "translate"}), n3.applyOnce([c2.point1, c2.point2, c2.point3]), this) : this;
          }), c2.prepareUpdate().update(), c2;
        }, t.registerElement("sector", t.createSector), t.createCircumcircleSector = function(t2, e3, i2) {
          var r2, s2, o2, a2;
          if ((a2 = n.providePoints(t2, e3, i2, "point")) === false)
            throw new Error("JSXGraph: Can't create circumcircle sector with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "' and '" + typeof e3[2] + "'.");
          return s2 = t2.create("circumcenter", a2.slice(0, 3), o2), s2.dump = false, o2 = n.copyAttributes(i2, t2.options, "circumcirclesector"), r2 = t2.create("sector", [s2, a2[0], a2[2], a2[1]], o2), r2.elType = "circumcirclesector", r2.setParents(a2), r2.center = s2, r2.subs = {center: s2}, r2;
        }, t.registerElement("circumcirclesector", t.createCircumcircleSector), t.createMinorSector = function(e3, i2, r2) {
          return r2.selection = "minor", t.createSector(e3, i2, r2);
        }, t.registerElement("minorsector", t.createMinorSector), t.createMajorSector = function(e3, i2, r2) {
          return r2.selection = "major", t.createSector(e3, i2, r2);
        }, t.registerElement("majorsector", t.createMajorSector), t.createAngle = function(t2, r2, a2) {
          var h2, l2, c2, d, u, p, f = "invalid";
          if (r2[0].elementClass === o.OBJECT_CLASS_LINE && r2[1].elementClass === o.OBJECT_CLASS_LINE && (n.isArray(r2[2]) || n.isNumber(r2[2])) && (n.isArray(r2[3]) || n.isNumber(r2[3])))
            f = "2lines";
          else {
            if ((p = n.providePoints(t2, r2, a2, "point")) === false)
              throw new Error("JSXGraph: Can't create angle with parent types '" + typeof r2[0] + "' and '" + typeof r2[1] + "' and '" + typeof r2[2] + "'.");
            f = "3points";
          }
          if (c2 = n.copyAttributes(a2, t2.options, "angle"), n.exists(c2.name) && c2.name !== "" || (c2.name = t2.generateName({type: o.OBJECT_TYPE_ANGLE})), l2 = n.exists(c2.radius) ? c2.radius : 0, f === "2lines" ? (r2.push(l2), h2 = t2.create("sector", r2, c2), h2.updateDataArraySector = h2.updateDataArray, h2.setAngle = function(t3) {
          }, h2.free = function(t3) {
          }) : (h2 = t2.create("sector", [p[1], p[0], p[2]], c2), h2.arc.visProp.priv = true, h2.point = h2.point2 = h2.radiuspoint = p[0], h2.pointsquare = h2.point3 = h2.anglepoint = p[2], h2.Radius = function() {
            return n.evaluate(l2);
          }, h2.updateDataArraySector = function() {
            var t3, i2, r3 = this.point2, s2 = this.point1, o2 = this.point3, a3 = this.Radius(), h3 = s2.Dist(r3), l3 = 1, c3 = n.evaluate(this.visProp.selection);
            i2 = e2.rad(r3, s2, o2), (c3 === "minor" && i2 > Math.PI || c3 === "major" && i2 < Math.PI) && (l3 = -1), r3 = r3.coords.usrCoords, s2 = s2.coords.usrCoords, o2 = o2.coords.usrCoords, r3 = [1, s2[1] + (r3[1] - s2[1]) * a3 / h3, s2[2] + (r3[2] - s2[2]) * a3 / h3], o2 = [1, s2[1] + (o2[1] - s2[1]) * a3 / h3, s2[2] + (o2[2] - s2[2]) * a3 / h3], t3 = e2.bezierArc(r3, s2, o2, true, l3), this.dataX = t3[0], this.dataY = t3[1], this.bezierDegree = 3;
          }, h2.setAngle = function(t3) {
            var e3, i2 = this.anglepoint, r3 = this.radiuspoint;
            return i2.draggable() && (e3 = this.board.create("transform", [t3, this.center], {type: "rotate"}), i2.addTransform(r3, e3), i2.isDraggable = false, i2.setParents(r3)), this;
          }, h2.free = function() {
            var t3 = this.anglepoint;
            return t3.transformations.length > 0 && (t3.transformations.pop(), t3.isDraggable = true, t3.parents = []), this;
          }, h2.setParents(p)), n.exists(h2.visProp.text) && h2.label.setText(n.evaluate(h2.visProp.text)), h2.elType = "angle", h2.type = o.OBJECT_TYPE_ANGLE, h2.subs = {}, h2.updateDataArraySquare = function() {
            var t3, r3, s2, o2, n3, a3, h3, l3, c3 = this.Radius();
            f === "2lines" && this.updateDataArraySector(), t3 = this.point2, r3 = this.point1, s2 = this.point3, t3 = t3.coords.usrCoords, r3 = r3.coords.usrCoords, s2 = s2.coords.usrCoords, o2 = e2.distance(t3, r3, 3), n3 = e2.distance(s2, r3, 3), t3 = [1, r3[1] + (t3[1] - r3[1]) * c3 / o2, r3[2] + (t3[2] - r3[2]) * c3 / o2], s2 = [1, r3[1] + (s2[1] - r3[1]) * c3 / n3, r3[2] + (s2[2] - r3[2]) * c3 / n3], a3 = i.crossProduct(s2, r3), h3 = [-t3[1] * a3[1] - t3[2] * a3[2], t3[0] * a3[1], t3[0] * a3[2]], a3 = i.crossProduct(t3, r3), l3 = [-s2[1] * a3[1] - s2[2] * a3[2], s2[0] * a3[1], s2[0] * a3[2]], a3 = i.crossProduct(h3, l3), a3[1] /= a3[0], a3[2] /= a3[0], this.dataX = [r3[1], t3[1], a3[1], s2[1], r3[1]], this.dataY = [r3[2], t3[2], a3[2], s2[2], r3[2]], this.bezierDegree = 1;
          }, h2.updateDataArrayNone = function() {
            this.dataX = [NaN], this.dataY = [NaN], this.bezierDegree = 1;
          }, h2.updateDataArray = function() {
            var t3 = n.evaluate(this.visProp.type), r3 = e2.trueAngle(this.point2, this.point1, this.point3), s2 = n.evaluate(this.visProp.selection);
            (s2 === "minor" && r3 > 180 || s2 === "major" && r3 < 180) && (r3 = 360 - r3), Math.abs(r3 - 90) < n.evaluate(this.visProp.orthosensitivity) + i.eps && (t3 = n.evaluate(this.visProp.orthotype)), t3 === "none" ? this.updateDataArrayNone() : t3 === "square" ? this.updateDataArraySquare() : t3 === "sector" ? this.updateDataArraySector() : t3 === "sectordot" && (this.updateDataArraySector(), this.dot.visProp.visible || this.dot.setAttribute({visible: true})), (!this.visProp.visible || t3 !== "sectordot" && this.dot.visProp.visible) && this.dot.setAttribute({visible: false});
          }, d = n.copyAttributes(a2, t2.options, "angle", "dot"), h2.dot = t2.create("point", [function() {
            var t3, r3, s2, o2, a3, l3, c3, d2, u2;
            return n.exists(h2.dot) && !h2.dot.visProp.visible ? [0, 0] : (t3 = h2.point2.coords.usrCoords, r3 = h2.point1.coords.usrCoords, s2 = h2.Radius(), o2 = e2.distance(t3, r3, 3), a3 = e2.rad(h2.point2, h2.point1, h2.point3), u2 = n.evaluate(h2.visProp.selection), (u2 === "minor" && a3 > Math.PI || u2 === "major" && a3 < Math.PI) && (a3 = -(2 * Math.PI - a3)), a3 *= 0.5, l3 = Math.cos(a3), c3 = Math.sin(a3), t3 = [1, r3[1] + (t3[1] - r3[1]) * s2 / o2, r3[2] + (t3[2] - r3[2]) * s2 / o2], d2 = [[1, 0, 0], [r3[1] - 0.5 * r3[1] * l3 + 0.5 * r3[2] * c3, 0.5 * l3, 0.5 * -c3], [r3[2] - 0.5 * r3[1] * c3 - 0.5 * r3[2] * l3, 0.5 * c3, 0.5 * l3]], i.matVecMult(d2, t3));
          }], d), h2.dot.dump = false, h2.subs.dot = h2.dot, f === "2lines")
            for (u = 0; u < 2; u++)
              t2.select(r2[u]).addChild(h2.dot);
          else
            for (u = 0; u < 3; u++)
              t2.select(p[u]).addChild(h2.dot);
          return h2.getLabelAnchor = function() {
            var t3, r3, a3, l3, c3, d2, u2, p2, f2, m = 12, g = n.evaluate(h2.visProp.selection), b = this.label ? this.label.visProp : this.visProp.label;
            return n.exists(this.label.visProp.fontSize) && (m = n.evaluate(this.label.visProp.fontSize)), m /= this.board.unitX, r3 = h2.point2.coords.usrCoords, a3 = h2.point1.coords.usrCoords, l3 = h2.Radius(), c3 = e2.distance(r3, a3, 3), d2 = e2.rad(h2.point2, h2.point1, h2.point3), (g === "minor" && d2 > Math.PI || g === "major" && d2 < Math.PI) && (d2 = -(2 * Math.PI - d2)), d2 *= 0.5, u2 = Math.cos(d2), p2 = Math.sin(d2), r3 = [1, a3[1] + (r3[1] - a3[1]) * l3 / c3, a3[2] + (r3[2] - a3[2]) * l3 / c3], f2 = [[1, 0, 0], [a3[1] - 0.5 * a3[1] * u2 + 0.5 * a3[2] * p2, 0.5 * u2, 0.5 * -p2], [a3[2] - 0.5 * a3[1] * p2 - 0.5 * a3[2] * u2, 0.5 * p2, 0.5 * u2]], t3 = i.matVecMult(f2, r3), t3[1] /= t3[0], t3[2] /= t3[0], t3[0] /= t3[0], c3 = e2.distance(t3, a3, 3), t3 = [t3[0], a3[1] + (t3[1] - a3[1]) * (l3 + m) / c3, a3[2] + (t3[2] - a3[2]) * (l3 + m) / c3], b.position = e2.calcLabelQuadrant(e2.rad([1, 0], [0, 0], t3)), new s(o.COORDS_BY_USER, t3, this.board);
          }, h2.Value = function() {
            return e2.rad(this.point2, this.point1, this.point3);
          }, h2.methodMap = n.deepCopy(h2.methodMap, {Value: "Value", setAngle: "setAngle", free: "free"}), h2;
        }, t.registerElement("angle", t.createAngle), t.createNonreflexAngle = function(i2, r2, s2) {
          var o2;
          return s2.selection = "minor", o2 = t.createAngle(i2, r2, s2), o2.Value = function() {
            var t2 = e2.rad(this.point2, this.point1, this.point3);
            return t2 < Math.PI ? t2 : 2 * Math.PI - t2;
          }, o2;
        }, t.registerElement("nonreflexangle", t.createNonreflexAngle), t.createReflexAngle = function(i2, r2, s2) {
          var o2;
          return s2.selection = "major", o2 = t.createAngle(i2, r2, s2), o2.Value = function() {
            var t2 = e2.rad(this.point2, this.point1, this.point3);
            return t2 >= Math.PI ? t2 : 2 * Math.PI - t2;
          }, o2;
        }, t.registerElement("reflexangle", t.createReflexAngle), {createSector: t.createSector, createCircumcircleSector: t.createCircumcircleSector, createMinorSector: t.createMinorSector, createMajorSector: t.createMajorSector, createAngle: t.createAngle, createReflexAngle: t.createReflexAngle, createNonreflexAngle: t.createNonreflexAngle};
      }), define("element/locus", ["jxg", "math/symbolic", "utils/type"], function(t, e2, i) {
        "use strict";
        return t.createLocus = function(t2, r, s) {
          var o, n;
          if (!i.isArray(r) || r.length !== 1 || !i.isPoint(r[0]))
            throw new Error("JSXGraph: Can't create locus with parent of type other than point.\nPossible parent types: [point]");
          return n = r[0], o = t2.create("curve", [[null], [null]], s), o.dontCallServer = false, o.elType = "locus", o.setParents([n.id]), o.updateDataArray = function() {
            var i2, r2, s2;
            o.board.mode > 0 || (i2 = e2.generatePolynomials(t2, n, true).join("|")) !== o.spe && (o.spe = i2, r2 = function(t3, e3, i3, r3) {
              o.dataX = t3, o.dataY = e3, o.eq = i3, o.ctime = r3, o.generatePolynomial = function(t4) {
                return function(e4) {
                  var i4, r4 = "(" + e4.symbolic.x + ")", s3 = "(" + e4.symbolic.y + ")", o2 = [];
                  for (i4 = 0; i4 < t4.length; i4++)
                    o2[i4] = t4[i4].replace(/\*\*/g, "^").replace(/x/g, r4).replace(/y/g, s3);
                  return o2;
                };
              }(i3);
            }, s2 = e2.geometricLocusByGroebnerBase(t2, n, r2), r2(s2.datax, s2.datay, s2.polynomial, s2.exectime));
          }, o;
        }, t.registerElement("locus", t.createLocus), {createLocus: t.createLocus};
      }), define("base/image", ["jxg", "base/constants", "base/coords", "base/element", "math/math", "utils/type", "base/coordselement"], function(t, e2, i, r, s, o, n) {
        "use strict";
        return t.Image = function(i2, r2, s2, n3, a) {
          this.constructor(i2, s2, e2.OBJECT_TYPE_IMAGE, e2.OBJECT_CLASS_OTHER), this.element = this.board.select(s2.anchor), this.coordsConstructor(r2), this.W = o.createFunction(a[0], this.board, ""), this.H = o.createFunction(a[1], this.board, ""), this.usrSize = [this.W(), this.H()], this.size = [Math.abs(this.usrSize[0] * i2.unitX), Math.abs(this.usrSize[1] * i2.unitY)], this.url = n3, this.elType = "image", this.span = [this.coords.usrCoords.slice(0), [this.coords.usrCoords[0], this.W(), 0], [this.coords.usrCoords[0], 0, this.H()]], this.id = this.board.setId(this, "Im"), this.board.renderer.drawImage(this), this.board.finalizeAdding(this), this.methodMap = t.deepCopy(this.methodMap, {addTransformation: "addTransform", trans: "addTransform"});
        }, t.Image.prototype = new r(), o.copyPrototypeMethods(t.Image, n, "coordsConstructor"), t.extend(t.Image.prototype, {hasPoint: function(t2, r2) {
          var n3, a, h, l, c, d, u, p, f, m = this.transformations.length;
          return o.isObject(o.evaluate(this.visProp.precision)) ? (l = this.board._inputDevice, c = o.evaluate(this.visProp.precision[l])) : c = this.board.options.precision.hasPoint, m === 0 ? (n3 = t2 - this.coords.scrCoords[1], a = this.coords.scrCoords[2] - r2, h = c, n3 >= -h && n3 - this.size[0] <= h && a >= -h && a - this.size[1] <= h) : (d = new i(e2.COORDS_BY_SCREEN, [t2, r2], this.board), d = d.usrCoords, u = [d[0] - this.span[0][0], d[1] - this.span[0][1], d[2] - this.span[0][2]], f = s.innerProduct, 0 <= (p = f(u, this.span[1])) && p <= f(this.span[1], this.span[1]) && 0 <= (p = f(u, this.span[2])) && p <= f(this.span[2], this.span[2]));
        }, update: function(t2) {
          return this.needsUpdate ? (this.updateCoords(t2), this.updateSize(), this.updateSpan(), this) : this;
        }, updateRenderer: function() {
          return this.updateRendererGeneric("updateImage");
        }, updateSize: function() {
          return this.usrSize = [this.W(), this.H()], this.size = [Math.abs(this.usrSize[0] * this.board.unitX), Math.abs(this.usrSize[1] * this.board.unitY)], this;
        }, updateSpan: function() {
          var t2, e3, i2 = this.transformations.length, r2 = [];
          if (i2 === 0)
            this.span = [[this.Z(), this.X(), this.Y()], [this.Z(), this.W(), 0], [this.Z(), 0, this.H()]];
          else {
            for (r2[0] = [this.Z(), this.X(), this.Y()], r2[1] = [this.Z(), this.X() + this.W(), this.Y()], r2[2] = [this.Z(), this.X(), this.Y() + this.H()], t2 = 0; t2 < i2; t2++)
              for (e3 = 0; e3 < 3; e3++)
                r2[e3] = s.matVecMult(this.transformations[t2].matrix, r2[e3]);
            for (e3 = 0; e3 < 3; e3++)
              r2[e3][1] /= r2[e3][0], r2[e3][2] /= r2[e3][0], r2[e3][0] /= r2[e3][0];
            for (e3 = 1; e3 < 3; e3++)
              r2[e3][0] -= r2[0][0], r2[e3][1] -= r2[0][1], r2[e3][2] -= r2[0][2];
            this.span = r2;
          }
          return this;
        }, addTransform: function(t2) {
          var e3;
          if (o.isArray(t2))
            for (e3 = 0; e3 < t2.length; e3++)
              this.transformations.push(t2[e3]);
          else
            this.transformations.push(t2);
          return this;
        }, getParents: function() {
          var t2 = [this.url, [this.Z(), this.X(), this.Y()], this.usrSize];
          return this.parents.length !== 0 && (t2 = this.parents), t2;
        }, setSize: function(t2, e3) {
          return this.W = o.createFunction(t2, this.board, ""), this.H = o.createFunction(e3, this.board, ""), this;
        }, W: function() {
        }, H: function() {
        }}), t.createImage = function(e3, i2, r2) {
          var s2, a, h = i2[0], l = i2[1], c = i2[2];
          if (s2 = o.copyAttributes(r2, e3.options, "image"), !(a = n.create(t.Image, e3, l, s2, h, c)))
            throw new Error("JSXGraph: Can't create image with parent types '" + typeof i2[0] + "' and '" + typeof i2[1] + "'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
          return s2.rotate !== 0 && a.addRotation(s2.rotate), a;
        }, t.registerElement("image", t.createImage), {Image: t.Image, createImage: t.createImage};
      }), define("base/ticks", ["jxg", "math/math", "math/geometry", "math/numerics", "base/constants", "base/element", "base/coords", "utils/type", "base/text"], function(t, e2, i, r, s, o, n, a, h) {
        "use strict";
        return t.Ticks = function(t2, i2, r2) {
          if (this.constructor(t2.board, r2, s.OBJECT_TYPE_TICKS, s.OBJECT_CLASS_OTHER), this.line = t2, this.board = this.line.board, this.ticksFunction = null, this.fixedTicks = null, this.equidistant = false, this.labelsData = [], a.isFunction(i2))
            throw this.ticksFunction = i2, new Error("Function arguments are no longer supported.");
          a.isArray(i2) ? this.fixedTicks = i2 : ((Math.abs(i2) < e2.eps || i2 < 0) && (i2 = r2.defaultdistance), this.ticksFunction = this.makeTicksFunction(i2), this.equidistant = true), this.minTicksDistance = r2.minticksdistance, this.ticks = [], this.ticksDelta = 1, this.labels = [], this.labelData = [], this.labelCounter = 0, this.id = this.line.addTicks(this), this.elType = "ticks", this.inherits.push(this.labels), this.board.setId(this, "Ti");
        }, t.Ticks.prototype = new o(), t.extend(t.Ticks.prototype, {makeTicksFunction: function(t2) {
          return function() {
            var e3, i2, r2;
            return a.evaluate(this.visProp.insertticks) ? (i2 = this.getLowerAndUpperBounds(this.getZeroCoordinates(), "ticksdistance"), r2 = i2.upper - i2.lower, e3 = Math.pow(10, Math.floor(Math.log(0.6 * r2) / Math.LN10)), r2 <= 6 * e3 && (e3 *= 0.5), e3) : t2;
          };
        }, hasPoint: function(t2, i2) {
          var r2, o2, n3, h2, l = this.ticks && this.ticks.length || 0;
          if (a.isObject(a.evaluate(this.visProp.precision)) ? (h2 = this.board._inputDevice, n3 = a.evaluate(this.visProp.precision[h2])) : n3 = this.board.options.precision.hasPoint, n3 += 0.5 * a.evaluate(this.visProp.strokewidth), !a.evaluate(this.line.visProp.scalable) || this.line.elementClass === s.OBJECT_CLASS_CURVE)
            return false;
          if (this.line.stdform[1] !== 0 && this.line.stdform[2] !== 0 && this.line.type !== s.OBJECT_TYPE_AXIS)
            return false;
          for (r2 = 0; r2 < l; r2++)
            if (o2 = this.ticks[r2], o2[2] && !(this.line.stdform[1] === 0 && Math.abs(o2[0][0] - this.line.point1.coords.scrCoords[1]) < e2.eps || this.line.stdform[2] === 0 && Math.abs(o2[1][0] - this.line.point1.coords.scrCoords[2]) < e2.eps) && (Math.abs(o2[0][0] - o2[0][1]) >= 1 || Math.abs(o2[1][0] - o2[1][1]) >= 1)) {
              if (this.line.stdform[1] === 0) {
                if (Math.abs(i2 - 0.5 * (o2[1][0] + o2[1][1])) < 2 * n3 && o2[0][0] - n3 < t2 && t2 < o2[0][1] + n3)
                  return true;
              } else if (this.line.stdform[2] === 0 && Math.abs(t2 - 0.5 * (o2[0][0] + o2[0][1])) < 2 * n3 && o2[1][0] - n3 < i2 && i2 < o2[1][1] + n3)
                return true;
            }
          return false;
        }, setPositionDirectly: function(t2, i2, r2) {
          var o2, h2, l = new n(t2, i2, this.board), c = new n(t2, r2, this.board), d = this.board.getBoundingBox();
          return this.line.type === s.OBJECT_TYPE_AXIS && a.evaluate(this.line.visProp.scalable) ? (Math.abs(this.line.stdform[1]) < e2.eps && Math.abs(l.usrCoords[1] * c.usrCoords[1]) > e2.eps ? (o2 = c.usrCoords[1] / l.usrCoords[1], d[0] *= o2, d[2] *= o2, this.board.setBoundingBox(d, false)) : Math.abs(this.line.stdform[2]) < e2.eps && Math.abs(l.usrCoords[2] * c.usrCoords[2]) > e2.eps && (h2 = c.usrCoords[2] / l.usrCoords[2], d[3] *= h2, d[1] *= h2, this.board.setBoundingBox(d, false)), this) : this;
        }, calculateTicksCoordinates: function() {
          var t2, i2, r2, o2;
          if (!(this.line.elementClass === s.OBJECT_CLASS_LINE && (this.setTicksSizeVariables(), Math.abs(this.dx) < e2.eps && Math.abs(this.dy) < e2.eps)))
            return t2 = this.getZeroCoordinates(), i2 = this.line.elementClass === s.OBJECT_CLASS_LINE ? this.getLowerAndUpperBounds(t2) : {lower: this.line.minX(), upper: this.line.maxX()}, a.evaluate(this.visProp.type) === "polar" && (o2 = this.board.getBoundingBox(), r2 = Math.max(Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), Math.sqrt(o2[2] * o2[2] + o2[3] * o2[3])), i2.upper = r2), this.ticks = [], this.labelsData = [], this.equidistant ? this.generateEquidistantTicks(t2, i2) : this.generateFixedTicks(t2, i2), this;
        }, setTicksSizeVariables: function(t2) {
          var i2, s2, o2, n3, h2 = 0.5 * a.evaluate(this.visProp.majorheight), l = 0.5 * a.evaluate(this.visProp.minorheight);
          a.exists(t2) ? (s2 = this.line.minX(), o2 = this.line.maxX(), n3 = this.line.points.length, n3 < 2 ? (this.dxMaj = 0, this.dyMaj = 0) : e2.relDif(t2, s2) < e2.eps ? (this.dxMaj = this.line.points[0].usrCoords[2] - this.line.points[1].usrCoords[2], this.dyMaj = this.line.points[1].usrCoords[1] - this.line.points[0].usrCoords[1]) : e2.relDif(t2, o2) < e2.eps ? (this.dxMaj = this.line.points[n3 - 2].usrCoords[2] - this.line.points[n3 - 1].usrCoords[2], this.dyMaj = this.line.points[n3 - 1].usrCoords[1] - this.line.points[n3 - 2].usrCoords[1]) : (this.dxMaj = -r.D(this.line.Y)(t2), this.dyMaj = r.D(this.line.X)(t2))) : (this.dxMaj = this.line.stdform[1], this.dyMaj = this.line.stdform[2]), this.dxMin = this.dxMaj, this.dyMin = this.dyMaj, this.dx = this.dxMaj, this.dy = this.dyMaj, i2 = Math.sqrt(this.dxMaj * this.dxMaj * this.board.unitX * this.board.unitX + this.dyMaj * this.dyMaj * this.board.unitY * this.board.unitY), this.dxMaj *= h2 / i2 * this.board.unitX, this.dyMaj *= h2 / i2 * this.board.unitY, this.dxMin *= l / i2 * this.board.unitX, this.dyMin *= l / i2 * this.board.unitY, this.minStyle = a.evaluate(this.visProp.minorheight) < 0 ? "infinite" : "finite", this.majStyle = a.evaluate(this.visProp.majorheight) < 0 ? "infinite" : "finite";
        }, getZeroCoordinates: function() {
          var t2, e3, r2, o2, h2, l, c, d, u = a.evaluate(this.visProp.anchor);
          return this.line.elementClass === s.OBJECT_CLASS_LINE ? this.line.type === s.OBJECT_TYPE_AXIS ? i.projectPointToLine({coords: {usrCoords: [1, 0, 0]}}, this.line, this.board) : (r2 = this.line.point1.coords.usrCoords[0], t2 = this.line.point1.coords.usrCoords[1], e3 = this.line.point1.coords.usrCoords[2], l = this.line.point2.coords.usrCoords[0], o2 = this.line.point2.coords.usrCoords[1], h2 = this.line.point2.coords.usrCoords[2], u === "right" ? this.line.point2.coords : u === "middle" ? new n(s.COORDS_BY_USER, [0.5 * (r2 + l), 0.5 * (t2 + o2), 0.5 * (e3 + h2)], this.board) : a.isNumber(u) ? new n(s.COORDS_BY_USER, [r2 + (l - r2) * u, t2 + (o2 - t2) * u, e3 + (h2 - e3) * u], this.board) : this.line.point1.coords) : (c = this.line.minX(), d = this.line.maxX(), u === "right" ? d : u === "middle" ? 0.5 * (c + d) : a.isNumber(u) ? c * (1 - u) + d * u : c);
        }, getLowerAndUpperBounds: function(t2, r2) {
          var o2, h2, l, c, d, u, p, f, m, g, b = a.evaluate(this.line.visProp.straightfirst), v = a.evaluate(this.line.visProp.straightlast), y = a.evaluate(this.visProp.includeboundaries);
          return this.line.elementClass === s.OBJECT_CLASS_CURVE ? {lower: this.line.minX(), upper: this.line.maxX()} : (d = new n(s.COORDS_BY_USER, this.line.point1.coords.usrCoords, this.board), u = new n(s.COORDS_BY_USER, this.line.point2.coords.usrCoords, this.board), p = Math.abs(d.usrCoords[0]) >= e2.eps && d.scrCoords[1] >= 0 && d.scrCoords[1] <= this.board.canvasWidth && d.scrCoords[2] >= 0 && d.scrCoords[2] <= this.board.canvasHeight, f = Math.abs(u.usrCoords[0]) >= e2.eps && u.scrCoords[1] >= 0 && u.scrCoords[1] <= this.board.canvasWidth && u.scrCoords[2] >= 0 && u.scrCoords[2] <= this.board.canvasHeight, a.exists(r2) || r2 === "tickdistance" ? i.calcStraight(this.line, d, u, a.evaluate(this.line.visProp.margin)) : i.calcLineDelimitingPoints(this.line, d, u), l = a.evaluate(this.line.visProp.firstarrow), c = a.evaluate(this.line.visProp.lastarrow), (l || c) && (this.board.renderer.getPositionArrowHead(this.line, d, u, a.evaluate(this.line.visProp.strokewidth)), l && d.setCoordinates(s.COORDS_BY_SCREEN, [d.scrCoords[1], d.scrCoords[2]]), c && u.setCoordinates(s.COORDS_BY_SCREEN, [u.scrCoords[1], u.scrCoords[2]])), m = this.getDistanceFromZero(t2, d), g = this.getDistanceFromZero(t2, u), m < g ? (o2 = m, b || !p || y || (o2 += e2.eps), h2 = g, v || !f || y || (h2 -= e2.eps)) : g < m ? (o2 = g, v || !f || y || (o2 += e2.eps), h2 = m, b || !p || y || (h2 -= e2.eps)) : (o2 = 0, h2 = 0), {lower: o2, upper: h2});
        }, getDistanceFromZero: function(t2, i2) {
          var r2, o2, n3, a2, h2;
          return r2 = this.line.point1.coords, o2 = this.line.point2.coords, h2 = t2.distance(s.COORDS_BY_USER, i2), n3 = [o2.usrCoords[0] - r2.usrCoords[0], o2.usrCoords[1] - r2.usrCoords[1], o2.usrCoords[2] - r2.usrCoords[2]], a2 = [i2.usrCoords[0] - t2.usrCoords[0], i2.usrCoords[1] - t2.usrCoords[1], i2.usrCoords[2] - t2.usrCoords[2]], e2.innerProduct(n3, a2, 3) < 0 && (h2 *= -1), h2;
        }, generateEquidistantTicks: function(t2, i2) {
          var r2, o2, n3 = e2.eps, h2 = this.equidistant ? this.ticksFunction(1) : this.ticksDelta, l = a.evaluate(this.visProp.insertticks), c = a.evaluate(this.visProp.minorticks);
          if (this.line.elementClass === s.OBJECT_CLASS_LINE && (o2 = this.getXandYdeltas()), h2 *= a.evaluate(this.visProp.scale), l && this.minTicksDistance > e2.eps ? (h2 = this.adjustTickDistance(h2, t2, o2), h2 /= c + 1) : l || (h2 /= c + 1), this.ticksDelta = h2, !(h2 < e2.eps)) {
            for (r2 = 0, a.evaluate(this.visProp.drawzero) || (r2 = h2); r2 <= i2.upper + n3; )
              r2 >= i2.lower - n3 && this.processTickPosition(t2, r2, h2, o2), r2 += h2;
            for (r2 = -h2; r2 >= i2.lower - n3; )
              r2 <= i2.upper + n3 && this.processTickPosition(t2, r2, h2, o2), r2 -= h2;
          }
        }, adjustTickDistance: function(t2, e3, i2) {
          var r2, o2, h2, l = 1, c = a.evaluate(this.visProp.minorticks);
          if (this.line.elementClass === s.OBJECT_CLASS_CURVE)
            return t2;
          if (this.getLowerAndUpperBounds(e3, "ticksdistance"), r2 = e3.usrCoords[1] + i2.x * t2, o2 = e3.usrCoords[2] + i2.y * t2, h2 = e3.distance(s.COORDS_BY_SCREEN, new n(s.COORDS_BY_USER, [r2, o2], this.board)), t2 === 0)
            return 0;
          for (; h2 / (c + 1) < this.minTicksDistance; )
            t2 *= l === 1 ? 2 : 5, l *= -1, r2 = e3.usrCoords[1] + i2.x * t2, o2 = e3.usrCoords[2] + i2.y * t2, h2 = e3.distance(s.COORDS_BY_SCREEN, new n(s.COORDS_BY_USER, [r2, o2], this.board));
          return t2;
        }, processTickPosition: function(t2, e3, i2, r2) {
          var o2, h2, l, c, d = null;
          this.line.elementClass === s.OBJECT_CLASS_LINE ? (o2 = t2.usrCoords[1] + e3 * r2.x, h2 = t2.usrCoords[2] + e3 * r2.y) : (o2 = this.line.X(t2 + e3), h2 = this.line.Y(t2 + e3)), l = new n(s.COORDS_BY_USER, [o2, h2], this.board), this.line.elementClass === s.OBJECT_CLASS_CURVE && (d = t2 + e3, this.setTicksSizeVariables(d)), l.major = Math.round(e3 / i2) % (a.evaluate(this.visProp.minorticks) + 1) == 0, c = this.createTickPath(l, l.major), c.length === 3 && (this.ticks.push(c), l.major && a.evaluate(this.visProp.drawlabels) ? this.labelsData.push(this.generateLabelData(this.generateLabelText(l, t2, d), l, this.ticks.length)) : this.labelsData.push(null));
        }, generateFixedTicks: function(t2, i2) {
          var r2, o2, h2, l, c, d, u, p, f = e2.eps, m = a.isArray(this.visProp.labels), g = a.evaluate(this.visProp.drawlabels);
          for (this.line.elementClass === s.OBJECT_CLASS_LINE && (p = this.getXandYdeltas()), h2 = 0; h2 < this.fixedTicks.length; h2++)
            this.line.elementClass === s.OBJECT_CLASS_LINE ? (u = this.fixedTicks[h2], c = t2.usrCoords[1] + u * p.x, d = t2.usrCoords[2] + u * p.y) : (u = t2 + this.fixedTicks[h2], c = this.line.X(u), d = this.line.Y(u)), r2 = new n(s.COORDS_BY_USER, [c, d], this.board), this.line.elementClass === s.OBJECT_CLASS_CURVE && this.setTicksSizeVariables(u), l = this.createTickPath(r2, true), l.length === 3 && u >= i2.lower - f && u <= i2.upper + f && (this.ticks.push(l), g && (m || a.exists(this.visProp.labels[h2])) ? (o2 = m ? a.evaluate(this.visProp.labels[h2]) : u, this.labelsData.push(this.generateLabelData(this.generateLabelText(r2, t2, o2), r2, h2))) : this.labelsData.push(null));
        }, getXandYdeltas: function() {
          var t2, i2, r2 = this.line.point1.Dist(this.line.point2);
          return this.line.type === s.OBJECT_TYPE_AXIS ? (t2 = this.line.point1.coords.usrCoords, i2 = this.line.point2.coords.usrCoords, (t2[1] > i2[1] || Math.abs(t2[1] - i2[1]) < e2.eps && t2[2] > i2[2]) && (t2 = this.line.point2.coords.usrCoords, i2 = this.line.point1.coords.usrCoords)) : (t2 = this.line.point1.coords.usrCoords, i2 = this.line.point2.coords.usrCoords), {x: (i2[1] - t2[1]) / r2, y: (i2[2] - t2[2]) / r2};
        }, _isInsideCanvas: function(t2, e3, i2) {
          var r2 = this.board.canvasWidth, s2 = this.board.canvasHeight;
          return i2 === void 0 && (i2 = 0), t2[0] >= i2 && t2[0] <= r2 - i2 && e3[0] >= i2 && e3[0] <= s2 - i2 || t2[1] >= i2 && t2[1] <= r2 - i2 && e3[1] >= i2 && e3[1] <= s2 - i2;
        }, createTickPath: function(t2, e3) {
          var r2, s2, o2, n3, h2, l, c, d, u, p, f, m, g, b, v, y = [-2e6, -2e6], C = [-2e6, -2e6];
          if (r2 = t2.scrCoords, e3 ? (n3 = this.dxMaj, h2 = this.dyMaj, u = this.majStyle) : (n3 = this.dxMin, h2 = this.dyMin, u = this.minStyle), s2 = [-h2 * r2[1] - n3 * r2[2], h2, n3], e3 && a.evaluate(this.visProp.type) === "polar") {
            if (g = this.board.getBoundingBox(), b = 2 * Math.PI, v = b / 180, r2 = t2.usrCoords, f = Math.sqrt(r2[1] * r2[1] + r2[2] * r2[2]), m = Math.max(Math.sqrt(g[0] * g[0] + g[1] * g[1]), Math.sqrt(g[2] * g[2] + g[3] * g[3])), f < m) {
              for (y = [], C = [], p = 0; p <= b; p += v)
                y.push(this.board.origin.scrCoords[1] + f * Math.cos(p) * this.board.unitX), C.push(this.board.origin.scrCoords[2] + f * Math.sin(p) * this.board.unitY);
              return [y, C, e3];
            }
          } else if (u === "infinite" ? (o2 = i.meetLineBoard(s2, this.board), y[0] = o2[0].scrCoords[1], y[1] = o2[1].scrCoords[1], C[0] = o2[0].scrCoords[2], C[1] = o2[1].scrCoords[2]) : (d = a.evaluate(this.visProp.face) === ">" ? Math.PI / 4 : a.evaluate(this.visProp.face) === "<" ? -Math.PI / 4 : 0, l = Math.cos(d) * n3 - Math.sin(d) * h2, c = Math.sin(d) * n3 + Math.cos(d) * h2, y[0] = r2[1] + l * a.evaluate(this.visProp.tickendings[0]), C[0] = r2[2] - c * a.evaluate(this.visProp.tickendings[0]), y[1] = r2[1], C[1] = r2[2], d = -d, l = Math.cos(d) * n3 - Math.sin(d) * h2, c = Math.sin(d) * n3 + Math.cos(d) * h2, y[2] = r2[1] - l * a.evaluate(this.visProp.tickendings[1]), C[2] = r2[2] + c * a.evaluate(this.visProp.tickendings[1])), this._isInsideCanvas(y, C))
            return [y, C, e3];
          return [];
        }, formatLabelText: function(t2) {
          var e3 = t2.toString(), i2 = a.evaluate(this.visProp.scalesymbol);
          return a.isNumber(t2) && ((e3.length > a.evaluate(this.visProp.maxlabellength) || e3.indexOf("e") !== -1) && (e3 = t2.toPrecision(a.evaluate(this.visProp.precision)).toString()), a.evaluate(this.visProp.beautifulscientificticklabels) && (e3 = this.beautifyScientificNotationLabel(e3)), e3.indexOf(".") > -1 && e3.indexOf("e") === -1 && (e3 = e3.replace(/0+$/, ""), e3 = e3.replace(/\.$/, ""))), i2.length > 0 && (e3 === "1" ? e3 = i2 : e3 === "-1" ? e3 = "-" + i2 : e3 !== "0" && (e3 += i2)), a.evaluate(this.visProp.useunicodeminus) && (e3 = e3.replace(/-/g, "\u2212")), e3;
        }, beautifyScientificNotationLabel: function(t2) {
          var e3;
          return t2.indexOf("e") === -1 ? t2 : (e3 = parseFloat(t2.substring(0, t2.indexOf("e"))) + t2.substring(t2.indexOf("e")), e3 = e3.replace(/e(.*)$/g, function(t3, e4) {
            var i2 = "\u202210";
            return i2 += e4.replace(/-/g, "\u207B").replace(/\+/g, "").replace(/0/g, "\u2070").replace(/1/g, "\xB9").replace(/2/g, "\xB2").replace(/3/g, "\xB3").replace(/4/g, "\u2074").replace(/5/g, "\u2075").replace(/6/g, "\u2076").replace(/7/g, "\u2077").replace(/8/g, "\u2078").replace(/9/g, "\u2079");
          }));
        }, generateLabelText: function(t2, i2, r2) {
          var s2;
          if (!a.exists(r2)) {
            if (s2 = this.getDistanceFromZero(i2, t2), Math.abs(s2) < e2.eps)
              return "0";
            r2 = s2 / a.evaluate(this.visProp.scale);
          }
          return this.formatLabelText(r2);
        }, generateLabelData: function(t2, e3, i2) {
          var r2, s2, o2, n3;
          return n3 = a.evaluate(this.visProp.label.fontsize), r2 = [e3.scrCoords[1], e3.scrCoords[1]], s2 = [e3.scrCoords[2], e3.scrCoords[2]], o2 = n3 === void 0 ? 12 : n3, o2 *= 0.5, this._isInsideCanvas(r2, s2, o2) ? (r2 = a.evaluate(this.visProp.label.offset[0]), s2 = a.evaluate(this.visProp.label.offset[1]), {x: e3.usrCoords[1] + r2 / this.board.unitX, y: e3.usrCoords[2] + s2 / this.board.unitY, t: t2, i: i2}) : null;
        }, update: function() {
          return this.needsUpdate && this.board.canvasWidth !== 0 && this.board.canvasHeight !== 0 && this.calculateTicksCoordinates(), this;
        }, updateRenderer: function() {
          return this.needsUpdate ? (this.visPropCalc.visible && this.board.renderer.updateTicks(this), this.updateRendererLabels(), this.setDisplayRendNode(), this.needsUpdate = false, this) : this;
        }, updateRendererLabels: function() {
          var t2, e3, i2, r2, s2, o2, n3, l;
          for (i2 = this.labelsData.length, r2 = this.labels.length, t2 = 0, e3 = 0; t2 < i2; t2++)
            this.labelsData[t2] !== null && (n3 = this.labelsData[t2], e3 < r2 ? (o2 = this.labels[e3], o2.setText(n3.t), o2.setCoords(n3.x, n3.y), e3++) : (this.labelCounter += 1, s2 = {isLabel: true, layer: this.board.options.layer.line, highlightStrokeColor: this.board.options.text.strokeColor, highlightStrokeWidth: this.board.options.text.strokeWidth, highlightStrokeOpacity: this.board.options.text.strokeOpacity, priv: this.visProp.priv}, s2 = a.deepCopy(s2, this.visProp.label), s2.id = this.id + n3.i + "Label" + this.labelCounter, o2 = h.createText(this.board, [n3.x, n3.y, n3.t], s2), o2.isDraggable = false, o2.dump = false, this.labels.push(o2)), l = a.evaluate(this.visProp.label.visible), l === "inherit" && (l = this.visPropCalc.visible), o2.prepareUpdate().updateVisibility(l).updateRenderer(), o2.distanceX = a.evaluate(this.visProp.label.offset[0]), o2.distanceY = a.evaluate(this.visProp.label.offset[1]));
          for (i2 = e3, e3 = i2; e3 < r2; e3++)
            this.board.renderer.display(this.labels[e3], false), this.labels[e3].visProp.visible = this.labels[e3].visPropCalc.visible = false;
          return this;
        }, hideElement: function() {
          var e3;
          for (t.deprecated("Element.hideElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = false, this.board.renderer.display(this, false), e3 = 0; e3 < this.labels.length; e3++)
            a.exists(this.labels[e3]) && this.labels[e3].hideElement();
          return this;
        }, showElement: function() {
          var e3;
          for (t.deprecated("Element.showElement()", "Element.setDisplayRendNode()"), this.visPropCalc.visible = true, this.board.renderer.display(this, false), e3 = 0; e3 < this.labels.length; e3++)
            a.exists(this.labels[e3]) && this.labels[e3].showElement();
          return this;
        }}), t.createTicks = function(e3, i2, r2) {
          var o2, n3, h2 = a.copyAttributes(r2, e3.options, "ticks");
          if (n3 = i2.length < 2 ? h2.ticksdistance : i2[1], i2[0].elementClass !== s.OBJECT_CLASS_LINE && i2[0].elementClass !== s.OBJECT_CLASS_CURVE)
            throw new Error("JSXGraph: Can't create Ticks with parent types '" + typeof i2[0] + "'.");
          return o2 = new t.Ticks(i2[0], n3, h2), a.isFunction(h2.generatelabelvalue) && (o2.generateLabelText = h2.generatelabelvalue), a.isFunction(h2.generatelabeltext) && (o2.generateLabelText = h2.generatelabeltext), o2.setParents(i2[0]), o2.isDraggable = true, o2.fullUpdate(i2[0].visPropCalc.visible), o2;
        }, t.createHatchmark = function(t2, e3, i2) {
          var r2, o2, n3, h2, l, c, d = [], u = a.copyAttributes(i2, t2.options, "hatch");
          if (e3[0].elementClass !== s.OBJECT_CLASS_LINE && e3[0].elementClass !== s.OBJECT_CLASS_CURVE || typeof e3[1] != "number")
            throw new Error("JSXGraph: Can't create Hatch mark with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + " and ''" + typeof e3[2] + "'.");
          for (r2 = e3[1], h2 = u.ticksdistance, l = (r2 - 1) * h2, n3 = 0.5 * -l, o2 = 0; o2 < r2; o2++)
            d[o2] = n3 + o2 * h2;
          return c = t2.create("ticks", [e3[0], d], u), c.elType = "hatch", c;
        }, t.registerElement("ticks", t.createTicks), t.registerElement("hash", t.createHatchmark), t.registerElement("hatch", t.createHatchmark), {Ticks: t.Ticks, createTicks: t.createTicks, createHashmark: t.createHatchmark, createHatchmark: t.createHatchmark};
      }), define("element/slider", ["jxg", "math/math", "base/constants", "base/coords", "utils/type", "base/point", "base/group", "base/element", "base/line", "base/ticks", "base/text"], function(t, e2, i, r, s, o, n, a, h, l, c) {
        "use strict";
        return t.createSlider = function(t2, n3, a2) {
          var h2, l2, c2, d, u, p, f, m, g, b, v, y, C, _4, P2, E, x, S, O, w, T, N, M;
          return N = s.copyAttributes(a2, t2.options, "slider"), S = N.withticks, x = N.withlabel, O = N.snapwidth, M = N.precision, N = s.copyAttributes(a2, t2.options, "slider", "point1"), f = t2.create("point", n3[0], N), N = s.copyAttributes(a2, t2.options, "slider", "point2"), m = t2.create("point", n3[1], N), N = s.copyAttributes(a2, t2.options, "slider", "baseline"), g = t2.create("segment", [f, m], N), g.updateStdform(), h2 = f.coords.usrCoords.slice(1), l2 = m.coords.usrCoords.slice(1), c2 = n3[2][0], d = n3[2][1], u = n3[2][2], p = u - c2, w = s.evaluate(O), T = w == -1 ? d : Math.round(d / w) * w, y = h2[0] + (l2[0] - h2[0]) * (T - c2) / (u - c2), C = h2[1] + (l2[1] - h2[1]) * (T - c2) / (u - c2), N = s.copyAttributes(a2, t2.options, "slider"), N.withLabel = false, _4 = t2.create("glider", [y, C, g], N), _4.setAttribute({snapwidth: O}), N = s.copyAttributes(a2, t2.options, "slider", "highline"), P2 = t2.create("segment", [f, _4], N), _4.Value = function() {
            var t3 = this._smax - this._smin, e3 = s.evaluate(this.visProp.snapwidth);
            return e3 === -1 ? this.position * t3 + this._smin : Math.round((this.position * t3 + this._smin) / e3) * e3;
          }, _4.methodMap = s.deepCopy(_4.methodMap, {Value: "Value", setValue: "setValue", smax: "_smax", smin: "_smin", setMax: "setMax", setMin: "setMin"}), _4._smax = u, _4._smin = c2, _4.setMax = function(t3) {
            return this._smax = t3, this;
          }, _4.setValue = function(t3) {
            var i2 = this._smax - this._smin;
            return Math.abs(i2) > e2.eps ? this.position = (t3 - this._smin) / i2 : this.position = 0, this.position = Math.max(0, Math.min(1, this.position)), this;
          }, _4.setMin = function(t3) {
            return this._smin = t3, this;
          }, x && (N = s.copyAttributes(a2, t2.options, "slider", "label"), E = t2.create("text", [function() {
            return 0.05 * (m.X() - f.X()) + m.X();
          }, function() {
            return 0.05 * (m.Y() - f.Y()) + m.Y();
          }, function() {
            var t3, e3 = s.evaluate(_4.visProp.suffixlabel), i2 = s.evaluate(_4.visProp.unitlabel), r2 = s.evaluate(_4.visProp.postlabel);
            return t3 = e3 !== null ? e3 : _4.name && _4.name !== "" ? _4.name + " = " : "", t3 += s.toFixed(_4.Value(), M), i2 !== null && (t3 += i2), r2 !== null && (t3 += r2), t3;
          }], N), _4.label = E, _4.visProp.withlabel = true, _4.hasLabel = true), _4.point1 = f, _4.point2 = m, _4.baseline = g, _4.highline = P2, S && (N = s.copyAttributes(a2, t2.options, "slider", "ticks"), s.exists(N.generatelabeltext) || (N.generateLabelText = function(t3, i2, r2) {
            var s2 = _4.point1.Dist(_4.point2), o2 = _4._smin, n4 = _4._smax, a3 = this.getDistanceFromZero(i2, t3) * (n4 - o2) / s2 + o2;
            return s2 < e2.eps || Math.abs(a3) < e2.eps ? "0" : this.formatLabelText(a3);
          }), b = 2, v = t2.create("ticks", [_4.baseline, _4.point1.Dist(f) / b, function(t3) {
            var r2 = _4.point1.Dist(_4.point2), s2 = _4.point1.coords.distance(i.COORDS_BY_USER, t3);
            return r2 < e2.eps ? 0 : s2 / r2 * p + c2;
          }], N), _4.ticks = v), _4.remove = function() {
            x && t2.removeObject(E), t2.removeObject(P2), t2.removeObject(g), t2.removeObject(m), t2.removeObject(f), o.Point.prototype.remove.call(_4);
          }, f.dump = false, m.dump = false, g.dump = false, P2.dump = false, _4.elType = "slider", _4.parents = n3, _4.subs = {point1: f, point2: m, baseLine: g, highLine: P2}, _4.inherits.push(f, m, g, P2), S && (v.dump = false, _4.subs.ticks = v, _4.inherits.push(v)), _4.baseline.on("up", function(t3) {
            var e3, o2;
            s.evaluate(_4.visProp.moveonup) && !s.evaluate(_4.visProp.fixed) && (e3 = g.board.getMousePosition(t3, 0), o2 = new r(i.COORDS_BY_SCREEN, e3, this.board), _4.moveTo([o2.usrCoords[1], o2.usrCoords[2]]));
          }), _4.prepareUpdate().update(), t2.isSuspendedUpdate || (_4.updateVisibility().updateRenderer(), _4.baseline.updateVisibility().updateRenderer(), _4.highline.updateVisibility().updateRenderer(), S && _4.ticks.updateVisibility().updateRenderer()), _4;
        }, t.registerElement("slider", t.createSlider), {createSlider: t.createSlider};
      }), define("element/measure", ["jxg", "utils/type", "base/element", "base/point", "base/line", "base/ticks"], function(t, e2, i, r, s, o) {
        "use strict";
        return t.createTapemeasure = function(r2, s2, o2) {
          var n, a, h, l, c, d, u, p, f, m, g;
          return n = s2[0], a = s2[1], h = e2.copyAttributes(o2, r2.options, "tapemeasure", "point1"), p = r2.create("point", n, h), h = e2.copyAttributes(o2, r2.options, "tapemeasure", "point2"), f = r2.create("point", a, h), p.setAttribute({ignoredSnapToPoints: [f]}), f.setAttribute({ignoredSnapToPoints: [p]}), h = e2.copyAttributes(o2, r2.options, "tapemeasure"), l = h.withticks, c = h.withlabel, d = h.precision, c && (h.withlabel = true), u = r2.create("segment", [p, f], h), c && (m = o2.name && o2.name !== "" ? o2.name + " = " : "", u.label.setText(function() {
            return m + e2.toFixed(p.Dist(f), d);
          })), l && (h = e2.copyAttributes(o2, r2.options, "tapemeasure", "ticks"), g = r2.create("ticks", [u, 0.1], h), u.inherits.push(g)), u.remove = function() {
            l && u.removeTicks(g), r2.removeObject(f), r2.removeObject(p), i.prototype.remove.call(this);
          }, u.Value = function() {
            return p.Dist(f);
          }, p.dump = false, f.dump = false, u.elType = "tapemeasure", u.getParents = function() {
            return [[p.X(), p.Y()], [f.X(), f.Y()]];
          }, u.subs = {point1: p, point2: f}, l && (g.dump = false), u.methodMap = t.deepCopy(u.methodMap, {Value: "Value"}), u.prepareUpdate().update(), r2.isSuspendedUpdate || (u.updateVisibility().updateRenderer(), u.point1.updateVisibility().updateRenderer(), u.point2.updateVisibility().updateRenderer()), u;
        }, t.registerElement("tapemeasure", t.createTapemeasure), {createTapemeasure: t.createTapemeasure};
      }), define("parser/datasource", ["jxg", "utils/type"], function(t, e2) {
        "use strict";
        return t.DataSource = function() {
          return this.data = [], this.columnHeaders = [], this.rowHeaders = [], this;
        }, t.extend(t.DataSource.prototype, {loadFromArray: function(t2, i, r) {
          var s, o, n;
          if (e2.isArray(i) && (this.columnHeaders = i, i = false), e2.isArray(r) && (this.rowHeaders = r, r = false), this.data = [], i && (this.columnHeaders = []), r && (this.rowHeaders = []), e2.exists(t2)) {
            for (this.data = [], s = 0; s < t2.length; s++)
              for (this.data[s] = [], o = 0; o < t2[s].length; o++)
                n = t2[s][o], parseFloat(n).toString() === n ? this.data[s][o] = parseFloat(n) : this.data[s][o] = n !== "-" ? n : NaN;
            if (i && (this.columnHeaders = this.data[0].slice(1), this.data = this.data.slice(1)), r)
              for (this.rowHeaders = [], s = 0; s < this.data.length; s++)
                this.rowHeaders.push(this.data[s][0]), this.data[s] = this.data[s].slice(1);
          }
          return this;
        }, loadFromTable: function(t2, i, r) {
          var s, o, n, a, h;
          if (e2.isArray(i) && (this.columnHeaders = i, i = false), e2.isArray(r) && (this.rowHeaders = r, r = false), this.data = [], i && (this.columnHeaders = []), r && (this.rowHeaders = []), t2 = document.getElementById(t2), e2.exists(t2)) {
            for (s = t2.getElementsByTagName("tr"), this.data = [], o = 0; o < s.length; o++)
              for (a = s[o].getElementsByTagName("td"), this.data[o] = [], n = 0; n < a.length; n++)
                h = a[n].innerHTML, parseFloat(h).toString() === h ? this.data[o][n] = parseFloat(h) : this.data[o][n] = h !== "-" ? h : NaN;
            if (i && (this.columnHeaders = this.data[0].slice(1), this.data = this.data.slice(1)), r)
              for (this.rowHeaders = [], o = 0; o < this.data.length; o++)
                this.rowHeaders.push(this.data[o][0]), this.data[o] = this.data[o].slice(1);
          }
          return this;
        }, addColumn: function(t2, e3, i) {
          throw new Error("not implemented");
        }, addRow: function(t2, e3, i) {
          throw new Error("not implemented");
        }, getColumn: function(t2) {
          var i, r = [];
          if (e2.isString(t2)) {
            for (i = 0; i < this.columnHeaders.length; i++)
              if (t2 === this.columnHeaders[i]) {
                t2 = i;
                break;
              }
          }
          for (i = 0; i < this.data.length; i++)
            this.data[i].length > t2 && (r[i] = parseFloat(this.data[i][t2]));
          return r;
        }, getRow: function(t2) {
          var i, r;
          if (e2.isString(t2)) {
            for (r = 0; r < this.rowHeaders.length; r++)
              if (t2 === this.rowHeaders[r]) {
                t2 = r;
                break;
              }
          }
          for (i = [], r = 0; r < this.data[t2].length; r++)
            i[r] = this.data[t2][r];
          return i;
        }}), t.DataSource;
      }), define("base/chart", ["jxg", "math/numerics", "math/statistics", "base/constants", "base/coords", "base/element", "parser/datasource", "utils/color", "utils/type", "utils/env", "base/curve", "base/point", "base/text", "base/polygon", "element/sector", "base/transformation", "base/line", "base/circle"], function(t, e2, i, r, s, o, n, a, h, l, c, d, u, p, f, m, g, b) {
        "use strict";
        return t.Chart = function(t2, e3, i2) {
          this.constructor(t2, i2);
          var r2, s2, o2, n3, a2, l2;
          if (!h.isArray(e3) || e3.length === 0)
            throw new Error("JSXGraph: Can't create a chart without data");
          if (this.elements = [], h.isNumber(e3[0]))
            for (s2 = e3, r2 = [], o2 = 0; o2 < s2.length; o2++)
              r2[o2] = o2 + 1;
          else if (e3.length === 1 && h.isArray(e3[0]))
            for (s2 = e3[0], r2 = [], l2 = h.evaluate(s2).length, o2 = 0; o2 < l2; o2++)
              r2[o2] = o2 + 1;
          else
            e3.length === 2 && (l2 = Math.min(e3[0].length, e3[1].length), r2 = e3[0].slice(0, l2), s2 = e3[1].slice(0, l2));
          if (h.isArray(s2) && s2.length === 0)
            throw new Error("JSXGraph: Can't create charts without data.");
          for (a2 = i2.chartstyle.replace(/ /g, "").split(","), o2 = 0; o2 < a2.length; o2++) {
            switch (a2[o2]) {
              case "bar":
                n3 = this.drawBar(t2, r2, s2, i2);
                break;
              case "line":
                n3 = this.drawLine(t2, r2, s2, i2);
                break;
              case "fit":
                n3 = this.drawFit(t2, r2, s2, i2);
                break;
              case "spline":
                n3 = this.drawSpline(t2, r2, s2, i2);
                break;
              case "pie":
                n3 = this.drawPie(t2, s2, i2);
                break;
              case "point":
                n3 = this.drawPoints(t2, r2, s2, i2);
                break;
              case "radar":
                n3 = this.drawRadar(t2, e3, i2);
            }
            this.elements.push(n3);
          }
          return this.id = this.board.setId(this, "Chart"), this.elements;
        }, t.Chart.prototype = new o(), t.extend(t.Chart.prototype, {drawLine: function(t2, e3, i2, r2) {
          return r2.fillcolor = "none", r2.highlightfillcolor = "none", t2.create("curve", [e3, i2], r2);
        }, drawSpline: function(t2, e3, i2, r2) {
          return r2.fillColor = "none", r2.highlightfillcolor = "none", t2.create("spline", [e3, i2], r2);
        }, drawFit: function(t2, i2, r2, s2) {
          var o2 = s2.degree;
          return o2 = Math.max(parseInt(o2, 10), 1) || 1, s2.fillcolor = "none", s2.highlightfillcolor = "none", t2.create("functiongraph", [e2.regressionPolynomial(o2, i2, r2)], s2);
        }, drawBar: function(t2, e3, i2, r2) {
          var s2, o2, n3, a2, l2, c2, d2, u2, p2, f2, m2 = [], g2 = [], b2 = function(t3, i3) {
            return function() {
              return e3[t3]() - i3 * n3;
            };
          }, v = {fixed: true, withLabel: false, visible: false, name: ""};
          if ((p2 = h.copyAttributes(r2, t2.options, "chart")) && p2.width)
            n3 = p2.width;
          else {
            if (e3.length <= 1)
              n3 = 1;
            else
              for (n3 = e3[1] - e3[0], s2 = 1; s2 < e3.length - 1; s2++)
                n3 = e3[s2 + 1] - e3[s2] < n3 ? e3[s2 + 1] - e3[s2] : n3;
            n3 *= 0.8;
          }
          for (f2 = h.copyAttributes(r2, t2.options, "chart", "label"), s2 = 0; s2 < e3.length; s2++)
            h.isFunction(e3[s2]) ? (a2 = b2(s2, -0.5), l2 = b2(s2, 0), c2 = b2(s2, 0.5)) : (a2 = e3[s2] - 0.5 * n3, l2 = e3[s2], c2 = e3[s2] + 0.5 * n3), d2 = h.isFunction(i2[s2]) ? i2[s2]() : i2[s2], d2 = i2[s2], p2.dir === "horizontal" ? (g2[0] = t2.create("point", [0, a2], v), g2[1] = t2.create("point", [d2, a2], v), g2[2] = t2.create("point", [d2, c2], v), g2[3] = t2.create("point", [0, c2], v), h.exists(p2.labels) && h.exists(p2.labels[s2]) && (f2.anchorY = "middle", o2 = t2.create("text", [d2, l2, p2.labels[s2]], f2), o2.visProp.anchorx = function(t3) {
              return function() {
                return t3.X() >= 0 ? "left" : "right";
              };
            }(o2))) : (g2[0] = t2.create("point", [a2, 0], v), g2[1] = t2.create("point", [a2, d2], v), g2[2] = t2.create("point", [c2, d2], v), g2[3] = t2.create("point", [c2, 0], v), h.exists(p2.labels) && h.exists(p2.labels[s2]) && (f2.anchorX = "middle", o2 = t2.create("text", [l2, d2, p2.labels[s2]], f2), o2.visProp.anchory = function(t3) {
              return function() {
                return t3.Y() >= 0 ? "bottom" : "top";
              };
            }(o2))), h.isArray(p2.colors) && (u2 = p2.colors, p2.fillcolor = u2[s2 % u2.length]), m2[s2] = t2.create("polygon", g2, p2), h.exists(p2.labels) && h.exists(p2.labels[s2]) && (m2[s2].text = o2);
          return m2;
        }, drawPoints: function(t2, e3, i2, r2) {
          var s2, o2 = [], n3 = r2.infoboxarray;
          for (r2.fixed = true, r2.name = "", s2 = 0; s2 < e3.length; s2++)
            r2.infoboxtext = !!n3 && n3[s2 % n3.length], o2[s2] = t2.create("point", [e3[s2], i2[s2]], r2);
          return o2;
        }, drawPie: function(t2, e3, o2) {
          var n3, a2, l2 = [], c2 = [], d2 = (i.sum(e3), o2.colors), u2 = o2.highlightcolors, p2 = o2.labels, f2 = o2.radius || 4, m2 = f2, g2 = o2.center || [0, 0], b2 = g2[0], v = g2[1], y = function(t3, i2, r2) {
            return function() {
              var s2, o3, n4, a3 = 0;
              for (o3 = 0; o3 <= t3; o3++)
                a3 += parseFloat(h.evaluate(e3[o3]));
              for (s2 = a3, o3 = t3 + 1; o3 < e3.length; o3++)
                s2 += parseFloat(h.evaluate(e3[o3]));
              return n4 = s2 !== 0 ? 2 * Math.PI * a3 / s2 : 0, m2() * Math[i2](n4) + r2;
            };
          }, C = function(t3, e4) {
            var i2 = -this.point1.coords.usrCoords[1] + this.point2.coords.usrCoords[1], o3 = -this.point1.coords.usrCoords[2] + this.point2.coords.usrCoords[2];
            h.exists(this.label) && (this.label.rendNode.style.fontSize = e4 * h.evaluate(this.label.visProp.fontsize) + "px", this.label.fullUpdate()), this.point2.coords = new s(r.COORDS_BY_USER, [this.point1.coords.usrCoords[1] + i2 * t3, this.point1.coords.usrCoords[2] + o3 * t3], this.board), this.fullUpdate();
          }, _4 = function() {
            this.highlighted || (this.highlighted = true, this.board.highlightedObjects[this.id] = this, this.board.renderer.highlight(this), C.call(this, 1.1, 2));
          }, P2 = function() {
            this.highlighted && (this.highlighted = false, this.board.renderer.noHighlight(this), C.call(this, 0.9090909, 1));
          }, E = {fixed: true, withLabel: false, visible: false, name: ""};
          if (!h.isArray(p2))
            for (p2 = [], n3 = 0; n3 < e3.length; n3++)
              p2[n3] = "";
          for (h.isFunction(f2) || (m2 = function() {
            return f2;
          }), o2.highlightonsector = o2.highlightonsector || false, o2.straightfirst = false, o2.straightlast = false, a2 = t2.create("point", [b2, v], E), l2[0] = t2.create("point", [function() {
            return m2() + b2;
          }, function() {
            return v;
          }], E), n3 = 0; n3 < e3.length; n3++)
            l2[n3 + 1] = t2.create("point", [y(n3, "cos", b2), y(n3, "sin", v)], E), o2.name = p2[n3], o2.withlabel = o2.name !== "", o2.fillcolor = d2 && d2[n3 % d2.length], o2.labelcolor = d2 && d2[n3 % d2.length], o2.highlightfillcolor = u2 && u2[n3 % u2.length], c2[n3] = t2.create("sector", [a2, l2[n3], l2[n3 + 1]], o2), o2.highlightonsector && (c2[n3].hasPoint = c2[n3].hasPointSector), o2.highlightbysize && (c2[n3].highlight = _4, c2[n3].noHighlight = P2);
          return {sectors: c2, points: l2, midpoint: a2};
        }, drawRadar: function(e3, i2, o2) {
          var n3, a2, l2, c2, d2, u2, p2, f2, m2, g2, b2, v, y, C, _4, P2, E, x, S, O, w, T, N, M, A, R, L, k, B, I, Y, D, j, X, U, F, G, J, z, H, V, $, q, W = i2.length, Z = function() {
            var t2, e4, i3, o3, n4 = h.evaluate(this.visProp.label.offset).slice(0);
            return t2 = this.point1.X(), e4 = this.point2.X(), i3 = this.point1.Y(), o3 = this.point2.Y(), e4 < t2 && (n4[0] = -n4[0]), o3 < i3 && (n4[1] = -n4[1]), this.setLabelRelativeCoords(n4), new s(r.COORDS_BY_USER, [this.point2.X(), this.point2.Y()], this.board);
          }, Q2 = function(t2, i3) {
            var r2, s2, o3;
            return r2 = e3.create("transform", [-(_4[i3] - y[i3]), 0], {type: "translate"}), s2 = e3.create("transform", [S / (P2[i3] + C[i3] - (_4[i3] - y[i3])), 1], {type: "scale"}), r2.melt(s2), o3 = e3.create("transform", [t2], {type: "rotate"}), r2.melt(o3), r2;
          };
          if (W <= 0)
            throw new Error("JSXGraph radar chart: no data");
          if (l2 = o2.paramarray, !h.exists(l2))
            throw new Error("JSXGraph radar chart: need paramArray attribute");
          if ((c2 = l2.length) <= 1)
            throw new Error("JSXGraph radar chart: need more than one param in paramArray");
          for (n3 = 0; n3 < W; n3++)
            if (c2 !== i2[n3].length)
              throw new Error("JSXGraph radar chart: use data length equal to number of params (" + i2[n3].length + " != " + c2 + ")");
          for (d2 = [], u2 = [], a2 = 0; a2 < c2; a2++)
            d2[a2] = i2[0][a2], u2[a2] = d2[a2];
          for (n3 = 1; n3 < W; n3++)
            for (a2 = 0; a2 < c2; a2++)
              i2[n3][a2] > d2[a2] && (d2[a2] = i2[n3][a2]), i2[n3][a2] < u2[a2] && (u2[a2] = i2[n3][a2]);
          for (p2 = [], f2 = [], n3 = 0; n3 < W; n3++)
            p2[n3] = "", f2[n3] = [];
          for (m2 = [], g2 = [], b2 = o2.startshiftratio || 0, v = o2.endshiftratio || 0, n3 = 0; n3 < c2; n3++)
            m2[n3] = (d2[n3] - u2[n3]) * b2, g2[n3] = (d2[n3] - u2[n3]) * v;
          if (y = o2.startshiftarray || m2, C = o2.endshiftarray || g2, _4 = o2.startarray || u2, h.exists(o2.start))
            for (n3 = 0; n3 < c2; n3++)
              _4[n3] = o2.start;
          if (P2 = o2.endarray || d2, h.exists(o2.end))
            for (n3 = 0; n3 < c2; n3++)
              P2[n3] = o2.end;
          if (y.length !== c2)
            throw new Error("JSXGraph radar chart: start shifts length is not equal to number of parameters");
          if (C.length !== c2)
            throw new Error("JSXGraph radar chart: end shifts length is not equal to number of parameters");
          if (_4.length !== c2)
            throw new Error("JSXGraph radar chart: starts length is not equal to number of parameters");
          if (P2.length !== c2)
            throw new Error("JSXGraph radar chart: snds length is not equal to number of parameters");
          for (E = o2.labelarray || p2, x = o2.colors, o2.highlightcolors, S = o2.radius || 10, $ = o2.strokewidth || 1, h.exists(o2.highlightonsector) || (o2.highlightonsector = false), O = {name: o2.name, id: o2.id, strokewidth: $, polystrokewidth: o2.polystrokewidth || $, strokecolor: o2.strokecolor || "black", straightfirst: false, straightlast: false, fillcolor: o2.fillColor || "#FFFF88", fillopacity: o2.fillOpacity || 0.4, highlightfillcolor: o2.highlightFillColor || "#FF7400", highlightstrokecolor: o2.highlightStrokeColor || "black", gradient: o2.gradient || "none"}, w = o2.center || [0, 0], T = w[0], N = w[1], M = e3.create("point", [T, N], {name: "", fixed: true, withlabel: false, visible: false}), A = Math.PI / 2 - Math.PI / c2, A = o2.startangle || 0, R = A, L = [], k = [], n3 = 0; n3 < c2; n3++)
            for (R += 2 * Math.PI / c2, I = S * Math.cos(R) + T, Y = S * Math.sin(R) + N, L[n3] = e3.create("point", [I, Y], {name: "", fixed: true, withlabel: false, visible: false}), k[n3] = e3.create("line", [M, L[n3]], {name: l2[n3], strokeColor: O.strokecolor, strokeWidth: O.strokewidth, strokeOpacity: 1, straightFirst: false, straightLast: false, withLabel: true, highlightStrokeColor: O.highlightstrokecolor}), k[n3].getLabelAnchor = Z, B = Q2(R, n3), a2 = 0; a2 < i2.length; a2++)
              q = i2[a2][n3], f2[a2][n3] = e3.create("point", [q, 0], {name: "", fixed: true, withlabel: false, visible: false}), f2[a2][n3].addTransform(f2[a2][n3], B);
          for (D = [], n3 = 0; n3 < W; n3++)
            for (O.labelcolor = x && x[n3 % x.length], O.strokecolor = x && x[n3 % x.length], O.fillcolor = x && x[n3 % x.length], D[n3] = e3.create("polygon", f2[n3], {withLines: true, withLabel: false, fillColor: O.fillcolor, fillOpacity: O.fillopacity, highlightFillColor: O.highlightfillcolor}), a2 = 0; a2 < c2; a2++)
              D[n3].borders[a2].setAttribute("strokecolor:" + x[n3 % x.length]), D[n3].borders[a2].setAttribute("strokewidth:" + O.polystrokewidth);
          switch (o2.legendposition || "none") {
            case "right":
              X = o2.legendleftoffset || 2, U = o2.legendtopoffset || 1, this.legend = e3.create("legend", [T + S + X, N + S - U], {labels: E, colors: x});
              break;
            case "none":
              break;
            default:
              t.debug("Unknown legend position");
          }
          if (j = [], o2.showcircles) {
            for (F = [], n3 = 0; n3 < 6; n3++)
              F[n3] = 20 * n3;
            if (F[0] = "0", G = o2.circlelabelarray || F, (J = G.length) < 2)
              throw new Error("JSXGraph radar chart: too less circles in circleLabelArray");
            for (z = [], H = A + Math.PI / c2, B = Q2(H, 0), O.fillcolor = "none", O.highlightfillcolor = "none", O.strokecolor = o2.strokecolor || "black", O.strokewidth = o2.circlestrokewidth || 0.5, O.layer = 0, V = (P2[0] - _4[0]) / (J - 1), n3 = 0; n3 < J; n3++)
              z[n3] = e3.create("point", [_4[0] + n3 * V, 0], {name: G[n3], size: 0, fixed: true, withLabel: true, visible: true}), z[n3].addTransform(z[n3], B), j[n3] = e3.create("circle", [M, z[n3]], O);
          }
          return this.rendNode = D[0].rendNode, {circles: j, lines: k, points: f2, midpoint: M, polygons: D};
        }, updateRenderer: function() {
          return this;
        }, update: function() {
          return this.needsUpdate && this.updateDataArray(), this;
        }, updateDataArray: function() {
          return this;
        }}), t.createChart = function(e3, i2, r2) {
          var s2, o2, c2, d2, u2, p2, f2, m2, g2, b2, v, y, C, _4, P2, E, x = [], S = l.isBrowser ? e3.document.getElementById(i2[0]) : null;
          if (i2.length === 1 && h.isString(i2[0])) {
            if (h.exists(S)) {
              if (g2 = h.copyAttributes(r2, e3.options, "chart"), S = new n().loadFromTable(i2[0], g2.withheaders, g2.withheaders), s2 = S.data, u2 = S.columnHeaders, o2 = S.rowHeaders, b2 = g2.width, v = g2.name, y = g2.strokecolor, C = g2.fillcolor, _4 = g2.highlightstrokecolor, P2 = g2.highlightfillcolor, e3.suspendUpdate(), E = s2.length, m2 = [], g2.rows && h.isArray(g2.rows)) {
                for (c2 = 0; c2 < E; c2++)
                  for (d2 = 0; d2 < g2.rows.length; d2++)
                    if (g2.rows[d2] === c2 || g2.withheaders && g2.rows[d2] === o2[c2]) {
                      m2.push(s2[c2]);
                      break;
                    }
              } else
                m2 = s2;
              for (E = m2.length, c2 = 0; c2 < E; c2++) {
                if (f2 = [], g2.chartstyle && g2.chartstyle.indexOf("bar") !== -1) {
                  for (p2 = b2 || 0.8, f2.push(1 - p2 / 2 + (c2 + 0.5) * p2 / E), d2 = 1; d2 < m2[c2].length; d2++)
                    f2.push(f2[d2 - 1] + 1);
                  g2.width = p2 / E;
                }
                v && v.length === E ? g2.name = v[c2] : g2.withheaders && (g2.name = u2[c2]), y && y.length === E ? g2.strokecolor = y[c2] : g2.strokecolor = a.hsv2rgb((c2 + 1) / E * 360, 0.9, 0.6), C && C.length === E ? g2.fillcolor = C[c2] : g2.fillcolor = a.hsv2rgb((c2 + 1) / E * 360, 0.9, 1), _4 && _4.length === E ? g2.highlightstrokecolor = _4[c2] : g2.highlightstrokecolor = a.hsv2rgb((c2 + 1) / E * 360, 0.9, 1), P2 && P2.length === E ? g2.highlightfillcolor = P2[c2] : g2.highlightfillcolor = a.hsv2rgb((c2 + 1) / E * 360, 0.9, 0.6), g2.chartstyle && g2.chartstyle.indexOf("bar") !== -1 ? x.push(new t.Chart(e3, [f2, m2[c2]], g2)) : x.push(new t.Chart(e3, [m2[c2]], g2));
              }
              e3.unsuspendUpdate();
            }
            return x;
          }
          return g2 = h.copyAttributes(r2, e3.options, "chart"), new t.Chart(e3, i2, g2);
        }, t.registerElement("chart", t.createChart), t.Legend = function(t2, e3, i2) {
          var o2;
          if (this.constructor(), o2 = h.copyAttributes(i2, t2.options, "legend"), this.board = t2, this.coords = new s(r.COORDS_BY_USER, e3, this.board), this.myAtts = {}, this.label_array = o2.labelarray || o2.labels, this.color_array = o2.colorarray || o2.colors, this.lines = [], this.myAtts.strokewidth = o2.strokewidth || 5, this.myAtts.straightfirst = false, this.myAtts.straightlast = false, this.myAtts.withlabel = true, this.myAtts.fixed = true, this.style = o2.legendstyle || o2.style, this.style !== "vertical")
            throw new Error("JSXGraph: Unknown legend style: " + this.style);
          this.drawVerticalLegend(t2, o2);
        }, t.Legend.prototype = new o(), t.Legend.prototype.drawVerticalLegend = function(t2, e3) {
          var i2, o2 = e3.linelength || 1, n3 = (e3.rowheight || 20) / this.board.unitY, a2 = function() {
            return this.setLabelRelativeCoords(this.visProp.label.offset), new s(r.COORDS_BY_USER, [this.point2.X(), this.point2.Y()], this.board);
          };
          for (i2 = 0; i2 < this.label_array.length; i2++)
            this.myAtts.name = this.label_array[i2], this.myAtts.strokecolor = this.color_array[i2 % this.color_array.length], this.myAtts.highlightstrokecolor = this.color_array[i2 % this.color_array.length], this.myAtts.label = {offset: [10, 0], strokeColor: this.color_array[i2 % this.color_array.length], strokeWidth: this.myAtts.strokewidth}, this.lines[i2] = t2.create("line", [[this.coords.usrCoords[1], this.coords.usrCoords[2] - i2 * n3], [this.coords.usrCoords[1] + o2, this.coords.usrCoords[2] - i2 * n3]], this.myAtts), this.lines[i2].getLabelAnchor = a2, this.lines[i2].prepareUpdate().update().updateVisibility(h.evaluate(this.lines[i2].visProp.visible)).updateRenderer();
        }, t.createLegend = function(e3, i2, r2) {
          var s2 = [0, 0];
          if (!h.exists(i2) || i2.length !== 2)
            throw new Error("JSXGraph: Legend element needs two numbers as parameters");
          return s2 = i2, new t.Legend(e3, s2, r2);
        }, t.registerElement("legend", t.createLegend), {Chart: t.Chart, Legend: t.Legend, createChart: t.createChart, createLegend: t.createLegend};
      }), define("base/turtle", ["jxg", "base/constants", "base/element", "utils/type", "base/curve", "base/point", "base/line", "base/transformation"], function(t, e2, i, r, s, o, n, a) {
        "use strict";
        return t.Turtle = function(t2, i2, s2) {
          var o2, n3, a2;
          return this.constructor(t2, s2, e2.OBJECT_TYPE_TURTLE, e2.OBJECT_CLASS_OTHER), this.turtleIsHidden = false, this.board = t2, this.visProp.curveType = "plot", this._attributes = r.copyAttributes(this.visProp, t2.options, "turtle"), delete this._attributes.id, o2 = 0, n3 = 0, a2 = 90, i2.length !== 0 && (i2.length === 3 ? (o2 = i2[0], n3 = i2[1], a2 = i2[2]) : i2.length === 2 ? r.isArray(i2[0]) ? (o2 = i2[0][0], n3 = i2[0][1], a2 = i2[1]) : (o2 = i2[0], n3 = i2[1]) : (o2 = i2[0][0], n3 = i2[0][1])), this.init(o2, n3, a2), this.methodMap = r.deepCopy(this.methodMap, {forward: "forward", fd: "forward", back: "back", bk: "back", right: "right", rt: "right", left: "left", lt: "left", penUp: "penUp", pu: "penUp", penDown: "penDown", pd: "penDown", clearScreen: "clearScreen", cs: "clearScreen", clean: "clean", setPos: "setPos", home: "home", hideTurtle: "hideTurtle", ht: "hideTurtle", showTurtle: "showTurtle", st: "showTurtle", penSize: "setPenSize", penColor: "setPenColor", pushTurtle: "pushTurtle", push: "pushTurtle", popTurtle: "popTurtle", pop: "popTurtle", lookTo: "lookTo", pos: "pos", moveTo: "moveTo", X: "X", Y: "Y"}), this;
        }, t.Turtle.prototype = new i(), t.extend(t.Turtle.prototype, {init: function(t2, e3, i2) {
          var r2 = {fixed: true, name: "", visible: false, withLabel: false};
          this.arrowLen = 20 / Math.sqrt(this.board.unitX * this.board.unitX + this.board.unitY * this.board.unitY), this.pos = [t2, e3], this.isPenDown = true, this.dir = 90, this.stack = [], this.objects = [], this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve), this.turtle = this.board.create("point", this.pos, r2), this.objects.push(this.turtle), this.turtle2 = this.board.create("point", [this.pos[0], this.pos[1] + this.arrowLen], r2), this.objects.push(this.turtle2), this.visProp.arrow.lastArrow = true, this.visProp.arrow.straightFirst = false, this.visProp.arrow.straightLast = false, this.arrow = this.board.create("line", [this.turtle, this.turtle2], this.visProp.arrow), this.objects.push(this.arrow), this.subs = {arrow: this.arrow}, this.inherits.push(this.arrow), this.right(90 - i2), this.board.update();
        }, forward: function(t2) {
          if (t2 === 0)
            return this;
          var e3, i2 = t2 * Math.cos(this.dir * Math.PI / 180), r2 = t2 * Math.sin(this.dir * Math.PI / 180);
          return this.turtleIsHidden || (e3 = this.board.create("transform", [i2, r2], {type: "translate"}), e3.applyOnce(this.turtle), e3.applyOnce(this.turtle2)), this.isPenDown && this.curve.dataX.length >= 8192 && (this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve)), this.pos[0] += i2, this.pos[1] += r2, this.isPenDown && (this.curve.dataX.push(this.pos[0]), this.curve.dataY.push(this.pos[1])), this.board.update(), this;
        }, back: function(t2) {
          return this.forward(-t2);
        }, right: function(t2) {
          if (this.dir -= t2, this.dir %= 360, !this.turtleIsHidden) {
            this.board.create("transform", [-t2 * Math.PI / 180, this.turtle], {type: "rotate"}).applyOnce(this.turtle2);
          }
          return this.board.update(), this;
        }, left: function(t2) {
          return this.right(-t2);
        }, penUp: function() {
          return this.isPenDown = false, this;
        }, penDown: function() {
          return this.isPenDown = true, this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve), this;
        }, clean: function() {
          var t2, i2;
          for (t2 = 0; t2 < this.objects.length; t2++)
            i2 = this.objects[t2], i2.type === e2.OBJECT_TYPE_CURVE && (this.board.removeObject(i2), this.objects.splice(t2, 1));
          return this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve), this.board.update(), this;
        }, clearScreen: function() {
          var t2, e3, i2 = this.objects.length;
          for (t2 = 0; t2 < i2; t2++)
            e3 = this.objects[t2], this.board.removeObject(e3);
          return this.init(0, 0, 90), this;
        }, setPos: function(t2, i2) {
          var s2;
          return r.isArray(t2) ? this.pos = t2 : this.pos = [t2, i2], this.turtleIsHidden || (this.turtle.setPositionDirectly(e2.COORDS_BY_USER, [t2, i2]), this.turtle2.setPositionDirectly(e2.COORDS_BY_USER, [t2, i2 + this.arrowLen]), s2 = this.board.create("transform", [-(this.dir - 90) * Math.PI / 180, this.turtle], {type: "rotate"}), s2.applyOnce(this.turtle2)), this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve), this.board.update(), this;
        }, setPenSize: function(t2) {
          return this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this.copyAttr("strokeWidth", t2)), this.objects.push(this.curve), this;
        }, setPenColor: function(t2) {
          return this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this.copyAttr("strokeColor", t2)), this.objects.push(this.curve), this;
        }, setHighlightPenColor: function(t2) {
          return this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this.copyAttr("highlightStrokeColor", t2)), this.objects.push(this.curve), this;
        }, setAttribute: function(t2) {
          var i2, s2, o2, n3 = this.objects.length;
          for (i2 = 0; i2 < n3; i2++)
            s2 = this.objects[i2], s2.type === e2.OBJECT_TYPE_CURVE && s2.setAttribute(t2);
          return o2 = this.visProp.id, this.visProp = r.deepCopy(this.curve.visProp), this.visProp.id = o2, this._attributes = r.deepCopy(this.visProp), delete this._attributes.id, this;
        }, copyAttr: function(t2, e3) {
          return this._attributes[t2.toLowerCase()] = e3, this._attributes;
        }, showTurtle: function() {
          return this.turtleIsHidden = false, this.arrow.setAttribute({visible: true}), this.visProp.arrow.visible = false, this.setPos(this.pos[0], this.pos[1]), this.board.update(), this;
        }, hideTurtle: function() {
          return this.turtleIsHidden = true, this.arrow.setAttribute({visible: false}), this.visProp.arrow.visible = false, this.board.update(), this;
        }, home: function() {
          return this.pos = [0, 0], this.setPos(this.pos[0], this.pos[1]), this;
        }, pushTurtle: function() {
          return this.stack.push([this.pos[0], this.pos[1], this.dir]), this;
        }, popTurtle: function() {
          var t2 = this.stack.pop();
          return this.pos[0] = t2[0], this.pos[1] = t2[1], this.dir = t2[2], this.setPos(this.pos[0], this.pos[1]), this;
        }, lookTo: function(t2) {
          var e3, i2, s2, o2, n3;
          return r.isArray(t2) ? (e3 = this.pos[0], i2 = this.pos[1], s2 = t2[0], o2 = t2[1], n3 = Math.atan2(o2 - i2, s2 - e3), this.right(this.dir - 180 * n3 / Math.PI)) : r.isNumber(t2) && this.right(this.dir - t2), this;
        }, moveTo: function(t2) {
          var e3, i2, s2;
          return r.isArray(t2) && (e3 = t2[0] - this.pos[0], i2 = t2[1] - this.pos[1], this.turtleIsHidden || (s2 = this.board.create("transform", [e3, i2], {type: "translate"}), s2.applyOnce(this.turtle), s2.applyOnce(this.turtle2)), this.isPenDown && this.curve.dataX.length >= 8192 && (this.curve = this.board.create("curve", [[this.pos[0]], [this.pos[1]]], this._attributes), this.objects.push(this.curve)), this.pos[0] = t2[0], this.pos[1] = t2[1], this.isPenDown && (this.curve.dataX.push(this.pos[0]), this.curve.dataY.push(this.pos[1])), this.board.update()), this;
        }, fd: function(t2) {
          return this.forward(t2);
        }, bk: function(t2) {
          return this.back(t2);
        }, lt: function(t2) {
          return this.left(t2);
        }, rt: function(t2) {
          return this.right(t2);
        }, pu: function() {
          return this.penUp();
        }, pd: function() {
          return this.penDown();
        }, ht: function() {
          return this.hideTurtle();
        }, st: function() {
          return this.showTurtle();
        }, cs: function() {
          return this.clearScreen();
        }, push: function() {
          return this.pushTurtle();
        }, pop: function() {
          return this.popTurtle();
        }, evalAt: function(t2, i2) {
          var r2, s2, o2, n3, a2 = this.objects.length;
          for (r2 = 0, s2 = 0; r2 < a2; r2++)
            if (o2 = this.objects[r2], o2.elementClass === e2.OBJECT_CLASS_CURVE) {
              if (s2 <= t2 && t2 < s2 + o2.numberPoints)
                return n3 = t2 - s2, o2[i2](n3);
              s2 += o2.numberPoints;
            }
          return this[i2]();
        }, X: function(t2) {
          return r.exists(t2) ? this.evalAt(t2, "X") : this.pos[0];
        }, Y: function(t2) {
          return r.exists(t2) ? this.evalAt(t2, "Y") : this.pos[1];
        }, Z: function(t2) {
          return 1;
        }, minX: function() {
          return 0;
        }, maxX: function() {
          var t2, i2, r2 = this.objects.length, s2 = 0;
          for (t2 = 0; t2 < r2; t2++)
            i2 = this.objects[t2], i2.elementClass === e2.OBJECT_CLASS_CURVE && (s2 += this.objects[t2].numberPoints);
          return s2;
        }, hasPoint: function(t2, i2) {
          var r2, s2;
          for (r2 = 0; r2 < this.objects.length; r2++)
            if (s2 = this.objects[r2], s2.type === e2.OBJECT_TYPE_CURVE && s2.hasPoint(t2, i2))
              return true;
          return false;
        }}), t.createTurtle = function(e3, i2, s2) {
          var o2;
          return i2 = i2 || [], o2 = r.copyAttributes(s2, e3.options, "turtle"), new t.Turtle(e3, i2, o2);
        }, t.registerElement("turtle", t.createTurtle), {Turtle: t.Turtle, createTurtle: t.createTurtle};
      }), define("parser/ca", ["jxg", "base/constants", "base/text", "math/math", "math/geometry", "math/statistics", "utils/type", "utils/env"], function(t, e2, i, r, s, o, n, a) {
        "use strict";
        return t.CA = function(t2, e3, i2) {
          this.node = t2, this.createNode = e3, this.parser = i2;
        }, t.extend(t.CA.prototype, {findMapNode: function(t2, e3) {
          var i2, r2, s2;
          if (e3.value === "op_assign" && e3.children[0].value === t2)
            return e3.children[1];
          if (e3.children) {
            for (r2 = e3.children.length, i2 = 0; i2 < r2; ++i2)
              if ((s2 = this.findMapNode(t2, e3.children[i2])) !== null)
                return s2;
          }
          return null;
        }, setMath: function(t2) {
          var e3, i2;
          if ((t2.type != "node_op" || t2.value != "op_add" && t2.value != "op_sub" && t2.value != "op_mul" && t2.value != "op_div" && t2.value != "op_neg" && t2.value != "op_execfun" && t2.value != "op_exp") && t2.type != "node_var" && t2.type != "node_const" || (t2.isMath = true), t2.children)
            for (i2 = t2.children.length, e3 = 0; e3 < i2; ++e3)
              this.setMath(t2.children[e3]);
        }, deriveElementary: function(t2, e3) {
          var i2, r2 = t2.children[0].value, s2 = t2.children[1];
          switch (r2) {
            case "abs":
              i2 = this.createNode("node_op", "op_div", s2[0], this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_mul", n.deepCopy(s2[0]), n.deepCopy(s2[0]))]));
              break;
            case "sqrt":
              i2 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", this.createNode("node_const", 2), this.createNode(t2.type, t2.value, n.deepCopy(t2.children[0]), n.deepCopy(t2.children[1]))));
              break;
            case "sin":
              i2 = this.createNode("node_op", "op_execfun", this.createNode("node_var", "cos"), n.deepCopy(s2));
              break;
            case "cos":
              i2 = this.createNode("node_op", "op_neg", this.createNode("node_op", "op_execfun", this.createNode("node_var", "sin"), n.deepCopy(s2)));
              break;
            case "tan":
              i2 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_exp", this.createNode("node_op", "op_execfun", this.createNode("node_var", "cos"), n.deepCopy(s2)), this.createNode("node_const", 2)));
              break;
            case "cot":
              i2 = this.createNode("node_op", "op_neg", this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_exp", this.createNode("node_op", "op_execfun", this.createNode("node_var", "sin"), n.deepCopy(s2)), this.createNode("node_const", 2))));
              break;
            case "exp":
              i2 = this.createNode(t2.type, t2.value, n.deepCopy(t2.children[0]), n.deepCopy(t2.children[1]));
              break;
            case "pow":
              i2 = this.createNode("node_op", "op_mul", this.createNode("node_op", "op_execfun", n.deepCopy(t2.children[0]), n.deepCopy(t2.children[1])), this.createNode("node_op", "op_add", this.createNode("node_op", "op_mul", this.derivative(t2.children[1][0], e3), this.createNode("node_op", "op_div", n.deepCopy(t2.children[1][1]), n.deepCopy(t2.children[1][0]))), this.createNode("node_op", "op_mul", this.derivative(t2.children[1][1], e3), this.createNode("node_op", "op_execfun", this.createNode("node_var", "log"), [n.deepCopy(t2.children[1][0])]))));
              break;
            case "log":
            case "ln":
              i2 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), n.deepCopy(s2[0]));
              break;
            case "log2":
            case "lb":
            case "ld":
              i2 = this.createNode("node_op", "op_mul", this.createNode("node_op", "op_div", this.createNode("node_const", 1), n.deepCopy(s2[0])), this.createNode("node_const", 1.4426950408889634));
              break;
            case "log10":
            case "lg":
              i2 = this.createNode("node_op", "op_mul", this.createNode("node_op", "op_div", this.createNode("node_const", 1), n.deepCopy(s2[0])), this.createNode("node_const", 0.43429448190325176));
              break;
            case "asin":
              i2 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_sub", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", n.deepCopy(s2[0]), n.deepCopy(s2[0])))]));
              break;
            case "acos":
              i2 = this.createNode("node_op", "op_neg", this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_sub", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", n.deepCopy(s2[0]), n.deepCopy(s2[0])))])));
              break;
            case "atan":
              i2 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_add", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", n.deepCopy(s2[0]), n.deepCopy(s2[0]))));
              break;
            case "acot":
              i2 = this.createNode("node_op", "op_neg", this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_add", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", n.deepCopy(s2[0]), n.deepCopy(s2[0])))));
              break;
            case "sinh":
              i2 = this.createNode("node_op", "op_execfun", this.createNode("node_var", "cosh"), [n.deepCopy(s2[0])]);
              break;
            case "cosh":
              i2 = this.createNode("node_op", "op_execfun", this.createNode("node_var", "sinh"), [n.deepCopy(s2[0])]);
              break;
            case "tanh":
              i2 = this.createNode("node_op", "op_sub", this.createNode("node_const", 1), this.createNode("node_op", "op_exp", this.createNode("node_op", "op_execfun", this.createNode("node_var", "tanh"), [n.deepCopy(s2[0])]), this.createNode("node_const", 2)));
              break;
            case "asinh":
              i2 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_add", this.createNode("node_op", "op_mul", n.deepCopy(s2[0]), n.deepCopy(s2[0])), this.createNode("node_const", 1))]));
              break;
            case "acosh":
              i2 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_execfun", this.createNode("node_var", "sqrt"), [this.createNode("node_op", "op_sub", this.createNode("node_op", "op_mul", n.deepCopy(s2[0]), n.deepCopy(s2[0])), this.createNode("node_const", 1))]));
              break;
            case "atanh":
              i2 = this.createNode("node_op", "op_div", this.createNode("node_const", 1), this.createNode("node_op", "op_sub", this.createNode("node_const", 1), this.createNode("node_op", "op_mul", n.deepCopy(s2[0]), n.deepCopy(s2[0]))));
              break;
            default:
              i2 = this.createNode("node_const", 0), this._error('Derivative of "' + r2 + '" not yet implemented');
          }
          return i2;
        }, derivative: function(t2, e3) {
          var i2;
          switch (t2.type) {
            case "node_op":
              switch (t2.value) {
                case "op_execfun":
                  i2 = t2.children[0].value == "pow" ? this.deriveElementary(t2, e3) : this.createNode("node_op", "op_mul", this.deriveElementary(t2, e3), this.derivative(t2.children[1][0], e3));
                  break;
                case "op_div":
                  i2 = this.createNode("node_op", "op_div", this.createNode("node_op", "op_sub", this.createNode("node_op", "op_mul", this.derivative(t2.children[0], e3), n.deepCopy(t2.children[1])), this.createNode("node_op", "op_mul", n.deepCopy(t2.children[0]), this.derivative(t2.children[1], e3))), this.createNode("node_op", "op_mul", n.deepCopy(t2.children[1]), n.deepCopy(t2.children[1])));
                  break;
                case "op_mul":
                  i2 = this.createNode("node_op", "op_add", this.createNode("node_op", "op_mul", n.deepCopy(t2.children[0]), this.derivative(t2.children[1], e3)), this.createNode("node_op", "op_mul", this.derivative(t2.children[0], e3), n.deepCopy(t2.children[1])));
                  break;
                case "op_neg":
                  i2 = this.createNode("node_op", "op_neg", this.derivative(t2.children[0], e3));
                  break;
                case "op_add":
                case "op_sub":
                  i2 = this.createNode("node_op", t2.value, this.derivative(t2.children[0], e3), this.derivative(t2.children[1], e3));
                  break;
                case "op_exp":
                  i2 = this.createNode("node_op", "op_mul", n.deepCopy(t2), this.createNode("node_op", "op_add", this.createNode("node_op", "op_mul", this.derivative(t2.children[0], e3), this.createNode("node_op", "op_div", n.deepCopy(t2.children[1]), n.deepCopy(t2.children[0]))), this.createNode("node_op", "op_mul", this.derivative(t2.children[1], e3), this.createNode("node_op", "op_execfun", this.createNode("node_var", "log"), [n.deepCopy(t2.children[0])]))));
              }
              break;
            case "node_var":
              i2 = t2.value === e3 ? this.createNode("node_const", 1) : this.createNode("node_const", 0);
              break;
            case "node_const":
              i2 = this.createNode("node_const", 0);
          }
          return i2;
        }, expandDerivatives: function(t2, e3, i2) {
          var r2, s2, o2, a2, h, l, c, d, u, p, f, m;
          if (l = 0, !t2)
            return l;
          for (this.line = t2.line, this.col = t2.col, r2 = t2.children.length, s2 = 0; s2 < r2; ++s2)
            if (t2.children[s2] && t2.children[s2].type)
              t2.children[s2] = this.expandDerivatives(t2.children[s2], t2, i2);
            else if (n.isArray(t2.children[s2]))
              for (o2 = 0; o2 < t2.children[s2].length; ++o2)
                t2.children[s2][o2] && t2.children[s2][o2].type && (t2.children[s2][o2] = this.expandDerivatives(t2.children[s2][o2], t2, i2));
          switch (t2.type) {
            case "node_op":
              switch (t2.value) {
                case "op_execfun":
                  if (t2.children[0] && t2.children[0].value === "D") {
                    if (t2.children[1][0].type == "node_var" ? (u = t2.children[1][0].value, a2 = this.findMapNode(u, i2), f = a2.children[0], p = t2.children[1].length >= 2 ? t2.children[1][1].value : a2.children[0][0], h = a2.children[1]) : (h = t2.children[1][0], f = ["x"], p = t2.children[1].length >= 2 ? t2.children[1][1].value : "x"), m = t2.children[1].length >= 3 ? t2.children[1][2].value : 1, d = h, m >= 1)
                      for (; m >= 1; )
                        d = this.derivative(d, p), d = this.removeTrivialNodes(d), m--;
                    c = e3.type == "node_op" && e3.value == "op_assign" ? this.createNode("node_op", "op_map", f, d) : d, this.setMath(c), t2.type = c.type, t2.value = c.value, t2.children[0] = c.children[0], t2.children[1] = c.children[1];
                  }
              }
          }
          return t2;
        }, removeTrivialNodes: function(t2) {
          var e3, i2, r2, s2, o2;
          if (n.isArray(t2))
            for (i2 = t2.length, e3 = 0; e3 < i2; ++e3)
              t2[e3] = this.removeTrivialNodes(t2[e3]);
          if (t2.type != "node_op" || !t2.children)
            return t2;
          for (i2 = t2.children.length, e3 = 0; e3 < i2; ++e3) {
            this.mayNotBeSimplified = false;
            do {
              t2.children[e3] = this.removeTrivialNodes(t2.children[e3]);
            } while (this.mayNotBeSimplified);
          }
          switch (t2.value) {
            case "op_map":
              if (r2 = t2.children[0], s2 = t2.children[1], s2.type == "node_var") {
                for (e3 = 0; e3 < r2.length; ++e3)
                  if (r2[e3] == s2.value) {
                    s2.isMath = true;
                    break;
                  }
              }
              break;
            case "op_add":
              if (r2 = t2.children[0], s2 = t2.children[1], r2.type == "node_const" && r2.value === 0)
                return s2;
              if (s2.type == "node_const" && s2.value === 0)
                return r2;
              if (r2.type == "node_const" && s2.type == "node_const")
                return r2.value += s2.value, r2;
              break;
            case "op_mul":
              if (r2 = t2.children[0], s2 = t2.children[1], r2.type == "node_const" && r2.value == 1)
                return s2;
              if (s2.type == "node_const" && s2.value == 1)
                return r2;
              if (r2.type == "node_const" && r2.value === 0)
                return r2;
              if (s2.type == "node_const" && s2.value === 0)
                return s2;
              if (s2.type == "node_const" && s2.value === 0)
                return s2;
              if (r2.type == "node_op" && r2.value == "op_neg" && s2.type == "node_op" && s2.value == "op_neg")
                return t2.children = [r2.children[0], s2.children[0]], this.mayNotBeSimplified = true, t2;
              if (r2.value == "op_neg" && s2.value != "op_neg")
                return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_op", "op_mul", r2.children[0], s2)], this.mayNotBeSimplified = true, t2;
              if (r2.value != "op_neg" && s2.value == "op_neg")
                return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_op", "op_mul", r2, s2.children[0])], this.mayNotBeSimplified = true, t2;
              if (r2.value == "op_div" && r2.children[0].type == "node_const" && r2.children[0].value == 1)
                return t2.type = "node_op", t2.value = "op_div", t2.children = [s2, r2.children[1]], this.mayNotBeSimplified = true, t2;
              if (s2.value == "op_div" && s2.children[0].type == "node_const" && s2.children[0].value == 1)
                return t2.type = "node_op", t2.value = "op_div", t2.children = [r2, s2.children[1]], this.mayNotBeSimplified = true, t2;
              if (r2.type != "node_const" && s2.type == "node_const")
                return t2.children = [s2, r2], this.mayNotBeSimplified = true, t2;
              if (r2.type != "node_const" && s2.type == "node_op" && s2.value == "op_neg" && s2.children[0].type == "node_const")
                return t2.children = [s2, r2], this.mayNotBeSimplified = true, t2;
              if (r2.type == "node_op" && r2.value != "op_execfun" && (s2.type == "node_var" || s2.type == "node_op" && s2.value == "op_execfun"))
                return t2.children = [s2, r2], this.mayNotBeSimplified = true, t2;
              if (r2.type != "node_op" && s2.type == "node_op" && s2.value == "op_neg" && s2.children[0].type == "node_var")
                return t2.children = [s2, r2], this.mayNotBeSimplified = true, t2;
              if (r2.type != "node_const" && s2.type == "node_op" && (s2.value == "op_mul" || s2.value == "op_div") && s2.children[0].type == "node_const")
                return o2 = s2.children[0], s2.children[0] = r2, t2.children = [o2, s2], this.mayNotBeSimplified = true, t2;
              if (s2.type != "node_const" && r2.type == "node_op" && r2.value == "op_mul" && r2.children[0].type == "node_const")
                return t2.children = [r2.children[0], this.createNode("node_op", "op_mul", r2.children[1], s2)], this.mayNotBeSimplified = true, t2;
              if (r2.type == "node_const" && s2.type == "node_const")
                return r2.value *= s2.value, r2;
              if (r2.type == "node_const" && s2.type == "node_op" && (s2.value == "op_mul" || s2.value == "op_div") && s2.children[0].type == "node_const")
                return s2.children[0].value *= r2.value, s2;
              if (r2.hash = this.parser.compile(r2), s2.hash = this.parser.compile(s2), r2.hash === s2.hash)
                return t2.value = "op_exp", t2.children[1] = this.createNode("node_const", 2), t2;
              if (r2.type == "node_const" && s2.type == "node_op" && (s2.value == "op_mul" || s2.value == "op_div") && s2.children[0].type == "node_const")
                return s2.children[0].value *= r2.value, s2;
              if (s2.type == "node_op" && s2.value == "op_exp" && (r2.hash || (r2.hash = this.parser.compile(r2)), s2.children[0].hash || (s2.children[0].hash = this.parser.compile(s2.children[0])), r2.hash === s2.children[0].hash))
                return s2.children[1] = this.createNode("node_op", "op_add", s2.children[1], this.createNode("node_const", 1)), this.mayNotBeSimplified = true, s2;
              if (r2.type == "node_op" && r2.value == "op_exp" && s2.type == "node_op" && s2.value == "op_exp" && (r2.children[0].hash = this.parser.compile(r2.children[0]), s2.children[0].hash = this.parser.compile(s2.children[0]), r2.children[0].hash === s2.children[0].hash))
                return r2.children[1] = this.createNode("node_op", "op_add", r2.children[1], s2.children[1]), this.mayNotBeSimplified = true, r2;
              break;
            case "op_sub":
              if (r2 = t2.children[0], s2 = t2.children[1], r2.type == "node_const" && r2.value === 0)
                return t2.value = "op_neg", t2.children[0] = s2, t2;
              if (s2.type == "node_const" && s2.value === 0)
                return r2;
              if (r2.type == "node_const" && s2.type == "node_const" && r2.value == s2.value)
                return this.createNode("node_const", 0);
              if (r2.type == "node_var" && s2.type == "node_var" && r2.value == s2.value)
                return this.createNode("node_const", 0);
              if (r2.type == "node_const" && s2.type == "node_const")
                return r2.value -= s2.value, r2;
              if (r2.type == "node_op" && r2.value == "op_mul" && s2.type == "node_op" && s2.value == "op_mul" && (r2.children[1].hash = this.parser.compile(r2.children[1]), s2.children[1].hash = this.parser.compile(s2.children[1]), r2.children[1].hash === s2.children[1].hash))
                return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_sub", r2.children[0], s2.children[0]), r2.children[1]], this.mayNotBeSimplified = true, t2;
              if (r2.type == "node_op" && r2.value == "op_mul" && (r2.children[1].hash = this.parser.compile(r2.children[1]), s2.hash = this.parser.compile(s2), r2.children[1].hash === s2.hash))
                return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_sub", r2.children[0], this.createNode("node_const", 1)), s2], this.mayNotBeSimplified = true, t2;
              if (s2.type == "node_op" && s2.value == "op_mul" && (s2.children[1].hash = this.parser.compile(s2.children[1]), r2.hash = this.parser.compile(r2), s2.children[1].hash === r2.hash))
                return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_sub", this.createNode("node_const", 1), s2.children[0]), r2], this.mayNotBeSimplified = true, t2;
              break;
            case "op_neg":
              if (r2 = t2.children[0], r2.type == "node_const" && r2.value === 0)
                return r2;
              if (r2.type == "node_op" && r2.value == "op_neg")
                return r2.children[0];
              break;
            case "op_div":
              if (r2 = t2.children[0], s2 = t2.children[1], r2.type == "node_const" && s2.type == "node_const" && r2.value == s2.value && r2.value !== 0)
                return r2.value = 1, r2;
              if (r2.type == "node_const" && r2.value === 0 && s2.type == "node_const" && s2.value !== 0)
                return r2.value = 0, r2;
              if (r2.type == "node_const" && r2.value === 0 && (s2.type == "node_op" || s2.type == "node_var"))
                return t2.type = "node_const", t2.value = 0, t2;
              if (r2.type == "node_var" && s2.type == "node_var" && r2.value == s2.value)
                return this.createNode("node_const", 1);
              if (r2.type == "node_const" && r2.value !== 0 && s2.type == "node_const" && s2.value === 0)
                return r2.value > 0 ? r2.value = 1 / 0 : r2.value = -1 / 0, r2;
              if (r2.type == "node_op" && r2.value == "op_neg" && s2.type == "node_op" && s2.value == "op_neg")
                return t2.children = [r2.children[0], s2.children[0]], this.mayNotBeSimplified = true, t2;
              if (r2.value == "op_neg" && s2.value != "op_neg")
                return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_op", "op_div", r2.children[0], s2)], this.mayNotBeSimplified = true, t2;
              if (r2.value != "op_neg" && s2.value == "op_neg")
                return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_op", "op_div", r2, s2.children[0])], this.mayNotBeSimplified = true, t2;
              if (r2.type == "node_op" && r2.value == "op_exp" && (s2.hash || (s2.hash = this.parser.compile(s2)), r2.children[0].hash || (r2.children[0].hash = this.parser.compile(r2.children[0])), s2.hash === r2.children[0].hash))
                return r2.children[1] = this.createNode("node_op", "op_sub", r2.children[1], this.createNode("node_const", 1)), this.mayNotBeSimplified = true, r2;
              if (s2.type != "node_const" && r2.type == "node_op" && r2.value == "op_mul" && r2.children[0].type == "node_const")
                return t2.value = "op_mul", t2.children = [r2.children[0], this.createNode("node_op", "op_div", r2.children[1], s2)], this.mayNotBeSimplified = true, t2;
              if (r2.type == "node_op" && r2.value == "op_exp" && s2.type == "node_op" && s2.value == "op_exp" && (r2.children[0].hash = this.parser.compile(r2.children[0]), s2.children[0].hash = this.parser.compile(s2.children[0]), r2.children[0].hash === s2.children[0].hash))
                return r2.children[1] = this.createNode("node_op", "op_sub", r2.children[1], s2.children[1]), this.mayNotBeSimplified = true, r2;
              break;
            case "op_exp":
              if (r2 = t2.children[0], s2 = t2.children[1], s2.type == "node_const" && s2.value === 0)
                return s2.value = 1, s2;
              if (s2.type == "node_const" && s2.value == 1)
                return r2;
              if (r2.type == "node_const" && r2.value == 1)
                return r2;
              if (r2.type == "node_const" && r2.value === 0 && s2.type == "node_const" && s2.value !== 0)
                return r2;
              if (r2.type == "node_op" && r2.value == "op_exp")
                return t2.children = [r2.children[0], this.createNode("node_op", "op_mul", r2.children[1], s2)], t2;
          }
          switch (t2.value) {
            case "op_add":
              if (r2 = t2.children[0], s2 = t2.children[1], r2.type == "node_const" && s2.type == "node_const" && r2.value == s2.value)
                return r2.value += s2.value, r2;
              if (r2.type == "node_var" && s2.type == "node_var" && r2.value == s2.value)
                return t2.children[0] = this.createNode("node_const", 2), t2.value = "op_mul", t2;
              if (r2.type == "node_op" && r2.value == "op_neg")
                return t2.value = "op_sub", t2.children[0] = s2, t2.children[1] = r2.children[0], this.mayNotBeSimplified = true, t2;
              if (s2.type == "node_op" && s2.value == "op_neg")
                return t2.value = "op_sub", t2.children[1] = s2.children[0], this.mayNotBeSimplified = true, t2;
              if (r2.type == "node_op" && r2.value == "op_mul" && s2.type == "node_op" && s2.value == "op_mul" && (r2.children[1].hash = this.parser.compile(r2.children[1]), s2.children[1].hash = this.parser.compile(s2.children[1]), r2.children[1].hash === s2.children[1].hash))
                return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_add", r2.children[0], s2.children[0]), r2.children[1]], this.mayNotBeSimplified = true, t2;
              if (r2.type == "node_op" && r2.value == "op_mul" && (r2.children[1].hash = this.parser.compile(r2.children[1]), s2.hash = this.parser.compile(s2), r2.children[1].hash === s2.hash))
                return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_add", r2.children[0], this.createNode("node_const", 1)), s2], this.mayNotBeSimplified = true, t2;
              if (s2.type == "node_op" && s2.value == "op_mul" && (s2.children[1].hash = this.parser.compile(s2.children[1]), r2.hash = this.parser.compile(r2), s2.children[1].hash === r2.hash))
                return t2.value = "op_mul", t2.children = [this.createNode("node_op", "op_add", this.createNode("node_const", 1), s2.children[0]), r2], this.mayNotBeSimplified = true, t2;
              break;
            case "op_sub":
              if (r2 = t2.children[0], s2 = t2.children[1], s2.type == "node_op" && s2.value == "op_neg")
                return t2.value = "op_add", t2.children[1] = s2.children[0], this.mayNotBeSimplified = true, t2;
              break;
            case "op_execfun":
              return this.simplifyElementary(t2);
          }
          return t2;
        }, simplifyElementary: function(t2) {
          var e3 = t2.children[0].value, i2 = t2.children[1];
          if (i2.length == 0)
            return t2;
          switch (e3) {
            case "sin":
            case "tan":
              if (i2[0].type == "node_const" && i2[0].value === 0)
                return t2.type = "node_const", t2.value = 0, t2;
              if (i2[0].type == "node_var" && i2[0].value == "PI")
                return t2.type = "node_const", t2.value = 0, t2;
              if (i2[0].type == "node_op" && i2[0].value == "op_mul" && i2[0].children[0].type == "node_const" && i2[0].children[0].value % 1 == 0 && i2[0].children[1].type == "node_var" && i2[0].children[1].value == "PI")
                return t2.type = "node_const", t2.value = 0, t2;
              break;
            case "cos":
              if (i2[0].type == "node_const" && i2[0].value === 0)
                return t2.type = "node_const", t2.value = 1, t2;
              if (i2[0].type == "node_var" && i2[0].value == "PI")
                return t2.type = "node_op", t2.value = "op_neg", t2.children = [this.createNode("node_const", 1)], t2;
              break;
            case "exp":
              if (i2[0].type == "node_const" && i2[0].value === 0)
                return t2.type = "node_const", t2.value = 1, t2;
              break;
            case "pow":
              if (i2[1].type == "node_const" && i2[1].value === 0)
                return t2.type = "node_const", t2.value = 1, t2;
          }
          return t2;
        }}), t.CA;
      }), define("utils/dump", ["jxg", "utils/type"], function(t, e2) {
        "use strict";
        return t.Dump = {addMarkers: function(t2, i, r) {
          var s, o, n;
          e2.isArray(i) || (i = [i]), e2.isArray(r) || (r = [r]), o = Math.min(i.length, r.length), i.length = o, r.length = o;
          for (s in t2.objects)
            if (t2.objects.hasOwnProperty(s))
              for (n = 0; n < o; n++)
                t2.objects[s][i[n]] = r[n];
        }, deleteMarkers: function(t2, i) {
          var r, s, o;
          e2.isArray(i) || (i = [i]), s = i.length, i.length = s;
          for (r in t2.objects)
            if (t2.objects.hasOwnProperty(r))
              for (o = 0; o < s; o++)
                delete t2.objects[r][i[o]];
        }, str: function(t2) {
          return typeof t2 == "string" && t2.substr(0, 7) !== "function" && (t2 = '"' + t2 + '"'), t2;
        }, minimizeObject: function(i, r) {
          var s, o, n, a = {}, h = e2.deepCopy(i), l = [];
          for (n = 1; n < arguments.length; n++)
            l.push(arguments[n]);
          for (a = e2.deepCopy(a, t.Options.elements, true), n = l.length; n > 0; n--)
            a = e2.deepCopy(a, l[n - 1], true);
          for (s in a)
            a.hasOwnProperty(s) && (o = s.toLowerCase(), typeof a[s] != "object" && a[s] === h[o] && delete h[o]);
          return h;
        }, prepareAttributes: function(e3, i) {
          var r, s;
          r = this.minimizeObject(i.getAttributes(), t.Options[i.elType]);
          for (s in i.subs)
            i.subs.hasOwnProperty(s) && (r[s] = this.minimizeObject(i.subs[s].getAttributes(), t.Options[i.elType][s], t.Options[i.subs[s].elType]), r[s].id = i.subs[s].id, r[s].name = i.subs[s].name);
          return r.id = i.id, r.name = i.name, r;
        }, setBoundingBox: function(t2, e3, i) {
          return t2.push({obj: i, method: "setBoundingBox", params: [e3.getBoundingBox(), true]}), t2;
        }, dump: function(t2) {
          var i, r, s, o, n = [], a = [], h = [], l = t2.objectsList.length;
          for (this.addMarkers(t2, "dumped", false), i = 0; i < l; i++)
            if (r = t2.objectsList[i], s = {}, !r.dumped && r.dump) {
              for (s.type = r.getType(), s.parents = r.getParents().slice(), s.type === "point" && s.parents[0] === 1 && (s.parents = s.parents.slice(1)), o = 0; o < s.parents.length; o++)
                e2.isString(s.parents[o]) && s.parents[o][0] !== "'" && s.parents[o][0] !== '"' ? s.parents[o] = '"' + s.parents[o] + '"' : e2.isArray(s.parents[o]) && (s.parents[o] = "[" + s.parents[o].toString() + "]");
              s.attributes = this.prepareAttributes(t2, r), s.type === "glider" && r.onPolygon && n.push({obj: r.id, prop: "onPolygon", val: true}), h.push(s);
            }
          return this.deleteMarkers(t2, "dumped"), {elements: h, props: n, methods: a};
        }, arrayToParamStr: function(t2, e3) {
          var i, r = [];
          for (i = 0; i < t2.length; i++)
            r.push(e3.call(this, t2[i]));
          return r.join(", ");
        }, toJCAN: function(t2) {
          var i, r, s;
          switch (typeof t2) {
            case "object":
              if (t2) {
                if (r = [], e2.isArray(t2)) {
                  for (i = 0; i < t2.length; i++)
                    r.push(this.toJCAN(t2[i]));
                  return "[" + r.join(",") + "]";
                }
                for (s in t2)
                  t2.hasOwnProperty(s) && r.push(s + ": " + this.toJCAN(t2[s]));
                return "<<" + r.join(", ") + ">> ";
              }
              return "null";
            case "string":
              return "'" + t2.replace(/(["'])/g, "\\$1") + "'";
            case "number":
            case "boolean":
              return t2.toString();
            case "null":
              return "null";
          }
        }, toJessie: function(t2) {
          var e3, i, r = this.dump(t2), s = [];
          for (r.methods = this.setBoundingBox(r.methods, t2, "$board"), i = r.elements, e3 = 0; e3 < i.length; e3++)
            i[e3].attributes.name.length > 0 && s.push("// " + i[e3].attributes.name), s.push("s" + e3 + " = " + i[e3].type + "(" + i[e3].parents.join(", ") + ") " + this.toJCAN(i[e3].attributes).replace(/\n/, "\\n") + ";"), s.push("");
          for (e3 = 0; e3 < r.methods.length; e3++)
            s.push(r.methods[e3].obj + "." + r.methods[e3].method + "(" + this.arrayToParamStr(r.methods[e3].params, this.toJCAN) + ");"), s.push("");
          for (e3 = 0; e3 < r.props.length; e3++)
            s.push(r.props[e3].obj + "." + r.props[e3].prop + " = " + this.toJCAN(r.props[e3].val) + ";"), s.push("");
          return s.join("\n");
        }, toJavaScript: function(t2) {
          var i, r, s = this.dump(t2), o = [];
          for (s.methods = this.setBoundingBox(s.methods, t2, "board"), r = s.elements, i = 0; i < r.length; i++)
            o.push('board.create("' + r[i].type + '", [' + r[i].parents.join(", ") + "], " + e2.toJSON(r[i].attributes) + ");");
          for (i = 0; i < s.methods.length; i++)
            o.push(s.methods[i].obj + "." + s.methods[i].method + "(" + this.arrayToParamStr(s.methods[i].params, e2.toJSON) + ");"), o.push("");
          for (i = 0; i < s.props.length; i++)
            o.push(s.props[i].obj + "." + s.props[i].prop + " = " + e2.toJSON(s.props[i].val) + ";"), o.push("");
          return o.join("\n");
        }}, t.Dump;
      }), define("element/comb", ["jxg", "options", "utils/type", "base/constants", "base/line", "base/polygon", "base/point"], function(t, e2, i, r, s, o, n) {
        "use strict";
        return t.createComb = function(t2, e3, r2) {
          var s2, o2, a, h, l;
          if (e3.length !== 2)
            throw l = e3.map(function(t3) {
              return "'" + typeof t3 + "'";
            }), new Error("JSXGraph: Can't create comb with parent types " + l.join(", ") + ".\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]");
          if (i.isArray(e3[0]) && e3[0].length > 1)
            h = i.copyAttributes(r2, t2.options, "comb", "point1"), s2 = t2.create("point", e3[0], h);
          else if (i.isString(e3[0]) || i.isPoint(e3[0]))
            s2 = t2.select(e3[0]);
          else if (i.isFunction(e3[0]) && i.isPoint(e3[0]()))
            s2 = e3[0]();
          else {
            if (!(i.isFunction(e3[0]) && e3[0]().length && e3[0]().length >= 2))
              throw new Error("JSXGraph: Can't create comb with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]");
            h = i.copyAttributes(r2, t2.options, "comb", "point1"), s2 = n.createPoint(t2, e3[0](), h);
          }
          if (i.isArray(e3[1]) && e3[1].length > 1)
            h = i.copyAttributes(r2, t2.options, "comb", "point2"), o2 = t2.create("point", e3[1], h);
          else if (i.isString(e3[1]) || i.isPoint(e3[1]))
            o2 = t2.select(e3[1]);
          else if (i.isFunction(e3[1]) && i.isPoint(e3[1]()))
            o2 = e3[1]();
          else {
            if (!(i.isFunction(e3[1]) && e3[1]().length && e3[1]().length >= 2))
              throw new Error("JSXGraph: Can't create comb with parent types '" + typeof e3[0] + "' and '" + typeof e3[1] + "'.\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]");
            h = i.copyAttributes(r2, t2.options, "comb", "point2"), o2 = n.createPoint(t2, e3[1](), h);
          }
          return h = i.copyAttributes(r2, t2.options, "comb"), i.merge(h, i.copyAttributes(r2, t2.options, "comb", "curve")), a = t2.create("curve", [[0], [0]], h), a.updateDataArray = function() {
            var t3, e4, r3, n3, h2, l2, c, d, u, p, f = 0, m = s2.Dist(o2), g = s2, b = o2;
            for (d = i.evaluate(a.visProp.frequency), u = -i.evaluate(a.visProp.angle), p = i.evaluate(a.visProp.width), i.evaluate(a.visProp.reverse) && (g = o2, b = s2, u = -u), t3 = Math.cos(u), e4 = Math.sin(u), r3 = (b.X() - g.X()) / m, n3 = (b.Y() - g.Y()) / m, t3 *= p / Math.abs(e4), e4 *= p / Math.abs(e4), this.dataX = [], this.dataY = []; f < m; )
              h2 = g.X() + r3 * f, l2 = g.Y() + n3 * f, c = Math.min(t3, m - f) / Math.abs(t3), e4 *= c, t3 *= c, this.dataX.push(h2), this.dataY.push(l2), this.dataX.push(h2 + r3 * t3 + n3 * e4), this.dataY.push(l2 - r3 * e4 + n3 * t3), this.dataX.push(NaN), this.dataY.push(NaN), f += d;
          }, a;
        }, t.registerElement("comb", t.createComb), {createComb: t.createComb};
      }), define("element/slopetriangle", ["jxg", "options", "utils/type", "base/constants", "base/line", "base/polygon", "base/point", "base/element"], function(t, e2, i, r, s, o, n, a) {
        "use strict";
        var h = {removeSlopeTriangle: function() {
          o.Polygon.prototype.remove.call(this), this.board.removeObject(this.toppoint), this.board.removeObject(this.glider), this.board.removeObject(this.baseline), this.board.removeObject(this.basepoint), this.board.removeObject(this.label), this._isPrivateTangent && this.board.removeObject(this.tangent);
        }, Value: function() {
          return this.tangent.getSlope();
        }};
        return t.createSlopeTriangle = function(e3, s2, o2) {
          var n3, a2, l, c, d, u, p, f, m, g = false;
          if (s2.length === 1 && s2[0].type === r.OBJECT_TYPE_TANGENT)
            a2 = s2[0], l = a2.glider;
          else if (s2.length === 1 && s2[0].type === r.OBJECT_TYPE_GLIDER)
            l = s2[0], m = i.copyAttributes(o2, e3.options, "slopetriangle", "tangent"), a2 = e3.create("tangent", [l], m), g = true;
          else {
            if (s2.length !== 2 || s2[0].elementClass !== r.OBJECT_CLASS_LINE || !i.isPoint(s2[1]))
              throw new Error("JSXGraph: Can't create slope triangle with parent types '" + typeof s2[0] + "'.");
            a2 = s2[0], l = s2[1];
          }
          return m = i.copyAttributes(o2, e3.options, "slopetriangle", "basepoint"), p = e3.create("point", [function() {
            return [l.X() + 1, l.Y()];
          }], m), m = i.copyAttributes(o2, e3.options, "slopetriangle", "baseline"), u = e3.create("line", [l, p], m), m = i.copyAttributes(o2, e3.options, "slopetriangle", "glider"), c = e3.create("glider", [l.X() + 1, l.Y(), u], m), m = i.copyAttributes(o2, e3.options, "slopetriangle", "toppoint"), d = e3.create("point", [function() {
            return [c.X(), c.Y() + (c.X() - l.X()) * a2.getSlope()];
          }], m), m = i.copyAttributes(o2, e3.options, "slopetriangle"), m.borders = i.copyAttributes(m.borders, e3.options, "slopetriangle", "borders"), n3 = e3.create("polygon", [l, c, d], m), n3.Value = h.Value, n3.tangent = a2, n3._isPrivateTangent = g, n3.borders[2].setArrow(false, false), m = i.copyAttributes(o2, e3.options, "slopetriangle", "label"), f = e3.create("text", [function() {
            return c.X() + 0.1;
          }, function() {
            return 0.5 * (c.Y() + d.Y());
          }, function() {
            return "";
          }], m), f._setText(function() {
            return i.toFixed(n3.Value(), i.evaluate(f.visProp.digits));
          }), f.fullUpdate(), n3.glider = c, n3.basepoint = p, n3.baseline = u, n3.toppoint = d, n3.label = f, n3.subs = {glider: c, basePoint: p, baseLine: u, topPoint: d, label: f}, n3.inherits.push(c, p, u, d, f), n3.methodMap = t.deepCopy(n3.methodMap, {tangent: "tangent", glider: "glider", basepoint: "basepoint", baseline: "baseline", toppoint: "toppoint", label: "label", Value: "Value", V: "Value"}), n3.remove = h.removeSlopeTriangle, n3;
        }, t.registerElement("slopetriangle", t.createSlopeTriangle), {createSlopeTriangle: t.createSlopeTriangle};
      }), define("element/checkbox", ["jxg", "utils/env", "utils/type"], function(t, e2, i) {
        "use strict";
        var r = {CheckboxChangeEventHandler: function() {
          this._value = this.rendNodeCheckbox.checked, this.board.update();
        }};
        return t.createCheckbox = function(s, o, n) {
          var a, h, l = i.copyAttributes(n, s.options, "checkbox");
          return h = [o[0], o[1], '<span style="display:inline"><input type="checkbox" /><label for=""></label></span>'], a = s.create("text", h, l), a.type = i.OBJECT_TYPE_CHECKBOX, a.rendNodeCheckbox = a.rendNode.childNodes[0].childNodes[0], a.rendNodeLabel = a.rendNode.childNodes[0].childNodes[1], a.rendNodeTag = a.rendNodeCheckbox, a.rendNodeTag.disabled = !!l.disabled, a.rendNodeLabel.innerHTML = o[2], a.rendNodeCheckbox.id = a.rendNode.id + "_checkbox", a.rendNodeLabel.id = a.rendNode.id + "_label", a.rendNodeLabel.setAttribute("for", a.rendNodeCheckbox.id), a.visPropOld.fontsize = "0px", s.renderer.updateTextStyle(a, false), a.rendNodeCheckbox.checked = l.checked, a._value = l.checked, a.Value = function() {
            return this._value;
          }, a.update = function() {
            return this.needsUpdate && (t.Text.prototype.update.call(this), this._value = this.rendNodeCheckbox.checked), this;
          }, e2.addEvent(a.rendNodeCheckbox, "change", r.CheckboxChangeEventHandler, a), a;
        }, t.registerElement("checkbox", t.createCheckbox), {createCheckbox: t.createCheckbox};
      }), define("element/input", ["jxg", "utils/env", "utils/type"], function(t, e2, i) {
        "use strict";
        var r = {InputInputEventHandler: function(t2) {
          this._value = this.rendNodeInput.value, this.board.update();
        }};
        return t.createInput = function(s, o, n) {
          var a, h, l = i.copyAttributes(n, s.options, "input");
          return h = [o[0], o[1], '<span style="display:inline; white-space:nowrap; padding:0px;"><span></span><input type="text" maxlength="' + l.maxlength + '" style="width:100%"/></span>'], a = s.create("text", h, l), a.type = i.OBJECT_TYPE_INPUT, a.rendNodeLabel = a.rendNode.childNodes[0].childNodes[0], a.rendNodeInput = a.rendNode.childNodes[0].childNodes[1], a.rendNodeLabel.innerHTML = o[3], a.rendNodeInput.value = o[2], a.rendNodeTag = a.rendNodeInput, a.rendNodeTag.disabled = !!l.disabled, a.rendNodeLabel.id = a.rendNode.id + "_label", a.rendNodeInput.id = a.rendNode.id + "_input", a._value = o[2], a.update = function() {
            return this.needsUpdate && (t.Text.prototype.update.call(this), this._value = this.rendNodeInput.value), this;
          }, a.Value = function() {
            return this._value;
          }, a.set = function(t2) {
            return this._value = t2, this.rendNodeInput.value = t2, this;
          }, e2.addEvent(a.rendNodeInput, "input", r.InputInputEventHandler, a), e2.addEvent(a.rendNodeInput, "mousedown", function(t2) {
            i.exists(t2.stopPropagation) && t2.stopPropagation();
          }, a), e2.addEvent(a.rendNodeInput, "touchstart", function(t2) {
            i.exists(t2.stopPropagation) && t2.stopPropagation();
          }, a), e2.addEvent(a.rendNodeInput, "pointerdown", function(t2) {
            i.exists(t2.stopPropagation) && t2.stopPropagation();
          }, a), a.visPropOld.fontsize = "0px", s.renderer.updateTextStyle(a, false), a;
        }, t.registerElement("input", t.createInput), {createInput: t.createInput};
      }), define("element/button", ["jxg", "utils/env", "utils/type"], function(t, e2, i) {
        "use strict";
        var r = {ButtonClickEventHandler: function() {
          this._handler && this._handler(), this.board.update();
        }};
        return t.createButton = function(s, o, n) {
          var a, h, l = i.copyAttributes(n, s.options, "button");
          return h = [o[0], o[1], '<button type="button" style="width:100%;"></button>'], a = s.create("text", h, l), a.type = i.OBJECT_TYPE_BUTTON, a.rendNodeButton = a.rendNode.childNodes[0], a.rendNodeButton.id = a.rendNode.id + "_button", a.rendNodeButton.innerHTML = o[2], a.rendNodeTag = a.rendNodeButton, a.rendNodeTag.disabled = !!l.disabled, a.visPropOld.fontsize = "0px", s.renderer.updateTextStyle(a, false), o[3] && (i.isString(o[3]) ? (a._jc = new t.JessieCode(), a._jc.use(s), a._handler = function() {
            a._jc.parse(o[3]);
          }) : a._handler = o[3]), e2.addEvent(a.rendNodeButton, "click", r.ButtonClickEventHandler, a), e2.addEvent(a.rendNodeButton, "mousedown", function(t2) {
            i.exists(t2.stopPropagation) && t2.stopPropagation();
          }, a), e2.addEvent(a.rendNodeButton, "touchstart", function(t2) {
            i.exists(t2.stopPropagation) && t2.stopPropagation();
          }, a), e2.addEvent(a.rendNodeButton, "pointerdown", function(t2) {
            i.exists(t2.stopPropagation) && t2.stopPropagation();
          }, a), a;
        }, t.registerElement("button", t.createButton), {createButton: t.createButton};
      }), define("../build/core.deps.js", ["jxg", "utils/env", "base/constants", "utils/type", "utils/xml", "utils/event", "utils/expect", "math/math", "math/ia", "math/extrapolate", "math/qdt", "math/numerics", "math/nlp", "math/plot", "math/metapost", "math/statistics", "math/symbolic", "math/geometry", "math/clip", "math/poly", "math/complex", "renderer/abstract", "reader/file", "parser/geonext", "base/board", "options", "jsxgraph", "base/element", "base/coords", "base/coordselement", "base/point", "base/line", "base/group", "base/circle", "element/conic", "base/polygon", "base/curve", "element/arc", "element/sector", "base/composition", "element/composition", "element/locus", "base/text", "base/image", "element/slider", "element/measure", "base/chart", "base/transformation", "base/turtle", "utils/color", "base/ticks", "utils/zip", "utils/base64", "utils/uuid", "utils/encoding", "server/server", "parser/datasource", "parser/jessiecode", "parser/ca", "utils/dump", "renderer/svg", "renderer/vml", "renderer/canvas", "renderer/no", "element/comb", "element/slopetriangle", "element/checkbox", "element/input", "element/button"], function(t, e2) {
        "use strict";
        return e2.isBrowser ? window.JXG = t : e2.isNode() && typeof module == "object" ? module.exports = t : e2.isWebWorker() && (self.JXG = t), t;
      }), require("../build/core.deps.js");
    });
  });

  // node_modules/js-file-download/file-download.js
  var require_file_download = __commonJS((exports2, module2) => {
    module2.exports = function(data, filename, mime, bom) {
      var blobData = typeof bom !== "undefined" ? [bom, data] : [data];
      var blob = new Blob(blobData, {type: mime || "application/octet-stream"});
      if (typeof window.navigator.msSaveBlob !== "undefined") {
        window.navigator.msSaveBlob(blob, filename);
      } else {
        var blobURL = window.URL && window.URL.createObjectURL ? window.URL.createObjectURL(blob) : window.webkitURL.createObjectURL(blob);
        var tempLink = document.createElement("a");
        tempLink.style.display = "none";
        tempLink.href = blobURL;
        tempLink.setAttribute("download", filename);
        if (typeof tempLink.download === "undefined") {
          tempLink.setAttribute("target", "_blank");
        }
        document.body.appendChild(tempLink);
        tempLink.click();
        setTimeout(function() {
          document.body.removeChild(tempLink);
          window.URL.revokeObjectURL(blobURL);
        }, 200);
      }
    };
  });

  // node_modules/mathjs/lib/esm/core/config.js
  var DEFAULT_CONFIG = {
    epsilon: 1e-12,
    matrix: "Matrix",
    number: "number",
    precision: 64,
    predictable: false,
    randomSeed: null
  };

  // node_modules/mathjs/lib/esm/utils/is.js
  function isNumber(x) {
    return typeof x === "number";
  }
  function isBigNumber(x) {
    return x && x.constructor.prototype.isBigNumber === true || false;
  }
  function isComplex(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
  }
  function isFraction(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
  }
  function isUnit(x) {
    return x && x.constructor.prototype.isUnit === true || false;
  }
  function isString(x) {
    return typeof x === "string";
  }
  var isArray = Array.isArray;
  function isMatrix(x) {
    return x && x.constructor.prototype.isMatrix === true || false;
  }
  function isCollection(x) {
    return Array.isArray(x) || isMatrix(x);
  }
  function isDenseMatrix(x) {
    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isSparseMatrix(x) {
    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isRange(x) {
    return x && x.constructor.prototype.isRange === true || false;
  }
  function isIndex(x) {
    return x && x.constructor.prototype.isIndex === true || false;
  }
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  function isResultSet(x) {
    return x && x.constructor.prototype.isResultSet === true || false;
  }
  function isHelp(x) {
    return x && x.constructor.prototype.isHelp === true || false;
  }
  function isFunction(x) {
    return typeof x === "function";
  }
  function isDate(x) {
    return x instanceof Date;
  }
  function isRegExp(x) {
    return x instanceof RegExp;
  }
  function isObject(x) {
    return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
  }
  function isNull(x) {
    return x === null;
  }
  function isUndefined(x) {
    return x === void 0;
  }
  function isAccessorNode(x) {
    return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isArrayNode(x) {
    return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isAssignmentNode(x) {
    return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isBlockNode(x) {
    return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConditionalNode(x) {
    return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConstantNode(x) {
    return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionAssignmentNode(x) {
    return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionNode(x) {
    return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isIndexNode(x) {
    return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isNode(x) {
    return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isObjectNode(x) {
    return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isOperatorNode(x) {
    return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isParenthesisNode(x) {
    return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRangeNode(x) {
    return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isSymbolNode(x) {
    return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isChain(x) {
    return x && x.constructor.prototype.isChain === true || false;
  }
  function typeOf(x) {
    var t = typeof x;
    if (t === "object") {
      if (x === null)
        return "null";
      if (Array.isArray(x))
        return "Array";
      if (x instanceof Date)
        return "Date";
      if (x instanceof RegExp)
        return "RegExp";
      if (isBigNumber(x))
        return "BigNumber";
      if (isComplex(x))
        return "Complex";
      if (isFraction(x))
        return "Fraction";
      if (isMatrix(x))
        return "Matrix";
      if (isUnit(x))
        return "Unit";
      if (isIndex(x))
        return "Index";
      if (isRange(x))
        return "Range";
      if (isResultSet(x))
        return "ResultSet";
      if (isNode(x))
        return x.type;
      if (isChain(x))
        return "Chain";
      if (isHelp(x))
        return "Help";
      return "Object";
    }
    if (t === "function")
      return "Function";
    return t;
  }

  // node_modules/mathjs/lib/esm/utils/object.js
  function clone(x) {
    var type = typeof x;
    if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
      return x;
    }
    if (typeof x.clone === "function") {
      return x.clone();
    }
    if (Array.isArray(x)) {
      return x.map(function(value) {
        return clone(value);
      });
    }
    if (x instanceof Date)
      return new Date(x.valueOf());
    if (isBigNumber(x))
      return x;
    if (x instanceof RegExp)
      throw new TypeError("Cannot clone " + x);
    return mapObject(x, clone);
  }
  function mapObject(object, callback) {
    var clone2 = {};
    for (var key in object) {
      if (hasOwnProperty2(object, key)) {
        clone2[key] = callback(object[key]);
      }
    }
    return clone2;
  }
  function extend(a, b) {
    for (var prop in b) {
      if (hasOwnProperty2(b, prop)) {
        a[prop] = b[prop];
      }
    }
    return a;
  }
  function deepExtend(a, b) {
    if (Array.isArray(b)) {
      throw new TypeError("Arrays are not supported by deepExtend");
    }
    for (var prop in b) {
      if (hasOwnProperty2(b, prop) && !(prop in Object.prototype) && !(prop in Function.prototype)) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === void 0) {
            a[prop] = {};
          }
          if (a[prop] && a[prop].constructor === Object) {
            deepExtend(a[prop], b[prop]);
          } else {
            a[prop] = b[prop];
          }
        } else if (Array.isArray(b[prop])) {
          throw new TypeError("Arrays are not supported by deepExtend");
        } else {
          a[prop] = b[prop];
        }
      }
    }
    return a;
  }
  function deepStrictEqual(a, b) {
    var prop, i, len;
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (i = 0, len = a.length; i < len; i++) {
        if (!deepStrictEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    } else if (typeof a === "function") {
      return a === b;
    } else if (a instanceof Object) {
      if (Array.isArray(b) || !(b instanceof Object)) {
        return false;
      }
      for (prop in a) {
        if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }
      for (prop in b) {
        if (!(prop in a) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }
      return true;
    } else {
      return a === b;
    }
  }
  function deepFlatten(nestedObject) {
    var flattenedObject = {};
    _deepFlatten(nestedObject, flattenedObject);
    return flattenedObject;
  }
  function _deepFlatten(nestedObject, flattenedObject) {
    for (var prop in nestedObject) {
      if (hasOwnProperty2(nestedObject, prop)) {
        var value = nestedObject[prop];
        if (typeof value === "object" && value !== null) {
          _deepFlatten(value, flattenedObject);
        } else {
          flattenedObject[prop] = value;
        }
      }
    }
  }
  function lazy(object, prop, valueResolver) {
    var _uninitialized = true;
    var _value;
    Object.defineProperty(object, prop, {
      get: function get() {
        if (_uninitialized) {
          _value = valueResolver();
          _uninitialized = false;
        }
        return _value;
      },
      set: function set(value) {
        _value = value;
        _uninitialized = false;
      },
      configurable: true,
      enumerable: true
    });
  }
  function hasOwnProperty2(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
  }
  function isLegacyFactory(object) {
    return object && typeof object.factory === "function";
  }
  function pickShallow(object, properties2) {
    var copy = {};
    for (var i = 0; i < properties2.length; i++) {
      var key = properties2[i];
      var value = object[key];
      if (value !== void 0) {
        copy[key] = value;
      }
    }
    return copy;
  }
  function values(object) {
    return Object.keys(object).map((key) => object[key]);
  }

  // node_modules/mathjs/lib/esm/core/function/config.js
  var MATRIX_OPTIONS = ["Matrix", "Array"];
  var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
  function configFactory(config, emit) {
    function _config(options) {
      if (options) {
        var prev = mapObject(config, clone);
        validateOption(options, "matrix", MATRIX_OPTIONS);
        validateOption(options, "number", NUMBER_OPTIONS);
        deepExtend(config, options);
        var curr = mapObject(config, clone);
        var changes = mapObject(options, clone);
        emit("config", curr, prev, changes);
        return curr;
      } else {
        return mapObject(config, clone);
      }
    }
    _config.MATRIX_OPTIONS = MATRIX_OPTIONS;
    _config.NUMBER_OPTIONS = NUMBER_OPTIONS;
    Object.keys(DEFAULT_CONFIG).forEach((key) => {
      Object.defineProperty(_config, key, {
        get: () => config[key],
        enumerable: true,
        configurable: true
      });
    });
    return _config;
  }
  function contains(array, item) {
    return array.indexOf(item) !== -1;
  }
  function validateOption(options, name284, values2) {
    if (options[name284] !== void 0 && !contains(values2, options[name284])) {
      console.warn('Warning: Unknown value "' + options[name284] + '" for configuration option "' + name284 + '". Available options: ' + values2.map((value) => JSON.stringify(value)).join(", ") + ".");
    }
  }

  // node_modules/mathjs/lib/esm/factoriesAny.js
  var factoriesAny_exports = {};
  __export(factoriesAny_exports, {
    createAbs: () => createAbs,
    createAccessorNode: () => createAccessorNode,
    createAcos: () => createAcos,
    createAcosh: () => createAcosh,
    createAcot: () => createAcot,
    createAcoth: () => createAcoth,
    createAcsc: () => createAcsc,
    createAcsch: () => createAcsch,
    createAdd: () => createAdd,
    createAddScalar: () => createAddScalar,
    createAnd: () => createAnd,
    createApply: () => createApply,
    createApplyTransform: () => createApplyTransform,
    createArg: () => createArg,
    createArrayNode: () => createArrayNode,
    createAsec: () => createAsec,
    createAsech: () => createAsech,
    createAsin: () => createAsin,
    createAsinh: () => createAsinh,
    createAssignmentNode: () => createAssignmentNode,
    createAtan: () => createAtan,
    createAtan2: () => createAtan2,
    createAtanh: () => createAtanh,
    createAtomicMass: () => createAtomicMass,
    createAvogadro: () => createAvogadro,
    createBellNumbers: () => createBellNumbers,
    createBigNumberClass: () => createBigNumberClass,
    createBignumber: () => createBignumber,
    createBin: () => createBin,
    createBitAnd: () => createBitAnd,
    createBitNot: () => createBitNot,
    createBitOr: () => createBitOr,
    createBitXor: () => createBitXor,
    createBlockNode: () => createBlockNode,
    createBohrMagneton: () => createBohrMagneton,
    createBohrRadius: () => createBohrRadius,
    createBoltzmann: () => createBoltzmann,
    createBoolean: () => createBoolean,
    createCatalan: () => createCatalan,
    createCbrt: () => createCbrt,
    createCeil: () => createCeil,
    createChain: () => createChain,
    createChainClass: () => createChainClass,
    createClassicalElectronRadius: () => createClassicalElectronRadius,
    createClone: () => createClone,
    createColumn: () => createColumn,
    createColumnTransform: () => createColumnTransform,
    createCombinations: () => createCombinations,
    createCombinationsWithRep: () => createCombinationsWithRep,
    createCompare: () => createCompare,
    createCompareNatural: () => createCompareNatural,
    createCompareText: () => createCompareText,
    createCompile: () => createCompile,
    createComplex: () => createComplex,
    createComplexClass: () => createComplexClass,
    createComposition: () => createComposition,
    createConcat: () => createConcat,
    createConcatTransform: () => createConcatTransform,
    createConditionalNode: () => createConditionalNode,
    createConductanceQuantum: () => createConductanceQuantum,
    createConj: () => createConj,
    createConstantNode: () => createConstantNode,
    createCos: () => createCos,
    createCosh: () => createCosh,
    createCot: () => createCot,
    createCoth: () => createCoth,
    createCoulomb: () => createCoulomb,
    createCount: () => createCount,
    createCreateUnit: () => createCreateUnit,
    createCross: () => createCross,
    createCsc: () => createCsc,
    createCsch: () => createCsch,
    createCtranspose: () => createCtranspose,
    createCube: () => createCube,
    createDeepEqual: () => createDeepEqual,
    createDenseMatrixClass: () => createDenseMatrixClass,
    createDerivative: () => createDerivative,
    createDet: () => createDet,
    createDeuteronMass: () => createDeuteronMass,
    createDiag: () => createDiag,
    createDiff: () => createDiff,
    createDiffTransform: () => createDiffTransform,
    createDistance: () => createDistance,
    createDivide: () => createDivide,
    createDivideScalar: () => createDivideScalar,
    createDot: () => createDot,
    createDotDivide: () => createDotDivide,
    createDotMultiply: () => createDotMultiply,
    createDotPow: () => createDotPow,
    createE: () => createE,
    createEfimovFactor: () => createEfimovFactor,
    createEigs: () => createEigs,
    createElectricConstant: () => createElectricConstant,
    createElectronMass: () => createElectronMass,
    createElementaryCharge: () => createElementaryCharge,
    createEqual: () => createEqual,
    createEqualScalar: () => createEqualScalar,
    createEqualText: () => createEqualText,
    createErf: () => createErf,
    createEvaluate: () => createEvaluate,
    createExp: () => createExp,
    createExpm: () => createExpm,
    createExpm1: () => createExpm1,
    createFactorial: () => createFactorial,
    createFalse: () => createFalse,
    createFaraday: () => createFaraday,
    createFermiCoupling: () => createFermiCoupling,
    createFibonacciHeapClass: () => createFibonacciHeapClass,
    createFilter: () => createFilter,
    createFilterTransform: () => createFilterTransform,
    createFineStructure: () => createFineStructure,
    createFirstRadiation: () => createFirstRadiation,
    createFix: () => createFix,
    createFlatten: () => createFlatten,
    createFloor: () => createFloor,
    createForEach: () => createForEach,
    createForEachTransform: () => createForEachTransform,
    createFormat: () => createFormat,
    createFraction: () => createFraction,
    createFractionClass: () => createFractionClass,
    createFunctionAssignmentNode: () => createFunctionAssignmentNode,
    createFunctionNode: () => createFunctionNode,
    createGamma: () => createGamma,
    createGasConstant: () => createGasConstant,
    createGcd: () => createGcd,
    createGetMatrixDataType: () => createGetMatrixDataType,
    createGravitationConstant: () => createGravitationConstant,
    createGravity: () => createGravity,
    createHartreeEnergy: () => createHartreeEnergy,
    createHasNumericValue: () => createHasNumericValue,
    createHelp: () => createHelp,
    createHelpClass: () => createHelpClass,
    createHex: () => createHex,
    createHypot: () => createHypot,
    createI: () => createI,
    createIdentity: () => createIdentity,
    createIm: () => createIm,
    createImmutableDenseMatrixClass: () => createImmutableDenseMatrixClass,
    createIndex: () => createIndex,
    createIndexClass: () => createIndexClass,
    createIndexNode: () => createIndexNode,
    createIndexTransform: () => createIndexTransform,
    createInfinity: () => createInfinity,
    createIntersect: () => createIntersect,
    createInv: () => createInv,
    createInverseConductanceQuantum: () => createInverseConductanceQuantum,
    createIsInteger: () => createIsInteger,
    createIsNaN: () => createIsNaN,
    createIsNegative: () => createIsNegative,
    createIsNumeric: () => createIsNumeric,
    createIsPositive: () => createIsPositive,
    createIsPrime: () => createIsPrime,
    createIsZero: () => createIsZero,
    createKldivergence: () => createKldivergence,
    createKlitzing: () => createKlitzing,
    createKron: () => createKron,
    createLN10: () => createLN10,
    createLN2: () => createLN2,
    createLOG10E: () => createLOG10E,
    createLOG2E: () => createLOG2E,
    createLarger: () => createLarger,
    createLargerEq: () => createLargerEq,
    createLcm: () => createLcm,
    createLeftShift: () => createLeftShift,
    createLog: () => createLog,
    createLog10: () => createLog10,
    createLog1p: () => createLog1p,
    createLog2: () => createLog2,
    createLoschmidt: () => createLoschmidt,
    createLsolve: () => createLsolve,
    createLsolveAll: () => createLsolveAll,
    createLup: () => createLup,
    createLusolve: () => createLusolve,
    createMad: () => createMad,
    createMagneticConstant: () => createMagneticConstant,
    createMagneticFluxQuantum: () => createMagneticFluxQuantum,
    createMap: () => createMap,
    createMapTransform: () => createMapTransform,
    createMatrix: () => createMatrix,
    createMatrixClass: () => createMatrixClass,
    createMax: () => createMax,
    createMaxTransform: () => createMaxTransform,
    createMean: () => createMean,
    createMeanTransform: () => createMeanTransform,
    createMedian: () => createMedian,
    createMin: () => createMin,
    createMinTransform: () => createMinTransform,
    createMod: () => createMod,
    createMode: () => createMode,
    createMolarMass: () => createMolarMass,
    createMolarMassC12: () => createMolarMassC12,
    createMolarPlanckConstant: () => createMolarPlanckConstant,
    createMolarVolume: () => createMolarVolume,
    createMultinomial: () => createMultinomial,
    createMultiply: () => createMultiply,
    createMultiplyScalar: () => createMultiplyScalar,
    createNaN: () => createNaN,
    createNeutronMass: () => createNeutronMass,
    createNode: () => createNode,
    createNorm: () => createNorm,
    createNot: () => createNot,
    createNthRoot: () => createNthRoot,
    createNthRoots: () => createNthRoots,
    createNuclearMagneton: () => createNuclearMagneton,
    createNull: () => createNull,
    createNumber: () => createNumber,
    createNumeric: () => createNumeric,
    createObjectNode: () => createObjectNode,
    createOct: () => createOct,
    createOnes: () => createOnes,
    createOperatorNode: () => createOperatorNode,
    createOr: () => createOr,
    createParenthesisNode: () => createParenthesisNode,
    createParse: () => createParse,
    createParser: () => createParser,
    createParserClass: () => createParserClass,
    createPartitionSelect: () => createPartitionSelect,
    createPermutations: () => createPermutations,
    createPhi: () => createPhi,
    createPi: () => createPi,
    createPickRandom: () => createPickRandom,
    createPlanckCharge: () => createPlanckCharge,
    createPlanckConstant: () => createPlanckConstant,
    createPlanckLength: () => createPlanckLength,
    createPlanckMass: () => createPlanckMass,
    createPlanckTemperature: () => createPlanckTemperature,
    createPlanckTime: () => createPlanckTime,
    createPow: () => createPow,
    createPrint: () => createPrint,
    createProd: () => createProd,
    createProtonMass: () => createProtonMass,
    createQr: () => createQr,
    createQuantileSeq: () => createQuantileSeq,
    createQuantumOfCirculation: () => createQuantumOfCirculation,
    createRandom: () => createRandom,
    createRandomInt: () => createRandomInt,
    createRange: () => createRange,
    createRangeClass: () => createRangeClass,
    createRangeNode: () => createRangeNode,
    createRangeTransform: () => createRangeTransform,
    createRationalize: () => createRationalize,
    createRe: () => createRe,
    createReducedPlanckConstant: () => createReducedPlanckConstant,
    createRelationalNode: () => createRelationalNode,
    createReplacer: () => createReplacer,
    createReshape: () => createReshape,
    createResize: () => createResize,
    createResultSet: () => createResultSet,
    createReviver: () => createReviver,
    createRightArithShift: () => createRightArithShift,
    createRightLogShift: () => createRightLogShift,
    createRotate: () => createRotate,
    createRotationMatrix: () => createRotationMatrix,
    createRound: () => createRound,
    createRow: () => createRow,
    createRowTransform: () => createRowTransform,
    createRydberg: () => createRydberg,
    createSQRT1_2: () => createSQRT1_2,
    createSQRT2: () => createSQRT2,
    createSackurTetrode: () => createSackurTetrode,
    createSec: () => createSec,
    createSech: () => createSech,
    createSecondRadiation: () => createSecondRadiation,
    createSetCartesian: () => createSetCartesian,
    createSetDifference: () => createSetDifference,
    createSetDistinct: () => createSetDistinct,
    createSetIntersect: () => createSetIntersect,
    createSetIsSubset: () => createSetIsSubset,
    createSetMultiplicity: () => createSetMultiplicity,
    createSetPowerset: () => createSetPowerset,
    createSetSize: () => createSetSize,
    createSetSymDifference: () => createSetSymDifference,
    createSetUnion: () => createSetUnion,
    createSign: () => createSign,
    createSimplify: () => createSimplify,
    createSin: () => createSin,
    createSinh: () => createSinh,
    createSize: () => createSize,
    createSlu: () => createSlu,
    createSmaller: () => createSmaller,
    createSmallerEq: () => createSmallerEq,
    createSort: () => createSort,
    createSpaClass: () => createSpaClass,
    createSparse: () => createSparse,
    createSparseMatrixClass: () => createSparseMatrixClass,
    createSpeedOfLight: () => createSpeedOfLight,
    createSplitUnit: () => createSplitUnit,
    createSqrt: () => createSqrt,
    createSqrtm: () => createSqrtm,
    createSquare: () => createSquare,
    createSqueeze: () => createSqueeze,
    createStd: () => createStd,
    createStdTransform: () => createStdTransform,
    createStefanBoltzmann: () => createStefanBoltzmann,
    createStirlingS2: () => createStirlingS2,
    createString: () => createString,
    createSubset: () => createSubset,
    createSubsetTransform: () => createSubsetTransform,
    createSubtract: () => createSubtract,
    createSum: () => createSum,
    createSumTransform: () => createSumTransform,
    createSymbolNode: () => createSymbolNode,
    createTan: () => createTan,
    createTanh: () => createTanh,
    createTau: () => createTau,
    createThomsonCrossSection: () => createThomsonCrossSection,
    createTo: () => createTo,
    createTrace: () => createTrace,
    createTranspose: () => createTranspose,
    createTrue: () => createTrue,
    createTypeOf: () => createTypeOf,
    createTyped: () => createTyped,
    createUnaryMinus: () => createUnaryMinus,
    createUnaryPlus: () => createUnaryPlus,
    createUnequal: () => createUnequal,
    createUnitClass: () => createUnitClass,
    createUnitFunction: () => createUnitFunction,
    createUppercaseE: () => createUppercaseE,
    createUppercasePi: () => createUppercasePi,
    createUsolve: () => createUsolve,
    createUsolveAll: () => createUsolveAll,
    createVacuumImpedance: () => createVacuumImpedance,
    createVariance: () => createVariance,
    createVarianceTransform: () => createVarianceTransform,
    createVersion: () => createVersion,
    createWeakMixingAngle: () => createWeakMixingAngle,
    createWienDisplacement: () => createWienDisplacement,
    createXgcd: () => createXgcd,
    createXor: () => createXor,
    createZeros: () => createZeros
  });

  // node_modules/mathjs/lib/esm/core/function/typed.js
  var import_typed_function = __toModule(require_typed_function());

  // node_modules/mathjs/lib/esm/utils/number.js
  function isInteger(value) {
    if (typeof value === "boolean") {
      return true;
    }
    return isFinite(value) ? value === Math.round(value) : false;
  }
  var sign = Math.sign || function(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };
  var log2 = Math.log2 || function log22(x) {
    return Math.log(x) / Math.LN2;
  };
  var log10 = Math.log10 || function log102(x) {
    return Math.log(x) / Math.LN10;
  };
  var log1p = Math.log1p || function(x) {
    return Math.log(x + 1);
  };
  var cbrt = Math.cbrt || function cbrt2(x) {
    if (x === 0) {
      return x;
    }
    var negate = x < 0;
    var result;
    if (negate) {
      x = -x;
    }
    if (isFinite(x)) {
      result = Math.exp(Math.log(x) / 3);
      result = (x / (result * result) + 2 * result) / 3;
    } else {
      result = x;
    }
    return negate ? -result : result;
  };
  var expm1 = Math.expm1 || function expm12(x) {
    return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
  };
  function formatNumberToBase(n, base, size) {
    var prefixes = {
      2: "0b",
      8: "0o",
      16: "0x"
    };
    var prefix = prefixes[base];
    var suffix = "";
    if (size) {
      if (size < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size)) {
        throw new Error("size must be an integer");
      }
      if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
        throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
      }
      if (!isInteger(n)) {
        throw new Error("Value must be an integer");
      }
      if (n < 0) {
        n = n + 2 ** size;
      }
      suffix = "i".concat(size);
    }
    var sign2 = "";
    if (n < 0) {
      n = -n;
      sign2 = "-";
    }
    return "".concat(sign2).concat(prefix).concat(n.toString(base)).concat(suffix);
  }
  function format(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (value === Infinity) {
      return "Infinity";
    } else if (value === -Infinity) {
      return "-Infinity";
    } else if (isNaN(value)) {
      return "NaN";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options) {
      if (options.notation) {
        notation = options.notation;
      }
      if (isNumber(options)) {
        precision = options;
      } else if (isNumber(options.precision)) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed(value, precision);
      case "exponential":
        return toExponential(value, precision);
      case "engineering":
        return toEngineering(value, precision);
      case "bin":
        return formatNumberToBase(value, 2, wordSize);
      case "oct":
        return formatNumberToBase(value, 8, wordSize);
      case "hex":
        return formatNumberToBase(value, 16, wordSize);
      case "auto":
        return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e2 = arguments[4];
          return digits2 !== "." ? digits2 + e2 : e2;
        });
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function splitNumber(value) {
    var match = String(value).toLowerCase().match(/^0*?(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
    if (!match) {
      throw new SyntaxError("Invalid number " + value);
    }
    var sign2 = match[1];
    var digits2 = match[2];
    var exponent = parseFloat(match[4] || "0");
    var dot = digits2.indexOf(".");
    exponent += dot !== -1 ? dot - 1 : digits2.length - 1;
    var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros2) {
      exponent -= zeros2.length;
      return "";
    }).replace(/0*$/, "").split("").map(function(d) {
      return parseInt(d);
    });
    if (coefficients.length === 0) {
      coefficients.push(0);
      exponent++;
    }
    return {
      sign: sign2,
      coefficients,
      exponent
    };
  }
  function toEngineering(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e2 = rounded.exponent;
    var c = rounded.coefficients;
    var newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
    if (isNumber(precision)) {
      while (precision > c.length || e2 - newExp + 1 > c.length) {
        c.push(0);
      }
    } else {
      var missingZeros = Math.abs(e2 - newExp) - (c.length - 1);
      for (var i = 0; i < missingZeros; i++) {
        c.push(0);
      }
    }
    var expDiff = Math.abs(e2 - newExp);
    var decimalIdx = 1;
    while (expDiff > 0) {
      decimalIdx++;
      expDiff--;
    }
    var decimals = c.slice(decimalIdx).join("");
    var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
    var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
    return rounded.sign + str;
  }
  function toFixed(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var splitValue = splitNumber(value);
    var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c = rounded.coefficients;
    var p = rounded.exponent + 1;
    var pp = p + (precision || 0);
    if (c.length < pp) {
      c = c.concat(zeros(pp - c.length));
    }
    if (p < 0) {
      c = zeros(-p + 1).concat(c);
      p = 1;
    }
    if (p < c.length) {
      c.splice(p, 0, p === 0 ? "0." : ".");
    }
    return rounded.sign + c.join("");
  }
  function toExponential(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c = rounded.coefficients;
    var e2 = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    var first = c.shift();
    return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e2 >= 0 ? "+" : "") + e2;
  }
  function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
    var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
      return toExponential(value, precision);
    } else {
      var c = rounded.coefficients;
      var e2 = rounded.exponent;
      if (c.length < precision) {
        c = c.concat(zeros(precision - c.length));
      }
      c = c.concat(zeros(e2 - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
      c = zeros(-e2).concat(c);
      var dot = e2 > 0 ? e2 : 0;
      if (dot < c.length - 1) {
        c.splice(dot + 1, 0, ".");
      }
      return rounded.sign + c.join("");
    }
  }
  function roundDigits(split, precision) {
    var rounded = {
      sign: split.sign,
      coefficients: split.coefficients,
      exponent: split.exponent
    };
    var c = rounded.coefficients;
    while (precision <= 0) {
      c.unshift(0);
      rounded.exponent++;
      precision++;
    }
    if (c.length > precision) {
      var removed = c.splice(precision, c.length - precision);
      if (removed[0] >= 5) {
        var i = precision - 1;
        c[i]++;
        while (c[i] === 10) {
          c.pop();
          if (i === 0) {
            c.unshift(0);
            rounded.exponent++;
            i++;
          }
          i--;
          c[i]++;
        }
      }
    }
    return rounded;
  }
  function zeros(length) {
    var arr = [];
    for (var i = 0; i < length; i++) {
      arr.push(0);
    }
    return arr;
  }
  function digits(value) {
    return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
  }
  var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
  function nearlyEqual(x, y, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x === y;
    }
    if (x === y) {
      return true;
    }
    if (isNaN(x) || isNaN(y)) {
      return false;
    }
    if (isFinite(x) && isFinite(y)) {
      var diff = Math.abs(x - y);
      if (diff < DBL_EPSILON) {
        return true;
      } else {
        return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
      }
    }
    return false;
  }
  var acosh = Math.acosh || function(x) {
    return Math.log(Math.sqrt(x * x - 1) + x);
  };
  var asinh = Math.asinh || function(x) {
    return Math.log(Math.sqrt(x * x + 1) + x);
  };
  var atanh = Math.atanh || function(x) {
    return Math.log((1 + x) / (1 - x)) / 2;
  };
  var cosh = Math.cosh || function(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
  };
  var sinh = Math.sinh || function(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  };
  var tanh = Math.tanh || function(x) {
    var e2 = Math.exp(2 * x);
    return (e2 - 1) / (e2 + 1);
  };

  // node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
  function formatBigNumberToBase(n, base, size) {
    var BigNumberCtor = n.constructor;
    var big2 = new BigNumberCtor(2);
    var suffix = "";
    if (size) {
      if (size < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size)) {
        throw new Error("size must be an integer");
      }
      if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
        throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
      }
      if (!n.isInteger()) {
        throw new Error("Value must be an integer");
      }
      if (n.lessThan(0)) {
        n = n.add(big2.pow(size));
      }
      suffix = "i".concat(size);
    }
    switch (base) {
      case 2:
        return "".concat(n.toBinary()).concat(suffix);
      case 8:
        return "".concat(n.toOctal()).concat(suffix);
      case 16:
        return "".concat(n.toHexadecimal()).concat(suffix);
      default:
        throw new Error("Base ".concat(base, " not supported "));
    }
  }
  function format2(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (!value.isFinite()) {
      return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options !== void 0) {
      if (options.notation) {
        notation = options.notation;
      }
      if (typeof options === "number") {
        precision = options;
      } else if (options.precision) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed2(value, precision);
      case "exponential":
        return toExponential2(value, precision);
      case "engineering":
        return toEngineering2(value, precision);
      case "bin":
        return formatBigNumberToBase(value, 2, wordSize);
      case "oct":
        return formatBigNumberToBase(value, 8, wordSize);
      case "hex":
        return formatBigNumberToBase(value, 16, wordSize);
      case "auto": {
        var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
        var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
        if (value.isZero())
          return "0";
        var str;
        var rounded = value.toSignificantDigits(precision);
        var exp = rounded.e;
        if (exp >= lowerExp && exp < upperExp) {
          str = rounded.toFixed();
        } else {
          str = toExponential2(value, precision);
        }
        return str.replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e2 = arguments[4];
          return digits2 !== "." ? digits2 + e2 : e2;
        });
      }
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function toEngineering2(value, precision) {
    var e2 = value.e;
    var newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);
    if (valueStr.indexOf("e") !== -1) {
      valueStr = valueWithoutExp.toString();
    }
    return valueStr + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
  }
  function toExponential2(value, precision) {
    if (precision !== void 0) {
      return value.toExponential(precision - 1);
    } else {
      return value.toExponential();
    }
  }
  function toFixed2(value, precision) {
    return value.toFixed(precision);
  }

  // node_modules/mathjs/lib/esm/utils/string.js
  function endsWith(text, search) {
    var start = text.length - search.length;
    var end = text.length;
    return text.substring(start, end) === search;
  }
  function format3(value, options) {
    if (typeof value === "number") {
      return format(value, options);
    }
    if (isBigNumber(value)) {
      return format2(value, options);
    }
    if (looksLikeFraction(value)) {
      if (!options || options.fraction !== "decimal") {
        return value.s * value.n + "/" + value.d;
      } else {
        return value.toString();
      }
    }
    if (Array.isArray(value)) {
      return formatArray(value, options);
    }
    if (isString(value)) {
      return '"' + value + '"';
    }
    if (typeof value === "function") {
      return value.syntax ? String(value.syntax) : "function";
    }
    if (value && typeof value === "object") {
      if (typeof value.format === "function") {
        return value.format(options);
      } else if (value && value.toString(options) !== {}.toString()) {
        return value.toString(options);
      } else {
        var entries = Object.keys(value).map((key) => {
          return '"' + key + '": ' + format3(value[key], options);
        });
        return "{" + entries.join(", ") + "}";
      }
    }
    return String(value);
  }
  function stringify(value) {
    var text = String(value);
    var escaped = "";
    var i = 0;
    while (i < text.length) {
      var c = text.charAt(i);
      if (c === "\\") {
        escaped += c;
        i++;
        c = text.charAt(i);
        if (c === "" || '"\\/bfnrtu'.indexOf(c) === -1) {
          escaped += "\\";
        }
        escaped += c;
      } else if (c === '"') {
        escaped += '\\"';
      } else {
        escaped += c;
      }
      i++;
    }
    return '"' + escaped + '"';
  }
  function escape2(value) {
    var text = String(value);
    text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return text;
  }
  function formatArray(array, options) {
    if (Array.isArray(array)) {
      var str = "[";
      var len = array.length;
      for (var i = 0; i < len; i++) {
        if (i !== 0) {
          str += ", ";
        }
        str += formatArray(array[i], options);
      }
      str += "]";
      return str;
    } else {
      return format3(array, options);
    }
  }
  function looksLikeFraction(value) {
    return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
  }
  function compareText(x, y) {
    if (!isString(x)) {
      throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(x) + ", index: 0)");
    }
    if (!isString(y)) {
      throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(y) + ", index: 1)");
    }
    return x === y ? 0 : x > y ? 1 : -1;
  }

  // node_modules/mathjs/lib/esm/error/DimensionError.js
  function DimensionError(actual, expected, relation) {
    if (!(this instanceof DimensionError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.actual = actual;
    this.expected = expected;
    this.relation = relation;
    this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
    this.stack = new Error().stack;
  }
  DimensionError.prototype = new RangeError();
  DimensionError.prototype.constructor = RangeError;
  DimensionError.prototype.name = "DimensionError";
  DimensionError.prototype.isDimensionError = true;

  // node_modules/mathjs/lib/esm/error/IndexError.js
  function IndexError(index, min, max) {
    if (!(this instanceof IndexError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.index = index;
    if (arguments.length < 3) {
      this.min = 0;
      this.max = min;
    } else {
      this.min = min;
      this.max = max;
    }
    if (this.min !== void 0 && this.index < this.min) {
      this.message = "Index out of range (" + this.index + " < " + this.min + ")";
    } else if (this.max !== void 0 && this.index >= this.max) {
      this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
    } else {
      this.message = "Index out of range (" + this.index + ")";
    }
    this.stack = new Error().stack;
  }
  IndexError.prototype = new RangeError();
  IndexError.prototype.constructor = RangeError;
  IndexError.prototype.name = "IndexError";
  IndexError.prototype.isIndexError = true;

  // node_modules/mathjs/lib/esm/utils/array.js
  function arraySize(x) {
    var s = [];
    while (Array.isArray(x)) {
      s.push(x.length);
      x = x[0];
    }
    return s;
  }
  function _validate(array, size, dim) {
    var i;
    var len = array.length;
    if (len !== size[dim]) {
      throw new DimensionError(len, size[dim]);
    }
    if (dim < size.length - 1) {
      var dimNext = dim + 1;
      for (i = 0; i < len; i++) {
        var child = array[i];
        if (!Array.isArray(child)) {
          throw new DimensionError(size.length - 1, size.length, "<");
        }
        _validate(array[i], size, dimNext);
      }
    } else {
      for (i = 0; i < len; i++) {
        if (Array.isArray(array[i])) {
          throw new DimensionError(size.length + 1, size.length, ">");
        }
      }
    }
  }
  function validate(array, size) {
    var isScalar = size.length === 0;
    if (isScalar) {
      if (Array.isArray(array)) {
        throw new DimensionError(array.length, 0);
      }
    } else {
      _validate(array, size, 0);
    }
  }
  function validateIndex(index, length) {
    if (!isNumber(index) || !isInteger(index)) {
      throw new TypeError("Index must be an integer (value: " + index + ")");
    }
    if (index < 0 || typeof length === "number" && index >= length) {
      throw new IndexError(index, length);
    }
  }
  function resize(array, size, defaultValue) {
    if (!Array.isArray(array) || !Array.isArray(size)) {
      throw new TypeError("Array expected");
    }
    if (size.length === 0) {
      throw new Error("Resizing to scalar is not supported");
    }
    size.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size) + ")");
      }
    });
    var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
    _resize(array, size, 0, _defaultValue);
    return array;
  }
  function _resize(array, size, dim, defaultValue) {
    var i;
    var elem;
    var oldLen = array.length;
    var newLen = size[dim];
    var minLen = Math.min(oldLen, newLen);
    array.length = newLen;
    if (dim < size.length - 1) {
      var dimNext = dim + 1;
      for (i = 0; i < minLen; i++) {
        elem = array[i];
        if (!Array.isArray(elem)) {
          elem = [elem];
          array[i] = elem;
        }
        _resize(elem, size, dimNext, defaultValue);
      }
      for (i = minLen; i < newLen; i++) {
        elem = [];
        array[i] = elem;
        _resize(elem, size, dimNext, defaultValue);
      }
    } else {
      for (i = 0; i < minLen; i++) {
        while (Array.isArray(array[i])) {
          array[i] = array[i][0];
        }
      }
      for (i = minLen; i < newLen; i++) {
        array[i] = defaultValue;
      }
    }
  }
  function reshape(array, sizes) {
    var flatArray = flatten(array);
    var currentLength = flatArray.length;
    if (!Array.isArray(array) || !Array.isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length === 0) {
      throw new DimensionError(0, currentLength, "!=");
    }
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = product(sizes);
    if (currentLength !== newLength) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    try {
      return _reshape(flatArray, sizes);
    } catch (e2) {
      if (e2 instanceof DimensionError) {
        throw new DimensionError(newLength, currentLength, "!=");
      }
      throw e2;
    }
  }
  function processSizesWildcard(sizes, currentLength) {
    var newLength = product(sizes);
    var processedSizes = sizes.slice();
    var WILDCARD = -1;
    var wildCardIndex = sizes.indexOf(WILDCARD);
    var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
    if (isMoreThanOneWildcard) {
      throw new Error("More than one wildcard in sizes");
    }
    var hasWildcard = wildCardIndex >= 0;
    var canReplaceWildcard = currentLength % newLength === 0;
    if (hasWildcard) {
      if (canReplaceWildcard) {
        processedSizes[wildCardIndex] = -currentLength / newLength;
      } else {
        throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
      }
    }
    return processedSizes;
  }
  function product(array) {
    return array.reduce((prev, curr) => prev * curr, 1);
  }
  function _reshape(array, sizes) {
    var tmpArray = array;
    var tmpArray2;
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size = sizes[sizeIndex];
      tmpArray2 = [];
      var length = tmpArray.length / size;
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
      }
      tmpArray = tmpArray2;
    }
    return tmpArray;
  }
  function squeeze(array, size) {
    var s = size || arraySize(array);
    while (Array.isArray(array) && array.length === 1) {
      array = array[0];
      s.shift();
    }
    var dims = s.length;
    while (s[dims - 1] === 1) {
      dims--;
    }
    if (dims < s.length) {
      array = _squeeze(array, dims, 0);
      s.length = dims;
    }
    return array;
  }
  function _squeeze(array, dims, dim) {
    var i, ii;
    if (dim < dims) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _squeeze(array[i], dims, next);
      }
    } else {
      while (Array.isArray(array)) {
        array = array[0];
      }
    }
    return array;
  }
  function unsqueeze(array, dims, outer, size) {
    var s = size || arraySize(array);
    if (outer) {
      for (var i = 0; i < outer; i++) {
        array = [array];
        s.unshift(1);
      }
    }
    array = _unsqueeze(array, dims, 0);
    while (s.length < dims) {
      s.push(1);
    }
    return array;
  }
  function _unsqueeze(array, dims, dim) {
    var i, ii;
    if (Array.isArray(array)) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _unsqueeze(array[i], dims, next);
      }
    } else {
      for (var d = dim; d < dims; d++) {
        array = [array];
      }
    }
    return array;
  }
  function flatten(array) {
    if (!Array.isArray(array)) {
      return array;
    }
    var flat = [];
    array.forEach(function callback(value) {
      if (Array.isArray(value)) {
        value.forEach(callback);
      } else {
        flat.push(value);
      }
    });
    return flat;
  }
  function map(array, callback) {
    return Array.prototype.map.call(array, callback);
  }
  function forEach(array, callback) {
    Array.prototype.forEach.call(array, callback);
  }
  function filter(array, callback) {
    if (arraySize(array).length !== 1) {
      throw new Error("Only one dimensional matrices supported");
    }
    return Array.prototype.filter.call(array, callback);
  }
  function filterRegExp(array, regexp) {
    if (arraySize(array).length !== 1) {
      throw new Error("Only one dimensional matrices supported");
    }
    return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
  }
  function join(array, separator) {
    return Array.prototype.join.call(array, separator);
  }
  function identify(a) {
    if (!Array.isArray(a)) {
      throw new TypeError("Array input expected");
    }
    if (a.length === 0) {
      return a;
    }
    var b = [];
    var count = 0;
    b[0] = {
      value: a[0],
      identifier: 0
    };
    for (var i = 1; i < a.length; i++) {
      if (a[i] === a[i - 1]) {
        count++;
      } else {
        count = 0;
      }
      b.push({
        value: a[i],
        identifier: count
      });
    }
    return b;
  }
  function generalize(a) {
    if (!Array.isArray(a)) {
      throw new TypeError("Array input expected");
    }
    if (a.length === 0) {
      return a;
    }
    var b = [];
    for (var i = 0; i < a.length; i++) {
      b.push(a[i].value);
    }
    return b;
  }
  function getArrayDataType(array, typeOf2) {
    var type;
    var length = 0;
    for (var i = 0; i < array.length; i++) {
      var item = array[i];
      var isArray2 = Array.isArray(item);
      if (i === 0 && isArray2) {
        length = item.length;
      }
      if (isArray2 && item.length !== length) {
        return void 0;
      }
      var itemType = isArray2 ? getArrayDataType(item, typeOf2) : typeOf2(item);
      if (type === void 0) {
        type = itemType;
      } else if (type !== itemType) {
        return "mixed";
      } else {
      }
    }
    return type;
  }
  function contains2(array, item) {
    return array.indexOf(item) !== -1;
  }

  // node_modules/mathjs/lib/esm/utils/factory.js
  function factory(name284, dependencies285, create2, meta) {
    function assertAndCreate(scope) {
      var deps = pickShallow(scope, dependencies285.map(stripOptionalNotation));
      assertDependencies(name284, dependencies285, scope);
      return create2(deps);
    }
    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name284;
    assertAndCreate.dependencies = dependencies285.slice().sort();
    if (meta) {
      assertAndCreate.meta = meta;
    }
    return assertAndCreate;
  }
  function isFactory(obj) {
    return typeof obj === "function" && typeof obj.fn === "string" && Array.isArray(obj.dependencies);
  }
  function assertDependencies(name284, dependencies285, scope) {
    var allDefined = dependencies285.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
    if (!allDefined) {
      var missingDependencies = dependencies285.filter((dependency) => scope[dependency] === void 0);
      throw new Error('Cannot create function "'.concat(name284, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
    }
  }
  function isOptionalDependency(dependency) {
    return dependency && dependency[0] === "?";
  }
  function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
  }

  // node_modules/mathjs/lib/esm/core/function/typed.js
  var _createTyped2 = function _createTyped() {
    _createTyped2 = import_typed_function.default.create;
    return import_typed_function.default;
  };
  var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
  var createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
    var {
      BigNumber,
      Complex: Complex2,
      DenseMatrix,
      Fraction: Fraction2
    } = _ref;
    var typed = _createTyped2();
    typed.types = [
      {
        name: "number",
        test: isNumber
      },
      {
        name: "Complex",
        test: isComplex
      },
      {
        name: "BigNumber",
        test: isBigNumber
      },
      {
        name: "Fraction",
        test: isFraction
      },
      {
        name: "Unit",
        test: isUnit
      },
      {
        name: "string",
        test: isString
      },
      {
        name: "Chain",
        test: isChain
      },
      {
        name: "Array",
        test: isArray
      },
      {
        name: "Matrix",
        test: isMatrix
      },
      {
        name: "DenseMatrix",
        test: isDenseMatrix
      },
      {
        name: "SparseMatrix",
        test: isSparseMatrix
      },
      {
        name: "Range",
        test: isRange
      },
      {
        name: "Index",
        test: isIndex
      },
      {
        name: "boolean",
        test: isBoolean
      },
      {
        name: "ResultSet",
        test: isResultSet
      },
      {
        name: "Help",
        test: isHelp
      },
      {
        name: "function",
        test: isFunction
      },
      {
        name: "Date",
        test: isDate
      },
      {
        name: "RegExp",
        test: isRegExp
      },
      {
        name: "null",
        test: isNull
      },
      {
        name: "undefined",
        test: isUndefined
      },
      {
        name: "AccessorNode",
        test: isAccessorNode
      },
      {
        name: "ArrayNode",
        test: isArrayNode
      },
      {
        name: "AssignmentNode",
        test: isAssignmentNode
      },
      {
        name: "BlockNode",
        test: isBlockNode
      },
      {
        name: "ConditionalNode",
        test: isConditionalNode
      },
      {
        name: "ConstantNode",
        test: isConstantNode
      },
      {
        name: "FunctionNode",
        test: isFunctionNode
      },
      {
        name: "FunctionAssignmentNode",
        test: isFunctionAssignmentNode
      },
      {
        name: "IndexNode",
        test: isIndexNode
      },
      {
        name: "Node",
        test: isNode
      },
      {
        name: "ObjectNode",
        test: isObjectNode
      },
      {
        name: "OperatorNode",
        test: isOperatorNode
      },
      {
        name: "ParenthesisNode",
        test: isParenthesisNode
      },
      {
        name: "RangeNode",
        test: isRangeNode
      },
      {
        name: "SymbolNode",
        test: isSymbolNode
      },
      {
        name: "Object",
        test: isObject
      }
    ];
    typed.conversions = [{
      from: "number",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }
        if (digits(x) > 15) {
          throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
        }
        return new BigNumber(x);
      }
    }, {
      from: "number",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex2) {
          throwNoComplex(x);
        }
        return new Complex2(x, 0);
      }
    }, {
      from: "number",
      to: "string",
      convert: function convert(x) {
        return x + "";
      }
    }, {
      from: "BigNumber",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex2) {
          throwNoComplex(x);
        }
        return new Complex2(x.toNumber(), 0);
      }
    }, {
      from: "Fraction",
      to: "BigNumber",
      convert: function convert(x) {
        throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
      }
    }, {
      from: "Fraction",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex2) {
          throwNoComplex(x);
        }
        return new Complex2(x.valueOf(), 0);
      }
    }, {
      from: "number",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction2) {
          throwNoFraction(x);
        }
        var f = new Fraction2(x);
        if (f.valueOf() !== x) {
          throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
        }
        return f;
      }
    }, {
      from: "string",
      to: "number",
      convert: function convert(x) {
        var n = Number(x);
        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }
        return n;
      }
    }, {
      from: "string",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }
        try {
          return new BigNumber(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to BigNumber');
        }
      }
    }, {
      from: "string",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction2) {
          throwNoFraction(x);
        }
        try {
          return new Fraction2(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Fraction');
        }
      }
    }, {
      from: "string",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex2) {
          throwNoComplex(x);
        }
        try {
          return new Complex2(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Complex');
        }
      }
    }, {
      from: "boolean",
      to: "number",
      convert: function convert(x) {
        return +x;
      }
    }, {
      from: "boolean",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }
        return new BigNumber(+x);
      }
    }, {
      from: "boolean",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction2) {
          throwNoFraction(x);
        }
        return new Fraction2(+x);
      }
    }, {
      from: "boolean",
      to: "string",
      convert: function convert(x) {
        return String(x);
      }
    }, {
      from: "Array",
      to: "Matrix",
      convert: function convert(array) {
        if (!DenseMatrix) {
          throwNoMatrix();
        }
        return new DenseMatrix(array);
      }
    }, {
      from: "Matrix",
      to: "Array",
      convert: function convert(matrix) {
        return matrix.valueOf();
      }
    }];
    return typed;
  });
  function throwNoBignumber(x) {
    throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
  }
  function throwNoComplex(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
  }
  function throwNoMatrix() {
    throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
  }
  function throwNoFraction(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
  }

  // node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
  var name = "ResultSet";
  var dependencies2 = [];
  var createResultSet = /* @__PURE__ */ factory(name, dependencies2, () => {
    function ResultSet(entries) {
      if (!(this instanceof ResultSet)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.entries = entries || [];
    }
    ResultSet.prototype.type = "ResultSet";
    ResultSet.prototype.isResultSet = true;
    ResultSet.prototype.valueOf = function() {
      return this.entries;
    };
    ResultSet.prototype.toString = function() {
      return "[" + this.entries.join(", ") + "]";
    };
    ResultSet.prototype.toJSON = function() {
      return {
        mathjs: "ResultSet",
        entries: this.entries
      };
    };
    ResultSet.fromJSON = function(json) {
      return new ResultSet(json.entries);
    };
    return ResultSet;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
  var import_decimal = __toModule(require_decimal());
  var name2 = "BigNumber";
  var dependencies3 = ["?on", "config"];
  var createBigNumberClass = /* @__PURE__ */ factory(name2, dependencies3, (_ref) => {
    var {
      on,
      config
    } = _ref;
    var EUCLID = 9;
    var BigNumber = import_decimal.default.clone({
      precision: config.precision,
      modulo: EUCLID
    });
    BigNumber.prototype.type = "BigNumber";
    BigNumber.prototype.isBigNumber = true;
    BigNumber.prototype.toJSON = function() {
      return {
        mathjs: "BigNumber",
        value: this.toString()
      };
    };
    BigNumber.fromJSON = function(json) {
      return new BigNumber(json.value);
    };
    if (on) {
      on("config", function(curr, prev) {
        if (curr.precision !== prev.precision) {
          BigNumber.config({
            precision: curr.precision
          });
        }
      });
    }
    return BigNumber;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/complex/Complex.js
  var import_complex = __toModule(require_complex());
  var name3 = "Complex";
  var dependencies4 = [];
  var createComplexClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
    import_complex.default.prototype.type = "Complex";
    import_complex.default.prototype.isComplex = true;
    import_complex.default.prototype.toJSON = function() {
      return {
        mathjs: "Complex",
        re: this.re,
        im: this.im
      };
    };
    import_complex.default.prototype.toPolar = function() {
      return {
        r: this.abs(),
        phi: this.arg()
      };
    };
    import_complex.default.prototype.format = function(options) {
      var str = "";
      var im = this.im;
      var re = this.re;
      var strRe = format(this.re, options);
      var strIm = format(this.im, options);
      var precision = isNumber(options) ? options : options ? options.precision : null;
      if (precision !== null) {
        var epsilon = Math.pow(10, -precision);
        if (Math.abs(re / im) < epsilon) {
          re = 0;
        }
        if (Math.abs(im / re) < epsilon) {
          im = 0;
        }
      }
      if (im === 0) {
        str = strRe;
      } else if (re === 0) {
        if (im === 1) {
          str = "i";
        } else if (im === -1) {
          str = "-i";
        } else {
          str = strIm + "i";
        }
      } else {
        if (im < 0) {
          if (im === -1) {
            str = strRe + " - i";
          } else {
            str = strRe + " - " + strIm.substring(1) + "i";
          }
        } else {
          if (im === 1) {
            str = strRe + " + i";
          } else {
            str = strRe + " + " + strIm + "i";
          }
        }
      }
      return str;
    };
    import_complex.default.fromPolar = function(args) {
      switch (arguments.length) {
        case 1: {
          var arg = arguments[0];
          if (typeof arg === "object") {
            return (0, import_complex.default)(arg);
          } else {
            throw new TypeError("Input has to be an object with r and phi keys.");
          }
        }
        case 2: {
          var r = arguments[0];
          var phi2 = arguments[1];
          if (isNumber(r)) {
            if (isUnit(phi2) && phi2.hasBase("ANGLE")) {
              phi2 = phi2.toNumber("rad");
            }
            if (isNumber(phi2)) {
              return new import_complex.default({
                r,
                phi: phi2
              });
            }
            throw new TypeError("Phi is not a number nor an angle unit.");
          } else {
            throw new TypeError("Radius r is not a number.");
          }
        }
        default:
          throw new SyntaxError("Wrong number of arguments in function fromPolar");
      }
    };
    import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
    import_complex.default.fromJSON = function(json) {
      return new import_complex.default(json);
    };
    import_complex.default.compare = function(a, b) {
      if (a.re > b.re) {
        return 1;
      }
      if (a.re < b.re) {
        return -1;
      }
      if (a.im > b.im) {
        return 1;
      }
      if (a.im < b.im) {
        return -1;
      }
      return 0;
    };
    return import_complex.default;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/fraction/Fraction.js
  var import_fraction = __toModule(require_fraction());
  var name4 = "Fraction";
  var dependencies5 = [];
  var createFractionClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
    import_fraction.default.prototype.type = "Fraction";
    import_fraction.default.prototype.isFraction = true;
    import_fraction.default.prototype.toJSON = function() {
      return {
        mathjs: "Fraction",
        n: this.s * this.n,
        d: this.d
      };
    };
    import_fraction.default.fromJSON = function(json) {
      return new import_fraction.default(json);
    };
    return import_fraction.default;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Range.js
  var name5 = "Range";
  var dependencies6 = [];
  var createRangeClass = /* @__PURE__ */ factory(name5, dependencies6, () => {
    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      var hasStart = start !== null && start !== void 0;
      var hasEnd = end !== null && end !== void 0;
      var hasStep = step !== null && step !== void 0;
      if (hasStart) {
        if (isBigNumber(start)) {
          start = start.toNumber();
        } else if (typeof start !== "number") {
          throw new TypeError("Parameter start must be a number");
        }
      }
      if (hasEnd) {
        if (isBigNumber(end)) {
          end = end.toNumber();
        } else if (typeof end !== "number") {
          throw new TypeError("Parameter end must be a number");
        }
      }
      if (hasStep) {
        if (isBigNumber(step)) {
          step = step.toNumber();
        } else if (typeof step !== "number") {
          throw new TypeError("Parameter step must be a number");
        }
      }
      this.start = hasStart ? parseFloat(start) : 0;
      this.end = hasEnd ? parseFloat(end) : 0;
      this.step = hasStep ? parseFloat(step) : 1;
    }
    Range.prototype.type = "Range";
    Range.prototype.isRange = true;
    Range.parse = function(str) {
      if (typeof str !== "string") {
        return null;
      }
      var args = str.split(":");
      var nums = args.map(function(arg) {
        return parseFloat(arg);
      });
      var invalid = nums.some(function(num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return new Range(nums[0], nums[1]);
        case 3:
          return new Range(nums[0], nums[2], nums[1]);
        default:
          return null;
      }
    };
    Range.prototype.clone = function() {
      return new Range(this.start, this.end, this.step);
    };
    Range.prototype.size = function() {
      var len = 0;
      var start = this.start;
      var step = this.step;
      var end = this.end;
      var diff = end - start;
      if (sign(step) === sign(diff)) {
        len = Math.ceil(diff / step);
      } else if (diff === 0) {
        len = 0;
      }
      if (isNaN(len)) {
        len = 0;
      }
      return [len];
    };
    Range.prototype.min = function() {
      var size = this.size()[0];
      if (size > 0) {
        if (this.step > 0) {
          return this.start;
        } else {
          return this.start + (size - 1) * this.step;
        }
      } else {
        return void 0;
      }
    };
    Range.prototype.max = function() {
      var size = this.size()[0];
      if (size > 0) {
        if (this.step > 0) {
          return this.start + (size - 1) * this.step;
        } else {
          return this.start;
        }
      } else {
        return void 0;
      }
    };
    Range.prototype.forEach = function(callback) {
      var x = this.start;
      var step = this.step;
      var end = this.end;
      var i = 0;
      if (step > 0) {
        while (x < end) {
          callback(x, [i], this);
          x += step;
          i++;
        }
      } else if (step < 0) {
        while (x > end) {
          callback(x, [i], this);
          x += step;
          i++;
        }
      }
    };
    Range.prototype.map = function(callback) {
      var array = [];
      this.forEach(function(value, index, obj) {
        array[index[0]] = callback(value, index, obj);
      });
      return array;
    };
    Range.prototype.toArray = function() {
      var array = [];
      this.forEach(function(value, index) {
        array[index[0]] = value;
      });
      return array;
    };
    Range.prototype.valueOf = function() {
      return this.toArray();
    };
    Range.prototype.format = function(options) {
      var str = format(this.start, options);
      if (this.step !== 1) {
        str += ":" + format(this.step, options);
      }
      str += ":" + format(this.end, options);
      return str;
    };
    Range.prototype.toString = function() {
      return this.format();
    };
    Range.prototype.toJSON = function() {
      return {
        mathjs: "Range",
        start: this.start,
        end: this.end,
        step: this.step
      };
    };
    Range.fromJSON = function(json) {
      return new Range(json.start, json.end, json.step);
    };
    return Range;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Matrix.js
  var name6 = "Matrix";
  var dependencies7 = [];
  var createMatrixClass = /* @__PURE__ */ factory(name6, dependencies7, () => {
    function Matrix() {
      if (!(this instanceof Matrix)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
    }
    Matrix.prototype.type = "Matrix";
    Matrix.prototype.isMatrix = true;
    Matrix.prototype.storage = function() {
      throw new Error("Cannot invoke storage on a Matrix interface");
    };
    Matrix.prototype.datatype = function() {
      throw new Error("Cannot invoke datatype on a Matrix interface");
    };
    Matrix.prototype.create = function(data, datatype) {
      throw new Error("Cannot invoke create on a Matrix interface");
    };
    Matrix.prototype.subset = function(index, replacement, defaultValue) {
      throw new Error("Cannot invoke subset on a Matrix interface");
    };
    Matrix.prototype.get = function(index) {
      throw new Error("Cannot invoke get on a Matrix interface");
    };
    Matrix.prototype.set = function(index, value, defaultValue) {
      throw new Error("Cannot invoke set on a Matrix interface");
    };
    Matrix.prototype.resize = function(size, defaultValue) {
      throw new Error("Cannot invoke resize on a Matrix interface");
    };
    Matrix.prototype.reshape = function(size, defaultValue) {
      throw new Error("Cannot invoke reshape on a Matrix interface");
    };
    Matrix.prototype.clone = function() {
      throw new Error("Cannot invoke clone on a Matrix interface");
    };
    Matrix.prototype.size = function() {
      throw new Error("Cannot invoke size on a Matrix interface");
    };
    Matrix.prototype.map = function(callback, skipZeros) {
      throw new Error("Cannot invoke map on a Matrix interface");
    };
    Matrix.prototype.forEach = function(callback) {
      throw new Error("Cannot invoke forEach on a Matrix interface");
    };
    Matrix.prototype.toArray = function() {
      throw new Error("Cannot invoke toArray on a Matrix interface");
    };
    Matrix.prototype.valueOf = function() {
      throw new Error("Cannot invoke valueOf on a Matrix interface");
    };
    Matrix.prototype.format = function(options) {
      throw new Error("Cannot invoke format on a Matrix interface");
    };
    Matrix.prototype.toString = function() {
      throw new Error("Cannot invoke toString on a Matrix interface");
    };
    return Matrix;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
  var name7 = "DenseMatrix";
  var dependencies8 = ["Matrix"];
  var createDenseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
    var {
      Matrix
    } = _ref;
    function DenseMatrix(data, datatype) {
      if (!(this instanceof DenseMatrix)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        if (data.type === "DenseMatrix") {
          this._data = clone(data._data);
          this._size = clone(data._size);
          this._datatype = datatype || data._datatype;
        } else {
          this._data = data.toArray();
          this._size = data.size();
          this._datatype = datatype || data._datatype;
        }
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        validate(this._data, this._size);
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        this._data = preprocess(data);
        this._size = arraySize(this._data);
        validate(this._data, this._size);
        this._datatype = datatype;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
      }
    }
    DenseMatrix.prototype = new Matrix();
    DenseMatrix.prototype.createDenseMatrix = function(data, datatype) {
      return new DenseMatrix(data, datatype);
    };
    DenseMatrix.prototype.type = "DenseMatrix";
    DenseMatrix.prototype.isDenseMatrix = true;
    DenseMatrix.prototype.getDataType = function() {
      return getArrayDataType(this._data, typeOf);
    };
    DenseMatrix.prototype.storage = function() {
      return "dense";
    };
    DenseMatrix.prototype.datatype = function() {
      return this._datatype;
    };
    DenseMatrix.prototype.create = function(data, datatype) {
      return new DenseMatrix(data, datatype);
    };
    DenseMatrix.prototype.subset = function(index, replacement, defaultValue) {
      switch (arguments.length) {
        case 1:
          return _get(this, index);
        case 2:
        case 3:
          return _set(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    DenseMatrix.prototype.get = function(index) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      for (var x = 0; x < index.length; x++) {
        validateIndex(index[x], this._size[x]);
      }
      var data = this._data;
      for (var i = 0, ii = index.length; i < ii; i++) {
        var indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      return data;
    };
    DenseMatrix.prototype.set = function(index, value, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length < this._size.length) {
        throw new DimensionError(index.length, this._size.length, "<");
      }
      var i, ii, indexI;
      var size = index.map(function(i2) {
        return i2 + 1;
      });
      _fit(this, size, defaultValue);
      var data = this._data;
      for (i = 0, ii = index.length - 1; i < ii; i++) {
        indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      indexI = index[index.length - 1];
      validateIndex(indexI, data.length);
      data[indexI] = value;
      return this;
    };
    function _get(matrix, index) {
      if (!isIndex(index)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = index.isScalar();
      if (isScalar) {
        return matrix.get(index.min());
      } else {
        var size = index.size();
        if (size.length !== matrix._size.length) {
          throw new DimensionError(size.length, matrix._size.length);
        }
        var min = index.min();
        var max = index.max();
        for (var i = 0, ii = matrix._size.length; i < ii; i++) {
          validateIndex(min[i], matrix._size[i]);
          validateIndex(max[i], matrix._size[i]);
        }
        return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
      }
    }
    function _getSubmatrix(data, index, dims, dim) {
      var last = dim === dims - 1;
      var range = index.dimension(dim);
      if (last) {
        return range.map(function(i) {
          validateIndex(i, data.length);
          return data[i];
        }).valueOf();
      } else {
        return range.map(function(i) {
          validateIndex(i, data.length);
          var child = data[i];
          return _getSubmatrix(child, index, dims, dim + 1);
        }).valueOf();
      }
    }
    function _set(matrix, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index.size();
      var isScalar = index.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        if (iSize.length < matrix._size.length) {
          throw new DimensionError(iSize.length, matrix._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        var size = index.max().map(function(i2) {
          return i2 + 1;
        });
        _fit(matrix, size, defaultValue);
        var dims = iSize.length;
        var dim = 0;
        _setSubmatrix(matrix._data, index, submatrix, dims, dim);
      }
      return matrix;
    }
    function _setSubmatrix(data, index, submatrix, dims, dim) {
      var last = dim === dims - 1;
      var range = index.dimension(dim);
      if (last) {
        range.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          data[dataIndex] = submatrix[subIndex[0]];
        });
      } else {
        range.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
        });
      }
    }
    DenseMatrix.prototype.resize = function(size, defaultValue, copy) {
      if (!isCollection(size)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray, defaultValue);
    };
    function _resize2(matrix, size, defaultValue) {
      if (size.length === 0) {
        var v = matrix._data;
        while (isArray(v)) {
          v = v[0];
        }
        return v;
      }
      matrix._size = size.slice(0);
      matrix._data = resize(matrix._data, matrix._size, defaultValue);
      return matrix;
    }
    DenseMatrix.prototype.reshape = function(size, copy) {
      var m = copy ? this.clone() : this;
      m._data = reshape(m._data, size);
      var currentLength = m._size.reduce((length, size2) => length * size2);
      m._size = processSizesWildcard(size, currentLength);
      return m;
    };
    function _fit(matrix, size, defaultValue) {
      var newSize = matrix._size.slice(0);
      var changed = false;
      while (newSize.length < size.length) {
        newSize.push(0);
        changed = true;
      }
      for (var i = 0, ii = size.length; i < ii; i++) {
        if (size[i] > newSize[i]) {
          newSize[i] = size[i];
          changed = true;
        }
      }
      if (changed) {
        _resize2(matrix, newSize, defaultValue);
      }
    }
    DenseMatrix.prototype.clone = function() {
      var m = new DenseMatrix({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    DenseMatrix.prototype.size = function() {
      return this._size.slice(0);
    };
    DenseMatrix.prototype.map = function(callback) {
      var me = this;
      var recurse = function recurse2(value, index) {
        if (isArray(value)) {
          return value.map(function(child, i) {
            return recurse2(child, index.concat(i));
          });
        } else {
          return callback(value, index, me);
        }
      };
      var data = recurse(this._data, []);
      var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
      return new DenseMatrix(data, datatype);
    };
    DenseMatrix.prototype.forEach = function(callback) {
      var me = this;
      var recurse = function recurse2(value, index) {
        if (isArray(value)) {
          value.forEach(function(child, i) {
            recurse2(child, index.concat(i));
          });
        } else {
          callback(value, index, me);
        }
      };
      recurse(this._data, []);
    };
    DenseMatrix.prototype.toArray = function() {
      return clone(this._data);
    };
    DenseMatrix.prototype.valueOf = function() {
      return this._data;
    };
    DenseMatrix.prototype.format = function(options) {
      return format3(this._data, options);
    };
    DenseMatrix.prototype.toString = function() {
      return format3(this._data);
    };
    DenseMatrix.prototype.toJSON = function() {
      return {
        mathjs: "DenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    DenseMatrix.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var data = [];
      for (var i = 0; i < n; i++) {
        data[i] = this._data[i + kSub][i + kSuper];
      }
      return new DenseMatrix({
        data,
        size: [n],
        datatype: this._datatype
      });
    };
    DenseMatrix.diagonal = function(size, value, k, defaultValue) {
      if (!isArray(size)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size = size.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size[0];
      var columns = size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i) {
          return value[i];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i) {
          return value.get([i]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      if (!defaultValue) {
        defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
      }
      var data = [];
      if (size.length > 0) {
        data = resize(data, size, defaultValue);
        for (var d = 0; d < n; d++) {
          data[d + kSub][d + kSuper] = _value(d);
        }
      }
      return new DenseMatrix({
        data,
        size: [rows, columns]
      });
    };
    DenseMatrix.fromJSON = function(json) {
      return new DenseMatrix(json);
    };
    DenseMatrix.prototype.swapRows = function(i, j) {
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]);
      DenseMatrix._swapRows(i, j, this._data);
      return this;
    };
    DenseMatrix._swapRows = function(i, j, data) {
      var vi = data[i];
      data[i] = data[j];
      data[j] = vi;
    };
    function preprocess(data) {
      for (var i = 0, ii = data.length; i < ii; i++) {
        var elem = data[i];
        if (isArray(elem)) {
          data[i] = preprocess(elem);
        } else if (elem && elem.isMatrix === true) {
          data[i] = preprocess(elem.valueOf());
        }
      }
      return data;
    }
    return DenseMatrix;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/function/utils/clone.js
  var name8 = "clone";
  var dependencies9 = ["typed"];
  var createClone = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name8, {
      any: clone
    });
  });

  // node_modules/mathjs/lib/esm/utils/collection.js
  function containsCollections(array) {
    for (var i = 0; i < array.length; i++) {
      if (isCollection(array[i])) {
        return true;
      }
    }
    return false;
  }
  function deepForEach(array, callback) {
    if (isMatrix(array)) {
      array = array.valueOf();
    }
    for (var i = 0, ii = array.length; i < ii; i++) {
      var value = array[i];
      if (Array.isArray(value)) {
        deepForEach(value, callback);
      } else {
        callback(value);
      }
    }
  }
  function deepMap(array, callback, skipZeros) {
    if (array && typeof array.map === "function") {
      return array.map(function(x) {
        return deepMap(x, callback, skipZeros);
      });
    } else {
      return callback(array);
    }
  }
  function reduce(mat, dim, callback) {
    var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
    if (dim < 0 || dim >= size.length) {
      throw new IndexError(dim, size.length);
    }
    if (isMatrix(mat)) {
      return mat.create(_reduce(mat.valueOf(), dim, callback));
    } else {
      return _reduce(mat, dim, callback);
    }
  }
  function _reduce(mat, dim, callback) {
    var i, ret, val, tran;
    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        val = mat[0];
        for (i = 1; i < mat.length; i++) {
          val = callback(val, mat[i]);
        }
        return val;
      } else {
        tran = _switch(mat);
        ret = [];
        for (i = 0; i < tran.length; i++) {
          ret[i] = _reduce(tran[i], dim - 1, callback);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i = 0; i < mat.length; i++) {
        ret[i] = _reduce(mat[i], dim - 1, callback);
      }
      return ret;
    }
  }
  function _switch(mat) {
    var I = mat.length;
    var J = mat[0].length;
    var i, j;
    var ret = [];
    for (j = 0; j < J; j++) {
      var tmp = [];
      for (i = 0; i < I; i++) {
        tmp.push(mat[i][j]);
      }
      ret.push(tmp);
    }
    return ret;
  }
  function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var k, k0, k1, i;
    if (x) {
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i = aindex[k];
        if (w[i] !== mark) {
          w[i] = mark;
          cindex.push(i);
          if (update) {
            x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
            u[i] = mark;
          } else {
            x[i] = avalues[k];
          }
        } else {
          x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
          u[i] = mark;
        }
      }
    } else {
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i = aindex[k];
        if (w[i] !== mark) {
          w[i] = mark;
          cindex.push(i);
        } else {
          u[i] = mark;
        }
      }
    }
  }

  // node_modules/mathjs/lib/esm/function/utils/isInteger.js
  var name9 = "isInteger";
  var dependencies10 = ["typed"];
  var createIsInteger = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name9, {
      number: isInteger,
      BigNumber: function BigNumber(x) {
        return x.isInt();
      },
      Fraction: function Fraction2(x) {
        return x.d === 1 && isFinite(x.n);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/plain/number/arithmetic.js
  var n1 = "number";
  var n2 = "number, number";
  function absNumber(a) {
    return Math.abs(a);
  }
  absNumber.signature = n1;
  function addNumber(a, b) {
    return a + b;
  }
  addNumber.signature = n2;
  function subtractNumber(a, b) {
    return a - b;
  }
  subtractNumber.signature = n2;
  function multiplyNumber(a, b) {
    return a * b;
  }
  multiplyNumber.signature = n2;
  function divideNumber(a, b) {
    return a / b;
  }
  divideNumber.signature = n2;
  function unaryMinusNumber(x) {
    return -x;
  }
  unaryMinusNumber.signature = n1;
  function unaryPlusNumber(x) {
    return x;
  }
  unaryPlusNumber.signature = n1;
  function cbrtNumber(x) {
    return cbrt(x);
  }
  cbrtNumber.signature = n1;
  function ceilNumber(x) {
    return Math.ceil(x);
  }
  ceilNumber.signature = n1;
  function cubeNumber(x) {
    return x * x * x;
  }
  cubeNumber.signature = n1;
  function expNumber(x) {
    return Math.exp(x);
  }
  expNumber.signature = n1;
  function expm1Number(x) {
    return expm1(x);
  }
  expm1Number.signature = n1;
  function fixNumber(x) {
    return x > 0 ? Math.floor(x) : Math.ceil(x);
  }
  fixNumber.signature = n1;
  function floorNumber(x) {
    return Math.floor(x);
  }
  floorNumber.signature = n1;
  function gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = a % b;
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  gcdNumber.signature = n2;
  function lcmNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a === 0 || b === 0) {
      return 0;
    }
    var t;
    var prod = a * b;
    while (b !== 0) {
      t = b;
      b = a % t;
      a = t;
    }
    return Math.abs(prod / a);
  }
  lcmNumber.signature = n2;
  function logNumber(x) {
    return Math.log(x);
  }
  logNumber.signature = n1;
  function log10Number(x) {
    return log10(x);
  }
  log10Number.signature = n1;
  function log2Number(x) {
    return log2(x);
  }
  log2Number.signature = n1;
  function log1pNumber(x) {
    return log1p(x);
  }
  log1pNumber.signature = n1;
  function modNumber(x, y) {
    if (y > 0) {
      return x - y * Math.floor(x / y);
    } else if (y === 0) {
      return x;
    } else {
      throw new Error("Cannot calculate mod for a negative divisor");
    }
  }
  modNumber.signature = n2;
  function nthRootNumber(a, root) {
    var inv = root < 0;
    if (inv) {
      root = -root;
    }
    if (root === 0) {
      throw new Error("Root must be non-zero");
    }
    if (a < 0 && Math.abs(root) % 2 !== 1) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a === 0) {
      return inv ? Infinity : 0;
    }
    if (!isFinite(a)) {
      return inv ? 0 : a;
    }
    var x = Math.pow(Math.abs(a), 1 / root);
    x = a < 0 ? -x : x;
    return inv ? 1 / x : x;
  }
  nthRootNumber.signature = n2;
  function signNumber(x) {
    return sign(x);
  }
  signNumber.signature = n1;
  function sqrtNumber(x) {
    return Math.sqrt(x);
  }
  sqrtNumber.signature = n1;
  function squareNumber(x) {
    return x * x;
  }
  squareNumber.signature = n1;
  function xgcdNumber(a, b) {
    var t;
    var q;
    var r;
    var x = 0;
    var lastx = 1;
    var y = 1;
    var lasty = 0;
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (b) {
      q = Math.floor(a / b);
      r = a - q * b;
      t = x;
      x = lastx - q * x;
      lastx = t;
      t = y;
      y = lasty - q * y;
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a < 0) {
      res = [-a, -lastx, -lasty];
    } else {
      res = [a, a ? lastx : 0, lasty];
    }
    return res;
  }
  xgcdNumber.signature = n2;
  function powNumber(x, y) {
    if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
      return 0;
    }
    return Math.pow(x, y);
  }
  powNumber.signature = n2;
  function roundNumber(value) {
    var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return parseFloat(toFixed(value, decimals));
  }
  roundNumber.signature = n2;
  function normNumber(x) {
    return Math.abs(x);
  }
  normNumber.signature = n1;

  // node_modules/mathjs/lib/esm/plain/number/bitwise.js
  var n12 = "number";
  var n22 = "number, number";
  function bitAndNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function bitAnd");
    }
    return x & y;
  }
  bitAndNumber.signature = n22;
  function bitNotNumber(x) {
    if (!isInteger(x)) {
      throw new Error("Integer expected in function bitNot");
    }
    return ~x;
  }
  bitNotNumber.signature = n12;
  function bitOrNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function bitOr");
    }
    return x | y;
  }
  bitOrNumber.signature = n22;
  function bitXorNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function bitXor");
    }
    return x ^ y;
  }
  bitXorNumber.signature = n22;
  function leftShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function leftShift");
    }
    return x << y;
  }
  leftShiftNumber.signature = n22;
  function rightArithShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function rightArithShift");
    }
    return x >> y;
  }
  rightArithShiftNumber.signature = n22;
  function rightLogShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function rightLogShift");
    }
    return x >>> y;
  }
  rightLogShiftNumber.signature = n22;

  // node_modules/mathjs/lib/esm/utils/product.js
  function product2(i, n) {
    if (n < i) {
      return 1;
    }
    if (n === i) {
      return n;
    }
    var half = n + i >> 1;
    return product2(i, half) * product2(half + 1, n);
  }

  // node_modules/mathjs/lib/esm/plain/number/combinations.js
  function combinationsNumber(n, k) {
    if (!isInteger(n) || n < 0) {
      throw new TypeError("Positive integer value expected in function combinations");
    }
    if (!isInteger(k) || k < 0) {
      throw new TypeError("Positive integer value expected in function combinations");
    }
    if (k > n) {
      throw new TypeError("k must be less than or equal to n");
    }
    var nMinusk = n - k;
    var prodrange;
    if (k < nMinusk) {
      prodrange = product2(nMinusk + 1, n);
      return prodrange / product2(1, k);
    }
    prodrange = product2(k + 1, n);
    return prodrange / product2(1, nMinusk);
  }
  combinationsNumber.signature = "number, number";

  // node_modules/mathjs/lib/esm/plain/number/constants.js
  var pi = Math.PI;
  var tau = 2 * Math.PI;
  var e = Math.E;
  var phi = 1.618033988749895;

  // node_modules/mathjs/lib/esm/plain/number/logical.js
  var n13 = "number";
  var n23 = "number, number";
  function notNumber(x) {
    return !x;
  }
  notNumber.signature = n13;
  function orNumber(x, y) {
    return !!(x || y);
  }
  orNumber.signature = n23;
  function xorNumber(x, y) {
    return !!x !== !!y;
  }
  xorNumber.signature = n23;
  function andNumber(x, y) {
    return !!(x && y);
  }
  andNumber.signature = n23;

  // node_modules/mathjs/lib/esm/plain/number/probability.js
  function gammaNumber(n) {
    var x;
    if (isInteger(n)) {
      if (n <= 0) {
        return isFinite(n) ? Infinity : NaN;
      }
      if (n > 171) {
        return Infinity;
      }
      return product2(1, n - 1);
    }
    if (n < 0.5) {
      return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
    }
    if (n >= 171.35) {
      return Infinity;
    }
    if (n > 85) {
      var twoN = n * n;
      var threeN = twoN * n;
      var fourN = threeN * n;
      var fiveN = fourN * n;
      return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
    }
    --n;
    x = gammaP[0];
    for (var i = 1; i < gammaP.length; ++i) {
      x += gammaP[i] / (n + i);
    }
    var t = n + gammaG + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
  }
  gammaNumber.signature = "number";
  var gammaG = 4.7421875;
  var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];

  // node_modules/mathjs/lib/esm/plain/number/trigonometry.js
  var n14 = "number";
  var n24 = "number, number";
  function acosNumber(x) {
    return Math.acos(x);
  }
  acosNumber.signature = n14;
  function acoshNumber(x) {
    return acosh(x);
  }
  acoshNumber.signature = n14;
  function acotNumber(x) {
    return Math.atan(1 / x);
  }
  acotNumber.signature = n14;
  function acothNumber(x) {
    return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
  }
  acothNumber.signature = n14;
  function acscNumber(x) {
    return Math.asin(1 / x);
  }
  acscNumber.signature = n14;
  function acschNumber(x) {
    var xInv = 1 / x;
    return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
  }
  acschNumber.signature = n14;
  function asecNumber(x) {
    return Math.acos(1 / x);
  }
  asecNumber.signature = n14;
  function asechNumber(x) {
    var xInv = 1 / x;
    var ret = Math.sqrt(xInv * xInv - 1);
    return Math.log(ret + xInv);
  }
  asechNumber.signature = n14;
  function asinNumber(x) {
    return Math.asin(x);
  }
  asinNumber.signature = n14;
  function asinhNumber(x) {
    return asinh(x);
  }
  asinhNumber.signature = n14;
  function atanNumber(x) {
    return Math.atan(x);
  }
  atanNumber.signature = n14;
  function atan2Number(y, x) {
    return Math.atan2(y, x);
  }
  atan2Number.signature = n24;
  function atanhNumber(x) {
    return atanh(x);
  }
  atanhNumber.signature = n14;
  function cosNumber(x) {
    return Math.cos(x);
  }
  cosNumber.signature = n14;
  function coshNumber(x) {
    return cosh(x);
  }
  coshNumber.signature = n14;
  function cotNumber(x) {
    return 1 / Math.tan(x);
  }
  cotNumber.signature = n14;
  function cothNumber(x) {
    var e2 = Math.exp(2 * x);
    return (e2 + 1) / (e2 - 1);
  }
  cothNumber.signature = n14;
  function cscNumber(x) {
    return 1 / Math.sin(x);
  }
  cscNumber.signature = n14;
  function cschNumber(x) {
    if (x === 0) {
      return Number.POSITIVE_INFINITY;
    } else {
      return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
    }
  }
  cschNumber.signature = n14;
  function secNumber(x) {
    return 1 / Math.cos(x);
  }
  secNumber.signature = n14;
  function sechNumber(x) {
    return 2 / (Math.exp(x) + Math.exp(-x));
  }
  sechNumber.signature = n14;
  function sinNumber(x) {
    return Math.sin(x);
  }
  sinNumber.signature = n14;
  function sinhNumber(x) {
    return sinh(x);
  }
  sinhNumber.signature = n14;
  function tanNumber(x) {
    return Math.tan(x);
  }
  tanNumber.signature = n14;
  function tanhNumber(x) {
    return tanh(x);
  }
  tanhNumber.signature = n14;

  // node_modules/mathjs/lib/esm/plain/number/utils.js
  var n15 = "number";
  function isIntegerNumber(x) {
    return isInteger(x);
  }
  isIntegerNumber.signature = n15;
  function isNegativeNumber(x) {
    return x < 0;
  }
  isNegativeNumber.signature = n15;
  function isPositiveNumber(x) {
    return x > 0;
  }
  isPositiveNumber.signature = n15;
  function isZeroNumber(x) {
    return x === 0;
  }
  isZeroNumber.signature = n15;
  function isNaNNumber(x) {
    return Number.isNaN(x);
  }
  isNaNNumber.signature = n15;

  // node_modules/mathjs/lib/esm/function/utils/isNegative.js
  var name10 = "isNegative";
  var dependencies11 = ["typed"];
  var createIsNegative = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name10, {
      number: isNegativeNumber,
      BigNumber: function BigNumber(x) {
        return x.isNeg() && !x.isZero() && !x.isNaN();
      },
      Fraction: function Fraction2(x) {
        return x.s < 0;
      },
      Unit: function Unit(x) {
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isNumeric.js
  var name11 = "isNumeric";
  var dependencies12 = ["typed"];
  var createIsNumeric = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name11, {
      "number | BigNumber | Fraction | boolean": function numberBigNumberFractionBoolean() {
        return true;
      },
      "Complex | Unit | string | null | undefined | Node": function ComplexUnitStringNullUndefinedNode() {
        return false;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
  var name12 = "hasNumericValue";
  var dependencies13 = ["typed", "isNumeric"];
  var createHasNumericValue = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
    var {
      typed,
      isNumeric
    } = _ref;
    return typed(name12, {
      string: function string(x) {
        return x.trim().length > 0 && !isNaN(Number(x));
      },
      any: function any(x) {
        return isNumeric(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isPositive.js
  var name13 = "isPositive";
  var dependencies14 = ["typed"];
  var createIsPositive = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name13, {
      number: isPositiveNumber,
      BigNumber: function BigNumber(x) {
        return !x.isNeg() && !x.isZero() && !x.isNaN();
      },
      Fraction: function Fraction2(x) {
        return x.s > 0 && x.n > 0;
      },
      Unit: function Unit(x) {
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isZero.js
  var name14 = "isZero";
  var dependencies15 = ["typed"];
  var createIsZero = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name14, {
      number: isZeroNumber,
      BigNumber: function BigNumber(x) {
        return x.isZero();
      },
      Complex: function Complex2(x) {
        return x.re === 0 && x.im === 0;
      },
      Fraction: function Fraction2(x) {
        return x.d === 1 && x.n === 0;
      },
      Unit: function Unit(x) {
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isNaN.js
  var name15 = "isNaN";
  var dependencies16 = ["typed"];
  var createIsNaN = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name15, {
      number: isNaNNumber,
      BigNumber: function BigNumber(x) {
        return x.isNaN();
      },
      Fraction: function Fraction2(x) {
        return false;
      },
      Complex: function Complex2(x) {
        return x.isNaN();
      },
      Unit: function Unit(x) {
        return Number.isNaN(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, Number.isNaN);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/typeOf.js
  var name16 = "typeOf";
  var dependencies17 = ["typed"];
  var createTypeOf = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name16, {
      any: typeOf
    });
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
  function nearlyEqual2(x, y, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x.eq(y);
    }
    if (x.eq(y)) {
      return true;
    }
    if (x.isNaN() || y.isNaN()) {
      return false;
    }
    if (x.isFinite() && y.isFinite()) {
      var diff = x.minus(y).abs();
      if (diff.isZero()) {
        return true;
      } else {
        var max = x.constructor.max(x.abs(), y.abs());
        return diff.lte(max.times(epsilon));
      }
    }
    return false;
  }

  // node_modules/mathjs/lib/esm/utils/complex.js
  function complexEquals(x, y, epsilon) {
    return nearlyEqual(x.re, y.re, epsilon) && nearlyEqual(x.im, y.im, epsilon);
  }

  // node_modules/mathjs/lib/esm/function/relational/equalScalar.js
  var name17 = "equalScalar";
  var dependencies18 = ["typed", "config"];
  var createEqualScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
    var {
      typed,
      config
    } = _ref;
    return typed(name17, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x === y;
      },
      "number, number": function numberNumber2(x, y) {
        return nearlyEqual(x, y, config.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.eq(y) || nearlyEqual2(x, y, config.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.equals(y);
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return complexEquals(x, y, config.epsilon);
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      }
    });
  });
  var createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
    var {
      typed,
      config
    } = _ref2;
    return typed(name17, {
      "number, number": function numberNumber2(x, y) {
        return nearlyEqual(x, y, config.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
  var name18 = "SparseMatrix";
  var dependencies19 = ["typed", "equalScalar", "Matrix"];
  var createSparseMatrixClass = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
    var {
      typed,
      equalScalar,
      Matrix
    } = _ref;
    function SparseMatrix(data, datatype) {
      if (!(this instanceof SparseMatrix)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        _createFromMatrix(this, data, datatype);
      } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
        this._values = data.values;
        this._index = data.index;
        this._ptr = data.ptr;
        this._size = data.size;
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        _createFromArray(this, data, datatype);
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._values = [];
        this._index = [];
        this._ptr = [0];
        this._size = [0, 0];
        this._datatype = datatype;
      }
    }
    function _createFromMatrix(matrix, source, datatype) {
      if (source.type === "SparseMatrix") {
        matrix._values = source._values ? clone(source._values) : void 0;
        matrix._index = clone(source._index);
        matrix._ptr = clone(source._ptr);
        matrix._size = clone(source._size);
        matrix._datatype = datatype || source._datatype;
      } else {
        _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
      }
    }
    function _createFromArray(matrix, data, datatype) {
      matrix._values = [];
      matrix._index = [];
      matrix._ptr = [];
      matrix._datatype = datatype;
      var rows = data.length;
      var columns = 0;
      var eq = equalScalar;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
        zero = typed.convert(0, datatype);
      }
      if (rows > 0) {
        var j = 0;
        do {
          matrix._ptr.push(matrix._index.length);
          for (var i = 0; i < rows; i++) {
            var row = data[i];
            if (isArray(row)) {
              if (j === 0 && columns < row.length) {
                columns = row.length;
              }
              if (j < row.length) {
                var v = row[j];
                if (!eq(v, zero)) {
                  matrix._values.push(v);
                  matrix._index.push(i);
                }
              }
            } else {
              if (j === 0 && columns < 1) {
                columns = 1;
              }
              if (!eq(row, zero)) {
                matrix._values.push(row);
                matrix._index.push(i);
              }
            }
          }
          j++;
        } while (j < columns);
      }
      matrix._ptr.push(matrix._index.length);
      matrix._size = [rows, columns];
    }
    SparseMatrix.prototype = new Matrix();
    SparseMatrix.prototype.createSparseMatrix = function(data, datatype) {
      return new SparseMatrix(data, datatype);
    };
    SparseMatrix.prototype.type = "SparseMatrix";
    SparseMatrix.prototype.isSparseMatrix = true;
    SparseMatrix.prototype.getDataType = function() {
      return getArrayDataType(this._values, typeOf);
    };
    SparseMatrix.prototype.storage = function() {
      return "sparse";
    };
    SparseMatrix.prototype.datatype = function() {
      return this._datatype;
    };
    SparseMatrix.prototype.create = function(data, datatype) {
      return new SparseMatrix(data, datatype);
    };
    SparseMatrix.prototype.density = function() {
      var rows = this._size[0];
      var columns = this._size[1];
      return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
    };
    SparseMatrix.prototype.subset = function(index, replacement, defaultValue) {
      if (!this._values) {
        throw new Error("Cannot invoke subset on a Pattern only matrix");
      }
      switch (arguments.length) {
        case 1:
          return _getsubset(this, index);
        case 2:
        case 3:
          return _setsubset(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    function _getsubset(matrix, idx) {
      if (!isIndex(idx)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = idx.isScalar();
      if (isScalar) {
        return matrix.get(idx.min());
      }
      var size = idx.size();
      if (size.length !== matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      }
      var i, ii, k, kk;
      var min = idx.min();
      var max = idx.max();
      for (i = 0, ii = matrix._size.length; i < ii; i++) {
        validateIndex(min[i], matrix._size[i]);
        validateIndex(max[i], matrix._size[i]);
      }
      var mvalues = matrix._values;
      var mindex = matrix._index;
      var mptr = matrix._ptr;
      var rows = idx.dimension(0);
      var columns = idx.dimension(1);
      var w = [];
      var pv = [];
      rows.forEach(function(i2, r) {
        pv[i2] = r[0];
        w[i2] = true;
      });
      var values2 = mvalues ? [] : void 0;
      var index = [];
      var ptr = [];
      columns.forEach(function(j) {
        ptr.push(index.length);
        for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
          i = mindex[k];
          if (w[i] === true) {
            index.push(pv[i]);
            if (values2) {
              values2.push(mvalues[k]);
            }
          }
        }
      });
      ptr.push(index.length);
      return new SparseMatrix({
        values: values2,
        index,
        ptr,
        size,
        datatype: matrix._datatype
      });
    }
    function _setsubset(matrix, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index.size();
      var isScalar = index.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.toArray();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        if (iSize.length !== 1 && iSize.length !== 2) {
          throw new DimensionError(iSize.length, matrix._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        var x0 = index.min()[0];
        var y0 = index.min()[1];
        var m = sSize[0];
        var n = sSize[1];
        for (var x = 0; x < m; x++) {
          for (var y = 0; y < n; y++) {
            var v = submatrix[x][y];
            matrix.set([x + x0, y + y0], v, defaultValue);
          }
        }
      }
      return matrix;
    }
    SparseMatrix.prototype.get = function(index) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke get on a Pattern only matrix");
      }
      var i = index[0];
      var j = index[1];
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[1]);
      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i) {
        return this._values[k];
      }
      return 0;
    };
    SparseMatrix.prototype.set = function(index, v, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke set on a Pattern only matrix");
      }
      var i = index[0];
      var j = index[1];
      var rows = this._size[0];
      var columns = this._size[1];
      var eq = equalScalar;
      var zero = 0;
      if (isString(this._datatype)) {
        eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
        zero = typed.convert(0, this._datatype);
      }
      if (i > rows - 1 || j > columns - 1) {
        _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
        rows = this._size[0];
        columns = this._size[1];
      }
      validateIndex(i, rows);
      validateIndex(j, columns);
      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i) {
        if (!eq(v, zero)) {
          this._values[k] = v;
        } else {
          _remove(k, j, this._values, this._index, this._ptr);
        }
      } else {
        _insert(k, i, j, v, this._values, this._index, this._ptr);
      }
      return this;
    };
    function _getValueIndex(i, top, bottom, index) {
      if (bottom - top === 0) {
        return bottom;
      }
      for (var r = top; r < bottom; r++) {
        if (index[r] === i) {
          return r;
        }
      }
      return top;
    }
    function _remove(k, j, values2, index, ptr) {
      values2.splice(k, 1);
      index.splice(k, 1);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]--;
      }
    }
    function _insert(k, i, j, v, values2, index, ptr) {
      values2.splice(k, 0, v);
      index.splice(k, 0, i);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]++;
      }
    }
    SparseMatrix.prototype.resize = function(size, defaultValue, copy) {
      if (!isCollection(size)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      if (sizeArray.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      sizeArray.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
        }
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
    };
    function _resize2(matrix, rows, columns, defaultValue) {
      var value = defaultValue || 0;
      var eq = equalScalar;
      var zero = 0;
      if (isString(matrix._datatype)) {
        eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
        zero = typed.convert(0, matrix._datatype);
        value = typed.convert(value, matrix._datatype);
      }
      var ins = !eq(value, zero);
      var r = matrix._size[0];
      var c = matrix._size[1];
      var i, j, k;
      if (columns > c) {
        for (j = c; j < columns; j++) {
          matrix._ptr[j] = matrix._values.length;
          if (ins) {
            for (i = 0; i < r; i++) {
              matrix._values.push(value);
              matrix._index.push(i);
            }
          }
        }
        matrix._ptr[columns] = matrix._values.length;
      } else if (columns < c) {
        matrix._ptr.splice(columns + 1, c - columns);
        matrix._values.splice(matrix._ptr[columns], matrix._values.length);
        matrix._index.splice(matrix._ptr[columns], matrix._index.length);
      }
      c = columns;
      if (rows > r) {
        if (ins) {
          var n = 0;
          for (j = 0; j < c; j++) {
            matrix._ptr[j] = matrix._ptr[j] + n;
            k = matrix._ptr[j + 1] + n;
            var p = 0;
            for (i = r; i < rows; i++, p++) {
              matrix._values.splice(k + p, 0, value);
              matrix._index.splice(k + p, 0, i);
              n++;
            }
          }
          matrix._ptr[c] = matrix._values.length;
        }
      } else if (rows < r) {
        var d = 0;
        for (j = 0; j < c; j++) {
          matrix._ptr[j] = matrix._ptr[j] - d;
          var k0 = matrix._ptr[j];
          var k1 = matrix._ptr[j + 1] - d;
          for (k = k0; k < k1; k++) {
            i = matrix._index[k];
            if (i > rows - 1) {
              matrix._values.splice(k, 1);
              matrix._index.splice(k, 1);
              d++;
            }
          }
        }
        matrix._ptr[j] = matrix._values.length;
      }
      matrix._size[0] = rows;
      matrix._size[1] = columns;
      return matrix;
    }
    SparseMatrix.prototype.reshape = function(sizes, copy) {
      if (!isArray(sizes)) {
        throw new TypeError("Array expected");
      }
      if (sizes.length !== 2) {
        throw new Error("Sparse matrices can only be reshaped in two dimensions");
      }
      sizes.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
          throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
        }
      });
      var currentLength = this._size[0] * this._size[1];
      sizes = processSizesWildcard(sizes, currentLength);
      var newLength = sizes[0] * sizes[1];
      if (currentLength !== newLength) {
        throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
      }
      var m = copy ? this.clone() : this;
      if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
        return m;
      }
      var colIndex = [];
      for (var i = 0; i < m._ptr.length; i++) {
        for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
          colIndex.push(i);
        }
      }
      var values2 = m._values.slice();
      var rowIndex = m._index.slice();
      for (var _i = 0; _i < m._index.length; _i++) {
        var r1 = rowIndex[_i];
        var c1 = colIndex[_i];
        var flat = r1 * m._size[1] + c1;
        colIndex[_i] = flat % sizes[1];
        rowIndex[_i] = Math.floor(flat / sizes[1]);
      }
      m._values.length = 0;
      m._index.length = 0;
      m._ptr.length = sizes[1] + 1;
      m._size = sizes.slice();
      for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
        m._ptr[_i2] = 0;
      }
      for (var h = 0; h < values2.length; h++) {
        var _i3 = rowIndex[h];
        var _j = colIndex[h];
        var v = values2[h];
        var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
        _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
      }
      return m;
    };
    SparseMatrix.prototype.clone = function() {
      var m = new SparseMatrix({
        values: this._values ? clone(this._values) : void 0,
        index: clone(this._index),
        ptr: clone(this._ptr),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    SparseMatrix.prototype.size = function() {
      return this._size.slice(0);
    };
    SparseMatrix.prototype.map = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke map on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      var invoke = function invoke2(v, i, j) {
        return callback(v, [i, j], me);
      };
      return _map3(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
    };
    function _map3(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
      var values2 = [];
      var index = [];
      var ptr = [];
      var eq = equalScalar;
      var zero = 0;
      if (isString(matrix._datatype)) {
        eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
        zero = typed.convert(0, matrix._datatype);
      }
      var invoke = function invoke2(v, x, y) {
        v = callback(v, x, y);
        if (!eq(v, zero)) {
          values2.push(v);
          index.push(x);
        }
      };
      for (var j = minColumn; j <= maxColumn; j++) {
        ptr.push(values2.length);
        var k0 = matrix._ptr[j];
        var k1 = matrix._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i = matrix._index[k];
            if (i >= minRow && i <= maxRow) {
              invoke(matrix._values[k], i - minRow, j - minColumn);
            }
          }
        } else {
          var _values = {};
          for (var _k = k0; _k < k1; _k++) {
            var _i4 = matrix._index[_k];
            _values[_i4] = matrix._values[_k];
          }
          for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
            var value = _i5 in _values ? _values[_i5] : 0;
            invoke(value, _i5 - minRow, j - minColumn);
          }
        }
      }
      ptr.push(values2.length);
      return new SparseMatrix({
        values: values2,
        index,
        ptr,
        size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
      });
    }
    SparseMatrix.prototype.forEach = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke forEach on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i = this._index[k];
            callback(this._values[k], [i, j], me);
          }
        } else {
          var values2 = {};
          for (var _k2 = k0; _k2 < k1; _k2++) {
            var _i6 = this._index[_k2];
            values2[_i6] = this._values[_k2];
          }
          for (var _i7 = 0; _i7 < rows; _i7++) {
            var value = _i7 in values2 ? values2[_i7] : 0;
            callback(value, [_i7, j], me);
          }
        }
      }
    };
    SparseMatrix.prototype.toArray = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, true);
    };
    SparseMatrix.prototype.valueOf = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, false);
    };
    function _toArray(values2, index, ptr, size, copy) {
      var rows = size[0];
      var columns = size[1];
      var a = [];
      var i, j;
      for (i = 0; i < rows; i++) {
        a[i] = [];
        for (j = 0; j < columns; j++) {
          a[i][j] = 0;
        }
      }
      for (j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          i = index[k];
          a[i][j] = values2 ? copy ? clone(values2[k]) : values2[k] : 1;
        }
      }
      return a;
    }
    SparseMatrix.prototype.format = function(options) {
      var rows = this._size[0];
      var columns = this._size[1];
      var density = this.density();
      var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i = this._index[k];
          str += "\n    (" + format3(i, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
        }
      }
      return str;
    };
    SparseMatrix.prototype.toString = function() {
      return format3(this.toArray());
    };
    SparseMatrix.prototype.toJSON = function() {
      return {
        mathjs: "SparseMatrix",
        values: this._values,
        index: this._index,
        ptr: this._ptr,
        size: this._size,
        datatype: this._datatype
      };
    };
    SparseMatrix.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var values2 = [];
      var index = [];
      var ptr = [];
      ptr[0] = 0;
      for (var j = kSuper; j < columns && values2.length < n; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var x = k0; x < k1; x++) {
          var i = this._index[x];
          if (i === j - kSuper + kSub) {
            values2.push(this._values[x]);
            index[values2.length - 1] = i - kSub;
            break;
          }
        }
      }
      ptr.push(values2.length);
      return new SparseMatrix({
        values: values2,
        index,
        ptr,
        size: [n, 1]
      });
    };
    SparseMatrix.fromJSON = function(json) {
      return new SparseMatrix(json);
    };
    SparseMatrix.diagonal = function(size, value, k, defaultValue, datatype) {
      if (!isArray(size)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size = size.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var eq = equalScalar;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
        zero = typed.convert(0, datatype);
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size[0];
      var columns = size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i2) {
          return value[i2];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i2) {
          return value.get([i2]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      var values2 = [];
      var index = [];
      var ptr = [];
      for (var j = 0; j < columns; j++) {
        ptr.push(values2.length);
        var i = j - kSuper;
        if (i >= 0 && i < n) {
          var v = _value(i);
          if (!eq(v, zero)) {
            index.push(i + kSub);
            values2.push(v);
          }
        }
      }
      ptr.push(values2.length);
      return new SparseMatrix({
        values: values2,
        index,
        ptr,
        size: [rows, columns]
      });
    };
    SparseMatrix.prototype.swapRows = function(i, j) {
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]);
      SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
      return this;
    };
    SparseMatrix._forEachRow = function(j, values2, index, ptr, callback) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        callback(index[k], values2[k]);
      }
    };
    SparseMatrix._swapRows = function(x, y, columns, values2, index, ptr) {
      for (var j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        var kx = _getValueIndex(x, k0, k1, index);
        var ky = _getValueIndex(y, k0, k1, index);
        if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
          if (values2) {
            var v = values2[kx];
            values2[kx] = values2[ky];
            values2[ky] = v;
          }
          continue;
        }
        if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
          var vx = values2 ? values2[kx] : void 0;
          index.splice(ky, 0, y);
          if (values2) {
            values2.splice(ky, 0, vx);
          }
          index.splice(ky <= kx ? kx + 1 : kx, 1);
          if (values2) {
            values2.splice(ky <= kx ? kx + 1 : kx, 1);
          }
          continue;
        }
        if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
          var vy = values2 ? values2[ky] : void 0;
          index.splice(kx, 0, x);
          if (values2) {
            values2.splice(kx, 0, vy);
          }
          index.splice(kx <= ky ? ky + 1 : ky, 1);
          if (values2) {
            values2.splice(kx <= ky ? ky + 1 : ky, 1);
          }
        }
      }
    };
    return SparseMatrix;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/number.js
  var name19 = "number";
  var dependencies20 = ["typed"];
  function getNonDecimalNumberParts(input) {
    var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
    if (nonDecimalWithRadixMatch) {
      var radix = {
        "0b": 2,
        "0o": 8,
        "0x": 16
      }[nonDecimalWithRadixMatch[1]];
      var integerPart = nonDecimalWithRadixMatch[2];
      var fractionalPart = nonDecimalWithRadixMatch[3];
      return {
        input,
        radix,
        integerPart,
        fractionalPart
      };
    } else {
      return null;
    }
  }
  function makeNumberFromNonDecimalParts(parts) {
    var n = parseInt(parts.integerPart, parts.radix);
    var f = 0;
    for (var i = 0; i < parts.fractionalPart.length; i++) {
      var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
      f += digitValue / Math.pow(parts.radix, i + 1);
    }
    var result = n + f;
    if (isNaN(result)) {
      throw new SyntaxError('String "' + parts.input + '" is no valid number');
    }
    return result;
  }
  var createNumber = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
    var {
      typed
    } = _ref;
    var number = typed("number", {
      "": function _4() {
        return 0;
      },
      number: function number2(x) {
        return x;
      },
      string: function string(x) {
        if (x === "NaN")
          return NaN;
        var nonDecimalNumberParts = getNonDecimalNumberParts(x);
        if (nonDecimalNumberParts) {
          return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
        }
        var size = 0;
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          size = Number(wordSizeSuffixMatch[2]);
          x = wordSizeSuffixMatch[1];
        }
        var num = Number(x);
        if (isNaN(num)) {
          throw new SyntaxError('String "' + x + '" is no valid number');
        }
        if (wordSizeSuffixMatch) {
          if (num > 2 ** size - 1) {
            throw new SyntaxError('String "'.concat(x, '" is out of range'));
          }
          if (num >= 2 ** (size - 1)) {
            num = num - 2 ** size;
          }
        }
        return num;
      },
      BigNumber: function BigNumber(x) {
        return x.toNumber();
      },
      Fraction: function Fraction2(x) {
        return x.valueOf();
      },
      Unit: function Unit(x) {
        throw new Error("Second argument with valueless unit expected");
      },
      null: function _null(x) {
        return 0;
      },
      "Unit, string | Unit": function UnitStringUnit(unit, valuelessUnit) {
        return unit.toNumber(valuelessUnit);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
    number.fromJSON = function(json) {
      return parseFloat(json.value);
    };
    return number;
  });

  // node_modules/mathjs/lib/esm/type/string.js
  var name20 = "string";
  var dependencies21 = ["typed"];
  var createString = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name20, {
      "": function _4() {
        return "";
      },
      number: format,
      null: function _null(x) {
        return "null";
      },
      boolean: function boolean(x) {
        return x + "";
      },
      string: function string(x) {
        return x;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      },
      any: function any(x) {
        return String(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/boolean.js
  var name21 = "boolean";
  var dependencies22 = ["typed"];
  var createBoolean = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name21, {
      "": function _4() {
        return false;
      },
      boolean: function boolean(x) {
        return x;
      },
      number: function number(x) {
        return !!x;
      },
      null: function _null(x) {
        return false;
      },
      BigNumber: function BigNumber(x) {
        return !x.isZero();
      },
      string: function string(x) {
        var lcase = x.toLowerCase();
        if (lcase === "true") {
          return true;
        } else if (lcase === "false") {
          return false;
        }
        var num = Number(x);
        if (x !== "" && !isNaN(num)) {
          return !!num;
        }
        throw new Error('Cannot convert "' + x + '" to a boolean');
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
  var name22 = "bignumber";
  var dependencies23 = ["typed", "BigNumber"];
  var createBignumber = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
    var {
      typed,
      BigNumber
    } = _ref;
    return typed("bignumber", {
      "": function _4() {
        return new BigNumber(0);
      },
      number: function number(x) {
        return new BigNumber(x + "");
      },
      string: function string(x) {
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          var size = wordSizeSuffixMatch[2];
          var n = BigNumber(wordSizeSuffixMatch[1]);
          var twoPowSize = new BigNumber(2).pow(Number(size));
          if (n.gt(twoPowSize.sub(1))) {
            throw new SyntaxError('String "'.concat(x, '" is out of range'));
          }
          var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
          if (n.gte(twoPowSizeSubOne)) {
            return n.sub(twoPowSize);
          } else {
            return n;
          }
        }
        return new BigNumber(x);
      },
      BigNumber: function BigNumber2(x) {
        return x;
      },
      Fraction: function Fraction2(x) {
        return new BigNumber(x.n).div(x.d).times(x.s);
      },
      null: function _null(x) {
        return new BigNumber(0);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/complex/function/complex.js
  var name23 = "complex";
  var dependencies24 = ["typed", "Complex"];
  var createComplex = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
    var {
      typed,
      Complex: Complex2
    } = _ref;
    return typed("complex", {
      "": function _4() {
        return Complex2.ZERO;
      },
      number: function number(x) {
        return new Complex2(x, 0);
      },
      "number, number": function numberNumber2(re, im) {
        return new Complex2(re, im);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(re, im) {
        return new Complex2(re.toNumber(), im.toNumber());
      },
      Fraction: function Fraction2(x) {
        return new Complex2(x.valueOf(), 0);
      },
      Complex: function Complex3(x) {
        return x.clone();
      },
      string: function string(x) {
        return Complex2(x);
      },
      null: function _null(x) {
        return Complex2(0);
      },
      Object: function Object2(x) {
        if ("re" in x && "im" in x) {
          return new Complex2(x.re, x.im);
        }
        if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
          return new Complex2(x);
        }
        throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
  var name24 = "fraction";
  var dependencies25 = ["typed", "Fraction"];
  var createFraction = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
    var {
      typed,
      Fraction: Fraction2
    } = _ref;
    return typed("fraction", {
      number: function number(x) {
        if (!isFinite(x) || isNaN(x)) {
          throw new Error(x + " cannot be represented as a fraction");
        }
        return new Fraction2(x);
      },
      string: function string(x) {
        return new Fraction2(x);
      },
      "number, number": function numberNumber2(numerator, denominator) {
        return new Fraction2(numerator, denominator);
      },
      null: function _null(x) {
        return new Fraction2(0);
      },
      BigNumber: function BigNumber(x) {
        return new Fraction2(x.toString());
      },
      Fraction: function Fraction3(x) {
        return x;
      },
      Object: function Object2(x) {
        return new Fraction2(x);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
  var name25 = "matrix";
  var dependencies26 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
  var createMatrix = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
    var {
      typed,
      Matrix,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    return typed(name25, {
      "": function _4() {
        return _create([]);
      },
      string: function string(format4) {
        return _create([], format4);
      },
      "string, string": function stringString(format4, datatype) {
        return _create([], format4, datatype);
      },
      Array: function Array2(data) {
        return _create(data);
      },
      Matrix: function Matrix2(data) {
        return _create(data, data.storage());
      },
      "Array | Matrix, string": _create,
      "Array | Matrix, string, string": _create
    });
    function _create(data, format4, datatype) {
      if (format4 === "dense" || format4 === "default" || format4 === void 0) {
        return new DenseMatrix(data, datatype);
      }
      if (format4 === "sparse") {
        return new SparseMatrix(data, datatype);
      }
      throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
    }
  });

  // node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
  var name26 = "splitUnit";
  var dependencies27 = ["typed"];
  var createSplitUnit = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name26, {
      "Unit, Array": function UnitArray(unit, parts) {
        return unit.splitUnit(parts);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
  var name27 = "unaryMinus";
  var dependencies28 = ["typed"];
  var createUnaryMinus = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name27, {
      number: unaryMinusNumber,
      Complex: function Complex2(x) {
        return x.neg();
      },
      BigNumber: function BigNumber(x) {
        return x.neg();
      },
      Fraction: function Fraction2(x) {
        return x.neg();
      },
      Unit: function Unit(x) {
        var res = x.clone();
        res.value = this(x.value);
        return res;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
  var name28 = "unaryPlus";
  var dependencies29 = ["typed", "config", "BigNumber"];
  var createUnaryPlus = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
    var {
      typed,
      config,
      BigNumber
    } = _ref;
    return typed(name28, {
      number: unaryPlusNumber,
      Complex: function Complex2(x) {
        return x;
      },
      BigNumber: function BigNumber2(x) {
        return x;
      },
      Fraction: function Fraction2(x) {
        return x;
      },
      Unit: function Unit(x) {
        return x.clone();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      "boolean | string": function booleanString(x) {
        return config.number === "BigNumber" ? new BigNumber(+x) : +x;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/abs.js
  var name29 = "abs";
  var dependencies30 = ["typed"];
  var createAbs = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name29, {
      number: absNumber,
      Complex: function Complex2(x) {
        return x.abs();
      },
      BigNumber: function BigNumber(x) {
        return x.abs();
      },
      Fraction: function Fraction2(x) {
        return x.abs();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.abs();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/apply.js
  var name30 = "apply";
  var dependencies31 = ["typed", "isInteger"];
  var createApply = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
    var {
      typed,
      isInteger: isInteger2
    } = _ref;
    return typed(name30, {
      "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
        if (!isInteger2(dim)) {
          throw new TypeError("Integer number expected for dimension");
        }
        var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
        if (dim < 0 || dim >= size.length) {
          throw new IndexError(dim, size.length);
        }
        if (isMatrix(mat)) {
          return mat.create(_apply(mat.valueOf(), dim, callback));
        } else {
          return _apply(mat, dim, callback);
        }
      }
    });
  });
  function _apply(mat, dim, callback) {
    var i, ret, tran;
    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        return callback(mat);
      } else {
        tran = _switch2(mat);
        ret = [];
        for (i = 0; i < tran.length; i++) {
          ret[i] = _apply(tran[i], dim - 1, callback);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i = 0; i < mat.length; i++) {
        ret[i] = _apply(mat[i], dim - 1, callback);
      }
      return ret;
    }
  }
  function _switch2(mat) {
    var I = mat.length;
    var J = mat[0].length;
    var i, j;
    var ret = [];
    for (j = 0; j < J; j++) {
      var tmp = [];
      for (i = 0; i < I; i++) {
        tmp.push(mat[i][j]);
      }
      ret.push(tmp);
    }
    return ret;
  }

  // node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
  var name31 = "addScalar";
  var dependencies32 = ["typed"];
  var createAddScalar = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name31, {
      "number, number": addNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.add(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.plus(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.add(y);
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (x.value === null || x.value === void 0)
          throw new Error("Parameter x contains a unit with undefined value");
        if (y.value === null || y.value === void 0)
          throw new Error("Parameter y contains a unit with undefined value");
        if (!x.equalBase(y))
          throw new Error("Units do not match");
        var res = x.clone();
        res.value = this(res.value, y.value);
        res.fixPrefix = false;
        return res;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
  var name32 = "cbrt";
  var dependencies33 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
  var createCbrt = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
    var {
      config,
      typed,
      isNegative,
      unaryMinus,
      matrix,
      Complex: Complex2,
      BigNumber,
      Fraction: Fraction2
    } = _ref;
    return typed(name32, {
      number: cbrtNumber,
      Complex: _cbrtComplex,
      "Complex, boolean": _cbrtComplex,
      BigNumber: function BigNumber2(x) {
        return x.cbrt();
      },
      Unit: _cbrtUnit,
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
    function _cbrtComplex(x, allRoots) {
      var arg3 = x.arg() / 3;
      var abs = x.abs();
      var principal = new Complex2(cbrtNumber(abs), 0).mul(new Complex2(0, arg3).exp());
      if (allRoots) {
        var all2 = [principal, new Complex2(cbrtNumber(abs), 0).mul(new Complex2(0, arg3 + Math.PI * 2 / 3).exp()), new Complex2(cbrtNumber(abs), 0).mul(new Complex2(0, arg3 - Math.PI * 2 / 3).exp())];
        return config.matrix === "Array" ? all2 : matrix(all2);
      } else {
        return principal;
      }
    }
    function _cbrtUnit(x) {
      if (x.value && isComplex(x.value)) {
        var result = x.clone();
        result.value = 1;
        result = result.pow(1 / 3);
        result.value = _cbrtComplex(x.value);
        return result;
      } else {
        var negate = isNegative(x.value);
        if (negate) {
          x.value = unaryMinus(x.value);
        }
        var third;
        if (isBigNumber(x.value)) {
          third = new BigNumber(1).div(3);
        } else if (isFraction(x.value)) {
          third = new Fraction2(1, 3);
        } else {
          third = 1 / 3;
        }
        var _result = x.pow(third);
        if (negate) {
          _result.value = unaryMinus(_result.value);
        }
        return _result;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
  var import_decimal2 = __toModule(require_decimal());

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm11.js
  var name33 = "algorithm11";
  var dependencies34 = ["typed", "equalScalar"];
  var createAlgorithm11 = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function algorithm11(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        b = typed.convert(b, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var i = aindex[k];
          var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
          if (!eq(v, zero)) {
            cindex.push(i);
            cvalues.push(v);
          }
        }
      }
      cptr[columns] = cindex.length;
      return s.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm14.js
  var name34 = "algorithm14";
  var dependencies35 = ["typed"];
  var createAlgorithm14 = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
    var {
      typed
    } = _ref;
    return function algorithm14(a, b, callback, inverse) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed.convert(b, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: clone(asize),
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv, inverse) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i = 0; i < n; i++) {
          cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
        }
      }
      return cv;
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
  var name35 = "ceil";
  var dependencies36 = ["typed", "config", "round", "matrix", "equalScalar"];
  var createCeil = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
    var {
      typed,
      config,
      round,
      matrix,
      equalScalar
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed("ceil", {
      number: function number(x) {
        if (nearlyEqual(x, round(x), config.epsilon)) {
          return round(x);
        } else {
          return ceilNumber(x);
        }
      },
      "number, number": function numberNumber2(x, n) {
        if (nearlyEqual(x, round(x, n), config.epsilon)) {
          return round(x, n);
        } else {
          var [number, exponent] = "".concat(x, "e").split("e");
          var result = Math.ceil(Number("".concat(number, "e").concat(Number(exponent) + n)));
          [number, exponent] = "".concat(result, "e").split("e");
          return Number("".concat(number, "e").concat(Number(exponent) - n));
        }
      },
      Complex: function Complex2(x) {
        return x.ceil();
      },
      "Complex, number": function ComplexNumber(x, n) {
        return x.ceil(n);
      },
      BigNumber: function BigNumber(x) {
        if (nearlyEqual2(x, round(x), config.epsilon)) {
          return round(x);
        } else {
          return x.ceil();
        }
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (nearlyEqual2(x, round(x, n), config.epsilon)) {
          return round(x, n);
        } else {
          return x.toDecimalPlaces(n.toNumber(), import_decimal2.default.ROUND_CEIL);
        }
      },
      Fraction: function Fraction2(x) {
        return x.ceil();
      },
      "Fraction, number": function FractionNumber(x, n) {
        return x.ceil(n);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      "Array | Matrix, number": function ArrayMatrixNumber(x, n) {
        return deepMap(x, (i) => this(i, n), true);
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      "number | Complex | BigNumber, Array": function numberComplexBigNumberArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/cube.js
  var name36 = "cube";
  var dependencies37 = ["typed"];
  var createCube = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name36, {
      number: cubeNumber,
      Complex: function Complex2(x) {
        return x.mul(x).mul(x);
      },
      BigNumber: function BigNumber(x) {
        return x.times(x).times(x);
      },
      Fraction: function Fraction2(x) {
        return x.pow(3);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.pow(3);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/exp.js
  var name37 = "exp";
  var dependencies38 = ["typed"];
  var createExp = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name37, {
      number: expNumber,
      Complex: function Complex2(x) {
        return x.exp();
      },
      BigNumber: function BigNumber(x) {
        return x.exp();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
  var name38 = "expm1";
  var dependencies39 = ["typed", "Complex"];
  var createExpm1 = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
    var {
      typed,
      Complex: _Complex
    } = _ref;
    return typed(name38, {
      number: expm1Number,
      Complex: function Complex2(x) {
        var r = Math.exp(x.re);
        return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
      },
      BigNumber: function BigNumber(x) {
        return x.exp().minus(1);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/fix.js
  var name39 = "fix";
  var dependencies40 = ["typed", "Complex", "matrix", "ceil", "floor"];
  var createFix = /* @__PURE__ */ factory(name39, dependencies40, (_ref) => {
    var {
      typed,
      Complex: _Complex,
      matrix,
      ceil,
      floor
    } = _ref;
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed("fix", {
      number: function number(x) {
        return x > 0 ? floor(x) : ceil(x);
      },
      "number, number | BigNumber": function numberNumberBigNumber(x, n) {
        return x > 0 ? floor(x, n) : ceil(x, n);
      },
      Complex: function Complex2(x) {
        return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
      },
      "Complex, number | BigNumber": function ComplexNumberBigNumber(x, n) {
        return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));
      },
      BigNumber: function BigNumber(x) {
        return x.isNegative() ? ceil(x) : floor(x);
      },
      "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
        return x.isNegative() ? ceil(x, n) : floor(x, n);
      },
      Fraction: function Fraction2(x) {
        return x.s < 0 ? x.ceil() : x.floor();
      },
      "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
        return x.s < 0 ? x.ceil(n) : x.floor(n);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(x, n) {
        return deepMap(x, (i) => this(i, n), true);
      },
      "number | Complex | BigNumber, Array": function numberComplexBigNumberArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/floor.js
  var import_decimal3 = __toModule(require_decimal());
  var name40 = "floor";
  var dependencies41 = ["typed", "config", "round", "matrix", "equalScalar"];
  var createFloor = /* @__PURE__ */ factory(name40, dependencies41, (_ref) => {
    var {
      typed,
      config,
      round,
      matrix,
      equalScalar
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed("floor", {
      number: function number(x) {
        if (nearlyEqual(x, round(x), config.epsilon)) {
          return round(x);
        } else {
          return Math.floor(x);
        }
      },
      "number, number": function numberNumber2(x, n) {
        if (nearlyEqual(x, round(x, n), config.epsilon)) {
          return round(x, n);
        } else {
          var [number, exponent] = "".concat(x, "e").split("e");
          var result = Math.floor(Number("".concat(number, "e").concat(Number(exponent) + n)));
          [number, exponent] = "".concat(result, "e").split("e");
          return Number("".concat(number, "e").concat(Number(exponent) - n));
        }
      },
      Complex: function Complex2(x) {
        return x.floor();
      },
      "Complex, number": function ComplexNumber(x, n) {
        return x.floor(n);
      },
      BigNumber: function BigNumber(x) {
        if (nearlyEqual2(x, round(x), config.epsilon)) {
          return round(x);
        } else {
          return x.floor();
        }
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (nearlyEqual2(x, round(x, n), config.epsilon)) {
          return round(x, n);
        } else {
          return x.toDecimalPlaces(n.toNumber(), import_decimal3.default.ROUND_FLOOR);
        }
      },
      Fraction: function Fraction2(x) {
        return x.floor();
      },
      "Fraction, number": function FractionNumber(x, n) {
        return x.floor(n);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      "Array | Matrix, number": function ArrayMatrixNumber(x, n) {
        return deepMap(x, (i) => this(i, n), true);
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      "number | Complex | BigNumber, Array": function numberComplexBigNumberArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm01.js
  var name41 = "algorithm01";
  var dependencies42 = ["typed"];
  var createAlgorithm01 = /* @__PURE__ */ factory(name41, dependencies42, (_ref) => {
    var {
      typed
    } = _ref;
    return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
      var cf = dt ? typed.find(callback, [dt, dt]) : callback;
      var i, j;
      var cdata = [];
      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      }
      var x = [];
      var w = [];
      for (j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        }
        for (i = 0; i < rows; i++) {
          if (w[i] === mark) {
            cdata[i][j] = x[i];
          } else {
            cdata[i][j] = adata[i][j];
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm04.js
  var name42 = "algorithm04";
  var dependencies43 = ["typed", "equalScalar"];
  var createAlgorithm04 = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function algorithm04(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var xa = avalues && bvalues ? [] : void 0;
      var xb = avalues && bvalues ? [] : void 0;
      var wa = [];
      var wb = [];
      var i, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          cindex.push(i);
          wa[i] = mark;
          if (xa) {
            xa[i] = avalues[k];
          }
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          if (wa[i] === mark) {
            if (xa) {
              var v = cf(xa[i], bvalues[k]);
              if (!eq(v, zero)) {
                xa[i] = v;
              } else {
                wa[i] = null;
              }
            }
          } else {
            cindex.push(i);
            wb[i] = mark;
            if (xb) {
              xb[i] = bvalues[k];
            }
          }
        }
        if (xa && xb) {
          k = cptr[j];
          while (k < cindex.length) {
            i = cindex[k];
            if (wa[i] === mark) {
              cvalues[k] = xa[i];
              k++;
            } else if (wb[i] === mark) {
              cvalues[k] = xb[i];
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm10.js
  var name43 = "algorithm10";
  var dependencies44 = ["typed", "DenseMatrix"];
  var createAlgorithm10 = /* @__PURE__ */ factory(name43, dependencies44, (_ref) => {
    var {
      typed,
      DenseMatrix
    } = _ref;
    return function algorithm10(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed.convert(b, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = [];
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var r = aindex[k];
          x[r] = avalues[k];
          w[r] = mark;
        }
        for (var i = 0; i < rows; i++) {
          if (j === 0) {
            cdata[i] = [];
          }
          if (w[i] === mark) {
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            cdata[i][j] = b;
          }
        }
      }
      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm13.js
  var name44 = "algorithm13";
  var dependencies45 = ["typed"];
  var createAlgorithm13 = /* @__PURE__ */ factory(name44, dependencies45, (_ref) => {
    var {
      typed
    } = _ref;
    return function algorithm13(a, b, callback) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var csize = [];
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      for (var s = 0; s < asize.length; s++) {
        if (asize[s] !== bsize[s]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        csize[s] = asize[s];
      }
      var dt;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: csize,
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i = 0; i < n; i++) {
          cv[i] = f(av[i], bv[i]);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
        }
      }
      return cv;
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
  var name45 = "gcd";
  var dependencies46 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
  var createGcd = /* @__PURE__ */ factory(name45, dependencies46, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      BigNumber,
      DenseMatrix
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm04 = createAlgorithm04({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name45, {
      "number, number": gcdNumber,
      "BigNumber, BigNumber": _gcdBigNumber,
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.gcd(y);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm04(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm01(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        return algorithm10(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
        return algorithm10(y, x, this, true);
      },
      "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "number | BigNumber, Array": function numberBigNumberArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      },
      "Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumberArrayMatrixNumberBigNumberArrayMatrixNumberBigNumber(a, b, args) {
        var res = this(a, b);
        for (var i = 0; i < args.length; i++) {
          res = this(res, args[i]);
        }
        return res;
      }
    });
    function _gcdBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function gcd must be integer numbers");
      }
      var zero = new BigNumber(0);
      while (!b.isZero()) {
        var r = a.mod(b);
        a = b;
        b = r;
      }
      return a.lt(zero) ? a.neg() : a;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm02.js
  var name46 = "algorithm02";
  var dependencies47 = ["typed", "equalScalar"];
  var createAlgorithm02 = /* @__PURE__ */ factory(name46, dependencies47, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function algorithm02(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          var i = bindex[k];
          var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          if (!eq(cij, zero)) {
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
      cptr[columns] = cindex.length;
      return sparseMatrix.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm06.js
  var name47 = "algorithm06";
  var dependencies48 = ["typed", "equalScalar"];
  var createAlgorithm06 = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function algorithm06(a, b, callback) {
      var avalues = a._values;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var x = cvalues ? [] : void 0;
      var w = [];
      var u = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        scatter(a, j, w, x, u, mark, cindex, cf);
        scatter(b, j, w, x, u, mark, cindex, cf);
        if (x) {
          var k = cptr[j];
          while (k < cindex.length) {
            var i = cindex[k];
            if (u[i] === mark) {
              var v = x[i];
              if (!eq(v, zero)) {
                cvalues.push(v);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            } else {
              cindex.splice(k, 1);
            }
          }
        } else {
          var p = cptr[j];
          while (p < cindex.length) {
            var r = cindex[p];
            if (u[r] !== mark) {
              cindex.splice(p, 1);
            } else {
              p++;
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
  var name48 = "lcm";
  var dependencies49 = ["typed", "matrix", "equalScalar"];
  var createLcm = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar
    } = _ref;
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm06 = createAlgorithm06({
      typed,
      equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name48, {
      "number, number": lcmNumber,
      "BigNumber, BigNumber": _lcmBigNumber,
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.lcm(y);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm06(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm02(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
        return algorithm11(y, x, this, true);
      },
      "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "number | BigNumber, Array": function numberBigNumberArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      },
      "Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumberArrayMatrixNumberBigNumberArrayMatrixNumberBigNumber(a, b, args) {
        var res = this(a, b);
        for (var i = 0; i < args.length; i++) {
          res = this(res, args[i]);
        }
        return res;
      }
    });
    function _lcmBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function lcm must be integer numbers");
      }
      if (a.isZero()) {
        return a;
      }
      if (b.isZero()) {
        return b;
      }
      var prod = a.times(b);
      while (!b.isZero()) {
        var t = b;
        b = a.mod(t);
        a = t;
      }
      return prod.div(a).abs();
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log10.js
  var name49 = "log10";
  var dependencies50 = ["typed", "config", "Complex"];
  var createLog10 = /* @__PURE__ */ factory(name49, dependencies50, (_ref) => {
    var {
      typed,
      config,
      Complex: _Complex
    } = _ref;
    return typed(name49, {
      number: function number(x) {
        if (x >= 0 || config.predictable) {
          return log10Number(x);
        } else {
          return new _Complex(x, 0).log().div(Math.LN10);
        }
      },
      Complex: function Complex2(x) {
        return new _Complex(x).log().div(Math.LN10);
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.log();
        } else {
          return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
        }
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log2.js
  var name50 = "log2";
  var dependencies51 = ["typed", "config", "Complex"];
  var createLog2 = /* @__PURE__ */ factory(name50, dependencies51, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2
    } = _ref;
    return typed(name50, {
      number: function number(x) {
        if (x >= 0 || config.predictable) {
          return log2Number(x);
        } else {
          return _log2Complex(new Complex2(x, 0));
        }
      },
      Complex: _log2Complex,
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.log(2);
        } else {
          return _log2Complex(new Complex2(x.toNumber(), 0));
        }
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
    function _log2Complex(x) {
      var newX = Math.sqrt(x.re * x.re + x.im * x.im);
      return new Complex2(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm03.js
  var name51 = "algorithm03";
  var dependencies52 = ["typed"];
  var createAlgorithm03 = /* @__PURE__ */ factory(name51, dependencies52, (_ref) => {
    var {
      typed
    } = _ref;
    return function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = [];
      for (var z = 0; z < rows; z++) {
        cdata[z] = [];
      }
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          var i = bindex[k];
          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        }
        for (var y = 0; y < rows; y++) {
          if (w[y] === mark) {
            cdata[y][j] = x[y];
          } else {
            cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm05.js
  var name52 = "algorithm05";
  var dependencies53 = ["typed", "equalScalar"];
  var createAlgorithm05 = /* @__PURE__ */ factory(name52, dependencies53, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function algorithm05(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var xa = cvalues ? [] : void 0;
      var xb = cvalues ? [] : void 0;
      var wa = [];
      var wb = [];
      var i, j, k, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
          i = aindex[k];
          cindex.push(i);
          wa[i] = mark;
          if (xa) {
            xa[i] = avalues[k];
          }
        }
        for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
          i = bindex[k];
          if (wa[i] !== mark) {
            cindex.push(i);
          }
          wb[i] = mark;
          if (xb) {
            xb[i] = bvalues[k];
          }
        }
        if (cvalues) {
          k = cptr[j];
          while (k < cindex.length) {
            i = cindex[k];
            var wai = wa[i];
            var wbi = wb[i];
            if (wai === mark || wbi === mark) {
              var va = wai === mark ? xa[i] : zero;
              var vb = wbi === mark ? xb[i] : zero;
              var vc = cf(va, vb);
              if (!eq(vc, zero)) {
                cvalues.push(vc);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm12.js
  var name53 = "algorithm12";
  var dependencies54 = ["typed", "DenseMatrix"];
  var createAlgorithm12 = /* @__PURE__ */ factory(name53, dependencies54, (_ref) => {
    var {
      typed,
      DenseMatrix
    } = _ref;
    return function algorithm12(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed.convert(b, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = [];
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var r = aindex[k];
          x[r] = avalues[k];
          w[r] = mark;
        }
        for (var i = 0; i < rows; i++) {
          if (j === 0) {
            cdata[i] = [];
          }
          if (w[i] === mark) {
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
          }
        }
      }
      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/mod.js
  var name54 = "mod";
  var dependencies55 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createMod = /* @__PURE__ */ factory(name54, dependencies55, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm05 = createAlgorithm05({
      typed,
      equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name54, {
      "number, number": modNumber,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        if (y.isNeg()) {
          throw new Error("Cannot calculate mod for a negative divisor");
        }
        return y.isZero() ? x : x.mod(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        if (y.compare(0) < 0) {
          throw new Error("Cannot calculate mod for a negative divisor");
        }
        return x.compare(0) >= 0 ? x.mod(y) : x.mod(y).add(y).mod(y);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm05(x, y, this, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
  var name55 = "multiplyScalar";
  var dependencies56 = ["typed"];
  var createMultiplyScalar = /* @__PURE__ */ factory(name55, dependencies56, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("multiplyScalar", {
      "number, number": multiplyNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.mul(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.times(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.mul(y);
      },
      "number | Fraction | BigNumber | Complex, Unit": function numberFractionBigNumberComplexUnit(x, y) {
        var res = y.clone();
        res.value = res.value === null ? res._normalize(x) : this(res.value, x);
        return res;
      },
      "Unit, number | Fraction | BigNumber | Complex": function UnitNumberFractionBigNumberComplex(x, y) {
        var res = x.clone();
        res.value = res.value === null ? res._normalize(y) : this(res.value, y);
        return res;
      },
      "Unit, Unit": function UnitUnit(x, y) {
        return x.multiply(y);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
  var name56 = "multiply";
  var dependencies57 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
  var createMultiply = /* @__PURE__ */ factory(name56, dependencies57, (_ref) => {
    var {
      typed,
      matrix,
      addScalar,
      multiplyScalar,
      equalScalar,
      dot
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    function _validateMatrixDimensions(size1, size2) {
      switch (size1.length) {
        case 1:
          switch (size2.length) {
            case 1:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
              }
              break;
            case 2:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        case 2:
          switch (size2.length) {
            case 1:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
              }
              break;
            case 2:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        default:
          throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
      }
    }
    function _multiplyVectorVector(a, b, n) {
      if (n === 0) {
        throw new Error("Cannot multiply two empty vectors");
      }
      return dot(a, b);
    }
    function _multiplyVectorMatrix(a, b) {
      if (b.storage() !== "dense") {
        throw new Error("Support for SparseMatrix not implemented");
      }
      return _multiplyVectorDenseMatrix(a, b);
    }
    function _multiplyVectorDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var alength = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      }
      var c = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum = mf(adata[0], bdata[0][j]);
        for (var i = 1; i < alength; i++) {
          sum = af(sum, mf(adata[i], bdata[i][j]));
        }
        c[j] = sum;
      }
      return a.createDenseMatrix({
        data: c,
        size: [bcolumns],
        datatype: dt
      });
    }
    var _multiplyMatrixVector = typed("_multiplyMatrixVector", {
      "DenseMatrix, any": _multiplyDenseMatrixVector,
      "SparseMatrix, any": _multiplySparseMatrixVector
    });
    var _multiplyMatrixMatrix = typed("_multiplyMatrixMatrix", {
      "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
      "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
      "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
      "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
    });
    function _multiplyDenseMatrixVector(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = asize[0];
      var acolumns = asize[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      }
      var c = [];
      for (var i = 0; i < arows; i++) {
        var row = adata[i];
        var sum = mf(row[0], bdata[0]);
        for (var j = 1; j < acolumns; j++) {
          sum = af(sum, mf(row[j], bdata[j]));
        }
        c[i] = sum;
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows],
        datatype: dt
      });
    }
    function _multiplyDenseMatrixDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var arows = asize[0];
      var acolumns = asize[1];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      }
      var c = [];
      for (var i = 0; i < arows; i++) {
        var row = adata[i];
        c[i] = [];
        for (var j = 0; j < bcolumns; j++) {
          var sum = mf(row[0], bdata[0][j]);
          for (var x = 1; x < acolumns; x++) {
            sum = af(sum, mf(row[x], bdata[x][j]));
          }
          c[i][j] = sum;
        }
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows, bcolumns],
        datatype: dt
      });
    }
    function _multiplyDenseMatrixSparseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (!bvalues) {
        throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
      }
      var arows = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      var eq = equalScalar;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = b.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var kb0 = bptr[jb];
        var kb1 = bptr[jb + 1];
        if (kb1 > kb0) {
          var last = 0;
          for (var i = 0; i < arows; i++) {
            var mark = i + 1;
            var cij = void 0;
            for (var kb = kb0; kb < kb1; kb++) {
              var ib = bindex[kb];
              if (last !== mark) {
                cij = mf(adata[i][ib], bvalues[kb]);
                last = mark;
              } else {
                cij = af(cij, mf(adata[i][ib], bvalues[kb]));
              }
            }
            if (last === mark && !eq(cij, zero)) {
              cindex.push(i);
              cvalues.push(cij);
            }
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixVector(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = a._size[0];
      var brows = b._size[0];
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      var eq = equalScalar;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
      }
      var x = [];
      var w = [];
      cptr[0] = 0;
      for (var ib = 0; ib < brows; ib++) {
        var vbi = bdata[ib];
        if (!eq(vbi, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (!w[ia]) {
              w[ia] = true;
              cindex.push(ia);
              x[ia] = mf(vbi, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbi, avalues[ka]));
            }
          }
        }
      }
      for (var p1 = cindex.length, p = 0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
      cptr[1] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, 1],
        datatype: dt
      });
    }
    function _multiplySparseMatrixDenseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = a._size[0];
      var brows = b._size[0];
      var bcolumns = b._size[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      var eq = equalScalar;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      var x = [];
      var w = [];
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (var ib = 0; ib < brows; ib++) {
          var vbij = bdata[ib][jb];
          if (!eq(vbij, zero)) {
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              var ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(vbij, avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(vbij, avalues[ka]));
              }
            }
          }
        }
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixSparseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bdt = b._datatype;
      var arows = a._size[0];
      var bcolumns = b._size[1];
      var values2 = avalues && bvalues;
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      }
      var cvalues = values2 ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      var x = values2 ? [] : void 0;
      var w = [];
      var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
          ib = bindex[kb];
          if (values2) {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(bvalues[kb], avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
              }
            }
          } else {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
              }
            }
          }
        }
        if (values2) {
          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            var ic = cindex[p];
            cvalues[p] = x[ic];
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    return typed(name56, extend({
      "Array, Array": function ArrayArray(x, y) {
        _validateMatrixDimensions(arraySize(x), arraySize(y));
        var m = this(matrix(x), matrix(y));
        return isMatrix(m) ? m.valueOf() : m;
      },
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        var xsize = x.size();
        var ysize = y.size();
        _validateMatrixDimensions(xsize, ysize);
        if (xsize.length === 1) {
          if (ysize.length === 1) {
            return _multiplyVectorVector(x, y, xsize[0]);
          }
          return _multiplyVectorMatrix(x, y);
        }
        if (ysize.length === 1) {
          return _multiplyMatrixVector(x, y);
        }
        return _multiplyMatrixMatrix(x, y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x, y.storage()), y);
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, multiplyScalar, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, multiplyScalar, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm11(y, x, multiplyScalar, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, multiplyScalar, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
      },
      "any, any": multiplyScalar,
      "any, any, ...any": function anyAnyAny(x, y, rest) {
        var result = this(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = this(result, rest[i]);
        }
        return result;
      }
    }, multiplyScalar.signatures));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
  var name57 = "nthRoot";
  var dependencies58 = ["typed", "matrix", "equalScalar", "BigNumber"];
  var createNthRoot = /* @__PURE__ */ factory(name57, dependencies58, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      BigNumber: _BigNumber
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm06 = createAlgorithm06({
      typed,
      equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    var complexErr = "Complex number not supported in function nthRoot. Use nthRoots instead.";
    return typed(name57, {
      number: function number(x) {
        return nthRootNumber(x, 2);
      },
      "number, number": nthRootNumber,
      BigNumber: function BigNumber(x) {
        return _bigNthRoot(x, new _BigNumber(2));
      },
      Complex: function Complex2(x) {
        throw new Error(complexErr);
      },
      "Complex, number": function ComplexNumber(x, y) {
        throw new Error(complexErr);
      },
      "BigNumber, BigNumber": _bigNthRoot,
      "Array | Matrix": function ArrayMatrix(x) {
        return this(x, 2);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        if (y.density() === 1) {
          return algorithm06(x, y, this);
        } else {
          throw new Error("Root must be non-zero");
        }
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        if (y.density() === 1) {
          return algorithm01(x, y, this, false);
        } else {
          throw new Error("Root must be non-zero");
        }
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
        if (y.density() === 1) {
          return algorithm11(y, x, this, true);
        } else {
          throw new Error("Root must be non-zero");
        }
      },
      "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
        return this(matrix(x), y).valueOf();
      },
      "number | BigNumber, Array": function numberBigNumberArray(x, y) {
        return this(x, matrix(y)).valueOf();
      }
    });
    function _bigNthRoot(a, root) {
      var precision = _BigNumber.precision;
      var Big = _BigNumber.clone({
        precision: precision + 2
      });
      var zero = new _BigNumber(0);
      var one = new Big(1);
      var inv = root.isNegative();
      if (inv) {
        root = root.neg();
      }
      if (root.isZero()) {
        throw new Error("Root must be non-zero");
      }
      if (a.isNegative() && !root.abs().mod(2).equals(1)) {
        throw new Error("Root must be odd when a is negative.");
      }
      if (a.isZero()) {
        return inv ? new Big(Infinity) : 0;
      }
      if (!a.isFinite()) {
        return inv ? zero : a;
      }
      var x = a.abs().pow(one.div(root));
      x = a.isNeg() ? x.neg() : x;
      return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/sign.js
  var name58 = "sign";
  var dependencies59 = ["typed", "BigNumber", "Fraction", "complex"];
  var createSign = /* @__PURE__ */ factory(name58, dependencies59, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber,
      complex,
      Fraction: _Fraction
    } = _ref;
    return typed(name58, {
      number: signNumber,
      Complex: function Complex2(x) {
        return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(x.cmp(0));
      },
      Fraction: function Fraction2(x) {
        return new _Fraction(x.s, 1);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return this(x.value);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
  var name59 = "sqrt";
  var dependencies60 = ["config", "typed", "Complex"];
  var createSqrt = /* @__PURE__ */ factory(name59, dependencies60, (_ref) => {
    var {
      config,
      typed,
      Complex: Complex2
    } = _ref;
    return typed("sqrt", {
      number: _sqrtNumber,
      Complex: function Complex3(x) {
        return x.sqrt();
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.sqrt();
        } else {
          return _sqrtNumber(x.toNumber());
        }
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.pow(0.5);
      }
    });
    function _sqrtNumber(x) {
      if (isNaN(x)) {
        return NaN;
      } else if (x >= 0 || config.predictable) {
        return Math.sqrt(x);
      } else {
        return new Complex2(x, 0).sqrt();
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/square.js
  var name60 = "square";
  var dependencies61 = ["typed"];
  var createSquare = /* @__PURE__ */ factory(name60, dependencies61, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name60, {
      number: squareNumber,
      Complex: function Complex2(x) {
        return x.mul(x);
      },
      BigNumber: function BigNumber(x) {
        return x.times(x);
      },
      Fraction: function Fraction2(x) {
        return x.mul(x);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.pow(2);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
  var name61 = "subtract";
  var dependencies62 = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix"];
  var createSubtract = /* @__PURE__ */ factory(name61, dependencies62, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      addScalar,
      unaryMinus,
      DenseMatrix
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm05 = createAlgorithm05({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name61, {
      "number, number": function numberNumber2(x, y) {
        return x - y;
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.sub(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.minus(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.sub(y);
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (x.value === null) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y.value === null) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y)) {
          throw new Error("Units do not match");
        }
        var res = x.clone();
        res.value = this(res.value, y.value);
        res.fixPrefix = false;
        return res;
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm05(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm01(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm10(x, unaryMinus(y), addScalar);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm10(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });
  function checkEqualDimensions(x, y) {
    var xsize = x.size();
    var ysize = y.size();
    if (xsize.length !== ysize.length) {
      throw new DimensionError(xsize.length, ysize.length);
    }
  }

  // node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
  var name62 = "xgcd";
  var dependencies63 = ["typed", "config", "matrix", "BigNumber"];
  var createXgcd = /* @__PURE__ */ factory(name62, dependencies63, (_ref) => {
    var {
      typed,
      config,
      matrix,
      BigNumber
    } = _ref;
    return typed(name62, {
      "number, number": function numberNumber2(a, b) {
        var res = xgcdNumber(a, b);
        return config.matrix === "Array" ? res : matrix(res);
      },
      "BigNumber, BigNumber": _xgcdBigNumber
    });
    function _xgcdBigNumber(a, b) {
      var t;
      var q;
      var r;
      var zero = new BigNumber(0);
      var one = new BigNumber(1);
      var x = zero;
      var lastx = one;
      var y = one;
      var lasty = zero;
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function xgcd must be integer numbers");
      }
      while (!b.isZero()) {
        q = a.div(b).floor();
        r = a.mod(b);
        t = x;
        x = lastx.minus(q.times(x));
        lastx = t;
        t = y;
        y = lasty.minus(q.times(y));
        lasty = t;
        a = b;
        b = r;
      }
      var res;
      if (a.lt(zero)) {
        res = [a.neg(), lastx.neg(), lasty.neg()];
      } else {
        res = [a, !a.isZero() ? lastx : 0, lasty];
      }
      return config.matrix === "Array" ? res : matrix(res);
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm09.js
  var name63 = "algorithm09";
  var dependencies64 = ["typed", "equalScalar"];
  var createAlgorithm09 = /* @__PURE__ */ factory(name63, dependencies64, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function algorithm09(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var x = cvalues ? [] : void 0;
      var w = [];
      var i, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        if (x) {
          for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            i = bindex[k];
            w[i] = mark;
            x[i] = bvalues[k];
          }
        }
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          if (x) {
            var vb = w[i] === mark ? x[i] : zero;
            var vc = cf(avalues[k], vb);
            if (!eq(vc, zero)) {
              cindex.push(i);
              cvalues.push(vc);
            }
          } else {
            cindex.push(i);
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
  var name64 = "dotMultiply";
  var dependencies65 = ["typed", "matrix", "equalScalar", "multiplyScalar"];
  var createDotMultiply = /* @__PURE__ */ factory(name64, dependencies65, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      multiplyScalar
    } = _ref;
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm09 = createAlgorithm09({
      typed,
      equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name64, {
      "any, any": multiplyScalar,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm09(x, y, multiplyScalar, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, multiplyScalar, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm02(x, y, multiplyScalar, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, multiplyScalar);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, multiplyScalar, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, multiplyScalar, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm11(y, x, multiplyScalar, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, multiplyScalar, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
  function bitAndBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function bitAnd");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }
    if (x.isZero() || y.eq(-1) || x.eq(y)) {
      return x;
    }
    if (y.isZero() || x.eq(-1)) {
      return y;
    }
    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !y.isFinite()) {
        if (x.isNegative() === y.isNegative()) {
          return x;
        }
        return new BigNumber(0);
      }
      if (!x.isFinite()) {
        if (y.isNegative()) {
          return x;
        }
        if (x.isNegative()) {
          return new BigNumber(0);
        }
        return y;
      }
      if (!y.isFinite()) {
        if (x.isNegative()) {
          return y;
        }
        if (y.isNegative()) {
          return new BigNumber(0);
        }
        return x;
      }
    }
    return bitwise(x, y, function(a, b) {
      return a & b;
    });
  }
  function bitNotBigNumber(x) {
    if (x.isFinite() && !x.isInteger()) {
      throw new Error("Integer expected in function bitNot");
    }
    var BigNumber = x.constructor;
    var prevPrec = BigNumber.precision;
    BigNumber.config({
      precision: 1e9
    });
    var result = x.plus(new BigNumber(1));
    result.s = -result.s || null;
    BigNumber.config({
      precision: prevPrec
    });
    return result;
  }
  function bitOrBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function bitOr");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }
    var negOne = new BigNumber(-1);
    if (x.isZero() || y.eq(negOne) || x.eq(y)) {
      return y;
    }
    if (y.isZero() || x.eq(negOne)) {
      return x;
    }
    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
        return negOne;
      }
      if (x.isNegative() && y.isNegative()) {
        return x.isFinite() ? x : y;
      }
      return x.isFinite() ? y : x;
    }
    return bitwise(x, y, function(a, b) {
      return a | b;
    });
  }
  function bitwise(x, y, func) {
    var BigNumber = x.constructor;
    var xBits, yBits;
    var xSign = +(x.s < 0);
    var ySign = +(y.s < 0);
    if (xSign) {
      xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
      for (var i = 0; i < xBits.length; ++i) {
        xBits[i] ^= 1;
      }
    } else {
      xBits = decCoefficientToBinaryString(x);
    }
    if (ySign) {
      yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
      for (var _i = 0; _i < yBits.length; ++_i) {
        yBits[_i] ^= 1;
      }
    } else {
      yBits = decCoefficientToBinaryString(y);
    }
    var minBits, maxBits, minSign;
    if (xBits.length <= yBits.length) {
      minBits = xBits;
      maxBits = yBits;
      minSign = xSign;
    } else {
      minBits = yBits;
      maxBits = xBits;
      minSign = ySign;
    }
    var shortLen = minBits.length;
    var longLen = maxBits.length;
    var expFuncVal = func(xSign, ySign) ^ 1;
    var outVal = new BigNumber(expFuncVal ^ 1);
    var twoPower = new BigNumber(1);
    var two = new BigNumber(2);
    var prevPrec = BigNumber.precision;
    BigNumber.config({
      precision: 1e9
    });
    while (shortLen > 0) {
      if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }
      twoPower = twoPower.times(two);
    }
    while (longLen > 0) {
      if (func(minSign, maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }
      twoPower = twoPower.times(two);
    }
    BigNumber.config({
      precision: prevPrec
    });
    if (expFuncVal === 0) {
      outVal.s = -outVal.s;
    }
    return outVal;
  }
  function decCoefficientToBinaryString(x) {
    var a = x.d;
    var r = a[0] + "";
    for (var i = 1; i < a.length; ++i) {
      var s = a[i] + "";
      for (var z = 7 - s.length; z--; ) {
        s = "0" + s;
      }
      r += s;
    }
    var j = r.length;
    while (r.charAt(j) === "0") {
      j--;
    }
    var xe = x.e;
    var str = r.slice(0, j + 1 || 1);
    var strL = str.length;
    if (xe > 0) {
      if (++xe > strL) {
        xe -= strL;
        while (xe--) {
          str += "0";
        }
      } else if (xe < strL) {
        str = str.slice(0, xe) + "." + str.slice(xe);
      }
    }
    var arr = [0];
    for (var _i2 = 0; _i2 < str.length; ) {
      var arrL = arr.length;
      while (arrL--) {
        arr[arrL] *= 10;
      }
      arr[0] += parseInt(str.charAt(_i2++));
      for (var _j = 0; _j < arr.length; ++_j) {
        if (arr[_j] > 1) {
          if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
            arr[_j + 1] = 0;
          }
          arr[_j + 1] += arr[_j] >> 1;
          arr[_j] &= 1;
        }
      }
    }
    return arr.reverse();
  }
  function bitXor(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function bitXor");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }
    if (x.isZero()) {
      return y;
    }
    if (y.isZero()) {
      return x;
    }
    if (x.eq(y)) {
      return new BigNumber(0);
    }
    var negOne = new BigNumber(-1);
    if (x.eq(negOne)) {
      return bitNotBigNumber(y);
    }
    if (y.eq(negOne)) {
      return bitNotBigNumber(x);
    }
    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !y.isFinite()) {
        return negOne;
      }
      return new BigNumber(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
    }
    return bitwise(x, y, function(a, b) {
      return a ^ b;
    });
  }
  function leftShiftBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function leftShift");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
      return new BigNumber(NaN);
    }
    if (x.isZero() || y.isZero()) {
      return x;
    }
    if (!x.isFinite() && !y.isFinite()) {
      return new BigNumber(NaN);
    }
    if (y.lt(55)) {
      return x.times(Math.pow(2, y.toNumber()) + "");
    }
    return x.times(new BigNumber(2).pow(y));
  }
  function rightArithShiftBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function rightArithShift");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
      return new BigNumber(NaN);
    }
    if (x.isZero() || y.isZero()) {
      return x;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return new BigNumber(-1);
      }
      if (!x.isFinite()) {
        return new BigNumber(NaN);
      }
      return new BigNumber(0);
    }
    if (y.lt(55)) {
      return x.div(Math.pow(2, y.toNumber()) + "").floor();
    }
    return x.div(new BigNumber(2).pow(y)).floor();
  }

  // node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
  var name65 = "bitAnd";
  var dependencies66 = ["typed", "matrix", "equalScalar"];
  var createBitAnd = /* @__PURE__ */ factory(name65, dependencies66, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar
    } = _ref;
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm06 = createAlgorithm06({
      typed,
      equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name65, {
      "number, number": bitAndNumber,
      "BigNumber, BigNumber": bitAndBigNumber,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm06(x, y, this, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm02(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm11(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
  var name66 = "bitNot";
  var dependencies67 = ["typed"];
  var createBitNot = /* @__PURE__ */ factory(name66, dependencies67, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name66, {
      number: bitNotNumber,
      BigNumber: bitNotBigNumber,
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
  var name67 = "bitOr";
  var dependencies68 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createBitOr = /* @__PURE__ */ factory(name67, dependencies68, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm04 = createAlgorithm04({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name67, {
      "number, number": bitOrNumber,
      "BigNumber, BigNumber": bitOrBigNumber,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm04(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm01(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm10(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm10(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm07.js
  var name68 = "algorithm07";
  var dependencies69 = ["typed", "DenseMatrix"];
  var createAlgorithm07 = /* @__PURE__ */ factory(name68, dependencies69, (_ref) => {
    var {
      typed,
      DenseMatrix
    } = _ref;
    return function algorithm07(a, b, callback) {
      var asize = a._size;
      var adt = a._datatype;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var i, j;
      var cdata = [];
      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      }
      var xa = [];
      var xb = [];
      var wa = [];
      var wb = [];
      for (j = 0; j < columns; j++) {
        var mark = j + 1;
        _scatter(a, j, wa, xa, mark);
        _scatter(b, j, wb, xb, mark);
        for (i = 0; i < rows; i++) {
          var va = wa[i] === mark ? xa[i] : zero;
          var vb = wb[i] === mark ? xb[i] : zero;
          cdata[i][j] = cf(va, vb);
        }
      }
      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
    function _scatter(m, j, w, x, mark) {
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
        var i = index[k];
        w[i] = mark;
        x[i] = values2[k];
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
  var name69 = "bitXor";
  var dependencies70 = ["typed", "matrix", "DenseMatrix"];
  var createBitXor = /* @__PURE__ */ factory(name69, dependencies70, (_ref) => {
    var {
      typed,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name69, {
      "number, number": bitXorNumber,
      "BigNumber, BigNumber": bitXor,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/arg.js
  var name70 = "arg";
  var dependencies71 = ["typed"];
  var createArg = /* @__PURE__ */ factory(name70, dependencies71, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name70, {
      number: function number(x) {
        return Math.atan2(0, x);
      },
      BigNumber: function BigNumber(x) {
        return x.constructor.atan2(0, x);
      },
      Complex: function Complex2(x) {
        return x.arg();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/conj.js
  var name71 = "conj";
  var dependencies72 = ["typed"];
  var createConj = /* @__PURE__ */ factory(name71, dependencies72, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name71, {
      number: function number(x) {
        return x;
      },
      BigNumber: function BigNumber(x) {
        return x;
      },
      Complex: function Complex2(x) {
        return x.conjugate();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/im.js
  var name72 = "im";
  var dependencies73 = ["typed"];
  var createIm = /* @__PURE__ */ factory(name72, dependencies73, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name72, {
      number: function number(x) {
        return 0;
      },
      BigNumber: function BigNumber(x) {
        return x.mul(0);
      },
      Complex: function Complex2(x) {
        return x.im;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/re.js
  var name73 = "re";
  var dependencies74 = ["typed"];
  var createRe = /* @__PURE__ */ factory(name73, dependencies74, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name73, {
      number: function number(x) {
        return x;
      },
      BigNumber: function BigNumber(x) {
        return x;
      },
      Complex: function Complex2(x) {
        return x.re;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/logical/not.js
  var name74 = "not";
  var dependencies75 = ["typed"];
  var createNot = /* @__PURE__ */ factory(name74, dependencies75, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name74, {
      number: notNumber,
      Complex: function Complex2(x) {
        return x.re === 0 && x.im === 0;
      },
      BigNumber: function BigNumber(x) {
        return x.isZero() || x.isNaN();
      },
      Unit: function Unit(x) {
        return x.value !== null ? this(x.value) : true;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/logical/or.js
  var name75 = "or";
  var dependencies76 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createOr = /* @__PURE__ */ factory(name75, dependencies76, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm05 = createAlgorithm05({
      typed,
      equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name75, {
      "number, number": orNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
      },
      "Unit, Unit": function UnitUnit(x, y) {
        return this(x.value || 0, y.value || 0);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm05(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/logical/xor.js
  var name76 = "xor";
  var dependencies77 = ["typed", "matrix", "DenseMatrix"];
  var createXor = /* @__PURE__ */ factory(name76, dependencies77, (_ref) => {
    var {
      typed,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name76, {
      "number, number": xorNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
      },
      "Unit, Unit": function UnitUnit(x, y) {
        return this(x.value || 0, y.value || 0);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/concat.js
  var name77 = "concat";
  var dependencies78 = ["typed", "matrix", "isInteger"];
  var createConcat = /* @__PURE__ */ factory(name77, dependencies78, (_ref) => {
    var {
      typed,
      matrix,
      isInteger: isInteger2
    } = _ref;
    return typed(name77, {
      "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
        var i;
        var len = args.length;
        var dim = -1;
        var prevDim;
        var asMatrix = false;
        var matrices = [];
        for (i = 0; i < len; i++) {
          var arg = args[i];
          if (isMatrix(arg)) {
            asMatrix = true;
          }
          if (isNumber(arg) || isBigNumber(arg)) {
            if (i !== len - 1) {
              throw new Error("Dimension must be specified as last argument");
            }
            prevDim = dim;
            dim = arg.valueOf();
            if (!isInteger2(dim)) {
              throw new TypeError("Integer number expected for dimension");
            }
            if (dim < 0 || i > 0 && dim > prevDim) {
              throw new IndexError(dim, prevDim + 1);
            }
          } else {
            var m = clone(arg).valueOf();
            var size = arraySize(m);
            matrices[i] = m;
            prevDim = dim;
            dim = size.length - 1;
            if (i > 0 && dim !== prevDim) {
              throw new DimensionError(prevDim + 1, dim + 1);
            }
          }
        }
        if (matrices.length === 0) {
          throw new SyntaxError("At least one matrix expected");
        }
        var res = matrices.shift();
        while (matrices.length) {
          res = _concat(res, matrices.shift(), dim, 0);
        }
        return asMatrix ? matrix(res) : res;
      },
      "...string": function string(args) {
        return args.join("");
      }
    });
  });
  function _concat(a, b, concatDim, dim) {
    if (dim < concatDim) {
      if (a.length !== b.length) {
        throw new DimensionError(a.length, b.length);
      }
      var c = [];
      for (var i = 0; i < a.length; i++) {
        c[i] = _concat(a[i], b[i], concatDim, dim + 1);
      }
      return c;
    } else {
      return a.concat(b);
    }
  }

  // node_modules/mathjs/lib/esm/function/matrix/column.js
  var name78 = "column";
  var dependencies79 = ["typed", "Index", "matrix", "range"];
  var createColumn = /* @__PURE__ */ factory(name78, dependencies79, (_ref) => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;
    return typed(name78, {
      "Matrix, number": _column,
      "Array, number": function ArrayNumber(value, column) {
        return _column(matrix(clone(value)), column).valueOf();
      }
    });
    function _column(value, column) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(column, value.size()[1]);
      var rowRange = range(0, value.size()[0]);
      var index = new Index(rowRange, column);
      return value.subset(index);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/count.js
  var name79 = "count";
  var dependencies80 = ["typed", "size", "prod"];
  var createCount = /* @__PURE__ */ factory(name79, dependencies80, (_ref) => {
    var {
      typed,
      size,
      prod
    } = _ref;
    return typed(name79, {
      string: function string(x) {
        return x.length;
      },
      "Matrix | Array": function MatrixArray(x) {
        return prod(size(x));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/cross.js
  var name80 = "cross";
  var dependencies81 = ["typed", "matrix", "subtract", "multiply"];
  var createCross = /* @__PURE__ */ factory(name80, dependencies81, (_ref) => {
    var {
      typed,
      matrix,
      subtract,
      multiply
    } = _ref;
    return typed(name80, {
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        return matrix(_cross(x.toArray(), y.toArray()));
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return matrix(_cross(x.toArray(), y));
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return matrix(_cross(x, y.toArray()));
      },
      "Array, Array": _cross
    });
    function _cross(x, y) {
      var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
      x = squeeze(x);
      y = squeeze(y);
      var xSize = arraySize(x);
      var ySize = arraySize(y);
      if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
        throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
      }
      var product3 = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];
      if (highestDimension > 1) {
        return [product3];
      } else {
        return product3;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/diag.js
  var name81 = "diag";
  var dependencies82 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
  var createDiag = /* @__PURE__ */ factory(name81, dependencies82, (_ref) => {
    var {
      typed,
      matrix,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    return typed(name81, {
      Array: function Array2(x) {
        return _diag(x, 0, arraySize(x), null);
      },
      "Array, number": function ArrayNumber(x, k) {
        return _diag(x, k, arraySize(x), null);
      },
      "Array, BigNumber": function ArrayBigNumber(x, k) {
        return _diag(x, k.toNumber(), arraySize(x), null);
      },
      "Array, string": function ArrayString(x, format4) {
        return _diag(x, 0, arraySize(x), format4);
      },
      "Array, number, string": function ArrayNumberString(x, k, format4) {
        return _diag(x, k, arraySize(x), format4);
      },
      "Array, BigNumber, string": function ArrayBigNumberString(x, k, format4) {
        return _diag(x, k.toNumber(), arraySize(x), format4);
      },
      Matrix: function Matrix(x) {
        return _diag(x, 0, x.size(), x.storage());
      },
      "Matrix, number": function MatrixNumber(x, k) {
        return _diag(x, k, x.size(), x.storage());
      },
      "Matrix, BigNumber": function MatrixBigNumber(x, k) {
        return _diag(x, k.toNumber(), x.size(), x.storage());
      },
      "Matrix, string": function MatrixString(x, format4) {
        return _diag(x, 0, x.size(), format4);
      },
      "Matrix, number, string": function MatrixNumberString(x, k, format4) {
        return _diag(x, k, x.size(), format4);
      },
      "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format4) {
        return _diag(x, k.toNumber(), x.size(), format4);
      }
    });
    function _diag(x, k, size, format4) {
      if (!isInteger(k)) {
        throw new TypeError("Second parameter in function diag must be an integer");
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      switch (size.length) {
        case 1:
          return _createDiagonalMatrix(x, k, format4, size[0], kSub, kSuper);
        case 2:
          return _getDiagonal(x, k, format4, size, kSub, kSuper);
      }
      throw new RangeError("Matrix for function diag must be 2 dimensional");
    }
    function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
      var ms = [l + kSub, l + kSuper];
      if (format4 && format4 !== "sparse" && format4 !== "dense") {
        throw new TypeError("Unknown matrix type ".concat(format4, '"'));
      }
      var m = format4 === "sparse" ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);
      return format4 !== null ? m : m.valueOf();
    }
    function _getDiagonal(x, k, format4, s, kSub, kSuper) {
      if (isMatrix(x)) {
        var dm = x.diagonal(k);
        if (format4 !== null) {
          if (format4 !== dm.storage()) {
            return matrix(dm, format4);
          }
          return dm;
        }
        return dm.valueOf();
      }
      var n = Math.min(s[0] - kSub, s[1] - kSuper);
      var vector = [];
      for (var i = 0; i < n; i++) {
        vector[i] = x[i + kSub][i + kSuper];
      }
      return format4 !== null ? matrix(vector) : vector;
    }
  });

  // node_modules/mathjs/lib/esm/utils/lruQueue.js
  function lruQueue(limit) {
    var size = 0;
    var base = 1;
    var queue = Object.create(null);
    var map2 = Object.create(null);
    var index = 0;
    var del = function del2(id) {
      var oldIndex = map2[id];
      if (!oldIndex)
        return;
      delete queue[oldIndex];
      delete map2[id];
      --size;
      if (base !== oldIndex)
        return;
      if (!size) {
        index = 0;
        base = 1;
        return;
      }
      while (!hasOwnProperty.call(queue, ++base)) {
        continue;
      }
    };
    limit = Math.abs(limit);
    return {
      hit: function hit(id) {
        var oldIndex = map2[id];
        var nuIndex = ++index;
        queue[nuIndex] = id;
        map2[id] = nuIndex;
        if (!oldIndex) {
          ++size;
          if (size <= limit)
            return void 0;
          id = queue[base];
          del(id);
          return id;
        }
        delete queue[oldIndex];
        if (base !== oldIndex)
          return void 0;
        while (!hasOwnProperty.call(queue, ++base)) {
          continue;
        }
        return void 0;
      },
      delete: del,
      clear: function clear() {
        size = index = 0;
        base = 1;
        queue = Object.create(null);
        map2 = Object.create(null);
      }
    };
  }

  // node_modules/mathjs/lib/esm/utils/function.js
  function memoize(fn) {
    var {
      hasher: hasher2,
      limit
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    limit = limit == null ? Number.POSITIVE_INFINITY : limit;
    hasher2 = hasher2 == null ? JSON.stringify : hasher2;
    return function memoize2() {
      if (typeof memoize2.cache !== "object") {
        memoize2.cache = {
          values: new Map(),
          lru: lruQueue(limit || Number.POSITIVE_INFINITY)
        };
      }
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      var hash = hasher2(args);
      if (memoize2.cache.values.has(hash)) {
        memoize2.cache.lru.hit(hash);
        return memoize2.cache.values.get(hash);
      }
      var newVal = fn.apply(fn, args);
      memoize2.cache.values.set(hash, newVal);
      memoize2.cache.values.delete(memoize2.cache.lru.hit(hash));
      return newVal;
    };
  }
  function maxArgumentCount(fn) {
    return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
      var count = (signature.match(/,/g) || []).length + 1;
      return Math.max(args, count);
    }, -1);
  }

  // node_modules/mathjs/lib/esm/function/matrix/filter.js
  var name82 = "filter";
  var dependencies83 = ["typed"];
  var createFilter = /* @__PURE__ */ factory(name82, dependencies83, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("filter", {
      "Array, function": _filterCallback,
      "Matrix, function": function MatrixFunction(x, test) {
        return x.create(_filterCallback(x.toArray(), test));
      },
      "Array, RegExp": filterRegExp,
      "Matrix, RegExp": function MatrixRegExp(x, test) {
        return x.create(filterRegExp(x.toArray(), test));
      }
    });
  });
  function _filterCallback(x, callback) {
    var args = maxArgumentCount(callback);
    return filter(x, function(value, index, array) {
      if (args === 1) {
        return callback(value);
      } else if (args === 2) {
        return callback(value, [index]);
      } else {
        return callback(value, [index], array);
      }
    });
  }

  // node_modules/mathjs/lib/esm/function/matrix/flatten.js
  var name83 = "flatten";
  var dependencies84 = ["typed", "matrix"];
  var createFlatten = /* @__PURE__ */ factory(name83, dependencies84, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return typed(name83, {
      Array: function Array2(x) {
        return flatten(clone(x));
      },
      Matrix: function Matrix(x) {
        var flat = flatten(clone(x.toArray()));
        return matrix(flat);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/forEach.js
  var name84 = "forEach";
  var dependencies85 = ["typed"];
  var createForEach = /* @__PURE__ */ factory(name84, dependencies85, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name84, {
      "Array, function": _forEach,
      "Matrix, function": function MatrixFunction(x, callback) {
        return x.forEach(callback);
      }
    });
  });
  function _forEach(array, callback) {
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index) {
      if (Array.isArray(value)) {
        forEach(value, function(child, i) {
          recurse2(child, index.concat(i));
        });
      } else {
        if (args === 1) {
          callback(value);
        } else if (args === 2) {
          callback(value, index);
        } else {
          callback(value, index, array);
        }
      }
    };
    recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
  var name85 = "getMatrixDataType";
  var dependencies86 = ["typed"];
  var createGetMatrixDataType = /* @__PURE__ */ factory(name85, dependencies86, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name85, {
      Array: function Array2(x) {
        return getArrayDataType(x, typeOf);
      },
      Matrix: function Matrix(x) {
        return x.getDataType();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/identity.js
  var name86 = "identity";
  var dependencies87 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
  var createIdentity = /* @__PURE__ */ factory(name86, dependencies87, (_ref) => {
    var {
      typed,
      config,
      matrix,
      BigNumber,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    return typed(name86, {
      "": function _4() {
        return config.matrix === "Matrix" ? matrix([]) : [];
      },
      string: function string(format4) {
        return matrix(format4);
      },
      "number | BigNumber": function numberBigNumber(rows) {
        return _identity(rows, rows, config.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, string": function numberBigNumberString(rows, format4) {
        return _identity(rows, rows, format4);
      },
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
        return _identity(rows, cols, config.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format4) {
        return _identity(rows, cols, format4);
      },
      Array: function Array2(size) {
        return _identityVector(size);
      },
      "Array, string": function ArrayString(size, format4) {
        return _identityVector(size, format4);
      },
      Matrix: function Matrix(size) {
        return _identityVector(size.valueOf(), size.storage());
      },
      "Matrix, string": function MatrixString(size, format4) {
        return _identityVector(size.valueOf(), format4);
      }
    });
    function _identityVector(size, format4) {
      switch (size.length) {
        case 0:
          return format4 ? matrix(format4) : [];
        case 1:
          return _identity(size[0], size[0], format4);
        case 2:
          return _identity(size[0], size[1], format4);
        default:
          throw new Error("Vector containing two values expected");
      }
    }
    function _identity(rows, cols, format4) {
      var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
      if (isBigNumber(rows))
        rows = rows.toNumber();
      if (isBigNumber(cols))
        cols = cols.toNumber();
      if (!isInteger(rows) || rows < 1) {
        throw new Error("Parameters in function identity must be positive integers");
      }
      if (!isInteger(cols) || cols < 1) {
        throw new Error("Parameters in function identity must be positive integers");
      }
      var one = Big ? new BigNumber(1) : 1;
      var defaultValue = Big ? new Big(0) : 0;
      var size = [rows, cols];
      if (format4) {
        if (format4 === "sparse") {
          return SparseMatrix.diagonal(size, one, 0, defaultValue);
        }
        if (format4 === "dense") {
          return DenseMatrix.diagonal(size, one, 0, defaultValue);
        }
        throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
      }
      var res = resize([], size, defaultValue);
      var minimum = rows < cols ? rows : cols;
      for (var d = 0; d < minimum; d++) {
        res[d][d] = one;
      }
      return res;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/kron.js
  var name87 = "kron";
  var dependencies88 = ["typed", "matrix", "multiplyScalar"];
  var createKron = /* @__PURE__ */ factory(name87, dependencies88, (_ref) => {
    var {
      typed,
      matrix,
      multiplyScalar
    } = _ref;
    return typed(name87, {
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        return matrix(_kron(x.toArray(), y.toArray()));
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return matrix(_kron(x.toArray(), y));
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return matrix(_kron(x, y.toArray()));
      },
      "Array, Array": _kron
    });
    function _kron(a, b) {
      if (arraySize(a).length === 1) {
        a = [a];
      }
      if (arraySize(b).length === 1) {
        b = [b];
      }
      if (arraySize(a).length > 2 || arraySize(b).length > 2) {
        throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
      }
      var t = [];
      var r = [];
      return a.map(function(a2) {
        return b.map(function(b2) {
          r = [];
          t.push(r);
          return a2.map(function(y) {
            return b2.map(function(x) {
              return r.push(multiplyScalar(y, x));
            });
          });
        });
      }) && t;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/map.js
  var name88 = "map";
  var dependencies89 = ["typed"];
  var createMap = /* @__PURE__ */ factory(name88, dependencies89, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name88, {
      "Array, function": _map,
      "Matrix, function": function MatrixFunction(x, callback) {
        return x.map(callback);
      }
    });
  });
  function _map(array, callback) {
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index) {
      if (Array.isArray(value)) {
        return value.map(function(child, i) {
          return recurse2(child, index.concat(i));
        });
      } else {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index);
        } else {
          return callback(value, index, array);
        }
      }
    };
    return recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/function/matrix/diff.js
  var name89 = "diff";
  var dependencies90 = ["typed", "matrix", "subtract", "number"];
  var createDiff = /* @__PURE__ */ factory(name89, dependencies90, (_ref) => {
    var {
      typed,
      matrix,
      subtract,
      number
    } = _ref;
    return typed(name89, {
      "Array | Matrix": function ArrayMatrix(arr) {
        if (isMatrix(arr)) {
          return matrix(_diff(arr.toArray()));
        } else {
          return _diff(arr);
        }
      },
      "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
        if (!isInteger(dim))
          throw new RangeError("Dimension must be a whole number");
        if (isMatrix(arr)) {
          return matrix(_recursive(arr.toArray(), dim));
        } else {
          return _recursive(arr, dim);
        }
      },
      "Array | Matrix, BigNumber": function ArrayMatrixBigNumber(arr, dim) {
        return this(arr, number(dim));
      }
    });
    function _recursive(arr, dim) {
      if (isMatrix(arr)) {
        arr = arr.toArray();
      }
      if (!Array.isArray(arr)) {
        throw RangeError("Array/Matrix does not have that many dimensions");
      }
      if (dim > 0) {
        var result = [];
        arr.forEach((element) => {
          result.push(_recursive(element, dim - 1));
        });
        return result;
      } else if (dim === 0) {
        return _diff(arr);
      } else {
        throw RangeError("Cannot have negative dimension");
      }
    }
    function _diff(arr) {
      var result = [];
      var size = arr.length;
      if (size < 2) {
        return arr;
      }
      for (var i = 1; i < size; i++) {
        result.push(_ElementDiff(arr[i - 1], arr[i]));
      }
      return result;
    }
    function _ElementDiff(obj1, obj2) {
      if (isMatrix(obj1))
        obj1 = obj1.toArray();
      if (isMatrix(obj2))
        obj2 = obj2.toArray();
      var obj1IsArray = Array.isArray(obj1);
      var obj2IsArray = Array.isArray(obj2);
      if (obj1IsArray && obj2IsArray) {
        return _ArrayDiff(obj1, obj2);
      }
      if (!obj1IsArray && !obj2IsArray) {
        return subtract(obj2, obj1);
      }
      throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
    }
    function _ArrayDiff(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        throw RangeError("Not all sub-arrays have the same length");
      }
      var result = [];
      var size = arr1.length;
      for (var i = 0; i < size; i++) {
        result.push(_ElementDiff(arr1[i], arr2[i]));
      }
      return result;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ones.js
  var name90 = "ones";
  var dependencies91 = ["typed", "config", "matrix", "BigNumber"];
  var createOnes = /* @__PURE__ */ factory(name90, dependencies91, (_ref) => {
    var {
      typed,
      config,
      matrix,
      BigNumber
    } = _ref;
    return typed("ones", {
      "": function _4() {
        return config.matrix === "Array" ? _ones([]) : _ones([], "default");
      },
      "...number | BigNumber | string": function numberBigNumberString(size) {
        var last = size[size.length - 1];
        if (typeof last === "string") {
          var format4 = size.pop();
          return _ones(size, format4);
        } else if (config.matrix === "Array") {
          return _ones(size);
        } else {
          return _ones(size, "default");
        }
      },
      Array: _ones,
      Matrix: function Matrix(size) {
        var format4 = size.storage();
        return _ones(size.valueOf(), format4);
      },
      "Array | Matrix, string": function ArrayMatrixString(size, format4) {
        return _ones(size.valueOf(), format4);
      }
    });
    function _ones(size, format4) {
      var hasBigNumbers = _normalize(size);
      var defaultValue = hasBigNumbers ? new BigNumber(1) : 1;
      _validate2(size);
      if (format4) {
        var m = matrix(format4);
        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }
        return m;
      } else {
        var arr = [];
        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size) {
      var hasBigNumbers = false;
      size.forEach(function(value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size) {
      size.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error("Parameters in function ones must be positive integers");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/noop.js
  function noBignumber() {
    throw new Error('No "bignumber" implementation available');
  }
  function noFraction() {
    throw new Error('No "fraction" implementation available');
  }
  function noMatrix() {
    throw new Error('No "matrix" implementation available');
  }

  // node_modules/mathjs/lib/esm/function/matrix/range.js
  var name91 = "range";
  var dependencies92 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
  var createRange = /* @__PURE__ */ factory(name91, dependencies92, (_ref) => {
    var {
      typed,
      config,
      matrix,
      bignumber,
      smaller,
      smallerEq,
      larger,
      largerEq
    } = _ref;
    return typed(name91, {
      string: _strRange,
      "string, boolean": _strRange,
      "number, number": function numberNumber2(start, end) {
        return _out(_rangeEx(start, end, 1));
      },
      "number, number, number": function numberNumberNumber(start, end, step) {
        return _out(_rangeEx(start, end, step));
      },
      "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
      },
      "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
        var BigNumber = start.constructor;
        return _out(_bigRangeEx(start, end, new BigNumber(1)));
      },
      "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
        return _out(_bigRangeEx(start, end, step));
      },
      "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
        var BigNumber = start.constructor;
        return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber(1))) : _out(_bigRangeEx(start, end, new BigNumber(1)));
      },
      "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
      }
    });
    function _out(arr) {
      if (config.matrix === "Matrix") {
        return matrix ? matrix(arr) : noMatrix();
      }
      return arr;
    }
    function _strRange(str, includeEnd) {
      var r = _parse(str);
      if (!r) {
        throw new SyntaxError('String "' + str + '" is no valid range');
      }
      var fn;
      if (config.number === "BigNumber") {
        if (bignumber === void 0) {
          noBignumber();
        }
        fn = includeEnd ? _bigRangeInc : _bigRangeEx;
        return _out(fn(bignumber(r.start), bignumber(r.end), bignumber(r.step)));
      } else {
        fn = includeEnd ? _rangeInc : _rangeEx;
        return _out(fn(r.start, r.end, r.step));
      }
    }
    function _rangeEx(start, end, step) {
      var array = [];
      var x = start;
      if (step > 0) {
        while (smaller(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (larger(x, end)) {
          array.push(x);
          x += step;
        }
      }
      return array;
    }
    function _rangeInc(start, end, step) {
      var array = [];
      var x = start;
      if (step > 0) {
        while (smallerEq(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (largerEq(x, end)) {
          array.push(x);
          x += step;
        }
      }
      return array;
    }
    function _bigRangeEx(start, end, step) {
      var zero = bignumber(0);
      var array = [];
      var x = start;
      if (step.gt(zero)) {
        while (smaller(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (larger(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }
      return array;
    }
    function _bigRangeInc(start, end, step) {
      var zero = bignumber(0);
      var array = [];
      var x = start;
      if (step.gt(zero)) {
        while (smallerEq(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (largerEq(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }
      return array;
    }
    function _parse(str) {
      var args = str.split(":");
      var nums = args.map(function(arg) {
        return Number(arg);
      });
      var invalid = nums.some(function(num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return {
            start: nums[0],
            end: nums[1],
            step: 1
          };
        case 3:
          return {
            start: nums[0],
            end: nums[2],
            step: nums[1]
          };
        default:
          return null;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/reshape.js
  var name92 = "reshape";
  var dependencies93 = ["typed", "isInteger", "matrix"];
  var createReshape = /* @__PURE__ */ factory(name92, dependencies93, (_ref) => {
    var {
      typed,
      isInteger: isInteger2
    } = _ref;
    return typed(name92, {
      "Matrix, Array": function MatrixArray(x, sizes) {
        return x.reshape(sizes);
      },
      "Array, Array": function ArrayArray(x, sizes) {
        sizes.forEach(function(size) {
          if (!isInteger2(size)) {
            throw new TypeError("Invalid size for dimension: " + size);
          }
        });
        return reshape(x, sizes);
      }
    });
  });

  // node_modules/mathjs/lib/esm/error/ArgumentsError.js
  function ArgumentsError(fn, count, min, max) {
    if (!(this instanceof ArgumentsError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.fn = fn;
    this.count = count;
    this.min = min;
    this.max = max;
    this.message = "Wrong number of arguments in function " + fn + " (" + count + " provided, " + min + (max !== void 0 && max !== null ? "-" + max : "") + " expected)";
    this.stack = new Error().stack;
  }
  ArgumentsError.prototype = new Error();
  ArgumentsError.prototype.constructor = Error;
  ArgumentsError.prototype.name = "ArgumentsError";
  ArgumentsError.prototype.isArgumentsError = true;

  // node_modules/mathjs/lib/esm/function/matrix/resize.js
  var name93 = "resize";
  var dependencies94 = ["config", "matrix"];
  var createResize = /* @__PURE__ */ factory(name93, dependencies94, (_ref) => {
    var {
      config,
      matrix
    } = _ref;
    return function resize2(x, size, defaultValue) {
      if (arguments.length !== 2 && arguments.length !== 3) {
        throw new ArgumentsError("resize", arguments.length, 2, 3);
      }
      if (isMatrix(size)) {
        size = size.valueOf();
      }
      if (isBigNumber(size[0])) {
        size = size.map(function(value) {
          return !isBigNumber(value) ? value : value.toNumber();
        });
      }
      if (isMatrix(x)) {
        return x.resize(size, defaultValue, true);
      }
      if (typeof x === "string") {
        return _resizeString(x, size, defaultValue);
      }
      var asMatrix = Array.isArray(x) ? false : config.matrix !== "Array";
      if (size.length === 0) {
        while (Array.isArray(x)) {
          x = x[0];
        }
        return clone(x);
      } else {
        if (!Array.isArray(x)) {
          x = [x];
        }
        x = clone(x);
        var res = resize(x, size, defaultValue);
        return asMatrix ? matrix(res) : res;
      }
    };
    function _resizeString(str, size, defaultChar) {
      if (defaultChar !== void 0) {
        if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
          throw new TypeError("Single character expected as defaultValue");
        }
      } else {
        defaultChar = " ";
      }
      if (size.length !== 1) {
        throw new DimensionError(size.length, 1);
      }
      var len = size[0];
      if (typeof len !== "number" || !isInteger(len)) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size) + ")");
      }
      if (str.length > len) {
        return str.substring(0, len);
      } else if (str.length < len) {
        var res = str;
        for (var i = 0, ii = len - str.length; i < ii; i++) {
          res += defaultChar;
        }
        return res;
      } else {
        return str;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/rotate.js
  var name94 = "rotate";
  var dependencies95 = ["typed", "multiply", "rotationMatrix"];
  var createRotate = /* @__PURE__ */ factory(name94, dependencies95, (_ref) => {
    var {
      typed,
      multiply,
      rotationMatrix
    } = _ref;
    return typed(name94, {
      "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
        _validateSize(w, 2);
        var matrixRes = multiply(rotationMatrix(theta), w);
        return matrixRes.toArray();
      },
      "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
        _validateSize(w, 2);
        return multiply(rotationMatrix(theta), w);
      },
      "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
        _validateSize(w, 3);
        var matrixRes = multiply(rotationMatrix(theta, v), w);
        return matrixRes;
      },
      "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
        _validateSize(w, 3);
        return multiply(rotationMatrix(theta, v), w);
      }
    });
    function _validateSize(v, expectedSize) {
      var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
      if (actualSize.length > 2) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
      if (actualSize.length === 2 && actualSize[1] !== 1) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
      if (actualSize[0] !== expectedSize) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
  var name95 = "rotationMatrix";
  var dependencies96 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
  var createRotationMatrix = /* @__PURE__ */ factory(name95, dependencies96, (_ref) => {
    var {
      typed,
      config,
      multiplyScalar,
      addScalar,
      unaryMinus,
      norm,
      BigNumber,
      matrix,
      DenseMatrix,
      SparseMatrix,
      cos,
      sin
    } = _ref;
    return typed(name95, {
      "": function _4() {
        return config.matrix === "Matrix" ? matrix([]) : [];
      },
      string: function string(format4) {
        return matrix(format4);
      },
      "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
        return _rotationMatrix2x2(theta, config.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format4) {
        return _rotationMatrix2x2(theta, format4);
      },
      "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
        var matrixV = matrix(v);
        _validateVector(matrixV);
        return _rotationMatrix3x3(theta, matrixV, void 0);
      },
      "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
        _validateVector(v);
        var storageType = v.storage() || (config.matrix === "Matrix" ? "dense" : void 0);
        return _rotationMatrix3x3(theta, v, storageType);
      },
      "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format4) {
        var matrixV = matrix(v);
        _validateVector(matrixV);
        return _rotationMatrix3x3(theta, matrixV, format4);
      },
      "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format4) {
        _validateVector(v);
        return _rotationMatrix3x3(theta, v, format4);
      }
    });
    function _rotationMatrix2x2(theta, format4) {
      var Big = isBigNumber(theta);
      var minusOne = Big ? new BigNumber(-1) : -1;
      var cosTheta = cos(theta);
      var sinTheta = sin(theta);
      var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];
      return _convertToFormat(data, format4);
    }
    function _validateVector(v) {
      var size = v.size();
      if (size.length < 1 || size[0] !== 3) {
        throw new RangeError("Vector must be of dimensions 1x3");
      }
    }
    function _mul(array) {
      return array.reduce((p, curr) => multiplyScalar(p, curr));
    }
    function _convertToFormat(data, format4) {
      if (format4) {
        if (format4 === "sparse") {
          return new SparseMatrix(data);
        }
        if (format4 === "dense") {
          return new DenseMatrix(data);
        }
        throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
      }
      return data;
    }
    function _rotationMatrix3x3(theta, v, format4) {
      var normV = norm(v);
      if (normV === 0) {
        throw new RangeError("Rotation around zero vector");
      }
      var Big = isBigNumber(theta) ? BigNumber : null;
      var one = Big ? new Big(1) : 1;
      var minusOne = Big ? new Big(-1) : -1;
      var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
      var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
      var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
      var c = cos(theta);
      var oneMinusC = addScalar(one, unaryMinus(c));
      var s = sin(theta);
      var r11 = addScalar(c, _mul([vx, vx, oneMinusC]));
      var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
      var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
      var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
      var r22 = addScalar(c, _mul([vy, vy, oneMinusC]));
      var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
      var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
      var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
      var r33 = addScalar(c, _mul([vz, vz, oneMinusC]));
      var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
      return _convertToFormat(data, format4);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/row.js
  var name96 = "row";
  var dependencies97 = ["typed", "Index", "matrix", "range"];
  var createRow = /* @__PURE__ */ factory(name96, dependencies97, (_ref) => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;
    return typed(name96, {
      "Matrix, number": _row,
      "Array, number": function ArrayNumber(value, row) {
        return _row(matrix(clone(value)), row).valueOf();
      }
    });
    function _row(value, row) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(row, value.size()[0]);
      var columnRange = range(0, value.size()[1]);
      var index = new Index(row, columnRange);
      return value.subset(index);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/size.js
  var name97 = "size";
  var dependencies98 = ["typed", "config", "?matrix"];
  var createSize = /* @__PURE__ */ factory(name97, dependencies98, (_ref) => {
    var {
      typed,
      config,
      matrix
    } = _ref;
    return typed(name97, {
      Matrix: function Matrix(x) {
        return x.create(x.size());
      },
      Array: arraySize,
      string: function string(x) {
        return config.matrix === "Array" ? [x.length] : matrix([x.length]);
      },
      "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
        return config.matrix === "Array" ? [] : matrix ? matrix([]) : noMatrix();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/squeeze.js
  var name98 = "squeeze";
  var dependencies99 = ["typed", "matrix"];
  var createSqueeze = /* @__PURE__ */ factory(name98, dependencies99, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return typed(name98, {
      Array: function Array2(x) {
        return squeeze(clone(x));
      },
      Matrix: function Matrix(x) {
        var res = squeeze(x.toArray());
        return Array.isArray(res) ? matrix(res) : res;
      },
      any: function any(x) {
        return clone(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/utils/customs.js
  function getSafeProperty(object, prop) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      return object[prop];
    }
    if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
      throw new Error('Cannot access method "' + prop + '" as a property');
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function setSafeProperty(object, prop, value) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      object[prop] = value;
      return value;
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function isSafeProperty(object, prop) {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (hasOwnProperty2(safeNativeProperties, prop)) {
      return true;
    }
    if (prop in Object.prototype) {
      return false;
    }
    if (prop in Function.prototype) {
      return false;
    }
    return true;
  }
  function validateSafeMethod(object, method) {
    if (!isSafeMethod(object, method)) {
      throw new Error('No access to method "' + method + '"');
    }
  }
  function isSafeMethod(object, method) {
    if (object === null || object === void 0 || typeof object[method] !== "function") {
      return false;
    }
    if (hasOwnProperty2(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
      return false;
    }
    if (hasOwnProperty2(safeNativeMethods, method)) {
      return true;
    }
    if (method in Object.prototype) {
      return false;
    }
    if (method in Function.prototype) {
      return false;
    }
    return true;
  }
  function isPlainObject(object) {
    return typeof object === "object" && object && object.constructor === Object;
  }
  var safeNativeProperties = {
    length: true,
    name: true
  };
  var safeNativeMethods = {
    toString: true,
    valueOf: true,
    toLocaleString: true
  };

  // node_modules/mathjs/lib/esm/function/matrix/subset.js
  var name99 = "subset";
  var dependencies100 = ["typed", "matrix"];
  var createSubset = /* @__PURE__ */ factory(name99, dependencies100, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return typed(name99, {
      "Array, Index": function ArrayIndex(value, index) {
        var m = matrix(value);
        var subset = m.subset(index);
        return index.isScalar() ? subset : subset.valueOf();
      },
      "Matrix, Index": function MatrixIndex(value, index) {
        return value.subset(index);
      },
      "Object, Index": _getObjectProperty,
      "string, Index": _getSubstring,
      "Array, Index, any": function ArrayIndexAny(value, index, replacement) {
        return matrix(clone(value)).subset(index, replacement, void 0).valueOf();
      },
      "Array, Index, any, any": function ArrayIndexAnyAny(value, index, replacement, defaultValue) {
        return matrix(clone(value)).subset(index, replacement, defaultValue).valueOf();
      },
      "Matrix, Index, any": function MatrixIndexAny(value, index, replacement) {
        return value.clone().subset(index, replacement);
      },
      "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index, replacement, defaultValue) {
        return value.clone().subset(index, replacement, defaultValue);
      },
      "string, Index, string": _setSubstring,
      "string, Index, string, string": _setSubstring,
      "Object, Index, any": _setObjectProperty
    });
  });
  function _getSubstring(str, index) {
    if (!isIndex(index)) {
      throw new TypeError("Index expected");
    }
    if (index.size().length !== 1) {
      throw new DimensionError(index.size().length, 1);
    }
    var strLen = str.length;
    validateIndex(index.min()[0], strLen);
    validateIndex(index.max()[0], strLen);
    var range = index.dimension(0);
    var substr = "";
    range.forEach(function(v) {
      substr += str.charAt(v);
    });
    return substr;
  }
  function _setSubstring(str, index, replacement, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Index expected");
    }
    if (index.size().length !== 1) {
      throw new DimensionError(index.size().length, 1);
    }
    if (defaultValue !== void 0) {
      if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultValue = " ";
    }
    var range = index.dimension(0);
    var len = range.size()[0];
    if (len !== replacement.length) {
      throw new DimensionError(range.size()[0], replacement.length);
    }
    var strLen = str.length;
    validateIndex(index.min()[0]);
    validateIndex(index.max()[0]);
    var chars = [];
    for (var i = 0; i < strLen; i++) {
      chars[i] = str.charAt(i);
    }
    range.forEach(function(v, i2) {
      chars[v] = replacement.charAt(i2[0]);
    });
    if (chars.length > strLen) {
      for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
        if (!chars[_i]) {
          chars[_i] = defaultValue;
        }
      }
    }
    return chars.join("");
  }
  function _getObjectProperty(object, index) {
    if (index.size().length !== 1) {
      throw new DimensionError(index.size(), 1);
    }
    var key = index.dimension(0);
    if (typeof key !== "string") {
      throw new TypeError("String expected as index to retrieve an object property");
    }
    return getSafeProperty(object, key);
  }
  function _setObjectProperty(object, index, replacement) {
    if (index.size().length !== 1) {
      throw new DimensionError(index.size(), 1);
    }
    var key = index.dimension(0);
    if (typeof key !== "string") {
      throw new TypeError("String expected as index to retrieve an object property");
    }
    var updated = clone(object);
    setSafeProperty(updated, key, replacement);
    return updated;
  }

  // node_modules/mathjs/lib/esm/function/matrix/transpose.js
  var name100 = "transpose";
  var dependencies101 = ["typed", "matrix"];
  var createTranspose = /* @__PURE__ */ factory(name100, dependencies101, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return typed("transpose", {
      Array: function Array2(x) {
        return this(matrix(x)).valueOf();
      },
      Matrix: function Matrix(x) {
        var size = x.size();
        var c;
        switch (size.length) {
          case 1:
            c = x.clone();
            break;
          case 2:
            {
              var rows = size[0];
              var columns = size[1];
              if (columns === 0) {
                throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size) + ")");
              }
              switch (x.storage()) {
                case "dense":
                  c = _denseTranspose(x, rows, columns);
                  break;
                case "sparse":
                  c = _sparseTranspose(x, rows, columns);
                  break;
              }
            }
            break;
          default:
            throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(this._size) + ")");
        }
        return c;
      },
      any: function any(x) {
        return clone(x);
      }
    });
    function _denseTranspose(m, rows, columns) {
      var data = m._data;
      var transposed = [];
      var transposedRow;
      for (var j = 0; j < columns; j++) {
        transposedRow = transposed[j] = [];
        for (var i = 0; i < rows; i++) {
          transposedRow[i] = clone(data[i][j]);
        }
      }
      return m.createDenseMatrix({
        data: transposed,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
    function _sparseTranspose(m, rows, columns) {
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var cvalues = values2 ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var w = [];
      for (var x = 0; x < rows; x++) {
        w[x] = 0;
      }
      var p, l, j;
      for (p = 0, l = index.length; p < l; p++) {
        w[index[p]]++;
      }
      var sum = 0;
      for (var i = 0; i < rows; i++) {
        cptr.push(sum);
        sum += w[i];
        w[i] = cptr[i];
      }
      cptr.push(sum);
      for (j = 0; j < columns; j++) {
        for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
          var q = w[index[k]]++;
          cindex[q] = j;
          if (values2) {
            cvalues[q] = clone(values2[k]);
          }
        }
      }
      return m.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
  var name101 = "ctranspose";
  var dependencies102 = ["typed", "transpose", "conj"];
  var createCtranspose = /* @__PURE__ */ factory(name101, dependencies102, (_ref) => {
    var {
      typed,
      transpose,
      conj
    } = _ref;
    return typed(name101, {
      any: function any(x) {
        return conj(transpose(x));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/zeros.js
  var name102 = "zeros";
  var dependencies103 = ["typed", "config", "matrix", "BigNumber"];
  var createZeros = /* @__PURE__ */ factory(name102, dependencies103, (_ref) => {
    var {
      typed,
      config,
      matrix,
      BigNumber
    } = _ref;
    return typed(name102, {
      "": function _4() {
        return config.matrix === "Array" ? _zeros([]) : _zeros([], "default");
      },
      "...number | BigNumber | string": function numberBigNumberString(size) {
        var last = size[size.length - 1];
        if (typeof last === "string") {
          var format4 = size.pop();
          return _zeros(size, format4);
        } else if (config.matrix === "Array") {
          return _zeros(size);
        } else {
          return _zeros(size, "default");
        }
      },
      Array: _zeros,
      Matrix: function Matrix(size) {
        var format4 = size.storage();
        return _zeros(size.valueOf(), format4);
      },
      "Array | Matrix, string": function ArrayMatrixString(size, format4) {
        return _zeros(size.valueOf(), format4);
      }
    });
    function _zeros(size, format4) {
      var hasBigNumbers = _normalize(size);
      var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
      _validate2(size);
      if (format4) {
        var m = matrix(format4);
        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }
        return m;
      } else {
        var arr = [];
        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size) {
      var hasBigNumbers = false;
      size.forEach(function(value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size) {
      size.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error("Parameters in function zeros must be positive integers");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/special/erf.js
  var name103 = "erf";
  var dependencies104 = ["typed"];
  var createErf = /* @__PURE__ */ factory(name103, dependencies104, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("name", {
      number: function number(x) {
        var y = Math.abs(x);
        if (y >= MAX_NUM) {
          return sign(x);
        }
        if (y <= THRESH) {
          return sign(x) * erf1(y);
        }
        if (y <= 4) {
          return sign(x) * (1 - erfc2(y));
        }
        return sign(x) * (1 - erfc3(y));
      },
      "Array | Matrix": function ArrayMatrix(n) {
        return deepMap(n, this);
      }
    });
    function erf1(y) {
      var ysq = y * y;
      var xnum = P[0][4] * ysq;
      var xden = ysq;
      var i;
      for (i = 0; i < 3; i += 1) {
        xnum = (xnum + P[0][i]) * ysq;
        xden = (xden + Q[0][i]) * ysq;
      }
      return y * (xnum + P[0][3]) / (xden + Q[0][3]);
    }
    function erfc2(y) {
      var xnum = P[1][8] * y;
      var xden = y;
      var i;
      for (i = 0; i < 7; i += 1) {
        xnum = (xnum + P[1][i]) * y;
        xden = (xden + Q[1][i]) * y;
      }
      var result = (xnum + P[1][7]) / (xden + Q[1][7]);
      var ysq = parseInt(y * 16) / 16;
      var del = (y - ysq) * (y + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
    function erfc3(y) {
      var ysq = 1 / (y * y);
      var xnum = P[2][5] * ysq;
      var xden = ysq;
      var i;
      for (i = 0; i < 4; i += 1) {
        xnum = (xnum + P[2][i]) * ysq;
        xden = (xden + Q[2][i]) * ysq;
      }
      var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
      result = (SQRPI - result) / y;
      ysq = parseInt(y * 16) / 16;
      var del = (y - ysq) * (y + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
  });
  var THRESH = 0.46875;
  var SQRPI = 0.5641895835477563;
  var P = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
  var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
  var MAX_NUM = Math.pow(2, 53);

  // node_modules/mathjs/lib/esm/function/statistics/mode.js
  var name104 = "mode";
  var dependencies105 = ["typed", "isNaN", "isNumeric"];
  var createMode = /* @__PURE__ */ factory(name104, dependencies105, (_ref) => {
    var {
      typed,
      isNaN: isNaN2,
      isNumeric
    } = _ref;
    return typed(name104, {
      "Array | Matrix": _mode,
      "...": function _4(args) {
        return _mode(args);
      }
    });
    function _mode(values2) {
      values2 = flatten(values2.valueOf());
      var num = values2.length;
      if (num === 0) {
        throw new Error("Cannot calculate mode of an empty array");
      }
      var count = {};
      var mode = [];
      var max = 0;
      for (var i = 0; i < values2.length; i++) {
        var value = values2[i];
        if (isNumeric(value) && isNaN2(value)) {
          throw new Error("Cannot calculate mode of an array containing NaN values");
        }
        if (!(value in count)) {
          count[value] = 0;
        }
        count[value]++;
        if (count[value] === max) {
          mode.push(value);
        } else if (count[value] > max) {
          max = count[value];
          mode = [value];
        }
      }
      return mode;
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
  function improveErrorMessage(err, fnName, value) {
    var details;
    if (String(err).indexOf("Unexpected type") !== -1) {
      details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
      return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
    }
    if (String(err).indexOf("complex numbers") !== -1) {
      details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
      return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
    }
    return err;
  }

  // node_modules/mathjs/lib/esm/function/statistics/prod.js
  var name105 = "prod";
  var dependencies106 = ["typed", "config", "multiplyScalar", "numeric"];
  var createProd = /* @__PURE__ */ factory(name105, dependencies106, (_ref) => {
    var {
      typed,
      config,
      multiplyScalar,
      numeric: numeric2
    } = _ref;
    return typed(name105, {
      "Array | Matrix": _prod,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        throw new Error("prod(A, dim) is not yet supported");
      },
      "...": function _4(args) {
        return _prod(args);
      }
    });
    function _prod(array) {
      var prod;
      deepForEach(array, function(value) {
        try {
          prod = prod === void 0 ? value : multiplyScalar(prod, value);
        } catch (err) {
          throw improveErrorMessage(err, "prod", value);
        }
      });
      if (typeof prod === "string") {
        prod = numeric2(prod, config.number);
      }
      if (prod === void 0) {
        throw new Error("Cannot calculate prod of an empty array");
      }
      return prod;
    }
  });

  // node_modules/mathjs/lib/esm/function/string/format.js
  var name106 = "format";
  var dependencies107 = ["typed"];
  var createFormat = /* @__PURE__ */ factory(name106, dependencies107, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name106, {
      any: format3,
      "any, Object | function | number": format3
    });
  });

  // node_modules/mathjs/lib/esm/function/string/bin.js
  var name107 = "bin";
  var dependencies108 = ["typed", "format"];
  var createBin = factory(name107, dependencies108, (_ref) => {
    var {
      typed,
      format: format4
    } = _ref;
    return typed(name107, {
      "number | BigNumber": function numberBigNumber(n) {
        return format4(n, {
          notation: "bin"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format4(n, {
          notation: "bin",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/string/oct.js
  var name108 = "oct";
  var dependencies109 = ["typed", "format"];
  var createOct = factory(name108, dependencies109, (_ref) => {
    var {
      typed,
      format: format4
    } = _ref;
    return typed(name108, {
      "number | BigNumber": function numberBigNumber(n) {
        return format4(n, {
          notation: "oct"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format4(n, {
          notation: "oct",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/string/hex.js
  var name109 = "hex";
  var dependencies110 = ["typed", "format"];
  var createHex = factory(name109, dependencies110, (_ref) => {
    var {
      typed,
      format: format4
    } = _ref;
    return typed(name109, {
      "number | BigNumber": function numberBigNumber(n) {
        return format4(n, {
          notation: "hex"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format4(n, {
          notation: "hex",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/string/print.js
  var name110 = "print";
  var dependencies111 = ["typed"];
  var createPrint = /* @__PURE__ */ factory(name110, dependencies111, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name110, {
      "string, Object | Array": _print,
      "string, Object | Array, number | Object": _print
    });
  });
  function _print(template, values2, options) {
    return template.replace(/\$([\w.]+)/g, function(original, key) {
      var keys = key.split(".");
      var value = values2[keys.shift()];
      while (keys.length && value !== void 0) {
        var k = keys.shift();
        value = k ? value[k] : value + ".";
      }
      if (value !== void 0) {
        if (!isString(value)) {
          return format3(value, options);
        } else {
          return value;
        }
      }
      return original;
    });
  }

  // node_modules/mathjs/lib/esm/function/unit/to.js
  var name111 = "to";
  var dependencies112 = ["typed", "matrix"];
  var createTo = /* @__PURE__ */ factory(name111, dependencies112, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name111, {
      "Unit, Unit | string": function UnitUnitString(x, unit) {
        return x.to(unit);
      },
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "Matrix, any": function MatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, Matrix": function anyMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isPrime.js
  var name112 = "isPrime";
  var dependencies113 = ["typed"];
  var createIsPrime = /* @__PURE__ */ factory(name112, dependencies113, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name112, {
      number: function number(x) {
        if (x * 0 !== 0) {
          return false;
        }
        if (x <= 3) {
          return x > 1;
        }
        if (x % 2 === 0 || x % 3 === 0) {
          return false;
        }
        for (var i = 5; i * i <= x; i += 6) {
          if (x % i === 0 || x % (i + 2) === 0) {
            return false;
          }
        }
        return true;
      },
      BigNumber: function BigNumber(n) {
        if (n.toNumber() * 0 !== 0) {
          return false;
        }
        if (n.lte(3))
          return n.gt(1);
        if (n.mod(2).eq(0) || n.mod(3).eq(0))
          return false;
        for (var i = 5; n.gte(i * i); i += 6) {
          if (n.mod(i).eq(0) || n.mod(i + 2).eq(0)) {
            return false;
          }
        }
        return true;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/numeric.js
  var name113 = "numeric";
  var dependencies114 = ["number", "?bignumber", "?fraction"];
  var createNumeric = /* @__PURE__ */ factory(name113, dependencies114, (_ref) => {
    var {
      number: _number,
      bignumber,
      fraction
    } = _ref;
    var validInputTypes = {
      string: true,
      number: true,
      BigNumber: true,
      Fraction: true
    };
    var validOutputTypes = {
      number: (x) => _number(x),
      BigNumber: bignumber ? (x) => bignumber(x) : noBignumber,
      Fraction: fraction ? (x) => fraction(x) : noFraction
    };
    return function numeric2(value, outputType) {
      var inputType = typeOf(value);
      if (!(inputType in validInputTypes)) {
        throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
      }
      if (!(outputType in validOutputTypes)) {
        throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
      }
      if (outputType === inputType) {
        return value;
      } else {
        return validOutputTypes[outputType](value);
      }
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
  var name114 = "divideScalar";
  var dependencies115 = ["typed", "numeric"];
  var createDivideScalar = /* @__PURE__ */ factory(name114, dependencies115, (_ref) => {
    var {
      typed,
      numeric: numeric2
    } = _ref;
    return typed(name114, {
      "number, number": function numberNumber2(x, y) {
        return x / y;
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.div(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.div(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.div(y);
      },
      "Unit, number | Fraction | BigNumber": function UnitNumberFractionBigNumber(x, y) {
        var res = x.clone();
        var one = numeric2(1, typeOf(y));
        res.value = this(res.value === null ? res._normalize(one) : res.value, y);
        return res;
      },
      "number | Fraction | BigNumber, Unit": function numberFractionBigNumberUnit(x, y) {
        var res = y.clone();
        res = res.pow(-1);
        var one = numeric2(1, typeOf(x));
        res.value = this(x, y.value === null ? y._normalize(one) : y.value);
        return res;
      },
      "Unit, Unit": function UnitUnit(x, y) {
        return x.divide(y);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/pow.js
  var name115 = "pow";
  var dependencies116 = ["typed", "config", "identity", "multiply", "matrix", "fraction", "number", "Complex"];
  var createPow = /* @__PURE__ */ factory(name115, dependencies116, (_ref) => {
    var {
      typed,
      config,
      identity,
      multiply,
      matrix,
      number,
      fraction,
      Complex: Complex2
    } = _ref;
    return typed(name115, {
      "number, number": _pow,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.pow(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        if (y.isInteger() || x >= 0 || config.predictable) {
          return x.pow(y);
        } else {
          return new Complex2(x.toNumber(), 0).pow(y.toNumber(), 0);
        }
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        if (y.d !== 1) {
          if (config.predictable) {
            throw new Error("Function pow does not support non-integer exponents for fractions.");
          } else {
            return _pow(x.valueOf(), y.valueOf());
          }
        } else {
          return x.pow(y);
        }
      },
      "Array, number": _powArray,
      "Array, BigNumber": function ArrayBigNumber(x, y) {
        return _powArray(x, y.toNumber());
      },
      "Matrix, number": _powMatrix,
      "Matrix, BigNumber": function MatrixBigNumber(x, y) {
        return _powMatrix(x, y.toNumber());
      },
      "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
        return x.pow(y);
      }
    });
    function _pow(x, y) {
      if (config.predictable && !isInteger(y) && x < 0) {
        try {
          var yFrac = fraction(y);
          var yNum = number(yFrac);
          if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
            if (yFrac.d % 2 === 1) {
              return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
            }
          }
        } catch (ex) {
        }
      }
      if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
        return NaN;
      }
      if (isInteger(y) || x >= 0 || config.predictable) {
        return powNumber(x, y);
      } else {
        if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
          return 0;
        }
        return new Complex2(x, 0).pow(y, 0);
      }
    }
    function _powArray(x, y) {
      if (!isInteger(y) || y < 0) {
        throw new TypeError("For A^b, b must be a positive integer (value is " + y + ")");
      }
      var s = arraySize(x);
      if (s.length !== 2) {
        throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
      }
      if (s[0] !== s[1]) {
        throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
      }
      var res = identity(s[0]).valueOf();
      var px = x;
      while (y >= 1) {
        if ((y & 1) === 1) {
          res = multiply(px, res);
        }
        y >>= 1;
        px = multiply(px, px);
      }
      return res;
    }
    function _powMatrix(x, y) {
      return matrix(_powArray(x.valueOf(), y));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/round.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var NO_INT = "Number of decimals in function round must be an integer";
  var name116 = "round";
  var dependencies117 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
  var createRound = /* @__PURE__ */ factory(name116, dependencies117, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      BigNumber,
      DenseMatrix
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name116, _objectSpread(_objectSpread({}, roundNumberSignatures), {}, {
      Complex: function Complex2(x) {
        return x.round();
      },
      "Complex, number": function ComplexNumber(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }
        return x.round(n);
      },
      "Complex, BigNumber": function ComplexBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        var _n = n.toNumber();
        return x.round(_n);
      },
      "number, BigNumber": function numberBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return new BigNumber(x).toDecimalPlaces(n.toNumber());
      },
      BigNumber: function BigNumber2(x) {
        return x.toDecimalPlaces(0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return x.toDecimalPlaces(n.toNumber());
      },
      Fraction: function Fraction2(x) {
        return x.round();
      },
      "Fraction, number": function FractionNumber(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }
        return x.round(n);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      "number | Complex | BigNumber, SparseMatrix": function numberComplexBigNumberSparseMatrix(x, y) {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return algorithm12(y, x, this, true);
      },
      "number | Complex | BigNumber, DenseMatrix": function numberComplexBigNumberDenseMatrix(x, y) {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return algorithm14(y, x, this, true);
      },
      "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "number | Complex | BigNumber, Array": function numberComplexBigNumberArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    }));
  });
  var roundNumberSignatures = {
    number: roundNumber,
    "number, number": function numberNumber(x, n) {
      if (!isInteger(n)) {
        throw new TypeError(NO_INT);
      }
      if (n < 0 || n > 15) {
        throw new Error("Number of decimals in function round must be in te range of 0-15");
      }
      return roundNumber(x, n);
    }
  };

  // node_modules/mathjs/lib/esm/function/arithmetic/log.js
  var name117 = "log";
  var dependencies118 = ["config", "typed", "divideScalar", "Complex"];
  var createLog = /* @__PURE__ */ factory(name117, dependencies118, (_ref) => {
    var {
      typed,
      config,
      divideScalar,
      Complex: Complex2
    } = _ref;
    return typed(name117, {
      number: function number(x) {
        if (x >= 0 || config.predictable) {
          return logNumber(x);
        } else {
          return new Complex2(x, 0).log();
        }
      },
      Complex: function Complex3(x) {
        return x.log();
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.ln();
        } else {
          return new Complex2(x.toNumber(), 0).log();
        }
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      },
      "any, any": function anyAny(x, base) {
        return divideScalar(this(x), this(base));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
  var name118 = "log1p";
  var dependencies119 = ["typed", "config", "divideScalar", "log", "Complex"];
  var createLog1p = /* @__PURE__ */ factory(name118, dependencies119, (_ref) => {
    var {
      typed,
      config,
      divideScalar,
      log,
      Complex: Complex2
    } = _ref;
    return typed(name118, {
      number: function number(x) {
        if (x >= -1 || config.predictable) {
          return log1p(x);
        } else {
          return _log1pComplex(new Complex2(x, 0));
        }
      },
      Complex: _log1pComplex,
      BigNumber: function BigNumber(x) {
        var y = x.plus(1);
        if (!y.isNegative() || config.predictable) {
          return y.ln();
        } else {
          return _log1pComplex(new Complex2(x.toNumber(), 0));
        }
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      },
      "any, any": function anyAny(x, base) {
        return divideScalar(this(x), log(base));
      }
    });
    function _log1pComplex(x) {
      var xRe1p = x.re + 1;
      return new Complex2(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
  var name119 = "nthRoots";
  var dependencies120 = ["config", "typed", "divideScalar", "Complex"];
  var createNthRoots = /* @__PURE__ */ factory(name119, dependencies120, (_ref) => {
    var {
      typed,
      config,
      divideScalar,
      Complex: Complex2
    } = _ref;
    var _calculateExactResult = [function realPos(val) {
      return new Complex2(val, 0);
    }, function imagPos(val) {
      return new Complex2(0, val);
    }, function realNeg(val) {
      return new Complex2(-val, 0);
    }, function imagNeg(val) {
      return new Complex2(0, -val);
    }];
    function _nthComplexRoots(a, root) {
      if (root < 0)
        throw new Error("Root must be greater than zero");
      if (root === 0)
        throw new Error("Root must be non-zero");
      if (root % 1 !== 0)
        throw new Error("Root must be an integer");
      if (a === 0 || a.abs() === 0)
        return [new Complex2(0, 0)];
      var aIsNumeric = typeof a === "number";
      var offset;
      if (aIsNumeric || a.re === 0 || a.im === 0) {
        if (aIsNumeric) {
          offset = 2 * +(a < 0);
        } else if (a.im === 0) {
          offset = 2 * +(a.re < 0);
        } else {
          offset = 2 * +(a.im < 0) + 1;
        }
      }
      var arg = a.arg();
      var abs = a.abs();
      var roots = [];
      var r = Math.pow(abs, 1 / root);
      for (var k = 0; k < root; k++) {
        var halfPiFactor = (offset + 4 * k) / root;
        if (halfPiFactor === Math.round(halfPiFactor)) {
          roots.push(_calculateExactResult[halfPiFactor % 4](r));
          continue;
        }
        roots.push(new Complex2({
          r,
          phi: (arg + 2 * Math.PI * k) / root
        }));
      }
      return roots;
    }
    return typed(name119, {
      Complex: function Complex3(x) {
        return _nthComplexRoots(x, 2);
      },
      "Complex, number": _nthComplexRoots
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
  var name120 = "dotPow";
  var dependencies121 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix"];
  var createDotPow = /* @__PURE__ */ factory(name120, dependencies121, (_ref) => {
    var {
      typed,
      equalScalar,
      matrix,
      pow,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name120, {
      "any, any": pow,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, pow, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, pow, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, pow, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, pow);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
  var name121 = "dotDivide";
  var dependencies122 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix"];
  var createDotDivide = /* @__PURE__ */ factory(name121, dependencies122, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      divideScalar,
      DenseMatrix
    } = _ref;
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name121, {
      "any, any": divideScalar,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, divideScalar, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, divideScalar, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, divideScalar, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, divideScalar);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, divideScalar, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, divideScalar, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, divideScalar, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, divideScalar, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, divideScalar, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, divideScalar, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
  function createSolveValidation(_ref) {
    var {
      DenseMatrix
    } = _ref;
    return function solveValidation(m, b, copy) {
      var mSize = m.size();
      if (mSize.length !== 2) {
        throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
      }
      var rows = mSize[0];
      var columns = mSize[1];
      if (rows !== columns) {
        throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
      }
      var data = [];
      if (isMatrix(b)) {
        var bSize = b.size();
        var bdata = b._data;
        if (bSize.length === 1) {
          if (bSize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var i = 0; i < rows; i++) {
            data[i] = [bdata[i]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
        if (bSize.length === 2) {
          if (bSize[0] !== rows || bSize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          if (isDenseMatrix(b)) {
            if (copy) {
              data = [];
              for (var _i = 0; _i < rows; _i++) {
                data[_i] = [bdata[_i][0]];
              }
              return new DenseMatrix({
                data,
                size: [rows, 1],
                datatype: b._datatype
              });
            }
            return b;
          }
          if (isSparseMatrix(b)) {
            for (var _i2 = 0; _i2 < rows; _i2++) {
              data[_i2] = [0];
            }
            var values2 = b._values;
            var index = b._index;
            var ptr = b._ptr;
            for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
              var _i3 = index[k];
              data[_i3][0] = values2[k];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
      if (isArray(b)) {
        var bsize = arraySize(b);
        if (bsize.length === 1) {
          if (bsize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i4 = 0; _i4 < rows; _i4++) {
            data[_i4] = [b[_i4]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1]
          });
        }
        if (bsize.length === 2) {
          if (bsize[0] !== rows || bsize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i5 = 0; _i5 < rows; _i5++) {
            data[_i5] = [b[_i5][0]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1]
          });
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
    };
  }

  // node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
  var name122 = "lsolve";
  var dependencies123 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createLsolve = /* @__PURE__ */ factory(name122, dependencies123, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name122, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseForwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseForwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var r = _denseForwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseForwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var x = [];
      var mdata = m._data;
      for (var j = 0; j < columns; j++) {
        var bj = bdata[j][0] || 0;
        var xj = void 0;
        if (!equalScalar(bj, 0)) {
          var vjj = mdata[j][j];
          if (equalScalar(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          xj = divideScalar(bj, vjj);
          for (var i = j + 1; i < rows; i++) {
            bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseForwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var x = [];
      for (var j = 0; j < columns; j++) {
        var bj = bdata[j][0] || 0;
        if (!equalScalar(bj, 0)) {
          var vjj = 0;
          var jValues = [];
          var jIndices = [];
          var firstIndex = ptr[j];
          var lastIndex = ptr[j + 1];
          for (var k = firstIndex; k < lastIndex; k++) {
            var i = index[k];
            if (i === j) {
              vjj = values2[k];
            } else if (i > j) {
              jValues.push(values2[k]);
              jIndices.push(i);
            }
          }
          if (equalScalar(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          var xj = divideScalar(bj, vjj);
          for (var _k = 0, l = jIndices.length; _k < l; _k++) {
            var _i = jIndices[_k];
            bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
  var name123 = "usolve";
  var dependencies124 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createUsolve = /* @__PURE__ */ factory(name123, dependencies124, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name123, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var r = _denseBackwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseBackwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var x = [];
      var mdata = m._data;
      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        var xj = void 0;
        if (!equalScalar(bj, 0)) {
          var vjj = mdata[j][j];
          if (equalScalar(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          xj = divideScalar(bj, vjj);
          for (var i = j - 1; i >= 0; i--) {
            bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseBackwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var x = [];
      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        if (!equalScalar(bj, 0)) {
          var vjj = 0;
          var jValues = [];
          var jIndices = [];
          var firstIndex = ptr[j];
          var lastIndex = ptr[j + 1];
          for (var k = lastIndex - 1; k >= firstIndex; k--) {
            var i = index[k];
            if (i === j) {
              vjj = values2[k];
            } else if (i < j) {
              jValues.push(values2[k]);
              jIndices.push(i);
            }
          }
          if (equalScalar(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          var xj = divideScalar(bj, vjj);
          for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
            var _i = jIndices[_k];
            bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
  var name124 = "lsolveAll";
  var dependencies125 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createLsolveAll = /* @__PURE__ */ factory(name124, dependencies125, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name124, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseForwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseForwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var R = _denseForwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseForwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
      var M = m._data;
      var rows = m._size[0];
      var columns = m._size[1];
      for (var i = 0; i < columns; i++) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          if (!equalScalar(M[i][i], 0)) {
            b[i] = divideScalar(b[i], M[i][i]);
            for (var j = i + 1; j < columns; j++) {
              b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j = i + 1; _j < columns; _j++) {
              bNew[_j] = subtract(bNew[_j], M[_j][i]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix({
        data: x.map((e2) => [e2]),
        size: [rows, 1]
      }));
    }
    function _sparseForwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
      var rows = m._size[0];
      var columns = m._size[1];
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      for (var i = 0; i < columns; i++) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          var iValues = [];
          var iIndices = [];
          var firstIndex = ptr[i];
          var lastIndex = ptr[i + 1];
          var Mii = 0;
          for (var j = firstIndex; j < lastIndex; j++) {
            var J = index[j];
            if (J === i) {
              Mii = values2[j];
            } else if (J > i) {
              iValues.push(values2[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar(Mii, 0)) {
            b[i] = divideScalar(b[i], Mii);
            for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
              var _J = iIndices[_j2];
              b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
              var _J2 = iIndices[_j3];
              bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix({
        data: x.map((e2) => [e2]),
        size: [rows, 1]
      }));
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
  var name125 = "usolveAll";
  var dependencies126 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createUsolveAll = /* @__PURE__ */ factory(name125, dependencies126, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name125, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var R = _denseBackwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseBackwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
      var M = m._data;
      var rows = m._size[0];
      var columns = m._size[1];
      for (var i = columns - 1; i >= 0; i--) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          if (!equalScalar(M[i][i], 0)) {
            b[i] = divideScalar(b[i], M[i][i]);
            for (var j = i - 1; j >= 0; j--) {
              b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j = i - 1; _j >= 0; _j--) {
              bNew[_j] = subtract(bNew[_j], M[_j][i]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix({
        data: x.map((e2) => [e2]),
        size: [rows, 1]
      }));
    }
    function _sparseBackwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
      var rows = m._size[0];
      var columns = m._size[1];
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      for (var i = columns - 1; i >= 0; i--) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          var iValues = [];
          var iIndices = [];
          var firstIndex = ptr[i];
          var lastIndex = ptr[i + 1];
          var Mii = 0;
          for (var j = lastIndex - 1; j >= firstIndex; j--) {
            var J = index[j];
            if (J === i) {
              Mii = values2[j];
            } else if (J < i) {
              iValues.push(values2[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar(Mii, 0)) {
            b[i] = divideScalar(b[i], Mii);
            for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
              var _J = iIndices[_j2];
              b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
              var _J2 = iIndices[_j3];
              bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix({
        data: x.map((e2) => [e2]),
        size: [rows, 1]
      }));
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/algorithm08.js
  var name126 = "algorithm08";
  var dependencies127 = ["typed", "equalScalar"];
  var createAlgorithm08 = /* @__PURE__ */ factory(name126, dependencies127, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function algorithm08(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!avalues || !bvalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrices");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var x = [];
      var w = [];
      var k, k0, k1, i;
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          w[i] = mark;
          x[i] = avalues[k];
          cindex.push(i);
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          if (w[i] === mark) {
            x[i] = cf(x[i], bvalues[k]);
          }
        }
        k = cptr[j];
        while (k < cindex.length) {
          i = cindex[k];
          var v = x[i];
          if (!eq(v, zero)) {
            cvalues.push(v);
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
  var name127 = "leftShift";
  var dependencies128 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createLeftShift = /* @__PURE__ */ factory(name127, dependencies128, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm08 = createAlgorithm08({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name127, {
      "number, number": leftShiftNumber,
      "BigNumber, BigNumber": leftShiftBigNumber,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm08(x, y, this, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return algorithm14(x, y, this, false);
      },
      "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return algorithm10(y, x, this, true);
      },
      "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return algorithm14(y, x, this, true);
      },
      "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
        return this(matrix(x), y).valueOf();
      },
      "number | BigNumber, Array": function numberBigNumberArray(x, y) {
        return this(x, matrix(y)).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
  var name128 = "rightArithShift";
  var dependencies129 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createRightArithShift = /* @__PURE__ */ factory(name128, dependencies129, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm08 = createAlgorithm08({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name128, {
      "number, number": rightArithShiftNumber,
      "BigNumber, BigNumber": rightArithShiftBigNumber,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm08(x, y, this, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return algorithm14(x, y, this, false);
      },
      "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return algorithm10(y, x, this, true);
      },
      "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return algorithm14(y, x, this, true);
      },
      "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
        return this(matrix(x), y).valueOf();
      },
      "number | BigNumber, Array": function numberBigNumberArray(x, y) {
        return this(x, matrix(y)).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
  var name129 = "rightLogShift";
  var dependencies130 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createRightLogShift = /* @__PURE__ */ factory(name129, dependencies130, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm08 = createAlgorithm08({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name129, {
      "number, number": rightLogShiftNumber,
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm08(x, y, this, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return algorithm14(x, y, this, false);
      },
      "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return algorithm10(y, x, this, true);
      },
      "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return algorithm14(y, x, this, true);
      },
      "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
        return this(matrix(x), y).valueOf();
      },
      "number | BigNumber, Array": function numberBigNumberArray(x, y) {
        return this(x, matrix(y)).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/logical/and.js
  var name130 = "and";
  var dependencies131 = ["typed", "matrix", "equalScalar", "zeros", "not"];
  var createAnd = /* @__PURE__ */ factory(name130, dependencies131, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      not
    } = _ref;
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm06 = createAlgorithm06({
      typed,
      equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name130, {
      "number, number": andNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
      },
      "Unit, Unit": function UnitUnit(x, y) {
        return this(x.value || 0, y.value || 0);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm06(x, y, this, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm02(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        if (not(y)) {
          return zeros2(x.size(), x.storage());
        }
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        if (not(y)) {
          return zeros2(x.size(), x.storage());
        }
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        if (not(x)) {
          return zeros2(x.size(), x.storage());
        }
        return algorithm11(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        if (not(x)) {
          return zeros2(x.size(), x.storage());
        }
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return this(matrix(x), y).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return this(x, matrix(y)).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/compare.js
  var name131 = "compare";
  var dependencies132 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix"];
  var createCompare = /* @__PURE__ */ factory(name131, dependencies132, (_ref) => {
    var {
      typed,
      config,
      equalScalar,
      matrix,
      BigNumber,
      Fraction: Fraction2,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm05 = createAlgorithm05({
      typed,
      equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name131, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x === y ? 0 : x > y ? 1 : -1;
      },
      "number, number": function numberNumber2(x, y) {
        return nearlyEqual(x, y, config.epsilon) ? 0 : x > y ? 1 : -1;
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return nearlyEqual2(x, y, config.epsilon) ? new BigNumber(0) : new BigNumber(x.cmp(y));
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return new Fraction2(x.compare(y));
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm05(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/compareNatural.js
  var import_javascript_natural_sort = __toModule(require_naturalSort());
  var name132 = "compareNatural";
  var dependencies133 = ["typed", "compare"];
  var createCompareNatural = /* @__PURE__ */ factory(name132, dependencies133, (_ref) => {
    var {
      typed,
      compare
    } = _ref;
    var compareBooleans = compare.signatures["boolean,boolean"];
    return typed(name132, {
      "any, any": function anyAny(x, y) {
        var typeX = typeOf(x);
        var typeY = typeOf(y);
        var c;
        if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
          c = compare(x, y);
          if (c.toString() !== "0") {
            return c > 0 ? 1 : -1;
          } else {
            return (0, import_javascript_natural_sort.default)(typeX, typeY);
          }
        }
        if (typeX === "Array" || typeX === "Matrix" || typeY === "Array" || typeY === "Matrix") {
          c = compareMatricesAndArrays(this, x, y);
          if (c !== 0) {
            return c;
          } else {
            return (0, import_javascript_natural_sort.default)(typeX, typeY);
          }
        }
        if (typeX !== typeY) {
          return (0, import_javascript_natural_sort.default)(typeX, typeY);
        }
        if (typeX === "Complex") {
          return compareComplexNumbers(x, y);
        }
        if (typeX === "Unit") {
          if (x.equalBase(y)) {
            return this(x.value, y.value);
          }
          return compareArrays(this, x.formatUnits(), y.formatUnits());
        }
        if (typeX === "boolean") {
          return compareBooleans(x, y);
        }
        if (typeX === "string") {
          return (0, import_javascript_natural_sort.default)(x, y);
        }
        if (typeX === "Object") {
          return compareObjects(this, x, y);
        }
        if (typeX === "null") {
          return 0;
        }
        if (typeX === "undefined") {
          return 0;
        }
        throw new TypeError('Unsupported type of value "' + typeX + '"');
      }
    });
    function compareMatricesAndArrays(compareNatural, x, y) {
      if (isSparseMatrix(x) && isSparseMatrix(y)) {
        return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);
      }
      if (isSparseMatrix(x)) {
        return compareMatricesAndArrays(compareNatural, x.toArray(), y);
      }
      if (isSparseMatrix(y)) {
        return compareMatricesAndArrays(compareNatural, x, y.toArray());
      }
      if (isDenseMatrix(x)) {
        return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);
      }
      if (isDenseMatrix(y)) {
        return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);
      }
      if (!Array.isArray(x)) {
        return compareMatricesAndArrays(compareNatural, [x], y);
      }
      if (!Array.isArray(y)) {
        return compareMatricesAndArrays(compareNatural, x, [y]);
      }
      return compareArrays(compareNatural, x, y);
    }
    function compareArrays(compareNatural, x, y) {
      for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {
        var v = compareNatural(x[i], y[i]);
        if (v !== 0) {
          return v;
        }
      }
      if (x.length > y.length) {
        return 1;
      }
      if (x.length < y.length) {
        return -1;
      }
      return 0;
    }
    function compareObjects(compareNatural, x, y) {
      var keysX = Object.keys(x);
      var keysY = Object.keys(y);
      keysX.sort(import_javascript_natural_sort.default);
      keysY.sort(import_javascript_natural_sort.default);
      var c = compareArrays(compareNatural, keysX, keysY);
      if (c !== 0) {
        return c;
      }
      for (var i = 0; i < keysX.length; i++) {
        var v = compareNatural(x[keysX[i]], y[keysY[i]]);
        if (v !== 0) {
          return v;
        }
      }
      return 0;
    }
  });
  function compareComplexNumbers(x, y) {
    if (x.re > y.re) {
      return 1;
    }
    if (x.re < y.re) {
      return -1;
    }
    if (x.im > y.im) {
      return 1;
    }
    if (x.im < y.im) {
      return -1;
    }
    return 0;
  }

  // node_modules/mathjs/lib/esm/function/relational/compareText.js
  var name133 = "compareText";
  var dependencies134 = ["typed", "matrix"];
  var createCompareText = /* @__PURE__ */ factory(name133, dependencies134, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name133, {
      "any, any": compareText,
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, compareText);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, compareText, false);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, compareText, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, compareText, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, compareText, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/equal.js
  var name134 = "equal";
  var dependencies135 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createEqual = /* @__PURE__ */ factory(name134, dependencies135, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name134, {
      "any, any": function anyAny(x, y) {
        if (x === null) {
          return y === null;
        }
        if (y === null) {
          return x === null;
        }
        if (x === void 0) {
          return y === void 0;
        }
        if (y === void 0) {
          return x === void 0;
        }
        return equalScalar(x, y);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, equalScalar);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, equalScalar, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, equalScalar, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, equalScalar);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, equalScalar, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, equalScalar, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, equalScalar, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, equalScalar, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, equalScalar, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, equalScalar, true).valueOf();
      }
    });
  });
  var createEqualNumber = factory(name134, ["typed", "equalScalar"], (_ref2) => {
    var {
      typed,
      equalScalar
    } = _ref2;
    return typed(name134, {
      "any, any": function anyAny(x, y) {
        if (x === null) {
          return y === null;
        }
        if (y === null) {
          return x === null;
        }
        if (x === void 0) {
          return y === void 0;
        }
        if (y === void 0) {
          return x === void 0;
        }
        return equalScalar(x, y);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/equalText.js
  var name135 = "equalText";
  var dependencies136 = ["typed", "compareText", "isZero"];
  var createEqualText = /* @__PURE__ */ factory(name135, dependencies136, (_ref) => {
    var {
      typed,
      compareText: compareText2,
      isZero
    } = _ref;
    return typed(name135, {
      "any, any": function anyAny(x, y) {
        return isZero(compareText2(x, y));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/smaller.js
  var name136 = "smaller";
  var dependencies137 = ["typed", "config", "matrix", "DenseMatrix"];
  var createSmaller = /* @__PURE__ */ factory(name136, dependencies137, (_ref) => {
    var {
      typed,
      config,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name136, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x < y;
      },
      "number, number": function numberNumber2(x, y) {
        return x < y && !nearlyEqual(x, y, config.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.lt(y) && !nearlyEqual2(x, y, config.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.compare(y) === -1;
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/smallerEq.js
  var name137 = "smallerEq";
  var dependencies138 = ["typed", "config", "matrix", "DenseMatrix"];
  var createSmallerEq = /* @__PURE__ */ factory(name137, dependencies138, (_ref) => {
    var {
      typed,
      config,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name137, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x <= y;
      },
      "number, number": function numberNumber2(x, y) {
        return x <= y || nearlyEqual(x, y, config.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.lte(y) || nearlyEqual2(x, y, config.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.compare(y) !== 1;
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/larger.js
  var name138 = "larger";
  var dependencies139 = ["typed", "config", "matrix", "DenseMatrix"];
  var createLarger = /* @__PURE__ */ factory(name138, dependencies139, (_ref) => {
    var {
      typed,
      config,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name138, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x > y;
      },
      "number, number": function numberNumber2(x, y) {
        return x > y && !nearlyEqual(x, y, config.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.gt(y) && !nearlyEqual2(x, y, config.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.compare(y) === 1;
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/largerEq.js
  var name139 = "largerEq";
  var dependencies140 = ["typed", "config", "matrix", "DenseMatrix"];
  var createLargerEq = /* @__PURE__ */ factory(name139, dependencies140, (_ref) => {
    var {
      typed,
      config,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name139, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x >= y;
      },
      "number, number": function numberNumber2(x, y) {
        return x >= y || nearlyEqual(x, y, config.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.gte(y) || nearlyEqual2(x, y, config.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.compare(y) !== -1;
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/deepEqual.js
  var name140 = "deepEqual";
  var dependencies141 = ["typed", "equal"];
  var createDeepEqual = /* @__PURE__ */ factory(name140, dependencies141, (_ref) => {
    var {
      typed,
      equal
    } = _ref;
    return typed(name140, {
      "any, any": function anyAny(x, y) {
        return _deepEqual(x.valueOf(), y.valueOf());
      }
    });
    function _deepEqual(x, y) {
      if (Array.isArray(x)) {
        if (Array.isArray(y)) {
          var len = x.length;
          if (len !== y.length) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            if (!_deepEqual(x[i], y[i])) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      } else {
        if (Array.isArray(y)) {
          return false;
        } else {
          return equal(x, y);
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/unequal.js
  var name141 = "unequal";
  var dependencies142 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix"];
  var createUnequal = /* @__PURE__ */ factory(name141, dependencies142, (_ref) => {
    var {
      typed,
      config,
      equalScalar,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed("unequal", {
      "any, any": function anyAny(x, y) {
        if (x === null) {
          return y !== null;
        }
        if (y === null) {
          return x !== null;
        }
        if (x === void 0) {
          return y !== void 0;
        }
        if (y === void 0) {
          return x !== void 0;
        }
        return _unequal(x, y);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, _unequal);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, _unequal, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, _unequal, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, _unequal);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, _unequal, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, _unequal, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, _unequal, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, _unequal, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, _unequal, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, _unequal, true).valueOf();
      }
    });
    function _unequal(x, y) {
      return !equalScalar(x, y);
    }
  });
  var createUnequalNumber = factory(name141, ["typed", "equalScalar"], (_ref2) => {
    var {
      typed,
      equalScalar
    } = _ref2;
    return typed(name141, {
      "any, any": function anyAny(x, y) {
        if (x === null) {
          return y !== null;
        }
        if (y === null) {
          return x !== null;
        }
        if (x === void 0) {
          return y !== void 0;
        }
        if (y === void 0) {
          return x !== void 0;
        }
        return !equalScalar(x, y);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
  var name142 = "partitionSelect";
  var dependencies143 = ["typed", "isNumeric", "isNaN", "compare"];
  var createPartitionSelect = /* @__PURE__ */ factory(name142, dependencies143, (_ref) => {
    var {
      typed,
      isNumeric,
      isNaN: isNaN2,
      compare
    } = _ref;
    var asc = compare;
    var desc = (a, b) => -compare(a, b);
    return typed(name142, {
      "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
        return _partitionSelect(x, k, asc);
      },
      "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare2) {
        if (compare2 === "asc") {
          return _partitionSelect(x, k, asc);
        } else if (compare2 === "desc") {
          return _partitionSelect(x, k, desc);
        } else {
          throw new Error('Compare string must be "asc" or "desc"');
        }
      },
      "Array | Matrix, number, function": _partitionSelect
    });
    function _partitionSelect(x, k, compare2) {
      if (!isInteger(k) || k < 0) {
        throw new Error("k must be a non-negative integer");
      }
      if (isMatrix(x)) {
        var size = x.size();
        if (size.length > 1) {
          throw new Error("Only one dimensional matrices supported");
        }
        return quickSelect(x.valueOf(), k, compare2);
      }
      if (Array.isArray(x)) {
        return quickSelect(x, k, compare2);
      }
    }
    function quickSelect(arr, k, compare2) {
      if (k >= arr.length) {
        throw new Error("k out of bounds");
      }
      for (var i = 0; i < arr.length; i++) {
        if (isNumeric(arr[i]) && isNaN2(arr[i])) {
          return arr[i];
        }
      }
      var from = 0;
      var to = arr.length - 1;
      while (from < to) {
        var r = from;
        var w = to;
        var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];
        while (r < w) {
          if (compare2(arr[r], pivot) >= 0) {
            var tmp = arr[w];
            arr[w] = arr[r];
            arr[r] = tmp;
            --w;
          } else {
            ++r;
          }
        }
        if (compare2(arr[r], pivot) > 0) {
          --r;
        }
        if (k <= r) {
          to = r;
        } else {
          from = r + 1;
        }
      }
      return arr[k];
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/sort.js
  var name143 = "sort";
  var dependencies144 = ["typed", "matrix", "compare", "compareNatural"];
  var createSort = /* @__PURE__ */ factory(name143, dependencies144, (_ref) => {
    var {
      typed,
      matrix,
      compare,
      compareNatural
    } = _ref;
    var compareAsc = compare;
    var compareDesc = (a, b) => -compare(a, b);
    return typed(name143, {
      Array: function Array2(x) {
        _arrayIsVector(x);
        return x.sort(compareAsc);
      },
      Matrix: function Matrix(x) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(compareAsc), x.storage());
      },
      "Array, function": function ArrayFunction(x, _comparator2) {
        _arrayIsVector(x);
        return x.sort(_comparator2);
      },
      "Matrix, function": function MatrixFunction(x, _comparator2) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(_comparator2), x.storage());
      },
      "Array, string": function ArrayString(x, order) {
        _arrayIsVector(x);
        return x.sort(_comparator(order));
      },
      "Matrix, string": function MatrixString(x, order) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(_comparator(order)), x.storage());
      }
    });
    function _comparator(order) {
      if (order === "asc") {
        return compareAsc;
      } else if (order === "desc") {
        return compareDesc;
      } else if (order === "natural") {
        return compareNatural;
      } else {
        throw new Error('String "asc", "desc", or "natural" expected');
      }
    }
    function _arrayIsVector(array) {
      if (arraySize(array).length !== 1) {
        throw new Error("One dimensional array expected");
      }
    }
    function _matrixIsVector(matrix2) {
      if (matrix2.size().length !== 1) {
        throw new Error("One dimensional matrix expected");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/max.js
  var name144 = "max";
  var dependencies145 = ["typed", "config", "numeric", "larger"];
  var createMax = /* @__PURE__ */ factory(name144, dependencies145, (_ref) => {
    var {
      typed,
      config,
      numeric: numeric2,
      larger
    } = _ref;
    return typed(name144, {
      "Array | Matrix": _max,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return reduce(array, dim.valueOf(), _largest);
      },
      "...": function _4(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function max");
        }
        return _max(args);
      }
    });
    function _largest(x, y) {
      try {
        return larger(x, y) ? x : y;
      } catch (err) {
        throw improveErrorMessage(err, "max", y);
      }
    }
    function _max(array) {
      var res;
      deepForEach(array, function(value) {
        try {
          if (isNaN(value) && typeof value === "number") {
            res = NaN;
          } else if (res === void 0 || larger(value, res)) {
            res = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, "max", value);
        }
      });
      if (res === void 0) {
        throw new Error("Cannot calculate max of an empty array");
      }
      if (typeof res === "string") {
        res = numeric2(res, config.number);
      }
      return res;
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/min.js
  var name145 = "min";
  var dependencies146 = ["typed", "config", "numeric", "smaller"];
  var createMin = /* @__PURE__ */ factory(name145, dependencies146, (_ref) => {
    var {
      typed,
      config,
      numeric: numeric2,
      smaller
    } = _ref;
    return typed(name145, {
      "Array | Matrix": _min,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return reduce(array, dim.valueOf(), _smallest);
      },
      "...": function _4(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function min");
        }
        return _min(args);
      }
    });
    function _smallest(x, y) {
      try {
        return smaller(x, y) ? x : y;
      } catch (err) {
        throw improveErrorMessage(err, "min", y);
      }
    }
    function _min(array) {
      var min;
      deepForEach(array, function(value) {
        try {
          if (isNaN(value) && typeof value === "number") {
            min = NaN;
          } else if (min === void 0 || smaller(value, min)) {
            min = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, "min", value);
        }
      });
      if (min === void 0) {
        throw new Error("Cannot calculate min of an empty array");
      }
      if (typeof min === "string") {
        min = numeric2(min, config.number);
      }
      return min;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
  var name146 = "ImmutableDenseMatrix";
  var dependencies147 = ["smaller", "DenseMatrix"];
  var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name146, dependencies147, (_ref) => {
    var {
      smaller,
      DenseMatrix
    } = _ref;
    function ImmutableDenseMatrix(data, datatype) {
      if (!(this instanceof ImmutableDenseMatrix)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data) || isArray(data)) {
        var matrix = new DenseMatrix(data, datatype);
        this._data = matrix._data;
        this._size = matrix._size;
        this._datatype = matrix._datatype;
        this._min = null;
        this._max = null;
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        this._datatype = data.datatype;
        this._min = typeof data.min !== "undefined" ? data.min : null;
        this._max = typeof data.max !== "undefined" ? data.max : null;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
        this._min = null;
        this._max = null;
      }
    }
    ImmutableDenseMatrix.prototype = new DenseMatrix();
    ImmutableDenseMatrix.prototype.type = "ImmutableDenseMatrix";
    ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
    ImmutableDenseMatrix.prototype.subset = function(index) {
      switch (arguments.length) {
        case 1: {
          var m = DenseMatrix.prototype.subset.call(this, index);
          if (isMatrix(m)) {
            return new ImmutableDenseMatrix({
              data: m._data,
              size: m._size,
              datatype: m._datatype
            });
          }
          return m;
        }
        case 2:
        case 3:
          throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    ImmutableDenseMatrix.prototype.set = function() {
      throw new Error("Cannot invoke set on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix.prototype.resize = function() {
      throw new Error("Cannot invoke resize on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix.prototype.reshape = function() {
      throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix.prototype.clone = function() {
      return new ImmutableDenseMatrix({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
    };
    ImmutableDenseMatrix.prototype.toJSON = function() {
      return {
        mathjs: "ImmutableDenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    ImmutableDenseMatrix.fromJSON = function(json) {
      return new ImmutableDenseMatrix(json);
    };
    ImmutableDenseMatrix.prototype.swapRows = function() {
      throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix.prototype.min = function() {
      if (this._min === null) {
        var m = null;
        this.forEach(function(v) {
          if (m === null || smaller(v, m)) {
            m = v;
          }
        });
        this._min = m !== null ? m : void 0;
      }
      return this._min;
    };
    ImmutableDenseMatrix.prototype.max = function() {
      if (this._max === null) {
        var m = null;
        this.forEach(function(v) {
          if (m === null || smaller(m, v)) {
            m = v;
          }
        });
        this._max = m !== null ? m : void 0;
      }
      return this._max;
    };
    return ImmutableDenseMatrix;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
  var name147 = "Index";
  var dependencies148 = ["ImmutableDenseMatrix"];
  var createIndexClass = /* @__PURE__ */ factory(name147, dependencies148, (_ref) => {
    var {
      ImmutableDenseMatrix
    } = _ref;
    function Index(ranges) {
      if (!(this instanceof Index)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._dimensions = [];
      this._isScalar = true;
      for (var i = 0, ii = arguments.length; i < ii; i++) {
        var arg = arguments[i];
        if (isRange(arg)) {
          this._dimensions.push(arg);
          this._isScalar = false;
        } else if (Array.isArray(arg) || isMatrix(arg)) {
          var m = _createImmutableMatrix(arg.valueOf());
          this._dimensions.push(m);
          var size = m.size();
          if (size.length !== 1 || size[0] !== 1) {
            this._isScalar = false;
          }
        } else if (typeof arg === "number") {
          this._dimensions.push(_createImmutableMatrix([arg]));
        } else if (typeof arg === "string") {
          this._dimensions.push(arg);
        } else {
          throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
        }
      }
    }
    Index.prototype.type = "Index";
    Index.prototype.isIndex = true;
    function _createImmutableMatrix(arg) {
      for (var i = 0, l = arg.length; i < l; i++) {
        if (typeof arg[i] !== "number" || !isInteger(arg[i])) {
          throw new TypeError("Index parameters must be positive integer numbers");
        }
      }
      return new ImmutableDenseMatrix(arg);
    }
    Index.prototype.clone = function() {
      var index = new Index();
      index._dimensions = clone(this._dimensions);
      index._isScalar = this._isScalar;
      return index;
    };
    Index.create = function(ranges) {
      var index = new Index();
      Index.apply(index, ranges);
      return index;
    };
    Index.prototype.size = function() {
      var size = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var d = this._dimensions[i];
        size[i] = typeof d === "string" ? 1 : d.size()[0];
      }
      return size;
    };
    Index.prototype.max = function() {
      var values2 = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range = this._dimensions[i];
        values2[i] = typeof range === "string" ? range : range.max();
      }
      return values2;
    };
    Index.prototype.min = function() {
      var values2 = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range = this._dimensions[i];
        values2[i] = typeof range === "string" ? range : range.min();
      }
      return values2;
    };
    Index.prototype.forEach = function(callback) {
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        callback(this._dimensions[i], i, this);
      }
    };
    Index.prototype.dimension = function(dim) {
      return this._dimensions[dim] || null;
    };
    Index.prototype.isObjectProperty = function() {
      return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
    };
    Index.prototype.getObjectProperty = function() {
      return this.isObjectProperty() ? this._dimensions[0] : null;
    };
    Index.prototype.isScalar = function() {
      return this._isScalar;
    };
    Index.prototype.toArray = function() {
      var array = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        array.push(typeof dimension === "string" ? dimension : dimension.toArray());
      }
      return array;
    };
    Index.prototype.valueOf = Index.prototype.toArray;
    Index.prototype.toString = function() {
      var strings = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        if (typeof dimension === "string") {
          strings.push(JSON.stringify(dimension));
        } else {
          strings.push(dimension.toString());
        }
      }
      return "[" + strings.join(", ") + "]";
    };
    Index.prototype.toJSON = function() {
      return {
        mathjs: "Index",
        dimensions: this._dimensions
      };
    };
    Index.fromJSON = function(json) {
      return Index.create(json.dimensions);
    };
    return Index;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
  var name148 = "FibonacciHeap";
  var dependencies149 = ["smaller", "larger"];
  var createFibonacciHeapClass = /* @__PURE__ */ factory(name148, dependencies149, (_ref) => {
    var {
      smaller,
      larger
    } = _ref;
    var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
    function FibonacciHeap() {
      if (!(this instanceof FibonacciHeap)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._minimum = null;
      this._size = 0;
    }
    FibonacciHeap.prototype.type = "FibonacciHeap";
    FibonacciHeap.prototype.isFibonacciHeap = true;
    FibonacciHeap.prototype.insert = function(key, value) {
      var node = {
        key,
        value,
        degree: 0
      };
      if (this._minimum) {
        var minimum = this._minimum;
        node.left = minimum;
        node.right = minimum.right;
        minimum.right = node;
        node.right.left = node;
        if (smaller(key, minimum.key)) {
          this._minimum = node;
        }
      } else {
        node.left = node;
        node.right = node;
        this._minimum = node;
      }
      this._size++;
      return node;
    };
    FibonacciHeap.prototype.size = function() {
      return this._size;
    };
    FibonacciHeap.prototype.clear = function() {
      this._minimum = null;
      this._size = 0;
    };
    FibonacciHeap.prototype.isEmpty = function() {
      return this._size === 0;
    };
    FibonacciHeap.prototype.extractMinimum = function() {
      var node = this._minimum;
      if (node === null) {
        return node;
      }
      var minimum = this._minimum;
      var numberOfChildren = node.degree;
      var x = node.child;
      while (numberOfChildren > 0) {
        var tempRight = x.right;
        x.left.right = x.right;
        x.right.left = x.left;
        x.left = minimum;
        x.right = minimum.right;
        minimum.right = x;
        x.right.left = x;
        x.parent = null;
        x = tempRight;
        numberOfChildren--;
      }
      node.left.right = node.right;
      node.right.left = node.left;
      if (node === node.right) {
        minimum = null;
      } else {
        minimum = node.right;
        minimum = _findMinimumNode(minimum, this._size);
      }
      this._size--;
      this._minimum = minimum;
      return node;
    };
    FibonacciHeap.prototype.remove = function(node) {
      this._minimum = _decreaseKey(this._minimum, node, -1);
      this.extractMinimum();
    };
    function _decreaseKey(minimum, node, key) {
      node.key = key;
      var parent = node.parent;
      if (parent && smaller(node.key, parent.key)) {
        _cut(minimum, node, parent);
        _cascadingCut(minimum, parent);
      }
      if (smaller(node.key, minimum.key)) {
        minimum = node;
      }
      return minimum;
    }
    function _cut(minimum, node, parent) {
      node.left.right = node.right;
      node.right.left = node.left;
      parent.degree--;
      if (parent.child === node) {
        parent.child = node.right;
      }
      if (parent.degree === 0) {
        parent.child = null;
      }
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      node.parent = null;
      node.mark = false;
    }
    function _cascadingCut(minimum, node) {
      var parent = node.parent;
      if (!parent) {
        return;
      }
      if (!node.mark) {
        node.mark = true;
      } else {
        _cut(minimum, node, parent);
        _cascadingCut(parent);
      }
    }
    var _linkNodes = function _linkNodes2(node, parent) {
      node.left.right = node.right;
      node.right.left = node.left;
      node.parent = parent;
      if (!parent.child) {
        parent.child = node;
        node.right = node;
        node.left = node;
      } else {
        node.left = parent.child;
        node.right = parent.child.right;
        parent.child.right = node;
        node.right.left = node;
      }
      parent.degree++;
      node.mark = false;
    };
    function _findMinimumNode(minimum, size) {
      var arraySize2 = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
      var array = new Array(arraySize2);
      var numRoots = 0;
      var x = minimum;
      if (x) {
        numRoots++;
        x = x.right;
        while (x !== minimum) {
          numRoots++;
          x = x.right;
        }
      }
      var y;
      while (numRoots > 0) {
        var d = x.degree;
        var next = x.right;
        while (true) {
          y = array[d];
          if (!y) {
            break;
          }
          if (larger(x.key, y.key)) {
            var temp = y;
            y = x;
            x = temp;
          }
          _linkNodes(y, x);
          array[d] = null;
          d++;
        }
        array[d] = x;
        x = next;
        numRoots--;
      }
      minimum = null;
      for (var i = 0; i < arraySize2; i++) {
        y = array[i];
        if (!y) {
          continue;
        }
        if (minimum) {
          y.left.right = y.right;
          y.right.left = y.left;
          y.left = minimum;
          y.right = minimum.right;
          minimum.right = y;
          y.right.left = y;
          if (smaller(y.key, minimum.key)) {
            minimum = y;
          }
        } else {
          minimum = y;
        }
      }
      return minimum;
    }
    return FibonacciHeap;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Spa.js
  var name149 = "Spa";
  var dependencies150 = ["addScalar", "equalScalar", "FibonacciHeap"];
  var createSpaClass = /* @__PURE__ */ factory(name149, dependencies150, (_ref) => {
    var {
      addScalar,
      equalScalar,
      FibonacciHeap
    } = _ref;
    function Spa() {
      if (!(this instanceof Spa)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._values = [];
      this._heap = new FibonacciHeap();
    }
    Spa.prototype.type = "Spa";
    Spa.prototype.isSpa = true;
    Spa.prototype.set = function(i, v) {
      if (!this._values[i]) {
        var node = this._heap.insert(i, v);
        this._values[i] = node;
      } else {
        this._values[i].value = v;
      }
    };
    Spa.prototype.get = function(i) {
      var node = this._values[i];
      if (node) {
        return node.value;
      }
      return 0;
    };
    Spa.prototype.accumulate = function(i, v) {
      var node = this._values[i];
      if (!node) {
        node = this._heap.insert(i, v);
        this._values[i] = node;
      } else {
        node.value = addScalar(node.value, v);
      }
    };
    Spa.prototype.forEach = function(from, to, callback) {
      var heap = this._heap;
      var values2 = this._values;
      var nodes = [];
      var node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
      while (node && node.key <= to) {
        if (node.key >= from) {
          if (!equalScalar(node.value, 0)) {
            callback(node.key, node.value, this);
          }
        }
        node = heap.extractMinimum();
        if (node) {
          nodes.push(node);
        }
      }
      for (var i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        node = heap.insert(n.key, n.value);
        values2[node.key] = node;
      }
    };
    Spa.prototype.swap = function(i, j) {
      var nodei = this._values[i];
      var nodej = this._values[j];
      if (!nodei && nodej) {
        nodei = this._heap.insert(i, nodej.value);
        this._heap.remove(nodej);
        this._values[i] = nodei;
        this._values[j] = void 0;
      } else if (nodei && !nodej) {
        nodej = this._heap.insert(j, nodei.value);
        this._heap.remove(nodei);
        this._values[j] = nodej;
        this._values[i] = void 0;
      } else if (nodei && nodej) {
        var v = nodei.value;
        nodei.value = nodej.value;
        nodej.value = v;
      }
    };
    return Spa;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/constants.js
  var createBigNumberE = memoize(function(BigNumber) {
    return new BigNumber(1).exp();
  }, {
    hasher
  });
  var createBigNumberPhi = memoize(function(BigNumber) {
    return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
  }, {
    hasher
  });
  var createBigNumberPi = memoize(function(BigNumber) {
    return BigNumber.acos(-1);
  }, {
    hasher
  });
  var createBigNumberTau = memoize(function(BigNumber) {
    return createBigNumberPi(BigNumber).times(2);
  }, {
    hasher
  });
  function hasher(args) {
    return args[0].precision;
  }

  // node_modules/mathjs/lib/esm/type/unit/Unit.js
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var name150 = "Unit";
  var dependencies151 = ["?on", "config", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
  var createUnitClass = /* @__PURE__ */ factory(name150, dependencies151, (_ref) => {
    var {
      on,
      config,
      addScalar,
      subtract,
      multiplyScalar,
      divideScalar,
      pow,
      abs,
      fix,
      round,
      equal,
      isNumeric,
      format: format4,
      number,
      Complex: Complex2,
      BigNumber: _BigNumber,
      Fraction: _Fraction
    } = _ref;
    var toNumber = number;
    function Unit(value, name284) {
      if (!(this instanceof Unit)) {
        throw new Error("Constructor must be called with the new operator");
      }
      if (!(value === null || value === void 0 || isNumeric(value) || isComplex(value))) {
        throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
      }
      if (name284 !== void 0 && (typeof name284 !== "string" || name284 === "")) {
        throw new TypeError("Second parameter in Unit constructor must be a string");
      }
      if (name284 !== void 0) {
        var u = Unit.parse(name284);
        this.units = u.units;
        this.dimensions = u.dimensions;
      } else {
        this.units = [{
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE,
          power: 0
        }];
        this.dimensions = [];
        for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
          this.dimensions[i] = 0;
        }
      }
      this.value = value !== void 0 && value !== null ? this._normalize(value) : null;
      this.fixPrefix = false;
      this.skipAutomaticSimplification = true;
    }
    Unit.prototype.type = "Unit";
    Unit.prototype.isUnit = true;
    var text, index, c;
    function skipWhitespace() {
      while (c === " " || c === "	") {
        next();
      }
    }
    function isDigitDot(c2) {
      return c2 >= "0" && c2 <= "9" || c2 === ".";
    }
    function isDigit(c2) {
      return c2 >= "0" && c2 <= "9";
    }
    function next() {
      index++;
      c = text.charAt(index);
    }
    function revert(oldIndex) {
      index = oldIndex;
      c = text.charAt(index);
    }
    function parseNumber() {
      var number2 = "";
      var oldIndex = index;
      if (c === "+") {
        next();
      } else if (c === "-") {
        number2 += c;
        next();
      }
      if (!isDigitDot(c)) {
        revert(oldIndex);
        return null;
      }
      if (c === ".") {
        number2 += c;
        next();
        if (!isDigit(c)) {
          revert(oldIndex);
          return null;
        }
      } else {
        while (isDigit(c)) {
          number2 += c;
          next();
        }
        if (c === ".") {
          number2 += c;
          next();
        }
      }
      while (isDigit(c)) {
        number2 += c;
        next();
      }
      if (c === "E" || c === "e") {
        var tentativeNumber = "";
        var tentativeIndex = index;
        tentativeNumber += c;
        next();
        if (c === "+" || c === "-") {
          tentativeNumber += c;
          next();
        }
        if (!isDigit(c)) {
          revert(tentativeIndex);
          return number2;
        }
        number2 = number2 + tentativeNumber;
        while (isDigit(c)) {
          number2 += c;
          next();
        }
      }
      return number2;
    }
    function parseUnit() {
      var unitName = "";
      while (isDigit(c) || Unit.isValidAlpha(c)) {
        unitName += c;
        next();
      }
      var firstC = unitName.charAt(0);
      if (Unit.isValidAlpha(firstC)) {
        return unitName;
      } else {
        return null;
      }
    }
    function parseCharacter(toFind) {
      if (c === toFind) {
        next();
        return toFind;
      } else {
        return null;
      }
    }
    Unit.parse = function(str, options) {
      options = options || {};
      text = str;
      index = -1;
      c = "";
      if (typeof text !== "string") {
        throw new TypeError("Invalid argument in Unit.parse, string expected");
      }
      var unit2 = new Unit();
      unit2.units = [];
      var powerMultiplierCurrent = 1;
      var expectingUnit = false;
      next();
      skipWhitespace();
      var valueStr = parseNumber();
      var value = null;
      if (valueStr) {
        if (config.number === "BigNumber") {
          value = new _BigNumber(valueStr);
        } else if (config.number === "Fraction") {
          try {
            value = new _Fraction(valueStr);
          } catch (err) {
            value = parseFloat(valueStr);
          }
        } else {
          value = parseFloat(valueStr);
        }
        skipWhitespace();
        if (parseCharacter("*")) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter("/")) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        }
      }
      var powerMultiplierStack = [];
      var powerMultiplierStackProduct = 1;
      while (true) {
        skipWhitespace();
        while (c === "(") {
          powerMultiplierStack.push(powerMultiplierCurrent);
          powerMultiplierStackProduct *= powerMultiplierCurrent;
          powerMultiplierCurrent = 1;
          next();
          skipWhitespace();
        }
        var uStr = void 0;
        if (c) {
          var oldC = c;
          uStr = parseUnit();
          if (uStr === null) {
            throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
          }
        } else {
          break;
        }
        var res = _findUnit(uStr);
        if (res === null) {
          throw new SyntaxError('Unit "' + uStr + '" not found.');
        }
        var power = powerMultiplierCurrent * powerMultiplierStackProduct;
        skipWhitespace();
        if (parseCharacter("^")) {
          skipWhitespace();
          var p = parseNumber();
          if (p === null) {
            throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
          }
          power *= p;
        }
        unit2.units.push({
          unit: res.unit,
          prefix: res.prefix,
          power
        });
        for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
          unit2.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
        }
        skipWhitespace();
        while (c === ")") {
          if (powerMultiplierStack.length === 0) {
            throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
          }
          powerMultiplierStackProduct /= powerMultiplierStack.pop();
          next();
          skipWhitespace();
        }
        expectingUnit = false;
        if (parseCharacter("*")) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter("/")) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        } else {
          powerMultiplierCurrent = 1;
        }
        if (res.unit.base) {
          var baseDim = res.unit.base.key;
          UNIT_SYSTEMS.auto[baseDim] = {
            unit: res.unit,
            prefix: res.prefix
          };
        }
      }
      skipWhitespace();
      if (c) {
        throw new SyntaxError('Could not parse: "' + str + '"');
      }
      if (expectingUnit) {
        throw new SyntaxError('Trailing characters: "' + str + '"');
      }
      if (powerMultiplierStack.length !== 0) {
        throw new SyntaxError('Unmatched "(" in "' + text + '"');
      }
      if (unit2.units.length === 0 && !options.allowNoUnits) {
        throw new SyntaxError('"' + str + '" contains no units');
      }
      unit2.value = value !== void 0 ? unit2._normalize(value) : null;
      return unit2;
    };
    Unit.prototype.clone = function() {
      var unit2 = new Unit();
      unit2.fixPrefix = this.fixPrefix;
      unit2.skipAutomaticSimplification = this.skipAutomaticSimplification;
      unit2.value = clone(this.value);
      unit2.dimensions = this.dimensions.slice(0);
      unit2.units = [];
      for (var i = 0; i < this.units.length; i++) {
        unit2.units[i] = {};
        for (var p in this.units[i]) {
          if (hasOwnProperty2(this.units[i], p)) {
            unit2.units[i][p] = this.units[i][p];
          }
        }
      }
      return unit2;
    };
    Unit.prototype._isDerived = function() {
      if (this.units.length === 0) {
        return false;
      }
      return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
    };
    Unit.prototype._normalize = function(value) {
      var unitValue, unitOffset, unitPower, unitPrefixValue;
      var convert;
      if (value === null || value === void 0 || this.units.length === 0) {
        return value;
      } else if (this._isDerived()) {
        var res = value;
        convert = Unit._getNumberConverter(typeOf(value));
        for (var i = 0; i < this.units.length; i++) {
          unitValue = convert(this.units[i].unit.value);
          unitPrefixValue = convert(this.units[i].prefix.value);
          unitPower = convert(this.units[i].power);
          res = multiplyScalar(res, pow(multiplyScalar(unitValue, unitPrefixValue), unitPower));
        }
        return res;
      } else {
        convert = Unit._getNumberConverter(typeOf(value));
        unitValue = convert(this.units[0].unit.value);
        unitOffset = convert(this.units[0].unit.offset);
        unitPrefixValue = convert(this.units[0].prefix.value);
        return multiplyScalar(addScalar(value, unitOffset), multiplyScalar(unitValue, unitPrefixValue));
      }
    };
    Unit.prototype._denormalize = function(value, prefixValue) {
      var unitValue, unitOffset, unitPower, unitPrefixValue;
      var convert;
      if (value === null || value === void 0 || this.units.length === 0) {
        return value;
      } else if (this._isDerived()) {
        var res = value;
        convert = Unit._getNumberConverter(typeOf(value));
        for (var i = 0; i < this.units.length; i++) {
          unitValue = convert(this.units[i].unit.value);
          unitPrefixValue = convert(this.units[i].prefix.value);
          unitPower = convert(this.units[i].power);
          res = divideScalar(res, pow(multiplyScalar(unitValue, unitPrefixValue), unitPower));
        }
        return res;
      } else {
        convert = Unit._getNumberConverter(typeOf(value));
        unitValue = convert(this.units[0].unit.value);
        unitPrefixValue = convert(this.units[0].prefix.value);
        unitOffset = convert(this.units[0].unit.offset);
        if (prefixValue === void 0 || prefixValue === null) {
          return subtract(divideScalar(divideScalar(value, unitValue), unitPrefixValue), unitOffset);
        } else {
          return subtract(divideScalar(divideScalar(value, unitValue), prefixValue), unitOffset);
        }
      }
    };
    var _findUnit = memoize((str) => {
      if (hasOwnProperty2(UNITS, str)) {
        var unit2 = UNITS[str];
        var prefix = unit2.prefixes[""];
        return {
          unit: unit2,
          prefix
        };
      }
      for (var _name in UNITS) {
        if (hasOwnProperty2(UNITS, _name)) {
          if (endsWith(str, _name)) {
            var _unit = UNITS[_name];
            var prefixLen = str.length - _name.length;
            var prefixName = str.substring(0, prefixLen);
            var _prefix = hasOwnProperty2(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
            if (_prefix !== void 0) {
              return {
                unit: _unit,
                prefix: _prefix
              };
            }
          }
        }
      }
      return null;
    }, {
      hasher: (args) => args[0],
      limit: 100
    });
    Unit.isValuelessUnit = function(name284) {
      return _findUnit(name284) !== null;
    };
    Unit.prototype.hasBase = function(base) {
      if (typeof base === "string") {
        base = BASE_UNITS[base];
      }
      if (!base) {
        return false;
      }
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
          return false;
        }
      }
      return true;
    };
    Unit.prototype.equalBase = function(other) {
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
          return false;
        }
      }
      return true;
    };
    Unit.prototype.equals = function(other) {
      return this.equalBase(other) && equal(this.value, other.value);
    };
    Unit.prototype.multiply = function(other) {
      var res = this.clone();
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
      }
      for (var _i = 0; _i < other.units.length; _i++) {
        var inverted = _objectSpread2({}, other.units[_i]);
        res.units.push(inverted);
      }
      if (this.value !== null || other.value !== null) {
        var valThis = this.value === null ? this._normalize(1) : this.value;
        var valOther = other.value === null ? other._normalize(1) : other.value;
        res.value = multiplyScalar(valThis, valOther);
      } else {
        res.value = null;
      }
      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    Unit.prototype.divide = function(other) {
      var res = this.clone();
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
      }
      for (var _i2 = 0; _i2 < other.units.length; _i2++) {
        var inverted = _objectSpread2(_objectSpread2({}, other.units[_i2]), {}, {
          power: -other.units[_i2].power
        });
        res.units.push(inverted);
      }
      if (this.value !== null || other.value !== null) {
        var valThis = this.value === null ? this._normalize(1) : this.value;
        var valOther = other.value === null ? other._normalize(1) : other.value;
        res.value = divideScalar(valThis, valOther);
      } else {
        res.value = null;
      }
      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    Unit.prototype.pow = function(p) {
      var res = this.clone();
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) * p;
      }
      for (var _i3 = 0; _i3 < res.units.length; _i3++) {
        res.units[_i3].power *= p;
      }
      if (res.value !== null) {
        res.value = pow(res.value, p);
      } else {
        res.value = null;
      }
      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    function getNumericIfUnitless(unit2) {
      if (unit2.equalBase(BASE_UNITS.NONE) && unit2.value !== null && !config.predictable) {
        return unit2.value;
      } else {
        return unit2;
      }
    }
    Unit.prototype.abs = function() {
      var ret = this.clone();
      ret.value = ret.value !== null ? abs(ret.value) : null;
      for (var i in ret.units) {
        if (ret.units[i].unit.name === "VA" || ret.units[i].unit.name === "VAR") {
          ret.units[i].unit = UNITS.W;
        }
      }
      return ret;
    };
    Unit.prototype.to = function(valuelessUnit) {
      var other;
      var value = this.value === null ? this._normalize(1) : this.value;
      if (typeof valuelessUnit === "string") {
        other = Unit.parse(valuelessUnit);
        if (!this.equalBase(other)) {
          throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
        }
        if (other.value !== null) {
          throw new Error("Cannot convert to a unit with a value");
        }
        other.value = clone(value);
        other.fixPrefix = true;
        other.skipAutomaticSimplification = true;
        return other;
      } else if (isUnit(valuelessUnit)) {
        if (!this.equalBase(valuelessUnit)) {
          throw new Error("Units do not match ('".concat(valuelessUnit.toString(), "' != '").concat(this.toString(), "')"));
        }
        if (valuelessUnit.value !== null) {
          throw new Error("Cannot convert to a unit with a value");
        }
        other = valuelessUnit.clone();
        other.value = clone(value);
        other.fixPrefix = true;
        other.skipAutomaticSimplification = true;
        return other;
      } else {
        throw new Error("String or Unit expected as parameter");
      }
    };
    Unit.prototype.toNumber = function(valuelessUnit) {
      return toNumber(this.toNumeric(valuelessUnit));
    };
    Unit.prototype.toNumeric = function(valuelessUnit) {
      var other;
      if (valuelessUnit) {
        other = this.to(valuelessUnit);
      } else {
        other = this.clone();
      }
      if (other._isDerived() || other.units.length === 0) {
        return other._denormalize(other.value);
      } else {
        return other._denormalize(other.value, other.units[0].prefix.value);
      }
    };
    Unit.prototype.toString = function() {
      return this.format();
    };
    Unit.prototype.toJSON = function() {
      return {
        mathjs: "Unit",
        value: this._denormalize(this.value),
        unit: this.formatUnits(),
        fixPrefix: this.fixPrefix
      };
    };
    Unit.fromJSON = function(json) {
      var unit2 = new Unit(json.value, json.unit);
      unit2.fixPrefix = json.fixPrefix || false;
      return unit2;
    };
    Unit.prototype.valueOf = Unit.prototype.toString;
    Unit.prototype.simplify = function() {
      var ret = this.clone();
      var proposedUnitList = [];
      var matchingBase;
      for (var key2 in currentUnitSystem) {
        if (hasOwnProperty2(currentUnitSystem, key2)) {
          if (ret.hasBase(BASE_UNITS[key2])) {
            matchingBase = key2;
            break;
          }
        }
      }
      if (matchingBase === "NONE") {
        ret.units = [];
      } else {
        var matchingUnit;
        if (matchingBase) {
          if (hasOwnProperty2(currentUnitSystem, matchingBase)) {
            matchingUnit = currentUnitSystem[matchingBase];
          }
        }
        if (matchingUnit) {
          ret.units = [{
            unit: matchingUnit.unit,
            prefix: matchingUnit.prefix,
            power: 1
          }];
        } else {
          var missingBaseDim = false;
          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            var baseDim = BASE_DIMENSIONS[i];
            if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
              if (hasOwnProperty2(currentUnitSystem, baseDim)) {
                proposedUnitList.push({
                  unit: currentUnitSystem[baseDim].unit,
                  prefix: currentUnitSystem[baseDim].prefix,
                  power: ret.dimensions[i] || 0
                });
              } else {
                missingBaseDim = true;
              }
            }
          }
          if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
            ret.units = proposedUnitList;
          }
        }
      }
      return ret;
    };
    Unit.prototype.toSI = function() {
      var ret = this.clone();
      var proposedUnitList = [];
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        var baseDim = BASE_DIMENSIONS[i];
        if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
          if (hasOwnProperty2(UNIT_SYSTEMS.si, baseDim)) {
            proposedUnitList.push({
              unit: UNIT_SYSTEMS.si[baseDim].unit,
              prefix: UNIT_SYSTEMS.si[baseDim].prefix,
              power: ret.dimensions[i] || 0
            });
          } else {
            throw new Error("Cannot express custom unit " + baseDim + " in SI units");
          }
        }
      }
      ret.units = proposedUnitList;
      ret.fixPrefix = true;
      ret.skipAutomaticSimplification = true;
      return ret;
    };
    Unit.prototype.formatUnits = function() {
      var strNum = "";
      var strDen = "";
      var nNum = 0;
      var nDen = 0;
      for (var i = 0; i < this.units.length; i++) {
        if (this.units[i].power > 0) {
          nNum++;
          strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
          if (Math.abs(this.units[i].power - 1) > 1e-15) {
            strNum += "^" + this.units[i].power;
          }
        } else if (this.units[i].power < 0) {
          nDen++;
        }
      }
      if (nDen > 0) {
        for (var _i4 = 0; _i4 < this.units.length; _i4++) {
          if (this.units[_i4].power < 0) {
            if (nNum > 0) {
              strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
              if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
                strDen += "^" + -this.units[_i4].power;
              }
            } else {
              strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
              strDen += "^" + this.units[_i4].power;
            }
          }
        }
      }
      strNum = strNum.substr(1);
      strDen = strDen.substr(1);
      if (nNum > 1 && nDen > 0) {
        strNum = "(" + strNum + ")";
      }
      if (nDen > 1 && nNum > 0) {
        strDen = "(" + strDen + ")";
      }
      var str = strNum;
      if (nNum > 0 && nDen > 0) {
        str += " / ";
      }
      str += strDen;
      return str;
    };
    Unit.prototype.format = function(options) {
      var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
      var isImaginary = false;
      if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
        isImaginary = Math.abs(simp.value.re) < 1e-14;
      }
      for (var i in simp.units) {
        if (hasOwnProperty2(simp.units, i)) {
          if (simp.units[i].unit) {
            if (simp.units[i].unit.name === "VA" && isImaginary) {
              simp.units[i].unit = UNITS.VAR;
            } else if (simp.units[i].unit.name === "VAR" && !isImaginary) {
              simp.units[i].unit = UNITS.VA;
            }
          }
        }
      }
      if (simp.units.length === 1 && !simp.fixPrefix) {
        if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
          simp.units[0].prefix = simp._bestPrefix();
        }
      }
      var value = simp._denormalize(simp.value);
      var str = simp.value !== null ? format4(value, options || {}) : "";
      var unitStr = simp.formatUnits();
      if (simp.value && isComplex(simp.value)) {
        str = "(" + str + ")";
      }
      if (unitStr.length > 0 && str.length > 0) {
        str += " ";
      }
      str += unitStr;
      return str;
    };
    Unit.prototype._bestPrefix = function() {
      if (this.units.length !== 1) {
        throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
      }
      if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
        throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
      }
      var absValue = this.value !== null ? abs(this.value) : 0;
      var absUnitValue = abs(this.units[0].unit.value);
      var bestPrefix = this.units[0].prefix;
      if (absValue === 0) {
        return bestPrefix;
      }
      var power = this.units[0].power;
      var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
      if (bestDiff > -2.200001 && bestDiff < 1.800001)
        return bestPrefix;
      bestDiff = Math.abs(bestDiff);
      var prefixes = this.units[0].unit.prefixes;
      for (var p in prefixes) {
        if (hasOwnProperty2(prefixes, p)) {
          var prefix = prefixes[p];
          if (prefix.scientific) {
            var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
            if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
              bestPrefix = prefix;
              bestDiff = diff;
            }
          }
        }
      }
      return bestPrefix;
    };
    Unit.prototype.splitUnit = function(parts) {
      var x = this.clone();
      var ret = [];
      for (var i = 0; i < parts.length; i++) {
        x = x.to(parts[i]);
        if (i === parts.length - 1)
          break;
        var xNumeric = x.toNumeric();
        var xRounded = round(xNumeric);
        var xFixed = void 0;
        var isNearlyEqual = equal(xRounded, xNumeric);
        if (isNearlyEqual) {
          xFixed = xRounded;
        } else {
          xFixed = fix(x.toNumeric());
        }
        var y = new Unit(xFixed, parts[i].toString());
        ret.push(y);
        x = subtract(x, y);
      }
      var testSum = 0;
      for (var _i5 = 0; _i5 < ret.length; _i5++) {
        testSum = addScalar(testSum, ret[_i5].value);
      }
      if (equal(testSum, this.value)) {
        x.value = 0;
      }
      ret.push(x);
      return ret;
    };
    var PREFIXES = {
      NONE: {
        "": {
          name: "",
          value: 1,
          scientific: true
        }
      },
      SHORT: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 10,
          scientific: false
        },
        h: {
          name: "h",
          value: 100,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e3,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e6,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e9,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e12,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e15,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e18,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e21,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e24,
          scientific: true
        },
        d: {
          name: "d",
          value: 0.1,
          scientific: false
        },
        c: {
          name: "c",
          value: 0.01,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-3,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-6,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-9,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-12,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-15,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-18,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-21,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-24,
          scientific: true
        }
      },
      LONG: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        deca: {
          name: "deca",
          value: 10,
          scientific: false
        },
        hecto: {
          name: "hecto",
          value: 100,
          scientific: false
        },
        kilo: {
          name: "kilo",
          value: 1e3,
          scientific: true
        },
        mega: {
          name: "mega",
          value: 1e6,
          scientific: true
        },
        giga: {
          name: "giga",
          value: 1e9,
          scientific: true
        },
        tera: {
          name: "tera",
          value: 1e12,
          scientific: true
        },
        peta: {
          name: "peta",
          value: 1e15,
          scientific: true
        },
        exa: {
          name: "exa",
          value: 1e18,
          scientific: true
        },
        zetta: {
          name: "zetta",
          value: 1e21,
          scientific: true
        },
        yotta: {
          name: "yotta",
          value: 1e24,
          scientific: true
        },
        deci: {
          name: "deci",
          value: 0.1,
          scientific: false
        },
        centi: {
          name: "centi",
          value: 0.01,
          scientific: false
        },
        milli: {
          name: "milli",
          value: 1e-3,
          scientific: true
        },
        micro: {
          name: "micro",
          value: 1e-6,
          scientific: true
        },
        nano: {
          name: "nano",
          value: 1e-9,
          scientific: true
        },
        pico: {
          name: "pico",
          value: 1e-12,
          scientific: true
        },
        femto: {
          name: "femto",
          value: 1e-15,
          scientific: true
        },
        atto: {
          name: "atto",
          value: 1e-18,
          scientific: true
        },
        zepto: {
          name: "zepto",
          value: 1e-21,
          scientific: true
        },
        yocto: {
          name: "yocto",
          value: 1e-24,
          scientific: true
        }
      },
      SQUARED: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 100,
          scientific: false
        },
        h: {
          name: "h",
          value: 1e4,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e6,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e12,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e18,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e24,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e30,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e36,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e42,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e48,
          scientific: true
        },
        d: {
          name: "d",
          value: 0.01,
          scientific: false
        },
        c: {
          name: "c",
          value: 1e-4,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-6,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-12,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-18,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-24,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-30,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-36,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-42,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-48,
          scientific: true
        }
      },
      CUBIC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 1e3,
          scientific: false
        },
        h: {
          name: "h",
          value: 1e6,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e9,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e18,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e27,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e36,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e45,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e54,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e63,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e72,
          scientific: true
        },
        d: {
          name: "d",
          value: 1e-3,
          scientific: false
        },
        c: {
          name: "c",
          value: 1e-6,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-9,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-18,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-27,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-36,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-45,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-54,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-63,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-72,
          scientific: true
        }
      },
      BINARY_SHORT_SI: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        k: {
          name: "k",
          value: 1e3,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e6,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e9,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e12,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e15,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e18,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e21,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e24,
          scientific: true
        }
      },
      BINARY_SHORT_IEC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        Ki: {
          name: "Ki",
          value: 1024,
          scientific: true
        },
        Mi: {
          name: "Mi",
          value: Math.pow(1024, 2),
          scientific: true
        },
        Gi: {
          name: "Gi",
          value: Math.pow(1024, 3),
          scientific: true
        },
        Ti: {
          name: "Ti",
          value: Math.pow(1024, 4),
          scientific: true
        },
        Pi: {
          name: "Pi",
          value: Math.pow(1024, 5),
          scientific: true
        },
        Ei: {
          name: "Ei",
          value: Math.pow(1024, 6),
          scientific: true
        },
        Zi: {
          name: "Zi",
          value: Math.pow(1024, 7),
          scientific: true
        },
        Yi: {
          name: "Yi",
          value: Math.pow(1024, 8),
          scientific: true
        }
      },
      BINARY_LONG_SI: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        kilo: {
          name: "kilo",
          value: 1e3,
          scientific: true
        },
        mega: {
          name: "mega",
          value: 1e6,
          scientific: true
        },
        giga: {
          name: "giga",
          value: 1e9,
          scientific: true
        },
        tera: {
          name: "tera",
          value: 1e12,
          scientific: true
        },
        peta: {
          name: "peta",
          value: 1e15,
          scientific: true
        },
        exa: {
          name: "exa",
          value: 1e18,
          scientific: true
        },
        zetta: {
          name: "zetta",
          value: 1e21,
          scientific: true
        },
        yotta: {
          name: "yotta",
          value: 1e24,
          scientific: true
        }
      },
      BINARY_LONG_IEC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        kibi: {
          name: "kibi",
          value: 1024,
          scientific: true
        },
        mebi: {
          name: "mebi",
          value: Math.pow(1024, 2),
          scientific: true
        },
        gibi: {
          name: "gibi",
          value: Math.pow(1024, 3),
          scientific: true
        },
        tebi: {
          name: "tebi",
          value: Math.pow(1024, 4),
          scientific: true
        },
        pebi: {
          name: "pebi",
          value: Math.pow(1024, 5),
          scientific: true
        },
        exi: {
          name: "exi",
          value: Math.pow(1024, 6),
          scientific: true
        },
        zebi: {
          name: "zebi",
          value: Math.pow(1024, 7),
          scientific: true
        },
        yobi: {
          name: "yobi",
          value: Math.pow(1024, 8),
          scientific: true
        }
      },
      BTU: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        MM: {
          name: "MM",
          value: 1e6,
          scientific: true
        }
      }
    };
    PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
    PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
    PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
    var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
    var BASE_UNITS = {
      NONE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      MASS: {
        dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      LENGTH: {
        dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
      },
      TIME: {
        dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
      },
      CURRENT: {
        dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
      },
      TEMPERATURE: {
        dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
      },
      LUMINOUS_INTENSITY: {
        dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
      },
      AMOUNT_OF_SUBSTANCE: {
        dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
      },
      FORCE: {
        dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
      },
      SURFACE: {
        dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
      },
      VOLUME: {
        dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
      },
      ENERGY: {
        dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
      },
      POWER: {
        dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
      },
      PRESSURE: {
        dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CHARGE: {
        dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CAPACITANCE: {
        dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_POTENTIAL: {
        dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_RESISTANCE: {
        dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_INDUCTANCE: {
        dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CONDUCTANCE: {
        dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX: {
        dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX_DENSITY: {
        dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
      },
      FREQUENCY: {
        dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
      },
      ANGLE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
      },
      BIT: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
      }
    };
    for (var key in BASE_UNITS) {
      if (hasOwnProperty2(BASE_UNITS, key)) {
        BASE_UNITS[key].key = key;
      }
    }
    var BASE_UNIT_NONE = {};
    var UNIT_NONE = {
      name: "",
      base: BASE_UNIT_NONE,
      value: 1,
      offset: 0,
      dimensions: BASE_DIMENSIONS.map((x) => 0)
    };
    var UNITS = {
      meter: {
        name: "meter",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      inch: {
        name: "inch",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      foot: {
        name: "foot",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yard: {
        name: "yard",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mile: {
        name: "mile",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      link: {
        name: "link",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rod: {
        name: "rod",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.0292,
        offset: 0
      },
      chain: {
        name: "chain",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      angstrom: {
        name: "angstrom",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1e-10,
        offset: 0
      },
      m: {
        name: "m",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      in: {
        name: "in",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      ft: {
        name: "ft",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yd: {
        name: "yd",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mi: {
        name: "mi",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      li: {
        name: "li",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rd: {
        name: "rd",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.02921,
        offset: 0
      },
      ch: {
        name: "ch",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      mil: {
        name: "mil",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 254e-7,
        offset: 0
      },
      m2: {
        name: "m2",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.SQUARED,
        value: 1,
        offset: 0
      },
      sqin: {
        name: "sqin",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 64516e-8,
        offset: 0
      },
      sqft: {
        name: "sqft",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.09290304,
        offset: 0
      },
      sqyd: {
        name: "sqyd",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.83612736,
        offset: 0
      },
      sqmi: {
        name: "sqmi",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 2589988110336e-6,
        offset: 0
      },
      sqrd: {
        name: "sqrd",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 25.29295,
        offset: 0
      },
      sqch: {
        name: "sqch",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 404.6873,
        offset: 0
      },
      sqmil: {
        name: "sqmil",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 64516e-14,
        offset: 0
      },
      acre: {
        name: "acre",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 4046.86,
        offset: 0
      },
      hectare: {
        name: "hectare",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 1e4,
        offset: 0
      },
      m3: {
        name: "m3",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.CUBIC,
        value: 1,
        offset: 0
      },
      L: {
        name: "L",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      l: {
        name: "l",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      litre: {
        name: "litre",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.LONG,
        value: 1e-3,
        offset: 0
      },
      cuin: {
        name: "cuin",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 16387064e-12,
        offset: 0
      },
      cuft: {
        name: "cuft",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.028316846592,
        offset: 0
      },
      cuyd: {
        name: "cuyd",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.764554857984,
        offset: 0
      },
      teaspoon: {
        name: "teaspoon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-6,
        offset: 0
      },
      tablespoon: {
        name: "tablespoon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 15e-6,
        offset: 0
      },
      drop: {
        name: "drop",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      gtt: {
        name: "gtt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      minim: {
        name: "minim",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 6161152e-14,
        offset: 0
      },
      fluiddram: {
        name: "fluiddram",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 36966911e-13,
        offset: 0
      },
      fluidounce: {
        name: "fluidounce",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2957353e-11,
        offset: 0
      },
      gill: {
        name: "gill",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1182941e-10,
        offset: 0
      },
      cc: {
        name: "cc",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1e-6,
        offset: 0
      },
      cup: {
        name: "cup",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2365882e-10,
        offset: 0
      },
      pint: {
        name: "pint",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 4731765e-10,
        offset: 0
      },
      quart: {
        name: "quart",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 9463529e-10,
        offset: 0
      },
      gallon: {
        name: "gallon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 3785412e-9,
        offset: 0
      },
      beerbarrel: {
        name: "beerbarrel",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1173478,
        offset: 0
      },
      oilbarrel: {
        name: "oilbarrel",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1589873,
        offset: 0
      },
      hogshead: {
        name: "hogshead",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.238481,
        offset: 0
      },
      fldr: {
        name: "fldr",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 36966911e-13,
        offset: 0
      },
      floz: {
        name: "floz",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2957353e-11,
        offset: 0
      },
      gi: {
        name: "gi",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1182941e-10,
        offset: 0
      },
      cp: {
        name: "cp",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2365882e-10,
        offset: 0
      },
      pt: {
        name: "pt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 4731765e-10,
        offset: 0
      },
      qt: {
        name: "qt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 9463529e-10,
        offset: 0
      },
      gal: {
        name: "gal",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 3785412e-9,
        offset: 0
      },
      bbl: {
        name: "bbl",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1173478,
        offset: 0
      },
      obl: {
        name: "obl",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1589873,
        offset: 0
      },
      g: {
        name: "g",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      gram: {
        name: "gram",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1e-3,
        offset: 0
      },
      ton: {
        name: "ton",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 907.18474,
        offset: 0
      },
      t: {
        name: "t",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1e3,
        offset: 0
      },
      tonne: {
        name: "tonne",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1e3,
        offset: 0
      },
      grain: {
        name: "grain",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6479891e-11,
        offset: 0
      },
      dram: {
        name: "dram",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.0017718451953125,
        offset: 0
      },
      ounce: {
        name: "ounce",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.028349523125,
        offset: 0
      },
      poundmass: {
        name: "poundmass",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.45359237,
        offset: 0
      },
      hundredweight: {
        name: "hundredweight",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      stick: {
        name: "stick",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.115,
        offset: 0
      },
      stone: {
        name: "stone",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6.35029318,
        offset: 0
      },
      gr: {
        name: "gr",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6479891e-11,
        offset: 0
      },
      dr: {
        name: "dr",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.0017718451953125,
        offset: 0
      },
      oz: {
        name: "oz",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.028349523125,
        offset: 0
      },
      lbm: {
        name: "lbm",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.45359237,
        offset: 0
      },
      cwt: {
        name: "cwt",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      s: {
        name: "s",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      min: {
        name: "min",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      h: {
        name: "h",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      second: {
        name: "second",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      sec: {
        name: "sec",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      minute: {
        name: "minute",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      hour: {
        name: "hour",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      day: {
        name: "day",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 86400,
        offset: 0
      },
      week: {
        name: "week",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 7 * 86400,
        offset: 0
      },
      month: {
        name: "month",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 2629800,
        offset: 0
      },
      year: {
        name: "year",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 31557600,
        offset: 0
      },
      decade: {
        name: "decade",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e3,
        offset: 0
      },
      century: {
        name: "century",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e4,
        offset: 0
      },
      millennium: {
        name: "millennium",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e5,
        offset: 0
      },
      hertz: {
        name: "Hertz",
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      Hz: {
        name: "Hz",
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      rad: {
        name: "rad",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      radian: {
        name: "radian",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      deg: {
        name: "deg",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        offset: 0
      },
      degree: {
        name: "degree",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        offset: 0
      },
      grad: {
        name: "grad",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        offset: 0
      },
      gradian: {
        name: "gradian",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        offset: 0
      },
      cycle: {
        name: "cycle",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        offset: 0
      },
      arcsec: {
        name: "arcsec",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        offset: 0
      },
      arcmin: {
        name: "arcmin",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        offset: 0
      },
      A: {
        name: "A",
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      ampere: {
        name: "ampere",
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      K: {
        name: "K",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1,
        offset: 0
      },
      degC: {
        name: "degC",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1,
        offset: 273.15
      },
      degF: {
        name: "degF",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1 / 1.8,
        offset: 459.67
      },
      degR: {
        name: "degR",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1 / 1.8,
        offset: 0
      },
      kelvin: {
        name: "kelvin",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1,
        offset: 0
      },
      celsius: {
        name: "celsius",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1,
        offset: 273.15
      },
      fahrenheit: {
        name: "fahrenheit",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1 / 1.8,
        offset: 459.67
      },
      rankine: {
        name: "rankine",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1 / 1.8,
        offset: 0
      },
      mol: {
        name: "mol",
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      mole: {
        name: "mole",
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      cd: {
        name: "cd",
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      candela: {
        name: "candela",
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      N: {
        name: "N",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      newton: {
        name: "newton",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      dyn: {
        name: "dyn",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1e-5,
        offset: 0
      },
      dyne: {
        name: "dyne",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1e-5,
        offset: 0
      },
      lbf: {
        name: "lbf",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      poundforce: {
        name: "poundforce",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      kip: {
        name: "kip",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 4448.2216,
        offset: 0
      },
      kilogramforce: {
        name: "kilogramforce",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      J: {
        name: "J",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      joule: {
        name: "joule",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      erg: {
        name: "erg",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.NONE,
        value: 1e-7,
        offset: 0
      },
      Wh: {
        name: "Wh",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 3600,
        offset: 0
      },
      BTU: {
        name: "BTU",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.BTU,
        value: 1055.05585262,
        offset: 0
      },
      eV: {
        name: "eV",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1602176565e-28,
        offset: 0
      },
      electronvolt: {
        name: "electronvolt",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.LONG,
        value: 1602176565e-28,
        offset: 0
      },
      W: {
        name: "W",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      watt: {
        name: "watt",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      hp: {
        name: "hp",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.NONE,
        value: 745.6998715386,
        offset: 0
      },
      VAR: {
        name: "VAR",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: Complex2.I,
        offset: 0
      },
      VA: {
        name: "VA",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      Pa: {
        name: "Pa",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      psi: {
        name: "psi",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 6894.75729276459,
        offset: 0
      },
      atm: {
        name: "atm",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 101325,
        offset: 0
      },
      bar: {
        name: "bar",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORTLONG,
        value: 1e5,
        offset: 0
      },
      torr: {
        name: "torr",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmHg: {
        name: "mmHg",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmH2O: {
        name: "mmH2O",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      cmH2O: {
        name: "cmH2O",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 98.0665,
        offset: 0
      },
      coulomb: {
        name: "coulomb",
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      C: {
        name: "C",
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      farad: {
        name: "farad",
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      F: {
        name: "F",
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      volt: {
        name: "volt",
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      V: {
        name: "V",
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      ohm: {
        name: "ohm",
        base: BASE_UNITS.ELECTRIC_RESISTANCE,
        prefixes: PREFIXES.SHORTLONG,
        value: 1,
        offset: 0
      },
      henry: {
        name: "henry",
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      H: {
        name: "H",
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      siemens: {
        name: "siemens",
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      S: {
        name: "S",
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      weber: {
        name: "weber",
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      Wb: {
        name: "Wb",
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      tesla: {
        name: "tesla",
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      T: {
        name: "T",
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      b: {
        name: "b",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 1,
        offset: 0
      },
      bits: {
        name: "bits",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 1,
        offset: 0
      },
      B: {
        name: "B",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 8,
        offset: 0
      },
      bytes: {
        name: "bytes",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 8,
        offset: 0
      }
    };
    var ALIASES = {
      meters: "meter",
      inches: "inch",
      feet: "foot",
      yards: "yard",
      miles: "mile",
      links: "link",
      rods: "rod",
      chains: "chain",
      angstroms: "angstrom",
      lt: "l",
      litres: "litre",
      liter: "litre",
      liters: "litre",
      teaspoons: "teaspoon",
      tablespoons: "tablespoon",
      minims: "minim",
      fluiddrams: "fluiddram",
      fluidounces: "fluidounce",
      gills: "gill",
      cups: "cup",
      pints: "pint",
      quarts: "quart",
      gallons: "gallon",
      beerbarrels: "beerbarrel",
      oilbarrels: "oilbarrel",
      hogsheads: "hogshead",
      gtts: "gtt",
      grams: "gram",
      tons: "ton",
      tonnes: "tonne",
      grains: "grain",
      drams: "dram",
      ounces: "ounce",
      poundmasses: "poundmass",
      hundredweights: "hundredweight",
      sticks: "stick",
      lb: "lbm",
      lbs: "lbm",
      kips: "kip",
      kgf: "kilogramforce",
      acres: "acre",
      hectares: "hectare",
      sqfeet: "sqft",
      sqyard: "sqyd",
      sqmile: "sqmi",
      sqmiles: "sqmi",
      mmhg: "mmHg",
      mmh2o: "mmH2O",
      cmh2o: "cmH2O",
      seconds: "second",
      secs: "second",
      minutes: "minute",
      mins: "minute",
      hours: "hour",
      hr: "hour",
      hrs: "hour",
      days: "day",
      weeks: "week",
      months: "month",
      years: "year",
      decades: "decade",
      centuries: "century",
      millennia: "millennium",
      hertz: "hertz",
      radians: "radian",
      degrees: "degree",
      gradians: "gradian",
      cycles: "cycle",
      arcsecond: "arcsec",
      arcseconds: "arcsec",
      arcminute: "arcmin",
      arcminutes: "arcmin",
      BTUs: "BTU",
      watts: "watt",
      joules: "joule",
      amperes: "ampere",
      coulombs: "coulomb",
      volts: "volt",
      ohms: "ohm",
      farads: "farad",
      webers: "weber",
      teslas: "tesla",
      electronvolts: "electronvolt",
      moles: "mole",
      bit: "bits",
      byte: "bytes"
    };
    function calculateAngleValues(config2) {
      if (config2.number === "BigNumber") {
        var pi2 = createBigNumberPi(_BigNumber);
        UNITS.rad.value = new _BigNumber(1);
        UNITS.deg.value = pi2.div(180);
        UNITS.grad.value = pi2.div(200);
        UNITS.cycle.value = pi2.times(2);
        UNITS.arcsec.value = pi2.div(648e3);
        UNITS.arcmin.value = pi2.div(10800);
      } else {
        UNITS.rad.value = 1;
        UNITS.deg.value = Math.PI / 180;
        UNITS.grad.value = Math.PI / 200;
        UNITS.cycle.value = Math.PI * 2;
        UNITS.arcsec.value = Math.PI / 648e3;
        UNITS.arcmin.value = Math.PI / 10800;
      }
      UNITS.radian.value = UNITS.rad.value;
      UNITS.degree.value = UNITS.deg.value;
      UNITS.gradian.value = UNITS.grad.value;
    }
    calculateAngleValues(config);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.number !== prev.number) {
          calculateAngleValues(curr);
        }
      });
    }
    var UNIT_SYSTEMS = {
      si: {
        NONE: {
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE[""]
        },
        LENGTH: {
          unit: UNITS.m,
          prefix: PREFIXES.SHORT[""]
        },
        MASS: {
          unit: UNITS.g,
          prefix: PREFIXES.SHORT.k
        },
        TIME: {
          unit: UNITS.s,
          prefix: PREFIXES.SHORT[""]
        },
        CURRENT: {
          unit: UNITS.A,
          prefix: PREFIXES.SHORT[""]
        },
        TEMPERATURE: {
          unit: UNITS.K,
          prefix: PREFIXES.SHORT[""]
        },
        LUMINOUS_INTENSITY: {
          unit: UNITS.cd,
          prefix: PREFIXES.SHORT[""]
        },
        AMOUNT_OF_SUBSTANCE: {
          unit: UNITS.mol,
          prefix: PREFIXES.SHORT[""]
        },
        ANGLE: {
          unit: UNITS.rad,
          prefix: PREFIXES.SHORT[""]
        },
        BIT: {
          unit: UNITS.bits,
          prefix: PREFIXES.SHORT[""]
        },
        FORCE: {
          unit: UNITS.N,
          prefix: PREFIXES.SHORT[""]
        },
        ENERGY: {
          unit: UNITS.J,
          prefix: PREFIXES.SHORT[""]
        },
        POWER: {
          unit: UNITS.W,
          prefix: PREFIXES.SHORT[""]
        },
        PRESSURE: {
          unit: UNITS.Pa,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CHARGE: {
          unit: UNITS.C,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CAPACITANCE: {
          unit: UNITS.F,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_POTENTIAL: {
          unit: UNITS.V,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_RESISTANCE: {
          unit: UNITS.ohm,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_INDUCTANCE: {
          unit: UNITS.H,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CONDUCTANCE: {
          unit: UNITS.S,
          prefix: PREFIXES.SHORT[""]
        },
        MAGNETIC_FLUX: {
          unit: UNITS.Wb,
          prefix: PREFIXES.SHORT[""]
        },
        MAGNETIC_FLUX_DENSITY: {
          unit: UNITS.T,
          prefix: PREFIXES.SHORT[""]
        },
        FREQUENCY: {
          unit: UNITS.Hz,
          prefix: PREFIXES.SHORT[""]
        }
      }
    };
    UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.cgs.LENGTH = {
      unit: UNITS.m,
      prefix: PREFIXES.SHORT.c
    };
    UNIT_SYSTEMS.cgs.MASS = {
      unit: UNITS.g,
      prefix: PREFIXES.SHORT[""]
    };
    UNIT_SYSTEMS.cgs.FORCE = {
      unit: UNITS.dyn,
      prefix: PREFIXES.SHORT[""]
    };
    UNIT_SYSTEMS.cgs.ENERGY = {
      unit: UNITS.erg,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.us.LENGTH = {
      unit: UNITS.ft,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.MASS = {
      unit: UNITS.lbm,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.TEMPERATURE = {
      unit: UNITS.degF,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.FORCE = {
      unit: UNITS.lbf,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.ENERGY = {
      unit: UNITS.BTU,
      prefix: PREFIXES.BTU[""]
    };
    UNIT_SYSTEMS.us.POWER = {
      unit: UNITS.hp,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.PRESSURE = {
      unit: UNITS.psi,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    var currentUnitSystem = UNIT_SYSTEMS.auto;
    Unit.setUnitSystem = function(name284) {
      if (hasOwnProperty2(UNIT_SYSTEMS, name284)) {
        currentUnitSystem = UNIT_SYSTEMS[name284];
      } else {
        throw new Error("Unit system " + name284 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
      }
    };
    Unit.getUnitSystem = function() {
      for (var _key in UNIT_SYSTEMS) {
        if (hasOwnProperty2(UNIT_SYSTEMS, _key)) {
          if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
            return _key;
          }
        }
      }
    };
    Unit.typeConverters = {
      BigNumber: function BigNumber(x) {
        return new _BigNumber(x + "");
      },
      Fraction: function Fraction2(x) {
        return new _Fraction(x);
      },
      Complex: function Complex3(x) {
        return x;
      },
      number: function number2(x) {
        return x;
      }
    };
    Unit._getNumberConverter = function(type) {
      if (!Unit.typeConverters[type]) {
        throw new TypeError('Unsupported type "' + type + '"');
      }
      return Unit.typeConverters[type];
    };
    for (var _key2 in UNITS) {
      if (hasOwnProperty2(UNITS, _key2)) {
        var unit = UNITS[_key2];
        unit.dimensions = unit.base.dimensions;
      }
    }
    for (var _name2 in ALIASES) {
      if (hasOwnProperty2(ALIASES, _name2)) {
        var _unit2 = UNITS[ALIASES[_name2]];
        var alias = {};
        for (var _key3 in _unit2) {
          if (hasOwnProperty2(_unit2, _key3)) {
            alias[_key3] = _unit2[_key3];
          }
        }
        alias.name = _name2;
        UNITS[_name2] = alias;
      }
    }
    Unit.isValidAlpha = function isValidAlpha(c2) {
      return /^[a-zA-Z]$/.test(c2);
    };
    function assertUnitNameIsValid(name284) {
      for (var i = 0; i < name284.length; i++) {
        c = name284.charAt(i);
        if (i === 0 && !Unit.isValidAlpha(c)) {
          throw new Error('Invalid unit name (must begin with alpha character): "' + name284 + '"');
        }
        if (i > 0 && !(Unit.isValidAlpha(c) || isDigit(c))) {
          throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name284 + '"');
        }
      }
    }
    Unit.createUnit = function(obj, options) {
      if (typeof obj !== "object") {
        throw new TypeError("createUnit expects first parameter to be of type 'Object'");
      }
      if (options && options.override) {
        for (var _key4 in obj) {
          if (hasOwnProperty2(obj, _key4)) {
            Unit.deleteUnit(_key4);
          }
          if (obj[_key4].aliases) {
            for (var i = 0; i < obj[_key4].aliases.length; i++) {
              Unit.deleteUnit(obj[_key4].aliases[i]);
            }
          }
        }
      }
      var lastUnit;
      for (var _key5 in obj) {
        if (hasOwnProperty2(obj, _key5)) {
          lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
        }
      }
      return lastUnit;
    };
    Unit.createUnitSingle = function(name284, obj, options) {
      if (typeof obj === "undefined" || obj === null) {
        obj = {};
      }
      if (typeof name284 !== "string") {
        throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
      }
      if (hasOwnProperty2(UNITS, name284)) {
        throw new Error('Cannot create unit "' + name284 + '": a unit with that name already exists');
      }
      assertUnitNameIsValid(name284);
      var defUnit = null;
      var aliases = [];
      var offset = 0;
      var definition;
      var prefixes;
      var baseName;
      if (obj && obj.type === "Unit") {
        defUnit = obj.clone();
      } else if (typeof obj === "string") {
        if (obj !== "") {
          definition = obj;
        }
      } else if (typeof obj === "object") {
        definition = obj.definition;
        prefixes = obj.prefixes;
        offset = obj.offset;
        baseName = obj.baseName;
        if (obj.aliases) {
          aliases = obj.aliases.valueOf();
        }
      } else {
        throw new TypeError('Cannot create unit "' + name284 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
      }
      if (aliases) {
        for (var i = 0; i < aliases.length; i++) {
          if (hasOwnProperty2(UNITS, aliases[i])) {
            throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
          }
        }
      }
      if (definition && typeof definition === "string" && !defUnit) {
        try {
          defUnit = Unit.parse(definition, {
            allowNoUnits: true
          });
        } catch (ex) {
          ex.message = 'Could not create unit "' + name284 + '" from "' + definition + '": ' + ex.message;
          throw ex;
        }
      } else if (definition && definition.type === "Unit") {
        defUnit = definition.clone();
      }
      aliases = aliases || [];
      offset = offset || 0;
      if (prefixes && prefixes.toUpperCase) {
        prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
      } else {
        prefixes = PREFIXES.NONE;
      }
      var newUnit = {};
      if (!defUnit) {
        baseName = baseName || name284 + "_STUFF";
        if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
          throw new Error('Cannot create new base unit "' + name284 + '": a base unit with that name already exists (and cannot be overridden)');
        }
        BASE_DIMENSIONS.push(baseName);
        for (var b in BASE_UNITS) {
          if (hasOwnProperty2(BASE_UNITS, b)) {
            BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
          }
        }
        var newBaseUnit = {
          dimensions: []
        };
        for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
          newBaseUnit.dimensions[_i6] = 0;
        }
        newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
        newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = newBaseUnit;
        newUnit = {
          name: name284,
          value: 1,
          dimensions: BASE_UNITS[baseName].dimensions.slice(0),
          prefixes,
          offset,
          base: BASE_UNITS[baseName]
        };
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
      } else {
        newUnit = {
          name: name284,
          value: defUnit.value,
          dimensions: defUnit.dimensions.slice(0),
          prefixes,
          offset
        };
        var anyMatch = false;
        for (var _i7 in BASE_UNITS) {
          if (hasOwnProperty2(BASE_UNITS, _i7)) {
            var match = true;
            for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
              if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
                match = false;
                break;
              }
            }
            if (match) {
              anyMatch = true;
              newUnit.base = BASE_UNITS[_i7];
              break;
            }
          }
        }
        if (!anyMatch) {
          baseName = baseName || name284 + "_STUFF";
          var _newBaseUnit = {
            dimensions: defUnit.dimensions.slice(0)
          };
          _newBaseUnit.key = baseName;
          BASE_UNITS[baseName] = _newBaseUnit;
          currentUnitSystem[baseName] = {
            unit: newUnit,
            prefix: PREFIXES.NONE[""]
          };
          newUnit.base = BASE_UNITS[baseName];
        }
      }
      Unit.UNITS[name284] = newUnit;
      for (var _i8 = 0; _i8 < aliases.length; _i8++) {
        var aliasName = aliases[_i8];
        var _alias = {};
        for (var _key6 in newUnit) {
          if (hasOwnProperty2(newUnit, _key6)) {
            _alias[_key6] = newUnit[_key6];
          }
        }
        _alias.name = aliasName;
        Unit.UNITS[aliasName] = _alias;
      }
      delete _findUnit.cache;
      return new Unit(null, name284);
    };
    Unit.deleteUnit = function(name284) {
      delete Unit.UNITS[name284];
    };
    Unit.PREFIXES = PREFIXES;
    Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
    Unit.BASE_UNITS = BASE_UNITS;
    Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
    Unit.UNITS = UNITS;
    return Unit;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/unit/function/unit.js
  var name151 = "unit";
  var dependencies152 = ["typed", "Unit"];
  var createUnitFunction = /* @__PURE__ */ factory(name151, dependencies152, (_ref) => {
    var {
      typed,
      Unit
    } = _ref;
    return typed(name151, {
      Unit: function Unit2(x) {
        return x.clone();
      },
      string: function string(x) {
        if (Unit.isValuelessUnit(x)) {
          return new Unit(null, x);
        }
        return Unit.parse(x, {
          allowNoUnits: true
        });
      },
      "number | BigNumber | Fraction | Complex, string": function numberBigNumberFractionComplexString(value, unit) {
        return new Unit(value, unit);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
  var name152 = "sparse";
  var dependencies153 = ["typed", "SparseMatrix"];
  var createSparse = /* @__PURE__ */ factory(name152, dependencies153, (_ref) => {
    var {
      typed,
      SparseMatrix
    } = _ref;
    return typed(name152, {
      "": function _4() {
        return new SparseMatrix([]);
      },
      string: function string(datatype) {
        return new SparseMatrix([], datatype);
      },
      "Array | Matrix": function ArrayMatrix(data) {
        return new SparseMatrix(data);
      },
      "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
        return new SparseMatrix(data, datatype);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
  var name153 = "createUnit";
  var dependencies154 = ["typed", "Unit"];
  var createCreateUnit = /* @__PURE__ */ factory(name153, dependencies154, (_ref) => {
    var {
      typed,
      Unit
    } = _ref;
    return typed(name153, {
      "Object, Object": function ObjectObject(obj, options) {
        return Unit.createUnit(obj, options);
      },
      Object: function Object2(obj) {
        return Unit.createUnit(obj, {});
      },
      "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name284, def, options) {
        var obj = {};
        obj[name284] = def;
        return Unit.createUnit(obj, options);
      },
      "string, Unit | string | Object": function stringUnitStringObject(name284, def) {
        var obj = {};
        obj[name284] = def;
        return Unit.createUnit(obj, {});
      },
      string: function string(name284) {
        var obj = {};
        obj[name284] = {};
        return Unit.createUnit(obj, {});
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acos.js
  var name154 = "acos";
  var dependencies155 = ["typed", "config", "Complex"];
  var createAcos = /* @__PURE__ */ factory(name154, dependencies155, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2
    } = _ref;
    return typed(name154, {
      number: function number(x) {
        if (x >= -1 && x <= 1 || config.predictable) {
          return Math.acos(x);
        } else {
          return new Complex2(x, 0).acos();
        }
      },
      Complex: function Complex3(x) {
        return x.acos();
      },
      BigNumber: function BigNumber(x) {
        return x.acos();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
  var name155 = "acosh";
  var dependencies156 = ["typed", "config", "Complex"];
  var createAcosh = /* @__PURE__ */ factory(name155, dependencies156, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2
    } = _ref;
    return typed(name155, {
      number: function number(x) {
        if (x >= 1 || config.predictable) {
          return acoshNumber(x);
        }
        if (x <= -1) {
          return new Complex2(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
        }
        return new Complex2(x, 0).acosh();
      },
      Complex: function Complex3(x) {
        return x.acosh();
      },
      BigNumber: function BigNumber(x) {
        return x.acosh();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acot.js
  var name156 = "acot";
  var dependencies157 = ["typed", "BigNumber"];
  var createAcot = /* @__PURE__ */ factory(name156, dependencies157, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name156, {
      number: acotNumber,
      Complex: function Complex2(x) {
        return x.acot();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).atan();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
  var name157 = "acoth";
  var dependencies158 = ["typed", "config", "Complex", "BigNumber"];
  var createAcoth = /* @__PURE__ */ factory(name157, dependencies158, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name157, {
      number: function number(x) {
        if (x >= 1 || x <= -1 || config.predictable) {
          return acothNumber(x);
        }
        return new Complex2(x, 0).acoth();
      },
      Complex: function Complex3(x) {
        return x.acoth();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).atanh();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
  var name158 = "acsc";
  var dependencies159 = ["typed", "config", "Complex", "BigNumber"];
  var createAcsc = /* @__PURE__ */ factory(name158, dependencies159, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name158, {
      number: function number(x) {
        if (x <= -1 || x >= 1 || config.predictable) {
          return acscNumber(x);
        }
        return new Complex2(x, 0).acsc();
      },
      Complex: function Complex3(x) {
        return x.acsc();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).asin();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
  var name159 = "acsch";
  var dependencies160 = ["typed", "BigNumber"];
  var createAcsch = /* @__PURE__ */ factory(name159, dependencies160, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name159, {
      number: acschNumber,
      Complex: function Complex2(x) {
        return x.acsch();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).asinh();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asec.js
  var name160 = "asec";
  var dependencies161 = ["typed", "config", "Complex", "BigNumber"];
  var createAsec = /* @__PURE__ */ factory(name160, dependencies161, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name160, {
      number: function number(x) {
        if (x <= -1 || x >= 1 || config.predictable) {
          return asecNumber(x);
        }
        return new Complex2(x, 0).asec();
      },
      Complex: function Complex3(x) {
        return x.asec();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).acos();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asech.js
  var name161 = "asech";
  var dependencies162 = ["typed", "config", "Complex", "BigNumber"];
  var createAsech = /* @__PURE__ */ factory(name161, dependencies162, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name161, {
      number: function number(x) {
        if (x <= 1 && x >= -1 || config.predictable) {
          var xInv = 1 / x;
          if (xInv > 0 || config.predictable) {
            return asechNumber(x);
          }
          var ret = Math.sqrt(xInv * xInv - 1);
          return new Complex2(Math.log(ret - xInv), Math.PI);
        }
        return new Complex2(x, 0).asech();
      },
      Complex: function Complex3(x) {
        return x.asech();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).acosh();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asin.js
  var name162 = "asin";
  var dependencies163 = ["typed", "config", "Complex"];
  var createAsin = /* @__PURE__ */ factory(name162, dependencies163, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2
    } = _ref;
    return typed(name162, {
      number: function number(x) {
        if (x >= -1 && x <= 1 || config.predictable) {
          return Math.asin(x);
        } else {
          return new Complex2(x, 0).asin();
        }
      },
      Complex: function Complex3(x) {
        return x.asin();
      },
      BigNumber: function BigNumber(x) {
        return x.asin();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
  var name163 = "asinh";
  var dependencies164 = ["typed"];
  var createAsinh = /* @__PURE__ */ factory(name163, dependencies164, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("asinh", {
      number: asinhNumber,
      Complex: function Complex2(x) {
        return x.asinh();
      },
      BigNumber: function BigNumber(x) {
        return x.asinh();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atan.js
  var name164 = "atan";
  var dependencies165 = ["typed"];
  var createAtan = /* @__PURE__ */ factory(name164, dependencies165, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("atan", {
      number: function number(x) {
        return Math.atan(x);
      },
      Complex: function Complex2(x) {
        return x.atan();
      },
      BigNumber: function BigNumber(x) {
        return x.atan();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
  var name165 = "atan2";
  var dependencies166 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
  var createAtan2 = /* @__PURE__ */ factory(name165, dependencies166, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      BigNumber,
      DenseMatrix
    } = _ref;
    var algorithm02 = createAlgorithm02({
      typed,
      equalScalar
    });
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm09 = createAlgorithm09({
      typed,
      equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name165, {
      "number, number": Math.atan2,
      "BigNumber, BigNumber": function BigNumberBigNumber(y, x) {
        return BigNumber.atan2(y, x);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm09(x, y, this, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      "number | BigNumber, Array": function numberBigNumberArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
  var name166 = "atanh";
  var dependencies167 = ["typed", "config", "Complex"];
  var createAtanh = /* @__PURE__ */ factory(name166, dependencies167, (_ref) => {
    var {
      typed,
      config,
      Complex: Complex2
    } = _ref;
    return typed(name166, {
      number: function number(x) {
        if (x <= 1 && x >= -1 || config.predictable) {
          return atanhNumber(x);
        }
        return new Complex2(x, 0).atanh();
      },
      Complex: function Complex3(x) {
        return x.atanh();
      },
      BigNumber: function BigNumber(x) {
        return x.atanh();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cos.js
  var name167 = "cos";
  var dependencies168 = ["typed"];
  var createCos = /* @__PURE__ */ factory(name167, dependencies168, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name167, {
      number: Math.cos,
      Complex: function Complex2(x) {
        return x.cos();
      },
      BigNumber: function BigNumber(x) {
        return x.cos();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function cos is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
  var name168 = "cosh";
  var dependencies169 = ["typed"];
  var createCosh = /* @__PURE__ */ factory(name168, dependencies169, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name168, {
      number: cosh,
      Complex: function Complex2(x) {
        return x.cosh();
      },
      BigNumber: function BigNumber(x) {
        return x.cosh();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function cosh is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cot.js
  var name169 = "cot";
  var dependencies170 = ["typed", "BigNumber"];
  var createCot = /* @__PURE__ */ factory(name169, dependencies170, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name169, {
      number: cotNumber,
      Complex: function Complex2(x) {
        return x.cot();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.tan());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function cot is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/coth.js
  var name170 = "coth";
  var dependencies171 = ["typed", "BigNumber"];
  var createCoth = /* @__PURE__ */ factory(name170, dependencies171, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name170, {
      number: cothNumber,
      Complex: function Complex2(x) {
        return x.coth();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.tanh());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function coth is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/csc.js
  var name171 = "csc";
  var dependencies172 = ["typed", "BigNumber"];
  var createCsc = /* @__PURE__ */ factory(name171, dependencies172, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name171, {
      number: cscNumber,
      Complex: function Complex2(x) {
        return x.csc();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.sin());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function csc is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/csch.js
  var name172 = "csch";
  var dependencies173 = ["typed", "BigNumber"];
  var createCsch = /* @__PURE__ */ factory(name172, dependencies173, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name172, {
      number: cschNumber,
      Complex: function Complex2(x) {
        return x.csch();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.sinh());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function csch is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sec.js
  var name173 = "sec";
  var dependencies174 = ["typed", "BigNumber"];
  var createSec = /* @__PURE__ */ factory(name173, dependencies174, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name173, {
      number: secNumber,
      Complex: function Complex2(x) {
        return x.sec();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.cos());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function sec is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sech.js
  var name174 = "sech";
  var dependencies175 = ["typed", "BigNumber"];
  var createSech = /* @__PURE__ */ factory(name174, dependencies175, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name174, {
      number: sechNumber,
      Complex: function Complex2(x) {
        return x.sech();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.cosh());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function sech is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sin.js
  var name175 = "sin";
  var dependencies176 = ["typed"];
  var createSin = /* @__PURE__ */ factory(name175, dependencies176, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name175, {
      number: Math.sin,
      Complex: function Complex2(x) {
        return x.sin();
      },
      BigNumber: function BigNumber(x) {
        return x.sin();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function sin is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
  var name176 = "sinh";
  var dependencies177 = ["typed"];
  var createSinh = /* @__PURE__ */ factory(name176, dependencies177, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name176, {
      number: sinhNumber,
      Complex: function Complex2(x) {
        return x.sinh();
      },
      BigNumber: function BigNumber(x) {
        return x.sinh();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function sinh is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/tan.js
  var name177 = "tan";
  var dependencies178 = ["typed"];
  var createTan = /* @__PURE__ */ factory(name177, dependencies178, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name177, {
      number: Math.tan,
      Complex: function Complex2(x) {
        return x.tan();
      },
      BigNumber: function BigNumber(x) {
        return x.tan();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function tan is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
  var name178 = "tanh";
  var dependencies179 = ["typed"];
  var createTanh = /* @__PURE__ */ factory(name178, dependencies179, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("tanh", {
      number: tanh,
      Complex: function Complex2(x) {
        return x.tanh();
      },
      BigNumber: function BigNumber(x) {
        return x.tanh();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function tanh is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setCartesian.js
  var name179 = "setCartesian";
  var dependencies180 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetCartesian = /* @__PURE__ */ factory(name179, dependencies180, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index,
      DenseMatrix
    } = _ref;
    return typed(name179, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result = [];
        if (subset(size(a1), new Index(0)) !== 0 && subset(size(a2), new Index(0)) !== 0) {
          var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
          var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
          result = [];
          for (var i = 0; i < b1.length; i++) {
            for (var j = 0; j < b2.length; j++) {
              result.push([b1[i], b2[j]]);
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return result;
        }
        return new DenseMatrix(result);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setDifference.js
  var name180 = "setDifference";
  var dependencies181 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetDifference = /* @__PURE__ */ factory(name180, dependencies181, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index,
      DenseMatrix
    } = _ref;
    return typed(name180, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result;
        if (subset(size(a1), new Index(0)) === 0) {
          result = [];
        } else if (subset(size(a2), new Index(0)) === 0) {
          return flatten(a1.toArray());
        } else {
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
          result = [];
          var inb2;
          for (var i = 0; i < b1.length; i++) {
            inb2 = false;
            for (var j = 0; j < b2.length; j++) {
              if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                inb2 = true;
                break;
              }
            }
            if (!inb2) {
              result.push(b1[i]);
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        }
        return new DenseMatrix(generalize(result));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setDistinct.js
  var name181 = "setDistinct";
  var dependencies182 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetDistinct = /* @__PURE__ */ factory(name181, dependencies182, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index,
      DenseMatrix
    } = _ref;
    return typed(name181, {
      "Array | Matrix": function ArrayMatrix(a) {
        var result;
        if (subset(size(a), new Index(0)) === 0) {
          result = [];
        } else {
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
          result = [];
          result.push(b[0]);
          for (var i = 1; i < b.length; i++) {
            if (compareNatural(b[i], b[i - 1]) !== 0) {
              result.push(b[i]);
            }
          }
        }
        if (Array.isArray(a)) {
          return result;
        }
        return new DenseMatrix(result);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setIntersect.js
  var name182 = "setIntersect";
  var dependencies183 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetIntersect = /* @__PURE__ */ factory(name182, dependencies183, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index,
      DenseMatrix
    } = _ref;
    return typed(name182, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result;
        if (subset(size(a1), new Index(0)) === 0 || subset(size(a2), new Index(0)) === 0) {
          result = [];
        } else {
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
          result = [];
          for (var i = 0; i < b1.length; i++) {
            for (var j = 0; j < b2.length; j++) {
              if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                result.push(b1[i]);
                break;
              }
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        }
        return new DenseMatrix(generalize(result));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setIsSubset.js
  var name183 = "setIsSubset";
  var dependencies184 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetIsSubset = /* @__PURE__ */ factory(name183, dependencies184, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index
    } = _ref;
    return typed(name183, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          return true;
        } else if (subset(size(a2), new Index(0)) === 0) {
          return false;
        }
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        var inb2;
        for (var i = 0; i < b1.length; i++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (inb2 === false) {
            return false;
          }
        }
        return true;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
  var name184 = "setMultiplicity";
  var dependencies185 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetMultiplicity = /* @__PURE__ */ factory(name184, dependencies185, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index
    } = _ref;
    return typed(name184, {
      "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e2, a) {
        if (subset(size(a), new Index(0)) === 0) {
          return 0;
        }
        var b = flatten(Array.isArray(a) ? a : a.toArray());
        var count = 0;
        for (var i = 0; i < b.length; i++) {
          if (compareNatural(b[i], e2) === 0) {
            count++;
          }
        }
        return count;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setPowerset.js
  var name185 = "setPowerset";
  var dependencies186 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetPowerset = /* @__PURE__ */ factory(name185, dependencies186, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index
    } = _ref;
    return typed(name185, {
      "Array | Matrix": function ArrayMatrix(a) {
        if (subset(size(a), new Index(0)) === 0) {
          return [];
        }
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
        var result = [];
        var number = 0;
        while (number.toString(2).length <= b.length) {
          result.push(_subset(b, number.toString(2).split("").reverse()));
          number++;
        }
        return _sort(result);
      }
    });
    function _subset(array, bitarray) {
      var result = [];
      for (var i = 0; i < bitarray.length; i++) {
        if (bitarray[i] === "1") {
          result.push(array[i]);
        }
      }
      return result;
    }
    function _sort(array) {
      var temp = [];
      for (var i = array.length - 1; i > 0; i--) {
        for (var j = 0; j < i; j++) {
          if (array[j].length > array[j + 1].length) {
            temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
          }
        }
      }
      return array;
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setSize.js
  var name186 = "setSize";
  var dependencies187 = ["typed", "compareNatural"];
  var createSetSize = /* @__PURE__ */ factory(name186, dependencies187, (_ref) => {
    var {
      typed,
      compareNatural
    } = _ref;
    return typed(name186, {
      "Array | Matrix": function ArrayMatrix(a) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      },
      "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
        if (unique === false || a.length === 0) {
          return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
        } else {
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
          var count = 1;
          for (var i = 1; i < b.length; i++) {
            if (compareNatural(b[i], b[i - 1]) !== 0) {
              count++;
            }
          }
          return count;
        }
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setSymDifference.js
  var name187 = "setSymDifference";
  var dependencies188 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
  var createSetSymDifference = /* @__PURE__ */ factory(name187, dependencies188, (_ref) => {
    var {
      typed,
      size,
      concat,
      subset,
      setDifference,
      Index
    } = _ref;
    return typed(name187, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          return flatten(a2);
        } else if (subset(size(a2), new Index(0)) === 0) {
          return flatten(a1);
        }
        var b1 = flatten(a1);
        var b2 = flatten(a2);
        return concat(setDifference(b1, b2), setDifference(b2, b1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setUnion.js
  var name188 = "setUnion";
  var dependencies189 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
  var createSetUnion = /* @__PURE__ */ factory(name188, dependencies189, (_ref) => {
    var {
      typed,
      size,
      concat,
      subset,
      setIntersect,
      setSymDifference,
      Index
    } = _ref;
    return typed(name188, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          return flatten(a2);
        } else if (subset(size(a2), new Index(0)) === 0) {
          return flatten(a1);
        }
        var b1 = flatten(a1);
        var b2 = flatten(a2);
        return concat(setSymDifference(b1, b2), setIntersect(b1, b2));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/add.js
  var name189 = "add";
  var dependencies190 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix"];
  var createAdd = /* @__PURE__ */ factory(name189, dependencies190, (_ref) => {
    var {
      typed,
      matrix,
      addScalar,
      equalScalar,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm04 = createAlgorithm04({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed(name189, extend({
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, addScalar);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, addScalar, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm01(y, x, addScalar, true);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm04(x, y, addScalar);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, addScalar, false);
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm10(x, y, addScalar, false);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, addScalar, true);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm10(y, x, addScalar, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, addScalar, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix(y), x, addScalar, true).valueOf();
      },
      "any, any": addScalar,
      "any, any, ...any": function anyAnyAny(x, y, rest) {
        var result = this(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = this(result, rest[i]);
        }
        return result;
      }
    }, addScalar.signatures));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
  var name190 = "hypot";
  var dependencies191 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
  var createHypot = /* @__PURE__ */ factory(name190, dependencies191, (_ref) => {
    var {
      typed,
      abs,
      addScalar,
      divideScalar,
      multiplyScalar,
      sqrt,
      smaller,
      isPositive
    } = _ref;
    return typed(name190, {
      "... number | BigNumber": _hypot,
      Array: function Array2(x) {
        return this.apply(this, flatten(x));
      },
      Matrix: function Matrix(x) {
        return this.apply(this, flatten(x.toArray()));
      }
    });
    function _hypot(args) {
      var result = 0;
      var largest = 0;
      for (var i = 0; i < args.length; i++) {
        var value = abs(args[i]);
        if (smaller(largest, value)) {
          result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
          result = addScalar(result, 1);
          largest = value;
        } else {
          result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
        }
      }
      return multiplyScalar(largest, sqrt(result));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/norm.js
  var name191 = "norm";
  var dependencies192 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
  var createNorm = /* @__PURE__ */ factory(name191, dependencies192, (_ref) => {
    var {
      typed,
      abs,
      add,
      pow,
      conj,
      sqrt,
      multiply,
      equalScalar,
      larger,
      smaller,
      matrix,
      ctranspose,
      eigs
    } = _ref;
    return typed(name191, {
      number: Math.abs,
      Complex: function Complex2(x) {
        return x.abs();
      },
      BigNumber: function BigNumber(x) {
        return x.abs();
      },
      boolean: function boolean(x) {
        return Math.abs(x);
      },
      Array: function Array2(x) {
        return _norm(matrix(x), 2);
      },
      Matrix: function Matrix(x) {
        return _norm(x, 2);
      },
      "number | Complex | BigNumber | boolean, number | BigNumber | string": function numberComplexBigNumberBooleanNumberBigNumberString(x) {
        return this(x);
      },
      "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
        return _norm(matrix(x), p);
      },
      "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
        return _norm(x, p);
      }
    });
    function _vectorNormPlusInfinity(x) {
      var pinf = 0;
      x.forEach(function(value) {
        var v = abs(value);
        if (larger(v, pinf)) {
          pinf = v;
        }
      }, true);
      return pinf;
    }
    function _vectorNormMinusInfinity(x) {
      var ninf;
      x.forEach(function(value) {
        var v = abs(value);
        if (!ninf || smaller(v, ninf)) {
          ninf = v;
        }
      }, true);
      return ninf || 0;
    }
    function _vectorNorm(x, p) {
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _vectorNormPlusInfinity(x);
      }
      if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
        return _vectorNormMinusInfinity(x);
      }
      if (p === "fro") {
        return _norm(x, 2);
      }
      if (typeof p === "number" && !isNaN(p)) {
        if (!equalScalar(p, 0)) {
          var n = 0;
          x.forEach(function(value) {
            n = add(pow(abs(value), p), n);
          }, true);
          return pow(n, 1 / p);
        }
        return Number.POSITIVE_INFINITY;
      }
      throw new Error("Unsupported parameter value");
    }
    function _matrixNormFrobenius(x) {
      var fro = 0;
      x.forEach(function(value, index) {
        fro = add(fro, multiply(value, conj(value)));
      });
      return abs(sqrt(fro));
    }
    function _matrixNormOne(x) {
      var c = [];
      var maxc = 0;
      x.forEach(function(value, index) {
        var j = index[1];
        var cj = add(c[j] || 0, abs(value));
        if (larger(cj, maxc)) {
          maxc = cj;
        }
        c[j] = cj;
      }, true);
      return maxc;
    }
    function _matrixNormTwo(x) {
      var sizeX = x.size();
      if (sizeX[0] !== sizeX[1]) {
        throw new RangeError("Invalid matrix dimensions");
      }
      var tx = ctranspose(x);
      var squaredX = multiply(tx, x);
      var eigenVals = eigs(squaredX).values;
      var rho = eigenVals.get([eigenVals.size()[0] - 1]);
      return abs(sqrt(rho));
    }
    function _matrixNormInfinity(x) {
      var r = [];
      var maxr = 0;
      x.forEach(function(value, index) {
        var i = index[0];
        var ri = add(r[i] || 0, abs(value));
        if (larger(ri, maxr)) {
          maxr = ri;
        }
        r[i] = ri;
      }, true);
      return maxr;
    }
    function _matrixNorm(x, p) {
      if (p === 1) {
        return _matrixNormOne(x);
      }
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _matrixNormInfinity(x);
      }
      if (p === "fro") {
        return _matrixNormFrobenius(x);
      }
      if (p === 2) {
        return _matrixNormTwo(x);
      }
      throw new Error("Unsupported parameter value " + p);
    }
    function _norm(x, p) {
      var sizeX = x.size();
      if (sizeX.length === 1) {
        return _vectorNorm(x, p);
      }
      if (sizeX.length === 2) {
        if (sizeX[0] && sizeX[1]) {
          return _matrixNorm(x, p);
        } else {
          throw new RangeError("Invalid matrix dimensions");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/dot.js
  var name192 = "dot";
  var dependencies193 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
  var createDot = /* @__PURE__ */ factory(name192, dependencies193, (_ref) => {
    var {
      typed,
      addScalar,
      multiplyScalar,
      conj,
      size
    } = _ref;
    return typed(name192, {
      "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
      "SparseMatrix, SparseMatrix": _sparseDot
    });
    function _validateDim(x, y) {
      var xSize = _size(x);
      var ySize = _size(y);
      var xLen, yLen;
      if (xSize.length === 1) {
        xLen = xSize[0];
      } else if (xSize.length === 2 && xSize[1] === 1) {
        xLen = xSize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
      }
      if (ySize.length === 1) {
        yLen = ySize[0];
      } else if (ySize.length === 2 && ySize[1] === 1) {
        yLen = ySize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
      }
      if (xLen !== yLen)
        throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
      if (xLen === 0)
        throw new RangeError("Cannot calculate the dot product of empty vectors");
      return xLen;
    }
    function _denseDot(a, b) {
      var N = _validateDim(a, b);
      var adata = isMatrix(a) ? a._data : a;
      var adt = isMatrix(a) ? a._datatype : void 0;
      var bdata = isMatrix(b) ? b._data : b;
      var bdt = isMatrix(b) ? b._datatype : void 0;
      var aIsColumn = _size(a).length === 2;
      var bIsColumn = _size(b).length === 2;
      var add = addScalar;
      var mul = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        var dt = adt;
        add = typed.find(addScalar, [dt, dt]);
        mul = typed.find(multiplyScalar, [dt, dt]);
      }
      if (!aIsColumn && !bIsColumn) {
        var c = mul(conj(adata[0]), bdata[0]);
        for (var i = 1; i < N; i++) {
          c = add(c, mul(conj(adata[i]), bdata[i]));
        }
        return c;
      }
      if (!aIsColumn && bIsColumn) {
        var _c = mul(conj(adata[0]), bdata[0][0]);
        for (var _i = 1; _i < N; _i++) {
          _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));
        }
        return _c;
      }
      if (aIsColumn && !bIsColumn) {
        var _c2 = mul(conj(adata[0][0]), bdata[0]);
        for (var _i2 = 1; _i2 < N; _i2++) {
          _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));
        }
        return _c2;
      }
      if (aIsColumn && bIsColumn) {
        var _c3 = mul(conj(adata[0][0]), bdata[0][0]);
        for (var _i3 = 1; _i3 < N; _i3++) {
          _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));
        }
        return _c3;
      }
    }
    function _sparseDot(x, y) {
      _validateDim(x, y);
      var xindex = x._index;
      var xvalues = x._values;
      var yindex = y._index;
      var yvalues = y._values;
      var c = 0;
      var add = addScalar;
      var mul = multiplyScalar;
      var i = 0;
      var j = 0;
      while (i < xindex.length && j < yindex.length) {
        var I = xindex[i];
        var J = yindex[j];
        if (I < J) {
          i++;
          continue;
        }
        if (I > J) {
          j++;
          continue;
        }
        if (I === J) {
          c = add(c, mul(xvalues[i], yvalues[j]));
          i++;
          j++;
        }
      }
      return c;
    }
    function _size(x) {
      return isMatrix(x) ? x.size() : size(x);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/trace.js
  var name193 = "trace";
  var dependencies194 = ["typed", "matrix", "add"];
  var createTrace = /* @__PURE__ */ factory(name193, dependencies194, (_ref) => {
    var {
      typed,
      matrix,
      add
    } = _ref;
    return typed("trace", {
      Array: function _arrayTrace(x) {
        return _denseTrace(matrix(x));
      },
      SparseMatrix: _sparseTrace,
      DenseMatrix: _denseTrace,
      any: clone
    });
    function _denseTrace(m) {
      var size = m._size;
      var data = m._data;
      switch (size.length) {
        case 1:
          if (size[0] === 1) {
            return clone(data[0]);
          }
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        case 2: {
          var rows = size[0];
          var cols = size[1];
          if (rows === cols) {
            var sum = 0;
            for (var i = 0; i < rows; i++) {
              sum = add(sum, data[i][i]);
            }
            return sum;
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
      }
    }
    function _sparseTrace(m) {
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var size = m._size;
      var rows = size[0];
      var columns = size[1];
      if (rows === columns) {
        var sum = 0;
        if (values2.length > 0) {
          for (var j = 0; j < columns; j++) {
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            for (var k = k0; k < k1; k++) {
              var i = index[k];
              if (i === j) {
                sum = add(sum, values2[k]);
                break;
              }
              if (i > j) {
                break;
              }
            }
          }
        }
        return sum;
      }
      throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/index.js
  var name194 = "index";
  var dependencies195 = ["typed", "Index"];
  var createIndex = /* @__PURE__ */ factory(name194, dependencies195, (_ref) => {
    var {
      typed,
      Index
    } = _ref;
    return typed(name194, {
      "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
        var ranges = args.map(function(arg) {
          if (isBigNumber(arg)) {
            return arg.toNumber();
          } else if (Array.isArray(arg) || isMatrix(arg)) {
            return arg.map(function(elem) {
              return isBigNumber(elem) ? elem.toNumber() : elem;
            });
          } else {
            return arg;
          }
        });
        var res = new Index();
        Index.apply(res, ranges);
        return res;
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/keywords.js
  var keywords = {
    end: true
  };

  // node_modules/mathjs/lib/esm/expression/node/Node.js
  var name195 = "Node";
  var dependencies196 = ["mathWithTransform"];
  var createNode = /* @__PURE__ */ factory(name195, dependencies196, (_ref) => {
    var {
      mathWithTransform
    } = _ref;
    function Node() {
      if (!(this instanceof Node)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
    }
    Node.prototype.evaluate = function(scope) {
      return this.compile().evaluate(scope);
    };
    Node.prototype.type = "Node";
    Node.prototype.isNode = true;
    Node.prototype.comment = "";
    Node.prototype.compile = function() {
      var expr = this._compile(mathWithTransform, {});
      var args = {};
      var context = null;
      function evaluate(scope) {
        var s = scope || {};
        _validateScope(s);
        return expr(s, args, context);
      }
      return {
        evaluate
      };
    };
    Node.prototype._compile = function(math2, argNames) {
      throw new Error("Method _compile should be implemented by type " + this.type);
    };
    Node.prototype.forEach = function(callback) {
      throw new Error("Cannot run forEach on a Node interface");
    };
    Node.prototype.map = function(callback) {
      throw new Error("Cannot run map on a Node interface");
    };
    Node.prototype._ifNode = function(node) {
      if (!isNode(node)) {
        throw new TypeError("Callback function must return a Node");
      }
      return node;
    };
    Node.prototype.traverse = function(callback) {
      callback(this, null, null);
      function _traverse(node, callback2) {
        node.forEach(function(child, path, parent) {
          callback2(child, path, parent);
          _traverse(child, callback2);
        });
      }
      _traverse(this, callback);
    };
    Node.prototype.transform = function(callback) {
      function _transform(child, path, parent) {
        var replacement = callback(child, path, parent);
        if (replacement !== child) {
          return replacement;
        }
        return child.map(_transform);
      }
      return _transform(this, null, null);
    };
    Node.prototype.filter = function(callback) {
      var nodes = [];
      this.traverse(function(node, path, parent) {
        if (callback(node, path, parent)) {
          nodes.push(node);
        }
      });
      return nodes;
    };
    Node.prototype.clone = function() {
      throw new Error("Cannot clone a Node interface");
    };
    Node.prototype.cloneDeep = function() {
      return this.map(function(node) {
        return node.cloneDeep();
      });
    };
    Node.prototype.equals = function(other) {
      return other ? deepStrictEqual(this, other) : false;
    };
    Node.prototype.toString = function(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toString(options);
    };
    Node.prototype.toJSON = function() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    };
    Node.prototype.toHTML = function(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this.toHTML(options);
    };
    Node.prototype._toString = function() {
      throw new Error("_toString not implemented for " + this.type);
    };
    Node.prototype.toTex = function(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toTex(options);
    };
    Node.prototype._toTex = function(options) {
      throw new Error("_toTex not implemented for " + this.type);
    };
    Node.prototype._getCustomString = function(options) {
      if (options && typeof options === "object") {
        switch (typeof options.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return options.handler(this, options);
          default:
            throw new TypeError("Object or function expected as callback");
        }
      }
    };
    Node.prototype.getIdentifier = function() {
      return this.type;
    };
    Node.prototype.getContent = function() {
      return this;
    };
    function _validateScope(scope) {
      for (var symbol in scope) {
        if (hasOwnProperty2(scope, symbol)) {
          if (symbol in keywords) {
            throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
          }
        }
      }
    }
    return Node;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
  function errorTransform(err) {
    if (err && err.isIndexError) {
      return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
    }
    return err;
  }

  // node_modules/mathjs/lib/esm/expression/node/utils/access.js
  function accessFactory(_ref) {
    var {
      subset
    } = _ref;
    return function access(object, index) {
      try {
        if (Array.isArray(object)) {
          return subset(object, index);
        } else if (object && typeof object.subset === "function") {
          return object.subset(index);
        } else if (typeof object === "string") {
          return subset(object, index);
        } else if (typeof object === "object") {
          if (!index.isObjectProperty()) {
            throw new TypeError("Cannot apply a numeric index as object property");
          }
          return getSafeProperty(object, index.getObjectProperty());
        } else {
          throw new TypeError("Cannot apply index: unsupported type of object");
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }

  // node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
  var name196 = "AccessorNode";
  var dependencies197 = ["subset", "Node"];
  var createAccessorNode = /* @__PURE__ */ factory(name196, dependencies197, (_ref) => {
    var {
      subset,
      Node
    } = _ref;
    var access = accessFactory({
      subset
    });
    function AccessorNode(object, index) {
      if (!(this instanceof AccessorNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!isNode(object)) {
        throw new TypeError('Node expected for parameter "object"');
      }
      if (!isIndexNode(index)) {
        throw new TypeError('IndexNode expected for parameter "index"');
      }
      this.object = object || null;
      this.index = index;
      Object.defineProperty(this, "name", {
        get: function() {
          if (this.index) {
            return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
          } else {
            return this.object.name || "";
          }
        }.bind(this),
        set: function set() {
          throw new Error("Cannot assign a new name, name is read-only");
        }
      });
    }
    AccessorNode.prototype = new Node();
    AccessorNode.prototype.type = "AccessorNode";
    AccessorNode.prototype.isAccessorNode = true;
    AccessorNode.prototype._compile = function(math2, argNames) {
      var evalObject = this.object._compile(math2, argNames);
      var evalIndex = this.index._compile(math2, argNames);
      if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAccessorNode(scope, args, context) {
          return getSafeProperty(evalObject(scope, args, context), prop);
        };
      } else {
        return function evalAccessorNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var index = evalIndex(scope, args, object);
          return access(object, index);
        };
      }
    };
    AccessorNode.prototype.forEach = function(callback) {
      callback(this.object, "object", this);
      callback(this.index, "index", this);
    };
    AccessorNode.prototype.map = function(callback) {
      return new AccessorNode(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
    };
    AccessorNode.prototype.clone = function() {
      return new AccessorNode(this.object, this.index);
    };
    AccessorNode.prototype._toString = function(options) {
      var object = this.object.toString(options);
      if (needParenthesis(this.object)) {
        object = "(" + object + ")";
      }
      return object + this.index.toString(options);
    };
    AccessorNode.prototype.toHTML = function(options) {
      var object = this.object.toHTML(options);
      if (needParenthesis(this.object)) {
        object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return object + this.index.toHTML(options);
    };
    AccessorNode.prototype._toTex = function(options) {
      var object = this.object.toTex(options);
      if (needParenthesis(this.object)) {
        object = "\\left(' + object + '\\right)";
      }
      return object + this.index.toTex(options);
    };
    AccessorNode.prototype.toJSON = function() {
      return {
        mathjs: "AccessorNode",
        object: this.object,
        index: this.index
      };
    };
    AccessorNode.fromJSON = function(json) {
      return new AccessorNode(json.object, json.index);
    };
    function needParenthesis(node) {
      return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
    }
    return AccessorNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
  var name197 = "ArrayNode";
  var dependencies198 = ["Node"];
  var createArrayNode = /* @__PURE__ */ factory(name197, dependencies198, (_ref) => {
    var {
      Node
    } = _ref;
    function ArrayNode(items) {
      if (!(this instanceof ArrayNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.items = items || [];
      if (!Array.isArray(this.items) || !this.items.every(isNode)) {
        throw new TypeError("Array containing Nodes expected");
      }
    }
    ArrayNode.prototype = new Node();
    ArrayNode.prototype.type = "ArrayNode";
    ArrayNode.prototype.isArrayNode = true;
    ArrayNode.prototype._compile = function(math2, argNames) {
      var evalItems = map(this.items, function(item) {
        return item._compile(math2, argNames);
      });
      var asMatrix = math2.config.matrix !== "Array";
      if (asMatrix) {
        var matrix = math2.matrix;
        return function evalArrayNode(scope, args, context) {
          return matrix(map(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          }));
        };
      } else {
        return function evalArrayNode(scope, args, context) {
          return map(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          });
        };
      }
    };
    ArrayNode.prototype.forEach = function(callback) {
      for (var i = 0; i < this.items.length; i++) {
        var node = this.items[i];
        callback(node, "items[" + i + "]", this);
      }
    };
    ArrayNode.prototype.map = function(callback) {
      var items = [];
      for (var i = 0; i < this.items.length; i++) {
        items[i] = this._ifNode(callback(this.items[i], "items[" + i + "]", this));
      }
      return new ArrayNode(items);
    };
    ArrayNode.prototype.clone = function() {
      return new ArrayNode(this.items.slice(0));
    };
    ArrayNode.prototype._toString = function(options) {
      var items = this.items.map(function(node) {
        return node.toString(options);
      });
      return "[" + items.join(", ") + "]";
    };
    ArrayNode.prototype.toJSON = function() {
      return {
        mathjs: "ArrayNode",
        items: this.items
      };
    };
    ArrayNode.fromJSON = function(json) {
      return new ArrayNode(json.items);
    };
    ArrayNode.prototype.toHTML = function(options) {
      var items = this.items.map(function(node) {
        return node.toHTML(options);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    };
    ArrayNode.prototype._toTex = function(options) {
      var s = "\\begin{bmatrix}";
      this.items.forEach(function(node) {
        if (node.items) {
          s += node.items.map(function(childNode) {
            return childNode.toTex(options);
          }).join("&");
        } else {
          s += node.toTex(options);
        }
        s += "\\\\";
      });
      s += "\\end{bmatrix}";
      return s;
    };
    return ArrayNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/utils/assign.js
  function assignFactory(_ref) {
    var {
      subset,
      matrix
    } = _ref;
    return function assign(object, index, value) {
      try {
        if (Array.isArray(object)) {
          return matrix(object).subset(index, value).valueOf();
        } else if (object && typeof object.subset === "function") {
          return object.subset(index, value);
        } else if (typeof object === "string") {
          return subset(object, index, value);
        } else if (typeof object === "object") {
          if (!index.isObjectProperty()) {
            throw TypeError("Cannot apply a numeric index as object property");
          }
          setSafeProperty(object, index.getObjectProperty(), value);
          return object;
        } else {
          throw new TypeError("Cannot apply index: unsupported type of object");
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }

  // node_modules/mathjs/lib/esm/expression/operators.js
  var properties = [{
    AssignmentNode: {},
    FunctionAssignmentNode: {}
  }, {
    ConditionalNode: {
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
    }
  }, {
    "OperatorNode:or": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:xor": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:and": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:bitOr": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:bitXor": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:bitAnd": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:equal": {
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:unequal": {
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:smaller": {
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:larger": {
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:smallerEq": {
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:largerEq": {
      associativity: "left",
      associativeWith: []
    },
    RelationalNode: {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:leftShift": {
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:rightArithShift": {
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:rightLogShift": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:to": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    RangeNode: {}
  }, {
    "OperatorNode:add": {
      associativity: "left",
      associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
    },
    "OperatorNode:subtract": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:multiply": {
      associativity: "left",
      associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
    },
    "OperatorNode:divide": {
      associativity: "left",
      associativeWith: [],
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
    },
    "OperatorNode:dotMultiply": {
      associativity: "left",
      associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
    },
    "OperatorNode:dotDivide": {
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:mod": {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:unaryPlus": {
      associativity: "right"
    },
    "OperatorNode:unaryMinus": {
      associativity: "right"
    },
    "OperatorNode:bitNot": {
      associativity: "right"
    },
    "OperatorNode:not": {
      associativity: "right"
    }
  }, {
    "OperatorNode:pow": {
      associativity: "right",
      associativeWith: [],
      latexRightParens: false
    },
    "OperatorNode:dotPow": {
      associativity: "right",
      associativeWith: []
    }
  }, {
    "OperatorNode:factorial": {
      associativity: "left"
    }
  }, {
    "OperatorNode:transpose": {
      associativity: "left"
    }
  }];
  function getPrecedence(_node, parenthesis) {
    var node = _node;
    if (parenthesis !== "keep") {
      node = _node.getContent();
    }
    var identifier = node.getIdentifier();
    for (var i = 0; i < properties.length; i++) {
      if (identifier in properties[i]) {
        return i;
      }
    }
    return null;
  }
  function getAssociativity(_node, parenthesis) {
    var node = _node;
    if (parenthesis !== "keep") {
      node = _node.getContent();
    }
    var identifier = node.getIdentifier();
    var index = getPrecedence(node, parenthesis);
    if (index === null) {
      return null;
    }
    var property = properties[index][identifier];
    if (hasOwnProperty2(property, "associativity")) {
      if (property.associativity === "left") {
        return "left";
      }
      if (property.associativity === "right") {
        return "right";
      }
      throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
    }
    return null;
  }
  function isAssociativeWith(nodeA, nodeB, parenthesis) {
    var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
    var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
    var identifierA = a.getIdentifier();
    var identifierB = b.getIdentifier();
    var index = getPrecedence(a, parenthesis);
    if (index === null) {
      return null;
    }
    var property = properties[index][identifierA];
    if (hasOwnProperty2(property, "associativeWith") && property.associativeWith instanceof Array) {
      for (var i = 0; i < property.associativeWith.length; i++) {
        if (property.associativeWith[i] === identifierB) {
          return true;
        }
      }
      return false;
    }
    return null;
  }

  // node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
  var name198 = "AssignmentNode";
  var dependencies199 = [
    "subset",
    "?matrix",
    "Node"
  ];
  var createAssignmentNode = /* @__PURE__ */ factory(name198, dependencies199, (_ref) => {
    var {
      subset,
      matrix,
      Node
    } = _ref;
    var access = accessFactory({
      subset
    });
    var assign = assignFactory({
      subset,
      matrix
    });
    function AssignmentNode(object, index, value) {
      if (!(this instanceof AssignmentNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.object = object;
      this.index = value ? index : null;
      this.value = value || index;
      if (!isSymbolNode(object) && !isAccessorNode(object)) {
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      }
      if (isSymbolNode(object) && object.name === "end") {
        throw new Error('Cannot assign to symbol "end"');
      }
      if (this.index && !isIndexNode(this.index)) {
        throw new TypeError('IndexNode expected as "index"');
      }
      if (!isNode(this.value)) {
        throw new TypeError('Node expected as "value"');
      }
      Object.defineProperty(this, "name", {
        get: function() {
          if (this.index) {
            return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
          } else {
            return this.object.name || "";
          }
        }.bind(this),
        set: function set() {
          throw new Error("Cannot assign a new name, name is read-only");
        }
      });
    }
    AssignmentNode.prototype = new Node();
    AssignmentNode.prototype.type = "AssignmentNode";
    AssignmentNode.prototype.isAssignmentNode = true;
    AssignmentNode.prototype._compile = function(math2, argNames) {
      var evalObject = this.object._compile(math2, argNames);
      var evalIndex = this.index ? this.index._compile(math2, argNames) : null;
      var evalValue = this.value._compile(math2, argNames);
      var name284 = this.object.name;
      if (!this.index) {
        if (!isSymbolNode(this.object)) {
          throw new TypeError("SymbolNode expected as object");
        }
        return function evalAssignmentNode(scope, args, context) {
          return setSafeProperty(scope, name284, evalValue(scope, args, context));
        };
      } else if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAssignmentNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          return setSafeProperty(object, prop, value);
        };
      } else if (isSymbolNode(this.object)) {
        return function evalAssignmentNode(scope, args, context) {
          var childObject = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          var index = evalIndex(scope, args, childObject);
          setSafeProperty(scope, name284, assign(childObject, index, value));
          return value;
        };
      } else {
        var evalParentObject = this.object.object._compile(math2, argNames);
        if (this.object.index.isObjectProperty()) {
          var parentProp = this.object.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var childObject = getSafeProperty(parent, parentProp);
            var index = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            setSafeProperty(parent, parentProp, assign(childObject, index, value));
            return value;
          };
        } else {
          var evalParentIndex = this.object.index._compile(math2, argNames);
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var parentIndex = evalParentIndex(scope, args, parent);
            var childObject = access(parent, parentIndex);
            var index = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            assign(parent, parentIndex, assign(childObject, index, value));
            return value;
          };
        }
      }
    };
    AssignmentNode.prototype.forEach = function(callback) {
      callback(this.object, "object", this);
      if (this.index) {
        callback(this.index, "index", this);
      }
      callback(this.value, "value", this);
    };
    AssignmentNode.prototype.map = function(callback) {
      var object = this._ifNode(callback(this.object, "object", this));
      var index = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
      var value = this._ifNode(callback(this.value, "value", this));
      return new AssignmentNode(object, index, value);
    };
    AssignmentNode.prototype.clone = function() {
      return new AssignmentNode(this.object, this.index, this.value);
    };
    function needParenthesis(node, parenthesis) {
      if (!parenthesis) {
        parenthesis = "keep";
      }
      var precedence = getPrecedence(node, parenthesis);
      var exprPrecedence = getPrecedence(node.value, parenthesis);
      return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    AssignmentNode.prototype._toString = function(options) {
      var object = this.object.toString(options);
      var index = this.index ? this.index.toString(options) : "";
      var value = this.value.toString(options);
      if (needParenthesis(this, options && options.parenthesis)) {
        value = "(" + value + ")";
      }
      return object + index + " = " + value;
    };
    AssignmentNode.prototype.toJSON = function() {
      return {
        mathjs: "AssignmentNode",
        object: this.object,
        index: this.index,
        value: this.value
      };
    };
    AssignmentNode.fromJSON = function(json) {
      return new AssignmentNode(json.object, json.index, json.value);
    };
    AssignmentNode.prototype.toHTML = function(options) {
      var object = this.object.toHTML(options);
      var index = this.index ? this.index.toHTML(options) : "";
      var value = this.value.toHTML(options);
      if (needParenthesis(this, options && options.parenthesis)) {
        value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      return object + index + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
    };
    AssignmentNode.prototype._toTex = function(options) {
      var object = this.object.toTex(options);
      var index = this.index ? this.index.toTex(options) : "";
      var value = this.value.toTex(options);
      if (needParenthesis(this, options && options.parenthesis)) {
        value = "\\left(".concat(value, "\\right)");
      }
      return object + index + ":=" + value;
    };
    return AssignmentNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/BlockNode.js
  var name199 = "BlockNode";
  var dependencies200 = ["ResultSet", "Node"];
  var createBlockNode = /* @__PURE__ */ factory(name199, dependencies200, (_ref) => {
    var {
      ResultSet,
      Node
    } = _ref;
    function BlockNode(blocks) {
      if (!(this instanceof BlockNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!Array.isArray(blocks))
        throw new Error("Array expected");
      this.blocks = blocks.map(function(block) {
        var node = block && block.node;
        var visible = block && block.visible !== void 0 ? block.visible : true;
        if (!isNode(node))
          throw new TypeError('Property "node" must be a Node');
        if (typeof visible !== "boolean")
          throw new TypeError('Property "visible" must be a boolean');
        return {
          node,
          visible
        };
      });
    }
    BlockNode.prototype = new Node();
    BlockNode.prototype.type = "BlockNode";
    BlockNode.prototype.isBlockNode = true;
    BlockNode.prototype._compile = function(math2, argNames) {
      var evalBlocks = map(this.blocks, function(block) {
        return {
          evaluate: block.node._compile(math2, argNames),
          visible: block.visible
        };
      });
      return function evalBlockNodes(scope, args, context) {
        var results = [];
        forEach(evalBlocks, function evalBlockNode(block) {
          var result = block.evaluate(scope, args, context);
          if (block.visible) {
            results.push(result);
          }
        });
        return new ResultSet(results);
      };
    };
    BlockNode.prototype.forEach = function(callback) {
      for (var i = 0; i < this.blocks.length; i++) {
        callback(this.blocks[i].node, "blocks[" + i + "].node", this);
      }
    };
    BlockNode.prototype.map = function(callback) {
      var blocks = [];
      for (var i = 0; i < this.blocks.length; i++) {
        var block = this.blocks[i];
        var node = this._ifNode(callback(block.node, "blocks[" + i + "].node", this));
        blocks[i] = {
          node,
          visible: block.visible
        };
      }
      return new BlockNode(blocks);
    };
    BlockNode.prototype.clone = function() {
      var blocks = this.blocks.map(function(block) {
        return {
          node: block.node,
          visible: block.visible
        };
      });
      return new BlockNode(blocks);
    };
    BlockNode.prototype._toString = function(options) {
      return this.blocks.map(function(param) {
        return param.node.toString(options) + (param.visible ? "" : ";");
      }).join("\n");
    };
    BlockNode.prototype.toJSON = function() {
      return {
        mathjs: "BlockNode",
        blocks: this.blocks
      };
    };
    BlockNode.fromJSON = function(json) {
      return new BlockNode(json.blocks);
    };
    BlockNode.prototype.toHTML = function(options) {
      return this.blocks.map(function(param) {
        return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    };
    BlockNode.prototype._toTex = function(options) {
      return this.blocks.map(function(param) {
        return param.node.toTex(options) + (param.visible ? "" : ";");
      }).join("\\;\\;\n");
    };
    return BlockNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
  var name200 = "ConditionalNode";
  var dependencies201 = ["Node"];
  var createConditionalNode = /* @__PURE__ */ factory(name200, dependencies201, (_ref) => {
    var {
      Node
    } = _ref;
    function ConditionalNode(condition, trueExpr, falseExpr) {
      if (!(this instanceof ConditionalNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!isNode(condition))
        throw new TypeError("Parameter condition must be a Node");
      if (!isNode(trueExpr))
        throw new TypeError("Parameter trueExpr must be a Node");
      if (!isNode(falseExpr))
        throw new TypeError("Parameter falseExpr must be a Node");
      this.condition = condition;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    }
    ConditionalNode.prototype = new Node();
    ConditionalNode.prototype.type = "ConditionalNode";
    ConditionalNode.prototype.isConditionalNode = true;
    ConditionalNode.prototype._compile = function(math2, argNames) {
      var evalCondition = this.condition._compile(math2, argNames);
      var evalTrueExpr = this.trueExpr._compile(math2, argNames);
      var evalFalseExpr = this.falseExpr._compile(math2, argNames);
      return function evalConditionalNode(scope, args, context) {
        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
      };
    };
    ConditionalNode.prototype.forEach = function(callback) {
      callback(this.condition, "condition", this);
      callback(this.trueExpr, "trueExpr", this);
      callback(this.falseExpr, "falseExpr", this);
    };
    ConditionalNode.prototype.map = function(callback) {
      return new ConditionalNode(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
    };
    ConditionalNode.prototype.clone = function() {
      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
    };
    ConditionalNode.prototype._toString = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis);
      var condition = this.condition.toString(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = "(" + condition + ")";
      }
      var trueExpr = this.trueExpr.toString(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = "(" + trueExpr + ")";
      }
      var falseExpr = this.falseExpr.toString(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = "(" + falseExpr + ")";
      }
      return condition + " ? " + trueExpr + " : " + falseExpr;
    };
    ConditionalNode.prototype.toJSON = function() {
      return {
        mathjs: "ConditionalNode",
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    };
    ConditionalNode.fromJSON = function(json) {
      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);
    };
    ConditionalNode.prototype.toHTML = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis);
      var condition = this.condition.toHTML(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var trueExpr = this.trueExpr.toHTML(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var falseExpr = this.falseExpr.toHTML(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
    };
    ConditionalNode.prototype._toTex = function(options) {
      return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    };
    function testCondition(condition) {
      if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
        return !!condition;
      }
      if (condition) {
        if (isBigNumber(condition)) {
          return !condition.isZero();
        }
        if (isComplex(condition)) {
          return !!(condition.re || condition.im);
        }
        if (isUnit(condition)) {
          return !!condition.value;
        }
      }
      if (condition === null || condition === void 0) {
        return false;
      }
      throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
    }
    return ConditionalNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/utils/latex.js
  var import_escape_latex = __toModule(require_dist());
  var latexSymbols = {
    Alpha: "A",
    alpha: "\\alpha",
    Beta: "B",
    beta: "\\beta",
    Gamma: "\\Gamma",
    gamma: "\\gamma",
    Delta: "\\Delta",
    delta: "\\delta",
    Epsilon: "E",
    epsilon: "\\epsilon",
    varepsilon: "\\varepsilon",
    Zeta: "Z",
    zeta: "\\zeta",
    Eta: "H",
    eta: "\\eta",
    Theta: "\\Theta",
    theta: "\\theta",
    vartheta: "\\vartheta",
    Iota: "I",
    iota: "\\iota",
    Kappa: "K",
    kappa: "\\kappa",
    varkappa: "\\varkappa",
    Lambda: "\\Lambda",
    lambda: "\\lambda",
    Mu: "M",
    mu: "\\mu",
    Nu: "N",
    nu: "\\nu",
    Xi: "\\Xi",
    xi: "\\xi",
    Omicron: "O",
    omicron: "o",
    Pi: "\\Pi",
    pi: "\\pi",
    varpi: "\\varpi",
    Rho: "P",
    rho: "\\rho",
    varrho: "\\varrho",
    Sigma: "\\Sigma",
    sigma: "\\sigma",
    varsigma: "\\varsigma",
    Tau: "T",
    tau: "\\tau",
    Upsilon: "\\Upsilon",
    upsilon: "\\upsilon",
    Phi: "\\Phi",
    phi: "\\phi",
    varphi: "\\varphi",
    Chi: "X",
    chi: "\\chi",
    Psi: "\\Psi",
    psi: "\\psi",
    Omega: "\\Omega",
    omega: "\\omega",
    true: "\\mathrm{True}",
    false: "\\mathrm{False}",
    i: "i",
    inf: "\\infty",
    Inf: "\\infty",
    infinity: "\\infty",
    Infinity: "\\infty",
    oo: "\\infty",
    lim: "\\lim",
    undefined: "\\mathbf{?}"
  };
  var latexOperators = {
    transpose: "^\\top",
    ctranspose: "^H",
    factorial: "!",
    pow: "^",
    dotPow: ".^\\wedge",
    unaryPlus: "+",
    unaryMinus: "-",
    bitNot: "\\~",
    not: "\\neg",
    multiply: "\\cdot",
    divide: "\\frac",
    dotMultiply: ".\\cdot",
    dotDivide: ".:",
    mod: "\\mod",
    add: "+",
    subtract: "-",
    to: "\\rightarrow",
    leftShift: "<<",
    rightArithShift: ">>",
    rightLogShift: ">>>",
    equal: "=",
    unequal: "\\neq",
    smaller: "<",
    larger: ">",
    smallerEq: "\\leq",
    largerEq: "\\geq",
    bitAnd: "\\&",
    bitXor: "\\underline{|}",
    bitOr: "|",
    and: "\\wedge",
    xor: "\\veebar",
    or: "\\vee"
  };
  var latexFunctions = {
    abs: {
      1: "\\left|${args[0]}\\right|"
    },
    add: {
      2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
    },
    cbrt: {
      1: "\\sqrt[3]{${args[0]}}"
    },
    ceil: {
      1: "\\left\\lceil${args[0]}\\right\\rceil"
    },
    cube: {
      1: "\\left(${args[0]}\\right)^3"
    },
    divide: {
      2: "\\frac{${args[0]}}{${args[1]}}"
    },
    dotDivide: {
      2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
    },
    dotMultiply: {
      2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
    },
    dotPow: {
      2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
    },
    exp: {
      1: "\\exp\\left(${args[0]}\\right)"
    },
    expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
    fix: {
      1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
    },
    floor: {
      1: "\\left\\lfloor${args[0]}\\right\\rfloor"
    },
    gcd: "\\gcd\\left(${args}\\right)",
    hypot: "\\hypot\\left(${args}\\right)",
    log: {
      1: "\\ln\\left(${args[0]}\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
    },
    log10: {
      1: "\\log_{10}\\left(${args[0]}\\right)"
    },
    log1p: {
      1: "\\ln\\left(${args[0]}+1\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
    },
    log2: "\\log_{2}\\left(${args[0]}\\right)",
    mod: {
      2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
    },
    multiply: {
      2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
    },
    norm: {
      1: "\\left\\|${args[0]}\\right\\|",
      2: void 0
    },
    nthRoot: {
      2: "\\sqrt[${args[1]}]{${args[0]}}"
    },
    nthRoots: {
      2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
    },
    pow: {
      2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
    },
    round: {
      1: "\\left\\lfloor${args[0]}\\right\\rceil",
      2: void 0
    },
    sign: {
      1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
    },
    sqrt: {
      1: "\\sqrt{${args[0]}}"
    },
    square: {
      1: "\\left(${args[0]}\\right)^2"
    },
    subtract: {
      2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
    },
    unaryMinus: {
      1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
    },
    unaryPlus: {
      1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
    },
    bitAnd: {
      2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
    },
    bitNot: {
      1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
    },
    bitOr: {
      2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
    },
    bitXor: {
      2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
    },
    leftShift: {
      2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
    },
    rightArithShift: {
      2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
    },
    rightLogShift: {
      2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
    },
    bellNumbers: {
      1: "\\mathrm{B}_{${args[0]}}"
    },
    catalan: {
      1: "\\mathrm{C}_{${args[0]}}"
    },
    stirlingS2: {
      2: "\\mathrm{S}\\left(${args}\\right)"
    },
    arg: {
      1: "\\arg\\left(${args[0]}\\right)"
    },
    conj: {
      1: "\\left(${args[0]}\\right)^*"
    },
    im: {
      1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
    },
    re: {
      1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
    },
    and: {
      2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
    },
    not: {
      1: latexOperators.not + "\\left(${args[0]}\\right)"
    },
    or: {
      2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
    },
    xor: {
      2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
    },
    cross: {
      2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
    },
    ctranspose: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
    },
    det: {
      1: "\\det\\left(${args[0]}\\right)"
    },
    dot: {
      2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
    },
    expm: {
      1: "\\exp\\left(${args[0]}\\right)"
    },
    inv: {
      1: "\\left(${args[0]}\\right)^{-1}"
    },
    sqrtm: {
      1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
    },
    trace: {
      1: "\\mathrm{tr}\\left(${args[0]}\\right)"
    },
    transpose: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
    },
    combinations: {
      2: "\\binom{${args[0]}}{${args[1]}}"
    },
    combinationsWithRep: {
      2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
    },
    factorial: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
    },
    gamma: {
      1: "\\Gamma\\left(${args[0]}\\right)"
    },
    equal: {
      2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
    },
    larger: {
      2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
    },
    largerEq: {
      2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
    },
    smaller: {
      2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
    },
    smallerEq: {
      2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
    },
    unequal: {
      2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
    },
    erf: {
      1: "erf\\left(${args[0]}\\right)"
    },
    max: "\\max\\left(${args}\\right)",
    min: "\\min\\left(${args}\\right)",
    variance: "\\mathrm{Var}\\left(${args}\\right)",
    acos: {
      1: "\\cos^{-1}\\left(${args[0]}\\right)"
    },
    acosh: {
      1: "\\cosh^{-1}\\left(${args[0]}\\right)"
    },
    acot: {
      1: "\\cot^{-1}\\left(${args[0]}\\right)"
    },
    acoth: {
      1: "\\coth^{-1}\\left(${args[0]}\\right)"
    },
    acsc: {
      1: "\\csc^{-1}\\left(${args[0]}\\right)"
    },
    acsch: {
      1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
    },
    asec: {
      1: "\\sec^{-1}\\left(${args[0]}\\right)"
    },
    asech: {
      1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
    },
    asin: {
      1: "\\sin^{-1}\\left(${args[0]}\\right)"
    },
    asinh: {
      1: "\\sinh^{-1}\\left(${args[0]}\\right)"
    },
    atan: {
      1: "\\tan^{-1}\\left(${args[0]}\\right)"
    },
    atan2: {
      2: "\\mathrm{atan2}\\left(${args}\\right)"
    },
    atanh: {
      1: "\\tanh^{-1}\\left(${args[0]}\\right)"
    },
    cos: {
      1: "\\cos\\left(${args[0]}\\right)"
    },
    cosh: {
      1: "\\cosh\\left(${args[0]}\\right)"
    },
    cot: {
      1: "\\cot\\left(${args[0]}\\right)"
    },
    coth: {
      1: "\\coth\\left(${args[0]}\\right)"
    },
    csc: {
      1: "\\csc\\left(${args[0]}\\right)"
    },
    csch: {
      1: "\\mathrm{csch}\\left(${args[0]}\\right)"
    },
    sec: {
      1: "\\sec\\left(${args[0]}\\right)"
    },
    sech: {
      1: "\\mathrm{sech}\\left(${args[0]}\\right)"
    },
    sin: {
      1: "\\sin\\left(${args[0]}\\right)"
    },
    sinh: {
      1: "\\sinh\\left(${args[0]}\\right)"
    },
    tan: {
      1: "\\tan\\left(${args[0]}\\right)"
    },
    tanh: {
      1: "\\tanh\\left(${args[0]}\\right)"
    },
    to: {
      2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
    },
    numeric: function numeric(node, options) {
      return node.args[0].toTex();
    },
    number: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
    },
    string: {
      0: '\\mathtt{""}',
      1: "\\mathrm{string}\\left(${args[0]}\\right)"
    },
    bignumber: {
      0: "0",
      1: "\\left(${args[0]}\\right)"
    },
    complex: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
    },
    matrix: {
      0: "\\begin{bmatrix}\\end{bmatrix}",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(${args[0]}\\right)"
    },
    sparse: {
      0: "\\begin{bsparse}\\end{bsparse}",
      1: "\\left(${args[0]}\\right)"
    },
    unit: {
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
    }
  };
  var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
  var latexUnits = {
    deg: "^\\circ"
  };
  function escapeLatex(string) {
    return (0, import_escape_latex.default)(string, {
      preserveFormatting: true
    });
  }
  function toSymbol(name284, isUnit2) {
    isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
    if (isUnit2) {
      if (hasOwnProperty2(latexUnits, name284)) {
        return latexUnits[name284];
      }
      return "\\mathrm{" + escapeLatex(name284) + "}";
    }
    if (hasOwnProperty2(latexSymbols, name284)) {
      return latexSymbols[name284];
    }
    return escapeLatex(name284);
  }

  // node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
  var name201 = "ConstantNode";
  var dependencies202 = ["Node"];
  var createConstantNode = /* @__PURE__ */ factory(name201, dependencies202, (_ref) => {
    var {
      Node
    } = _ref;
    function ConstantNode(value) {
      if (!(this instanceof ConstantNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.value = value;
    }
    ConstantNode.prototype = new Node();
    ConstantNode.prototype.type = "ConstantNode";
    ConstantNode.prototype.isConstantNode = true;
    ConstantNode.prototype._compile = function(math2, argNames) {
      var value = this.value;
      return function evalConstantNode() {
        return value;
      };
    };
    ConstantNode.prototype.forEach = function(callback) {
    };
    ConstantNode.prototype.map = function(callback) {
      return this.clone();
    };
    ConstantNode.prototype.clone = function() {
      return new ConstantNode(this.value);
    };
    ConstantNode.prototype._toString = function(options) {
      return format3(this.value, options);
    };
    ConstantNode.prototype.toHTML = function(options) {
      var value = this._toString(options);
      switch (typeOf(this.value)) {
        case "number":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + value + "</span>";
        case "string":
          return '<span class="math-string">' + value + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + value + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + value + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + value + "</span>";
        default:
          return '<span class="math-symbol">' + value + "</span>";
      }
    };
    ConstantNode.prototype.toJSON = function() {
      return {
        mathjs: "ConstantNode",
        value: this.value
      };
    };
    ConstantNode.fromJSON = function(json) {
      return new ConstantNode(json.value);
    };
    ConstantNode.prototype._toTex = function(options) {
      var value = this._toString(options);
      switch (typeOf(this.value)) {
        case "string":
          return "\\mathtt{" + escapeLatex(value) + "}";
        case "number":
        case "BigNumber":
          {
            if (!isFinite(this.value)) {
              return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
            }
            var index = value.toLowerCase().indexOf("e");
            if (index !== -1) {
              return value.substring(0, index) + "\\cdot10^{" + value.substring(index + 1) + "}";
            }
          }
          return value;
        case "Fraction":
          return this.value.toLatex();
        default:
          return value;
      }
    };
    return ConstantNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
  var name202 = "FunctionAssignmentNode";
  var dependencies203 = ["typed", "Node"];
  var createFunctionAssignmentNode = /* @__PURE__ */ factory(name202, dependencies203, (_ref) => {
    var {
      typed,
      Node
    } = _ref;
    function FunctionAssignmentNode(name284, params, expr) {
      if (!(this instanceof FunctionAssignmentNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (typeof name284 !== "string")
        throw new TypeError('String expected for parameter "name"');
      if (!Array.isArray(params))
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      if (!isNode(expr))
        throw new TypeError('Node expected for parameter "expr"');
      if (name284 in keywords)
        throw new Error('Illegal function name, "' + name284 + '" is a reserved keyword');
      this.name = name284;
      this.params = params.map(function(param) {
        return param && param.name || param;
      });
      this.types = params.map(function(param) {
        return param && param.type || "any";
      });
      this.expr = expr;
    }
    FunctionAssignmentNode.prototype = new Node();
    FunctionAssignmentNode.prototype.type = "FunctionAssignmentNode";
    FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;
    FunctionAssignmentNode.prototype._compile = function(math2, argNames) {
      var childArgNames = Object.create(argNames);
      forEach(this.params, function(param) {
        childArgNames[param] = true;
      });
      var evalExpr = this.expr._compile(math2, childArgNames);
      var name284 = this.name;
      var params = this.params;
      var signature = join(this.types, ",");
      var syntax = name284 + "(" + join(this.params, ", ") + ")";
      return function evalFunctionAssignmentNode(scope, args, context) {
        var signatures = {};
        signatures[signature] = function() {
          var childArgs = Object.create(args);
          for (var i = 0; i < params.length; i++) {
            childArgs[params[i]] = arguments[i];
          }
          return evalExpr(scope, childArgs, context);
        };
        var fn = typed(name284, signatures);
        fn.syntax = syntax;
        setSafeProperty(scope, name284, fn);
        return fn;
      };
    };
    FunctionAssignmentNode.prototype.forEach = function(callback) {
      callback(this.expr, "expr", this);
    };
    FunctionAssignmentNode.prototype.map = function(callback) {
      var expr = this._ifNode(callback(this.expr, "expr", this));
      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
    };
    FunctionAssignmentNode.prototype.clone = function() {
      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
    };
    function needParenthesis(node, parenthesis) {
      var precedence = getPrecedence(node, parenthesis);
      var exprPrecedence = getPrecedence(node.expr, parenthesis);
      return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    FunctionAssignmentNode.prototype._toString = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toString(options);
      if (needParenthesis(this, parenthesis)) {
        expr = "(" + expr + ")";
      }
      return this.name + "(" + this.params.join(", ") + ") = " + expr;
    };
    FunctionAssignmentNode.prototype.toJSON = function() {
      var types = this.types;
      return {
        mathjs: "FunctionAssignmentNode",
        name: this.name,
        params: this.params.map(function(param, index) {
          return {
            name: param,
            type: types[index]
          };
        }),
        expr: this.expr
      };
    };
    FunctionAssignmentNode.fromJSON = function(json) {
      return new FunctionAssignmentNode(json.name, json.params, json.expr);
    };
    FunctionAssignmentNode.prototype.toHTML = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var params = [];
      for (var i = 0; i < this.params.length; i++) {
        params.push('<span class="math-symbol math-parameter">' + escape2(this.params[i]) + "</span>");
      }
      var expr = this.expr.toHTML(options);
      if (needParenthesis(this, parenthesis)) {
        expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return '<span class="math-function">' + escape2(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
    };
    FunctionAssignmentNode.prototype._toTex = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toTex(options);
      if (needParenthesis(this, parenthesis)) {
        expr = "\\left(".concat(expr, "\\right)");
      }
      return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right):=" + expr;
    };
    return FunctionAssignmentNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/IndexNode.js
  var name203 = "IndexNode";
  var dependencies204 = ["Range", "Node", "size"];
  var createIndexNode = /* @__PURE__ */ factory(name203, dependencies204, (_ref) => {
    var {
      Range,
      Node,
      size
    } = _ref;
    function IndexNode(dimensions, dotNotation) {
      if (!(this instanceof IndexNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.dimensions = dimensions;
      this.dotNotation = dotNotation || false;
      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      }
      if (this.dotNotation && !this.isObjectProperty()) {
        throw new Error("dotNotation only applicable for object properties");
      }
    }
    IndexNode.prototype = new Node();
    IndexNode.prototype.type = "IndexNode";
    IndexNode.prototype.isIndexNode = true;
    IndexNode.prototype._compile = function(math2, argNames) {
      var evalDimensions = map(this.dimensions, function(range, i) {
        if (isRangeNode(range)) {
          if (range.needsEnd()) {
            var childArgNames = Object.create(argNames);
            childArgNames.end = true;
            var evalStart = range.start._compile(math2, childArgNames);
            var evalEnd = range.end._compile(math2, childArgNames);
            var evalStep = range.step ? range.step._compile(math2, childArgNames) : function() {
              return 1;
            };
            return function evalDimension(scope, args, context) {
              var s = size(context).valueOf();
              var childArgs = Object.create(args);
              childArgs.end = s[i];
              return createRange2(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));
            };
          } else {
            var _evalStart = range.start._compile(math2, argNames);
            var _evalEnd = range.end._compile(math2, argNames);
            var _evalStep = range.step ? range.step._compile(math2, argNames) : function() {
              return 1;
            };
            return function evalDimension(scope, args, context) {
              return createRange2(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));
            };
          }
        } else if (isSymbolNode(range) && range.name === "end") {
          var _childArgNames = Object.create(argNames);
          _childArgNames.end = true;
          var evalRange = range._compile(math2, _childArgNames);
          return function evalDimension(scope, args, context) {
            var s = size(context).valueOf();
            var childArgs = Object.create(args);
            childArgs.end = s[i];
            return evalRange(scope, childArgs, context);
          };
        } else {
          var _evalRange = range._compile(math2, argNames);
          return function evalDimension(scope, args, context) {
            return _evalRange(scope, args, context);
          };
        }
      });
      var index = getSafeProperty(math2, "index");
      return function evalIndexNode(scope, args, context) {
        var dimensions = map(evalDimensions, function(evalDimension) {
          return evalDimension(scope, args, context);
        });
        return index(...dimensions);
      };
    };
    IndexNode.prototype.forEach = function(callback) {
      for (var i = 0; i < this.dimensions.length; i++) {
        callback(this.dimensions[i], "dimensions[" + i + "]", this);
      }
    };
    IndexNode.prototype.map = function(callback) {
      var dimensions = [];
      for (var i = 0; i < this.dimensions.length; i++) {
        dimensions[i] = this._ifNode(callback(this.dimensions[i], "dimensions[" + i + "]", this));
      }
      return new IndexNode(dimensions, this.dotNotation);
    };
    IndexNode.prototype.clone = function() {
      return new IndexNode(this.dimensions.slice(0), this.dotNotation);
    };
    IndexNode.prototype.isObjectProperty = function() {
      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
    };
    IndexNode.prototype.getObjectProperty = function() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    };
    IndexNode.prototype._toString = function(options) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    };
    IndexNode.prototype.toJSON = function() {
      return {
        mathjs: "IndexNode",
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    };
    IndexNode.fromJSON = function(json) {
      return new IndexNode(json.dimensions, json.dotNotation);
    };
    IndexNode.prototype.toHTML = function(options) {
      var dimensions = [];
      for (var i = 0; i < this.dimensions.length; i++) {
        dimensions[i] = this.dimensions[i].toHTML();
      }
      if (this.dotNotation) {
        return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape2(this.getObjectProperty()) + "</span>";
      } else {
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
    };
    IndexNode.prototype._toTex = function(options) {
      var dimensions = this.dimensions.map(function(range) {
        return range.toTex(options);
      });
      return this.dotNotation ? "." + this.getObjectProperty() + "" : "_{" + dimensions.join(",") + "}";
    };
    function createRange2(start, end, step) {
      return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);
    }
    return IndexNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
  var name204 = "ObjectNode";
  var dependencies205 = ["Node"];
  var createObjectNode = /* @__PURE__ */ factory(name204, dependencies205, (_ref) => {
    var {
      Node
    } = _ref;
    function ObjectNode(properties2) {
      if (!(this instanceof ObjectNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.properties = properties2 || {};
      if (properties2) {
        if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
          return isNode(properties2[key]);
        })) {
          throw new TypeError("Object containing Nodes expected");
        }
      }
    }
    ObjectNode.prototype = new Node();
    ObjectNode.prototype.type = "ObjectNode";
    ObjectNode.prototype.isObjectNode = true;
    ObjectNode.prototype._compile = function(math2, argNames) {
      var evalEntries = {};
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          var stringifiedKey = stringify(key);
          var parsedKey = JSON.parse(stringifiedKey);
          if (!isSafeProperty(this.properties, parsedKey)) {
            throw new Error('No access to property "' + parsedKey + '"');
          }
          evalEntries[parsedKey] = this.properties[key]._compile(math2, argNames);
        }
      }
      return function evalObjectNode(scope, args, context) {
        var obj = {};
        for (var _key in evalEntries) {
          if (hasOwnProperty2(evalEntries, _key)) {
            obj[_key] = evalEntries[_key](scope, args, context);
          }
        }
        return obj;
      };
    };
    ObjectNode.prototype.forEach = function(callback) {
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          callback(this.properties[key], "properties[" + stringify(key) + "]", this);
        }
      }
    };
    ObjectNode.prototype.map = function(callback) {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
        }
      }
      return new ObjectNode(properties2);
    };
    ObjectNode.prototype.clone = function() {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          properties2[key] = this.properties[key];
        }
      }
      return new ObjectNode(properties2);
    };
    ObjectNode.prototype._toString = function(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          entries.push(stringify(key) + ": " + this.properties[key].toString(options));
        }
      }
      return "{" + entries.join(", ") + "}";
    };
    ObjectNode.prototype.toJSON = function() {
      return {
        mathjs: "ObjectNode",
        properties: this.properties
      };
    };
    ObjectNode.fromJSON = function(json) {
      return new ObjectNode(json.properties);
    };
    ObjectNode.prototype.toHTML = function(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          entries.push('<span class="math-symbol math-property">' + escape2(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
        }
      }
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    };
    ObjectNode.prototype._toTex = function(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty2(this.properties, key)) {
          entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
        }
      }
      return "\\left\\{\\begin{array}{ll}".concat(entries.join("\n"), "\\end{array}\\right\\}");
    };
    return ObjectNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
  var name205 = "OperatorNode";
  var dependencies206 = ["Node"];
  var createOperatorNode = /* @__PURE__ */ factory(name205, dependencies206, (_ref) => {
    var {
      Node
    } = _ref;
    function OperatorNode(op, fn, args, implicit) {
      if (!(this instanceof OperatorNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (typeof op !== "string") {
        throw new TypeError('string expected for parameter "op"');
      }
      if (typeof fn !== "string") {
        throw new TypeError('string expected for parameter "fn"');
      }
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.implicit = implicit === true;
      this.op = op;
      this.fn = fn;
      this.args = args || [];
    }
    OperatorNode.prototype = new Node();
    OperatorNode.prototype.type = "OperatorNode";
    OperatorNode.prototype.isOperatorNode = true;
    OperatorNode.prototype._compile = function(math2, argNames) {
      if (typeof this.fn !== "string" || !isSafeMethod(math2, this.fn)) {
        if (!math2[this.fn]) {
          throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
        } else {
          throw new Error('No access to function "' + this.fn + '"');
        }
      }
      var fn = getSafeProperty(math2, this.fn);
      var evalArgs = map(this.args, function(arg) {
        return arg._compile(math2, argNames);
      });
      if (evalArgs.length === 1) {
        var evalArg0 = evalArgs[0];
        return function evalOperatorNode(scope, args, context) {
          return fn(evalArg0(scope, args, context));
        };
      } else if (evalArgs.length === 2) {
        var _evalArg = evalArgs[0];
        var evalArg1 = evalArgs[1];
        return function evalOperatorNode(scope, args, context) {
          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
        };
      } else {
        return function evalOperatorNode(scope, args, context) {
          return fn.apply(null, map(evalArgs, function(evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      }
    };
    OperatorNode.prototype.forEach = function(callback) {
      for (var i = 0; i < this.args.length; i++) {
        callback(this.args[i], "args[" + i + "]", this);
      }
    };
    OperatorNode.prototype.map = function(callback) {
      var args = [];
      for (var i = 0; i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
      }
      return new OperatorNode(this.op, this.fn, args, this.implicit);
    };
    OperatorNode.prototype.clone = function() {
      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);
    };
    OperatorNode.prototype.isUnary = function() {
      return this.args.length === 1;
    };
    OperatorNode.prototype.isBinary = function() {
      return this.args.length === 2;
    };
    function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
      var precedence = getPrecedence(root, parenthesis);
      var associativity = getAssociativity(root, parenthesis);
      if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
        return args.map(function(arg) {
          switch (arg.getContent().type) {
            case "ArrayNode":
            case "ConstantNode":
            case "SymbolNode":
            case "ParenthesisNode":
              return false;
            default:
              return true;
          }
        });
      }
      var result;
      switch (args.length) {
        case 0:
          result = [];
          break;
        case 1:
          {
            var operandPrecedence = getPrecedence(args[0], parenthesis);
            if (latex && operandPrecedence !== null) {
              var operandIdentifier;
              var rootIdentifier;
              if (parenthesis === "keep") {
                operandIdentifier = args[0].getIdentifier();
                rootIdentifier = root.getIdentifier();
              } else {
                operandIdentifier = args[0].getContent().getIdentifier();
                rootIdentifier = root.getContent().getIdentifier();
              }
              if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                result = [false];
                break;
              }
              if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
                result = [false];
                break;
              }
            }
            if (operandPrecedence === null) {
              result = [false];
              break;
            }
            if (operandPrecedence <= precedence) {
              result = [true];
              break;
            }
            result = [false];
          }
          break;
        case 2:
          {
            var lhsParens;
            var lhsPrecedence = getPrecedence(args[0], parenthesis);
            var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
            if (lhsPrecedence === null) {
              lhsParens = false;
            } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
              lhsParens = true;
            } else if (lhsPrecedence < precedence) {
              lhsParens = true;
            } else {
              lhsParens = false;
            }
            var rhsParens;
            var rhsPrecedence = getPrecedence(args[1], parenthesis);
            var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
            if (rhsPrecedence === null) {
              rhsParens = false;
            } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
              rhsParens = true;
            } else if (rhsPrecedence < precedence) {
              rhsParens = true;
            } else {
              rhsParens = false;
            }
            if (latex) {
              var _rootIdentifier;
              var lhsIdentifier;
              var rhsIdentifier;
              if (parenthesis === "keep") {
                _rootIdentifier = root.getIdentifier();
                lhsIdentifier = root.args[0].getIdentifier();
                rhsIdentifier = root.args[1].getIdentifier();
              } else {
                _rootIdentifier = root.getContent().getIdentifier();
                lhsIdentifier = root.args[0].getContent().getIdentifier();
                rhsIdentifier = root.args[1].getContent().getIdentifier();
              }
              if (lhsPrecedence !== null) {
                if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                  lhsParens = false;
                }
                if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                  lhsParens = false;
                }
              }
              if (rhsPrecedence !== null) {
                if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                  rhsParens = false;
                }
                if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                  rhsParens = false;
                }
              }
            }
            result = [lhsParens, rhsParens];
          }
          break;
        default:
          if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
            result = args.map(function(arg) {
              var argPrecedence = getPrecedence(arg, parenthesis);
              var assocWithArg = isAssociativeWith(root, arg, parenthesis);
              var argAssociativity = getAssociativity(arg, parenthesis);
              if (argPrecedence === null) {
                return false;
              } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                return true;
              } else if (argPrecedence < precedence) {
                return true;
              }
              return false;
            });
          }
          break;
      }
      if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis === "auto" && implicit === "hide") {
        result = args.map(function(arg, index) {
          var isParenthesisNode2 = arg.getIdentifier() === "ParenthesisNode";
          if (result[index] || isParenthesisNode2) {
            return true;
          }
          return false;
        });
      }
      return result;
    }
    OperatorNode.prototype._toString = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toString(options);
        if (parens[0]) {
          operand = "(" + operand + ")";
        }
        var opIsNamed = /[a-zA-Z]+/.test(this.op);
        if (assoc === "right") {
          return this.op + (opIsNamed ? " " : "") + operand;
        } else if (assoc === "left") {
          return operand + (opIsNamed ? " " : "") + this.op;
        }
        return operand + this.op;
      } else if (args.length === 2) {
        var lhs = args[0].toString(options);
        var rhs = args[1].toString(options);
        if (parens[0]) {
          lhs = "(" + lhs + ")";
        }
        if (parens[1]) {
          rhs = "(" + rhs + ")";
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + " " + rhs;
        }
        return lhs + " " + this.op + " " + rhs;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var stringifiedArgs = args.map(function(arg, index) {
          arg = arg.toString(options);
          if (parens[index]) {
            arg = "(" + arg + ")";
          }
          return arg;
        });
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return stringifiedArgs.join(" ");
        }
        return stringifiedArgs.join(" " + this.op + " ");
      } else {
        return this.fn + "(" + this.args.join(", ") + ")";
      }
    };
    OperatorNode.prototype.toJSON = function() {
      return {
        mathjs: "OperatorNode",
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit
      };
    };
    OperatorNode.fromJSON = function(json) {
      return new OperatorNode(json.op, json.fn, json.args, json.implicit);
    };
    OperatorNode.prototype.toHTML = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toHTML(options);
        if (parens[0]) {
          operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (assoc === "right") {
          return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape2(this.op) + "</span>" + operand;
        } else {
          return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape2(this.op) + "</span>";
        }
      } else if (args.length === 2) {
        var lhs = args[0].toHTML(options);
        var rhs = args[1].toHTML(options);
        if (parens[0]) {
          lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (parens[1]) {
          rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
        }
        return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape2(this.op) + "</span>" + rhs;
      } else {
        var stringifiedArgs = args.map(function(arg, index) {
          arg = arg.toHTML(options);
          if (parens[index]) {
            arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          return arg;
        });
        if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
          }
          return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape2(this.op) + "</span>");
        } else {
          return '<span class="math-function">' + escape2(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
      }
    };
    OperatorNode.prototype._toTex = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
      var op = latexOperators[this.fn];
      op = typeof op === "undefined" ? this.op : op;
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toTex(options);
        if (parens[0]) {
          operand = "\\left(".concat(operand, "\\right)");
        }
        if (assoc === "right") {
          return op + operand;
        } else if (assoc === "left") {
          return operand + op;
        }
        return operand + op;
      } else if (args.length === 2) {
        var lhs = args[0];
        var lhsTex = lhs.toTex(options);
        if (parens[0]) {
          lhsTex = "\\left(".concat(lhsTex, "\\right)");
        }
        var rhs = args[1];
        var rhsTex = rhs.toTex(options);
        if (parens[1]) {
          rhsTex = "\\left(".concat(rhsTex, "\\right)");
        }
        var lhsIdentifier;
        if (parenthesis === "keep") {
          lhsIdentifier = lhs.getIdentifier();
        } else {
          lhsIdentifier = lhs.getContent().getIdentifier();
        }
        switch (this.getIdentifier()) {
          case "OperatorNode:divide":
            return op + "{" + lhsTex + "}{" + rhsTex + "}";
          case "OperatorNode:pow":
            lhsTex = "{" + lhsTex + "}";
            rhsTex = "{" + rhsTex + "}";
            switch (lhsIdentifier) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && implicit === "hide") {
              return lhsTex + "~" + rhsTex;
            }
        }
        return lhsTex + op + rhsTex;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var texifiedArgs = args.map(function(arg, index) {
          arg = arg.toTex(options);
          if (parens[index]) {
            arg = "\\left(".concat(arg, "\\right)");
          }
          return arg;
        });
        if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit) {
          return texifiedArgs.join("~");
        }
        return texifiedArgs.join(op);
      } else {
        return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg) {
          return arg.toTex(options);
        }).join(",") + "\\right)";
      }
    };
    OperatorNode.prototype.getIdentifier = function() {
      return this.type + ":" + this.fn;
    };
    return OperatorNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
  var name206 = "ParenthesisNode";
  var dependencies207 = ["Node"];
  var createParenthesisNode = /* @__PURE__ */ factory(name206, dependencies207, (_ref) => {
    var {
      Node
    } = _ref;
    function ParenthesisNode(content) {
      if (!(this instanceof ParenthesisNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!isNode(content)) {
        throw new TypeError('Node expected for parameter "content"');
      }
      this.content = content;
    }
    ParenthesisNode.prototype = new Node();
    ParenthesisNode.prototype.type = "ParenthesisNode";
    ParenthesisNode.prototype.isParenthesisNode = true;
    ParenthesisNode.prototype._compile = function(math2, argNames) {
      return this.content._compile(math2, argNames);
    };
    ParenthesisNode.prototype.getContent = function() {
      return this.content.getContent();
    };
    ParenthesisNode.prototype.forEach = function(callback) {
      callback(this.content, "content", this);
    };
    ParenthesisNode.prototype.map = function(callback) {
      var content = callback(this.content, "content", this);
      return new ParenthesisNode(content);
    };
    ParenthesisNode.prototype.clone = function() {
      return new ParenthesisNode(this.content);
    };
    ParenthesisNode.prototype._toString = function(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "(" + this.content.toString(options) + ")";
      }
      return this.content.toString(options);
    };
    ParenthesisNode.prototype.toJSON = function() {
      return {
        mathjs: "ParenthesisNode",
        content: this.content
      };
    };
    ParenthesisNode.fromJSON = function(json) {
      return new ParenthesisNode(json.content);
    };
    ParenthesisNode.prototype.toHTML = function(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return this.content.toHTML(options);
    };
    ParenthesisNode.prototype._toTex = function(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "\\left(".concat(this.content.toTex(options), "\\right)");
      }
      return this.content.toTex(options);
    };
    return ParenthesisNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/RangeNode.js
  var name207 = "RangeNode";
  var dependencies208 = ["Node"];
  var createRangeNode = /* @__PURE__ */ factory(name207, dependencies208, (_ref) => {
    var {
      Node
    } = _ref;
    function RangeNode(start, end, step) {
      if (!(this instanceof RangeNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!isNode(start))
        throw new TypeError("Node expected");
      if (!isNode(end))
        throw new TypeError("Node expected");
      if (step && !isNode(step))
        throw new TypeError("Node expected");
      if (arguments.length > 3)
        throw new Error("Too many arguments");
      this.start = start;
      this.end = end;
      this.step = step || null;
    }
    RangeNode.prototype = new Node();
    RangeNode.prototype.type = "RangeNode";
    RangeNode.prototype.isRangeNode = true;
    RangeNode.prototype.needsEnd = function() {
      var endSymbols = this.filter(function(node) {
        return isSymbolNode(node) && node.name === "end";
      });
      return endSymbols.length > 0;
    };
    RangeNode.prototype._compile = function(math2, argNames) {
      var range = math2.range;
      var evalStart = this.start._compile(math2, argNames);
      var evalEnd = this.end._compile(math2, argNames);
      if (this.step) {
        var evalStep = this.step._compile(math2, argNames);
        return function evalRangeNode(scope, args, context) {
          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
        };
      } else {
        return function evalRangeNode(scope, args, context) {
          return range(evalStart(scope, args, context), evalEnd(scope, args, context));
        };
      }
    };
    RangeNode.prototype.forEach = function(callback) {
      callback(this.start, "start", this);
      callback(this.end, "end", this);
      if (this.step) {
        callback(this.step, "step", this);
      }
    };
    RangeNode.prototype.map = function(callback) {
      return new RangeNode(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
    };
    RangeNode.prototype.clone = function() {
      return new RangeNode(this.start, this.end, this.step && this.step);
    };
    function calculateNecessaryParentheses(node, parenthesis) {
      var precedence = getPrecedence(node, parenthesis);
      var parens = {};
      var startPrecedence = getPrecedence(node.start, parenthesis);
      parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
      if (node.step) {
        var stepPrecedence = getPrecedence(node.step, parenthesis);
        parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
      }
      var endPrecedence = getPrecedence(node.end, parenthesis);
      parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
      return parens;
    }
    RangeNode.prototype._toString = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis);
      var str;
      var start = this.start.toString(options);
      if (parens.start) {
        start = "(" + start + ")";
      }
      str = start;
      if (this.step) {
        var step = this.step.toString(options);
        if (parens.step) {
          step = "(" + step + ")";
        }
        str += ":" + step;
      }
      var end = this.end.toString(options);
      if (parens.end) {
        end = "(" + end + ")";
      }
      str += ":" + end;
      return str;
    };
    RangeNode.prototype.toJSON = function() {
      return {
        mathjs: "RangeNode",
        start: this.start,
        end: this.end,
        step: this.step
      };
    };
    RangeNode.fromJSON = function(json) {
      return new RangeNode(json.start, json.end, json.step);
    };
    RangeNode.prototype.toHTML = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis);
      var str;
      var start = this.start.toHTML(options);
      if (parens.start) {
        start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str = start;
      if (this.step) {
        var step = this.step.toHTML(options);
        if (parens.step) {
          step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + step;
      }
      var end = this.end.toHTML(options);
      if (parens.end) {
        end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str += '<span class="math-operator math-range-operator">:</span>' + end;
      return str;
    };
    RangeNode.prototype._toTex = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis);
      var str = this.start.toTex(options);
      if (parens.start) {
        str = "\\left(".concat(str, "\\right)");
      }
      if (this.step) {
        var step = this.step.toTex(options);
        if (parens.step) {
          step = "\\left(".concat(step, "\\right)");
        }
        str += ":" + step;
      }
      var end = this.end.toTex(options);
      if (parens.end) {
        end = "\\left(".concat(end, "\\right)");
      }
      str += ":" + end;
      return str;
    };
    return RangeNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
  var name208 = "RelationalNode";
  var dependencies209 = ["Node"];
  var createRelationalNode = /* @__PURE__ */ factory(name208, dependencies209, (_ref) => {
    var {
      Node
    } = _ref;
    function RelationalNode(conditionals, params) {
      if (!(this instanceof RelationalNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!Array.isArray(conditionals))
        throw new TypeError("Parameter conditionals must be an array");
      if (!Array.isArray(params))
        throw new TypeError("Parameter params must be an array");
      if (conditionals.length !== params.length - 1)
        throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
      this.conditionals = conditionals;
      this.params = params;
    }
    RelationalNode.prototype = new Node();
    RelationalNode.prototype.type = "RelationalNode";
    RelationalNode.prototype.isRelationalNode = true;
    RelationalNode.prototype._compile = function(math2, argNames) {
      var self2 = this;
      var compiled = this.params.map((p) => p._compile(math2, argNames));
      return function evalRelationalNode(scope, args, context) {
        var evalLhs;
        var evalRhs = compiled[0](scope, args, context);
        for (var i = 0; i < self2.conditionals.length; i++) {
          evalLhs = evalRhs;
          evalRhs = compiled[i + 1](scope, args, context);
          var condFn = getSafeProperty(math2, self2.conditionals[i]);
          if (!condFn(evalLhs, evalRhs)) {
            return false;
          }
        }
        return true;
      };
    };
    RelationalNode.prototype.forEach = function(callback) {
      this.params.forEach((n, i) => callback(n, "params[" + i + "]", this), this);
    };
    RelationalNode.prototype.map = function(callback) {
      return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, "params[" + i + "]", this)), this));
    };
    RelationalNode.prototype.clone = function() {
      return new RelationalNode(this.conditionals, this.params);
    };
    RelationalNode.prototype._toString = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
      });
      var operatorMap = {
        equal: "==",
        unequal: "!=",
        smaller: "<",
        larger: ">",
        smallerEq: "<=",
        largerEq: ">="
      };
      var ret = paramStrings[0];
      for (var i = 0; i < this.conditionals.length; i++) {
        ret += " " + operatorMap[this.conditionals[i]] + " " + paramStrings[i + 1];
      }
      return ret;
    };
    RelationalNode.prototype.toJSON = function() {
      return {
        mathjs: "RelationalNode",
        conditionals: this.conditionals,
        params: this.params
      };
    };
    RelationalNode.fromJSON = function(json) {
      return new RelationalNode(json.conditionals, json.params);
    };
    RelationalNode.prototype.toHTML = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
      });
      var operatorMap = {
        equal: "==",
        unequal: "!=",
        smaller: "<",
        larger: ">",
        smallerEq: "<=",
        largerEq: ">="
      };
      var ret = paramStrings[0];
      for (var i = 0; i < this.conditionals.length; i++) {
        ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape2(operatorMap[this.conditionals[i]]) + "</span>" + paramStrings[i + 1];
      }
      return ret;
    };
    RelationalNode.prototype._toTex = function(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
      });
      var ret = paramStrings[0];
      for (var i = 0; i < this.conditionals.length; i++) {
        ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];
      }
      return ret;
    };
    return RelationalNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
  var name209 = "SymbolNode";
  var dependencies210 = ["math", "?Unit", "Node"];
  var createSymbolNode = /* @__PURE__ */ factory(name209, dependencies210, (_ref) => {
    var {
      math: math2,
      Unit,
      Node
    } = _ref;
    function isValuelessUnit(name284) {
      return Unit ? Unit.isValuelessUnit(name284) : false;
    }
    function SymbolNode(name284) {
      if (!(this instanceof SymbolNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (typeof name284 !== "string")
        throw new TypeError('String expected for parameter "name"');
      this.name = name284;
    }
    SymbolNode.prototype = new Node();
    SymbolNode.prototype.type = "SymbolNode";
    SymbolNode.prototype.isSymbolNode = true;
    SymbolNode.prototype._compile = function(math3, argNames) {
      var name284 = this.name;
      if (argNames[name284] === true) {
        return function(scope, args, context) {
          return args[name284];
        };
      } else if (name284 in math3) {
        return function(scope, args, context) {
          return name284 in scope ? getSafeProperty(scope, name284) : getSafeProperty(math3, name284);
        };
      } else {
        var isUnit2 = isValuelessUnit(name284);
        return function(scope, args, context) {
          return name284 in scope ? getSafeProperty(scope, name284) : isUnit2 ? new Unit(null, name284) : undef(name284);
        };
      }
    };
    SymbolNode.prototype.forEach = function(callback) {
    };
    SymbolNode.prototype.map = function(callback) {
      return this.clone();
    };
    function undef(name284) {
      throw new Error("Undefined symbol " + name284);
    }
    SymbolNode.prototype.clone = function() {
      return new SymbolNode(this.name);
    };
    SymbolNode.prototype._toString = function(options) {
      return this.name;
    };
    SymbolNode.prototype.toHTML = function(options) {
      var name284 = escape2(this.name);
      if (name284 === "true" || name284 === "false") {
        return '<span class="math-symbol math-boolean">' + name284 + "</span>";
      } else if (name284 === "i") {
        return '<span class="math-symbol math-imaginary-symbol">' + name284 + "</span>";
      } else if (name284 === "Infinity") {
        return '<span class="math-symbol math-infinity-symbol">' + name284 + "</span>";
      } else if (name284 === "NaN") {
        return '<span class="math-symbol math-nan-symbol">' + name284 + "</span>";
      } else if (name284 === "null") {
        return '<span class="math-symbol math-null-symbol">' + name284 + "</span>";
      } else if (name284 === "undefined") {
        return '<span class="math-symbol math-undefined-symbol">' + name284 + "</span>";
      }
      return '<span class="math-symbol">' + name284 + "</span>";
    };
    SymbolNode.prototype.toJSON = function() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    };
    SymbolNode.fromJSON = function(json) {
      return new SymbolNode(json.name);
    };
    SymbolNode.prototype._toTex = function(options) {
      var isUnit2 = false;
      if (typeof math2[this.name] === "undefined" && isValuelessUnit(this.name)) {
        isUnit2 = true;
      }
      var symbol = toSymbol(this.name, isUnit2);
      if (symbol[0] === "\\") {
        return symbol;
      }
      return " " + symbol;
    };
    return SymbolNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  var name210 = "FunctionNode";
  var dependencies211 = ["math", "Node", "SymbolNode"];
  var createFunctionNode = /* @__PURE__ */ factory(name210, dependencies211, (_ref) => {
    var {
      math: math2,
      Node,
      SymbolNode
    } = _ref;
    function FunctionNode(fn, args) {
      if (!(this instanceof FunctionNode)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (typeof fn === "string") {
        fn = new SymbolNode(fn);
      }
      if (!isNode(fn))
        throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.fn = fn;
      this.args = args || [];
      Object.defineProperty(this, "name", {
        get: function() {
          return this.fn.name || "";
        }.bind(this),
        set: function set() {
          throw new Error("Cannot assign a new name, name is read-only");
        }
      });
    }
    FunctionNode.prototype = new Node();
    FunctionNode.prototype.type = "FunctionNode";
    FunctionNode.prototype.isFunctionNode = true;
    FunctionNode.prototype._compile = function(math3, argNames) {
      if (!(this instanceof FunctionNode)) {
        throw new TypeError("No valid FunctionNode");
      }
      var evalArgs = map(this.args, function(arg) {
        return arg._compile(math3, argNames);
      });
      if (isSymbolNode(this.fn)) {
        var _name = this.fn.name;
        var fn = _name in math3 ? getSafeProperty(math3, _name) : void 0;
        var isRaw = typeof fn === "function" && fn.rawArgs === true;
        if (isRaw) {
          var rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            return (_name in scope ? getSafeProperty(scope, _name) : fn)(rawArgs, math3, _extends2({}, scope, args));
          };
        } else {
          if (evalArgs.length === 1) {
            var evalArg0 = evalArgs[0];
            return function evalFunctionNode(scope, args, context) {
              return (_name in scope ? getSafeProperty(scope, _name) : fn)(evalArg0(scope, args, context));
            };
          } else if (evalArgs.length === 2) {
            var _evalArg = evalArgs[0];
            var evalArg1 = evalArgs[1];
            return function evalFunctionNode(scope, args, context) {
              return (_name in scope ? getSafeProperty(scope, _name) : fn)(_evalArg(scope, args, context), evalArg1(scope, args, context));
            };
          } else {
            return function evalFunctionNode(scope, args, context) {
              return (_name in scope ? getSafeProperty(scope, _name) : fn).apply(null, map(evalArgs, function(evalArg) {
                return evalArg(scope, args, context);
              }));
            };
          }
        }
      } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
        var evalObject = this.fn.object._compile(math3, argNames);
        var prop = this.fn.index.getObjectProperty();
        var _rawArgs = this.args;
        return function evalFunctionNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          validateSafeMethod(object, prop);
          var isRaw2 = object[prop] && object[prop].rawArgs;
          return isRaw2 ? object[prop](_rawArgs, math3, _extends2({}, scope, args)) : object[prop].apply(object, map(evalArgs, function(evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      } else {
        var evalFn = this.fn._compile(math3, argNames);
        var _rawArgs2 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var fn2 = evalFn(scope, args, context);
          var isRaw2 = fn2 && fn2.rawArgs;
          return isRaw2 ? fn2(_rawArgs2, math3, _extends2({}, scope, args)) : fn2.apply(fn2, map(evalArgs, function(evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      }
    };
    FunctionNode.prototype.forEach = function(callback) {
      callback(this.fn, "fn", this);
      for (var i = 0; i < this.args.length; i++) {
        callback(this.args[i], "args[" + i + "]", this);
      }
    };
    FunctionNode.prototype.map = function(callback) {
      var fn = this._ifNode(callback(this.fn, "fn", this));
      var args = [];
      for (var i = 0; i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
      }
      return new FunctionNode(fn, args);
    };
    FunctionNode.prototype.clone = function() {
      return new FunctionNode(this.fn, this.args.slice(0));
    };
    var nodeToString = FunctionNode.prototype.toString;
    FunctionNode.prototype.toString = function(options) {
      var customString;
      var name284 = this.fn.toString(options);
      if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, name284)) {
        customString = options.handler[name284](this, options);
      }
      if (typeof customString !== "undefined") {
        return customString;
      }
      return nodeToString.call(this, options);
    };
    FunctionNode.prototype._toString = function(options) {
      var args = this.args.map(function(arg) {
        return arg.toString(options);
      });
      var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
      return fn + "(" + args.join(", ") + ")";
    };
    FunctionNode.prototype.toJSON = function() {
      return {
        mathjs: "FunctionNode",
        fn: this.fn,
        args: this.args
      };
    };
    FunctionNode.fromJSON = function(json) {
      return new FunctionNode(json.fn, json.args);
    };
    FunctionNode.prototype.toHTML = function(options) {
      var args = this.args.map(function(arg) {
        return arg.toHTML(options);
      });
      return '<span class="math-function">' + escape2(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    };
    function expandTemplate(template, node, options) {
      var latex = "";
      var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
      var inputPos = 0;
      var match;
      while ((match = regex.exec(template)) !== null) {
        latex += template.substring(inputPos, match.index);
        inputPos = match.index;
        if (match[0] === "$$") {
          latex += "$";
          inputPos++;
        } else {
          inputPos += match[0].length;
          var property = node[match[1]];
          if (!property) {
            throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
          }
          if (match[2] === void 0) {
            switch (typeof property) {
              case "string":
                latex += property;
                break;
              case "object":
                if (isNode(property)) {
                  latex += property.toTex(options);
                } else if (Array.isArray(property)) {
                  latex += property.map(function(arg, index) {
                    if (isNode(arg)) {
                      return arg.toTex(options);
                    }
                    throw new TypeError("Template: " + match[1] + "[" + index + "] is not a Node.");
                  }).join(",");
                } else {
                  throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                }
                break;
              default:
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
            }
          } else {
            if (isNode(property[match[2]] && property[match[2]])) {
              latex += property[match[2]].toTex(options);
            } else {
              throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
            }
          }
        }
      }
      latex += template.slice(inputPos);
      return latex;
    }
    var nodeToTex = FunctionNode.prototype.toTex;
    FunctionNode.prototype.toTex = function(options) {
      var customTex;
      if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, this.name)) {
        customTex = options.handler[this.name](this, options);
      }
      if (typeof customTex !== "undefined") {
        return customTex;
      }
      return nodeToTex.call(this, options);
    };
    FunctionNode.prototype._toTex = function(options) {
      var args = this.args.map(function(arg) {
        return arg.toTex(options);
      });
      var latexConverter;
      if (latexFunctions[this.name]) {
        latexConverter = latexFunctions[this.name];
      }
      if (math2[this.name] && (typeof math2[this.name].toTex === "function" || typeof math2[this.name].toTex === "object" || typeof math2[this.name].toTex === "string")) {
        latexConverter = math2[this.name].toTex;
      }
      var customToTex;
      switch (typeof latexConverter) {
        case "function":
          customToTex = latexConverter(this, options);
          break;
        case "string":
          customToTex = expandTemplate(latexConverter, this, options);
          break;
        case "object":
          switch (typeof latexConverter[args.length]) {
            case "function":
              customToTex = latexConverter[args.length](this, options);
              break;
            case "string":
              customToTex = expandTemplate(latexConverter[args.length], this, options);
              break;
          }
      }
      if (typeof customToTex !== "undefined") {
        return customToTex;
      }
      return expandTemplate(defaultTemplate, this, options);
    };
    FunctionNode.prototype.getIdentifier = function() {
      return this.type + ":" + this.name;
    };
    return FunctionNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/parse.js
  function _extends3() {
    _extends3 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  var name211 = "parse";
  var dependencies212 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
  var createParse = /* @__PURE__ */ factory(name211, dependencies212, (_ref) => {
    var {
      typed,
      numeric: numeric2,
      config,
      AccessorNode,
      ArrayNode,
      AssignmentNode,
      BlockNode,
      ConditionalNode,
      ConstantNode,
      FunctionAssignmentNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      RangeNode,
      RelationalNode,
      SymbolNode
    } = _ref;
    var parse = typed(name211, {
      string: function string(expression) {
        return parseStart(expression, {});
      },
      "Array | Matrix": function ArrayMatrix(expressions) {
        return parseMultiple(expressions, {});
      },
      "string, Object": function stringObject(expression, options) {
        var extraNodes = options.nodes !== void 0 ? options.nodes : {};
        return parseStart(expression, extraNodes);
      },
      "Array | Matrix, Object": parseMultiple
    });
    function parseMultiple(expressions) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var extraNodes = options.nodes !== void 0 ? options.nodes : {};
      return deepMap(expressions, function(elem) {
        if (typeof elem !== "string")
          throw new TypeError("String expected");
        return parseStart(elem, extraNodes);
      });
    }
    var TOKENTYPE = {
      NULL: 0,
      DELIMITER: 1,
      NUMBER: 2,
      SYMBOL: 3,
      UNKNOWN: 4
    };
    var DELIMITERS = {
      ",": true,
      "(": true,
      ")": true,
      "[": true,
      "]": true,
      "{": true,
      "}": true,
      '"': true,
      "'": true,
      ";": true,
      "+": true,
      "-": true,
      "*": true,
      ".*": true,
      "/": true,
      "./": true,
      "%": true,
      "^": true,
      ".^": true,
      "~": true,
      "!": true,
      "&": true,
      "|": true,
      "^|": true,
      "=": true,
      ":": true,
      "?": true,
      "==": true,
      "!=": true,
      "<": true,
      ">": true,
      "<=": true,
      ">=": true,
      "<<": true,
      ">>": true,
      ">>>": true
    };
    var NAMED_DELIMITERS = {
      mod: true,
      to: true,
      in: true,
      and: true,
      xor: true,
      or: true,
      not: true
    };
    var CONSTANTS = {
      true: true,
      false: false,
      null: null,
      undefined: void 0
    };
    var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
    function initialState() {
      return {
        extraNodes: {},
        expression: "",
        comment: "",
        index: 0,
        token: "",
        tokenType: TOKENTYPE.NULL,
        nestingLevel: 0,
        conditionalLevel: null
      };
    }
    function currentString(state, length) {
      return state.expression.substr(state.index, length);
    }
    function currentCharacter(state) {
      return currentString(state, 1);
    }
    function next(state) {
      state.index++;
    }
    function prevCharacter(state) {
      return state.expression.charAt(state.index - 1);
    }
    function nextCharacter(state) {
      return state.expression.charAt(state.index + 1);
    }
    function getToken(state) {
      state.tokenType = TOKENTYPE.NULL;
      state.token = "";
      state.comment = "";
      while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {
        next(state);
      }
      if (currentCharacter(state) === "#") {
        while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
          state.comment += currentCharacter(state);
          next(state);
        }
      }
      if (currentCharacter(state) === "") {
        state.tokenType = TOKENTYPE.DELIMITER;
        return;
      }
      if (currentCharacter(state) === "\n" && !state.nestingLevel) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = currentCharacter(state);
        next(state);
        return;
      }
      var c1 = currentCharacter(state);
      var c2 = currentString(state, 2);
      var c3 = currentString(state, 3);
      if (c3.length === 3 && DELIMITERS[c3]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c3;
        next(state);
        next(state);
        next(state);
        return;
      }
      if (c2.length === 2 && DELIMITERS[c2]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c2;
        next(state);
        next(state);
        return;
      }
      if (DELIMITERS[c1]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c1;
        next(state);
        return;
      }
      if (parse.isDigitDot(c1)) {
        state.tokenType = TOKENTYPE.NUMBER;
        var _c = currentString(state, 2);
        if (_c === "0b" || _c === "0o" || _c === "0x") {
          state.token += currentCharacter(state);
          next(state);
          state.token += currentCharacter(state);
          next(state);
          while (parse.isHexDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (currentCharacter(state) === ".") {
            state.token += ".";
            next(state);
            while (parse.isHexDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          } else if (currentCharacter(state) === "i") {
            state.token += "i";
            next(state);
            while (parse.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          }
          return;
        }
        if (currentCharacter(state) === ".") {
          state.token += currentCharacter(state);
          next(state);
          if (!parse.isDigit(currentCharacter(state))) {
            state.tokenType = TOKENTYPE.DELIMITER;
          }
        } else {
          while (parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        while (parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
          if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
            state.token += currentCharacter(state);
            next(state);
            if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
              state.token += currentCharacter(state);
              next(state);
            }
            if (!parse.isDigit(currentCharacter(state))) {
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }
            while (parse.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }
          } else if (nextCharacter(state) === ".") {
            next(state);
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        }
        return;
      }
      if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
        while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (hasOwnProperty2(NAMED_DELIMITERS, state.token)) {
          state.tokenType = TOKENTYPE.DELIMITER;
        } else {
          state.tokenType = TOKENTYPE.SYMBOL;
        }
        return;
      }
      state.tokenType = TOKENTYPE.UNKNOWN;
      while (currentCharacter(state) !== "") {
        state.token += currentCharacter(state);
        next(state);
      }
      throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
    }
    function getTokenSkipNewline(state) {
      do {
        getToken(state);
      } while (state.token === "\n");
    }
    function openParams(state) {
      state.nestingLevel++;
    }
    function closeParams(state) {
      state.nestingLevel--;
    }
    parse.isAlpha = function isAlpha(c, cPrev, cNext) {
      return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);
    };
    parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
      return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
    };
    parse.isValidMathSymbol = function isValidMathSymbol(high, low) {
      return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
    };
    parse.isWhitespace = function isWhitespace(c, nestingLevel) {
      return c === " " || c === "	" || c === "\n" && nestingLevel > 0;
    };
    parse.isDecimalMark = function isDecimalMark(c, cNext) {
      return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
    };
    parse.isDigitDot = function isDigitDot(c) {
      return c >= "0" && c <= "9" || c === ".";
    };
    parse.isDigit = function isDigit(c) {
      return c >= "0" && c <= "9";
    };
    parse.isHexDigit = function isHexDigit(c) {
      return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
    };
    function parseStart(expression, extraNodes) {
      var state = initialState();
      _extends3(state, {
        expression,
        extraNodes
      });
      getToken(state);
      var node = parseBlock(state);
      if (state.token !== "") {
        if (state.tokenType === TOKENTYPE.DELIMITER) {
          throw createError(state, "Unexpected operator " + state.token);
        } else {
          throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
        }
      }
      return node;
    }
    function parseBlock(state) {
      var node;
      var blocks = [];
      var visible;
      if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
        node = parseAssignment(state);
        node.comment = state.comment;
      }
      while (state.token === "\n" || state.token === ";") {
        if (blocks.length === 0 && node) {
          visible = state.token !== ";";
          blocks.push({
            node,
            visible
          });
        }
        getToken(state);
        if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
          node = parseAssignment(state);
          node.comment = state.comment;
          visible = state.token !== ";";
          blocks.push({
            node,
            visible
          });
        }
      }
      if (blocks.length > 0) {
        return new BlockNode(blocks);
      } else {
        if (!node) {
          node = new ConstantNode(void 0);
          node.comment = state.comment;
        }
        return node;
      }
    }
    function parseAssignment(state) {
      var name284, args, value, valid;
      var node = parseConditional(state);
      if (state.token === "=") {
        if (isSymbolNode(node)) {
          name284 = node.name;
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode(new SymbolNode(name284), value);
        } else if (isAccessorNode(node)) {
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode(node.object, node.index, value);
        } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
          valid = true;
          args = [];
          name284 = node.name;
          node.args.forEach(function(arg, index) {
            if (isSymbolNode(arg)) {
              args[index] = arg.name;
            } else {
              valid = false;
            }
          });
          if (valid) {
            getTokenSkipNewline(state);
            value = parseAssignment(state);
            return new FunctionAssignmentNode(name284, args, value);
          }
        }
        throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
      }
      return node;
    }
    function parseConditional(state) {
      var node = parseLogicalOr(state);
      while (state.token === "?") {
        var prev = state.conditionalLevel;
        state.conditionalLevel = state.nestingLevel;
        getTokenSkipNewline(state);
        var condition = node;
        var trueExpr = parseAssignment(state);
        if (state.token !== ":")
          throw createSyntaxError(state, "False part of conditional expression expected");
        state.conditionalLevel = null;
        getTokenSkipNewline(state);
        var falseExpr = parseAssignment(state);
        node = new ConditionalNode(condition, trueExpr, falseExpr);
        state.conditionalLevel = prev;
      }
      return node;
    }
    function parseLogicalOr(state) {
      var node = parseLogicalXor(state);
      while (state.token === "or") {
        getTokenSkipNewline(state);
        node = new OperatorNode("or", "or", [node, parseLogicalXor(state)]);
      }
      return node;
    }
    function parseLogicalXor(state) {
      var node = parseLogicalAnd(state);
      while (state.token === "xor") {
        getTokenSkipNewline(state);
        node = new OperatorNode("xor", "xor", [node, parseLogicalAnd(state)]);
      }
      return node;
    }
    function parseLogicalAnd(state) {
      var node = parseBitwiseOr(state);
      while (state.token === "and") {
        getTokenSkipNewline(state);
        node = new OperatorNode("and", "and", [node, parseBitwiseOr(state)]);
      }
      return node;
    }
    function parseBitwiseOr(state) {
      var node = parseBitwiseXor(state);
      while (state.token === "|") {
        getTokenSkipNewline(state);
        node = new OperatorNode("|", "bitOr", [node, parseBitwiseXor(state)]);
      }
      return node;
    }
    function parseBitwiseXor(state) {
      var node = parseBitwiseAnd(state);
      while (state.token === "^|") {
        getTokenSkipNewline(state);
        node = new OperatorNode("^|", "bitXor", [node, parseBitwiseAnd(state)]);
      }
      return node;
    }
    function parseBitwiseAnd(state) {
      var node = parseRelational(state);
      while (state.token === "&") {
        getTokenSkipNewline(state);
        node = new OperatorNode("&", "bitAnd", [node, parseRelational(state)]);
      }
      return node;
    }
    function parseRelational(state) {
      var params = [parseShift(state)];
      var conditionals = [];
      var operators = {
        "==": "equal",
        "!=": "unequal",
        "<": "smaller",
        ">": "larger",
        "<=": "smallerEq",
        ">=": "largerEq"
      };
      while (hasOwnProperty2(operators, state.token)) {
        var cond = {
          name: state.token,
          fn: operators[state.token]
        };
        conditionals.push(cond);
        getTokenSkipNewline(state);
        params.push(parseShift(state));
      }
      if (params.length === 1) {
        return params[0];
      } else if (params.length === 2) {
        return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
      } else {
        return new RelationalNode(conditionals.map((c) => c.fn), params);
      }
    }
    function parseShift(state) {
      var node, name284, fn, params;
      node = parseConversion(state);
      var operators = {
        "<<": "leftShift",
        ">>": "rightArithShift",
        ">>>": "rightLogShift"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name284 = state.token;
        fn = operators[name284];
        getTokenSkipNewline(state);
        params = [node, parseConversion(state)];
        node = new OperatorNode(name284, fn, params);
      }
      return node;
    }
    function parseConversion(state) {
      var node, name284, fn, params;
      node = parseRange(state);
      var operators = {
        to: "to",
        in: "to"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name284 = state.token;
        fn = operators[name284];
        getTokenSkipNewline(state);
        if (name284 === "in" && state.token === "") {
          node = new OperatorNode("*", "multiply", [node, new SymbolNode("in")], true);
        } else {
          params = [node, parseRange(state)];
          node = new OperatorNode(name284, fn, params);
        }
      }
      return node;
    }
    function parseRange(state) {
      var node;
      var params = [];
      if (state.token === ":") {
        node = new ConstantNode(1);
      } else {
        node = parseAddSubtract(state);
      }
      if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
        params.push(node);
        while (state.token === ":" && params.length < 3) {
          getTokenSkipNewline(state);
          if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
            params.push(new SymbolNode("end"));
          } else {
            params.push(parseAddSubtract(state));
          }
        }
        if (params.length === 3) {
          node = new RangeNode(params[0], params[2], params[1]);
        } else {
          node = new RangeNode(params[0], params[1]);
        }
      }
      return node;
    }
    function parseAddSubtract(state) {
      var node, name284, fn, params;
      node = parseMultiplyDivide(state);
      var operators = {
        "+": "add",
        "-": "subtract"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name284 = state.token;
        fn = operators[name284];
        getTokenSkipNewline(state);
        params = [node, parseMultiplyDivide(state)];
        node = new OperatorNode(name284, fn, params);
      }
      return node;
    }
    function parseMultiplyDivide(state) {
      var node, last, name284, fn;
      node = parseImplicitMultiplication(state);
      last = node;
      var operators = {
        "*": "multiply",
        ".*": "dotMultiply",
        "/": "divide",
        "./": "dotDivide",
        "%": "mod",
        mod: "mod"
      };
      while (true) {
        if (hasOwnProperty2(operators, state.token)) {
          name284 = state.token;
          fn = operators[name284];
          getTokenSkipNewline(state);
          last = parseImplicitMultiplication(state);
          node = new OperatorNode(name284, fn, [node, last]);
        } else {
          break;
        }
      }
      return node;
    }
    function parseImplicitMultiplication(state) {
      var node, last;
      node = parseRule2(state);
      last = node;
      while (true) {
        if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
          last = parseRule2(state);
          node = new OperatorNode("*", "multiply", [node, last], true);
        } else {
          break;
        }
      }
      return node;
    }
    function parseRule2(state) {
      var node = parseUnary(state);
      var last = node;
      var tokenStates = [];
      while (true) {
        if (state.token === "/" && isConstantNode(last)) {
          tokenStates.push(_extends3({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === TOKENTYPE.NUMBER) {
            tokenStates.push(_extends3({}, state));
            getTokenSkipNewline(state);
            if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
              _extends3(state, tokenStates.pop());
              tokenStates.pop();
              last = parseUnary(state);
              node = new OperatorNode("/", "divide", [node, last]);
            } else {
              tokenStates.pop();
              _extends3(state, tokenStates.pop());
              break;
            }
          } else {
            _extends3(state, tokenStates.pop());
            break;
          }
        } else {
          break;
        }
      }
      return node;
    }
    function parseUnary(state) {
      var name284, params, fn;
      var operators = {
        "-": "unaryMinus",
        "+": "unaryPlus",
        "~": "bitNot",
        not: "not"
      };
      if (hasOwnProperty2(operators, state.token)) {
        fn = operators[state.token];
        name284 = state.token;
        getTokenSkipNewline(state);
        params = [parseUnary(state)];
        return new OperatorNode(name284, fn, params);
      }
      return parsePow(state);
    }
    function parsePow(state) {
      var node, name284, fn, params;
      node = parseLeftHandOperators(state);
      if (state.token === "^" || state.token === ".^") {
        name284 = state.token;
        fn = name284 === "^" ? "pow" : "dotPow";
        getTokenSkipNewline(state);
        params = [node, parseUnary(state)];
        node = new OperatorNode(name284, fn, params);
      }
      return node;
    }
    function parseLeftHandOperators(state) {
      var node, name284, fn, params;
      node = parseCustomNodes(state);
      var operators = {
        "!": "factorial",
        "'": "ctranspose"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name284 = state.token;
        fn = operators[name284];
        getToken(state);
        params = [node];
        node = new OperatorNode(name284, fn, params);
        node = parseAccessors(state, node);
      }
      return node;
    }
    function parseCustomNodes(state) {
      var params = [];
      if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty2(state.extraNodes, state.token)) {
        var CustomNode = state.extraNodes[state.token];
        getToken(state);
        if (state.token === "(") {
          params = [];
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
        }
        return new CustomNode(params);
      }
      return parseSymbol(state);
    }
    function parseSymbol(state) {
      var node, name284;
      if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
        name284 = state.token;
        getToken(state);
        if (hasOwnProperty2(CONSTANTS, name284)) {
          node = new ConstantNode(CONSTANTS[name284]);
        } else if (NUMERIC_CONSTANTS.indexOf(name284) !== -1) {
          node = new ConstantNode(numeric2(name284, "number"));
        } else {
          node = new SymbolNode(name284);
        }
        node = parseAccessors(state, node);
        return node;
      }
      return parseDoubleQuotesString(state);
    }
    function parseAccessors(state, node, types) {
      var params;
      while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.indexOf(state.token) !== -1)) {
        params = [];
        if (state.token === "(") {
          if (isSymbolNode(node) || isAccessorNode(node)) {
            openParams(state);
            getToken(state);
            if (state.token !== ")") {
              params.push(parseAssignment(state));
              while (state.token === ",") {
                getToken(state);
                params.push(parseAssignment(state));
              }
            }
            if (state.token !== ")") {
              throw createSyntaxError(state, "Parenthesis ) expected");
            }
            closeParams(state);
            getToken(state);
            node = new FunctionNode(node, params);
          } else {
            return node;
          }
        } else if (state.token === "[") {
          openParams(state);
          getToken(state);
          if (state.token !== "]") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "Parenthesis ] expected");
          }
          closeParams(state);
          getToken(state);
          node = new AccessorNode(node, new IndexNode(params));
        } else {
          getToken(state);
          if (state.tokenType !== TOKENTYPE.SYMBOL) {
            throw createSyntaxError(state, "Property name expected after dot");
          }
          params.push(new ConstantNode(state.token));
          getToken(state);
          var dotNotation = true;
          node = new AccessorNode(node, new IndexNode(params, dotNotation));
        }
      }
      return node;
    }
    function parseDoubleQuotesString(state) {
      var node, str;
      if (state.token === '"') {
        str = parseDoubleQuotesStringToken(state);
        node = new ConstantNode(str);
        node = parseAccessors(state, node);
        return node;
      }
      return parseSingleQuotesString(state);
    }
    function parseDoubleQuotesStringToken(state) {
      var str = "";
      while (currentCharacter(state) !== "" && currentCharacter(state) !== '"') {
        if (currentCharacter(state) === "\\") {
          str += currentCharacter(state);
          next(state);
        }
        str += currentCharacter(state);
        next(state);
      }
      getToken(state);
      if (state.token !== '"') {
        throw createSyntaxError(state, 'End of string " expected');
      }
      getToken(state);
      return JSON.parse('"' + str + '"');
    }
    function parseSingleQuotesString(state) {
      var node, str;
      if (state.token === "'") {
        str = parseSingleQuotesStringToken(state);
        node = new ConstantNode(str);
        node = parseAccessors(state, node);
        return node;
      }
      return parseMatrix(state);
    }
    function parseSingleQuotesStringToken(state) {
      var str = "";
      while (currentCharacter(state) !== "" && currentCharacter(state) !== "'") {
        if (currentCharacter(state) === "\\") {
          str += currentCharacter(state);
          next(state);
        }
        str += currentCharacter(state);
        next(state);
      }
      getToken(state);
      if (state.token !== "'") {
        throw createSyntaxError(state, "End of string ' expected");
      }
      getToken(state);
      return JSON.parse('"' + str + '"');
    }
    function parseMatrix(state) {
      var array, params, rows, cols;
      if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          var row = parseRow(state);
          if (state.token === ";") {
            rows = 1;
            params = [row];
            while (state.token === ";") {
              getToken(state);
              params[rows] = parseRow(state);
              rows++;
            }
            if (state.token !== "]") {
              throw createSyntaxError(state, "End of matrix ] expected");
            }
            closeParams(state);
            getToken(state);
            cols = params[0].items.length;
            for (var r = 1; r < rows; r++) {
              if (params[r].items.length !== cols) {
                throw createError(state, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
              }
            }
            array = new ArrayNode(params);
          } else {
            if (state.token !== "]") {
              throw createSyntaxError(state, "End of matrix ] expected");
            }
            closeParams(state);
            getToken(state);
            array = row;
          }
        } else {
          closeParams(state);
          getToken(state);
          array = new ArrayNode([]);
        }
        return parseAccessors(state, array);
      }
      return parseObject(state);
    }
    function parseRow(state) {
      var params = [parseAssignment(state)];
      var len = 1;
      while (state.token === ",") {
        getToken(state);
        params[len] = parseAssignment(state);
        len++;
      }
      return new ArrayNode(params);
    }
    function parseObject(state) {
      if (state.token === "{") {
        openParams(state);
        var key;
        var properties2 = {};
        do {
          getToken(state);
          if (state.token !== "}") {
            if (state.token === '"') {
              key = parseDoubleQuotesStringToken(state);
            } else if (state.token === "'") {
              key = parseSingleQuotesStringToken(state);
            } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
              key = state.token;
              getToken(state);
            } else {
              throw createSyntaxError(state, "Symbol or string expected as object key");
            }
            if (state.token !== ":") {
              throw createSyntaxError(state, "Colon : expected after object key");
            }
            getToken(state);
            properties2[key] = parseAssignment(state);
          }
        } while (state.token === ",");
        if (state.token !== "}") {
          throw createSyntaxError(state, "Comma , or bracket } expected after object value");
        }
        closeParams(state);
        getToken(state);
        var node = new ObjectNode(properties2);
        node = parseAccessors(state, node);
        return node;
      }
      return parseNumber(state);
    }
    function parseNumber(state) {
      var numberStr;
      if (state.tokenType === TOKENTYPE.NUMBER) {
        numberStr = state.token;
        getToken(state);
        return new ConstantNode(numeric2(numberStr, config.number));
      }
      return parseParentheses(state);
    }
    function parseParentheses(state) {
      var node;
      if (state.token === "(") {
        openParams(state);
        getToken(state);
        node = parseAssignment(state);
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
        node = new ParenthesisNode(node);
        node = parseAccessors(state, node);
        return node;
      }
      return parseEnd(state);
    }
    function parseEnd(state) {
      if (state.token === "") {
        throw createSyntaxError(state, "Unexpected end of expression");
      } else {
        throw createSyntaxError(state, "Value expected");
      }
    }
    function col(state) {
      return state.index - state.token.length + 1;
    }
    function createSyntaxError(state, message) {
      var c = col(state);
      var error = new SyntaxError(message + " (char " + c + ")");
      error.char = c;
      return error;
    }
    function createError(state, message) {
      var c = col(state);
      var error = new SyntaxError(message + " (char " + c + ")");
      error.char = c;
      return error;
    }
    return parse;
  });

  // node_modules/mathjs/lib/esm/expression/function/compile.js
  var name212 = "compile";
  var dependencies213 = ["typed", "parse"];
  var createCompile = /* @__PURE__ */ factory(name212, dependencies213, (_ref) => {
    var {
      typed,
      parse
    } = _ref;
    return typed(name212, {
      string: function string(expr) {
        return parse(expr).compile();
      },
      "Array | Matrix": function ArrayMatrix(expr) {
        return deepMap(expr, function(entry) {
          return parse(entry).compile();
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/function/evaluate.js
  var name213 = "evaluate";
  var dependencies214 = ["typed", "parse"];
  var createEvaluate = /* @__PURE__ */ factory(name213, dependencies214, (_ref) => {
    var {
      typed,
      parse
    } = _ref;
    return typed(name213, {
      string: function string(expr) {
        var scope = {};
        return parse(expr).compile().evaluate(scope);
      },
      "string, Object": function stringObject(expr, scope) {
        return parse(expr).compile().evaluate(scope);
      },
      "Array | Matrix": function ArrayMatrix(expr) {
        var scope = {};
        return deepMap(expr, function(entry) {
          return parse(entry).compile().evaluate(scope);
        });
      },
      "Array | Matrix, Object": function ArrayMatrixObject(expr, scope) {
        return deepMap(expr, function(entry) {
          return parse(entry).compile().evaluate(scope);
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/Parser.js
  var name214 = "Parser";
  var dependencies215 = ["parse"];
  var createParserClass = /* @__PURE__ */ factory(name214, dependencies215, (_ref) => {
    var {
      parse
    } = _ref;
    function Parser() {
      if (!(this instanceof Parser)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.scope = {};
    }
    Parser.prototype.type = "Parser";
    Parser.prototype.isParser = true;
    Parser.prototype.evaluate = function(expr) {
      return parse(expr).compile().evaluate(this.scope);
    };
    Parser.prototype.get = function(name284) {
      return name284 in this.scope ? getSafeProperty(this.scope, name284) : void 0;
    };
    Parser.prototype.getAll = function() {
      return extend({}, this.scope);
    };
    Parser.prototype.set = function(name284, value) {
      return setSafeProperty(this.scope, name284, value);
    };
    Parser.prototype.remove = function(name284) {
      delete this.scope[name284];
    };
    Parser.prototype.clear = function() {
      for (var _name in this.scope) {
        if (hasOwnProperty2(this.scope, _name)) {
          delete this.scope[_name];
        }
      }
    };
    return Parser;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/expression/function/parser.js
  var name215 = "parser";
  var dependencies216 = ["typed", "Parser"];
  var createParser = /* @__PURE__ */ factory(name215, dependencies216, (_ref) => {
    var {
      typed,
      Parser
    } = _ref;
    return typed(name215, {
      "": function _4() {
        return new Parser();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
  var name216 = "lup";
  var dependencies217 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtract", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
  var createLup = /* @__PURE__ */ factory(name216, dependencies217, (_ref) => {
    var {
      typed,
      matrix,
      abs,
      addScalar,
      divideScalar,
      multiplyScalar,
      subtract,
      larger,
      equalScalar,
      unaryMinus,
      DenseMatrix,
      SparseMatrix,
      Spa
    } = _ref;
    return typed(name216, {
      DenseMatrix: function DenseMatrix2(m) {
        return _denseLUP(m);
      },
      SparseMatrix: function SparseMatrix2(m) {
        return _sparseLUP(m);
      },
      Array: function Array2(a) {
        var m = matrix(a);
        var r = _denseLUP(m);
        return {
          L: r.L.valueOf(),
          U: r.U.valueOf(),
          p: r.p
        };
      }
    });
    function _denseLUP(m) {
      var rows = m._size[0];
      var columns = m._size[1];
      var n = Math.min(rows, columns);
      var data = clone(m._data);
      var ldata = [];
      var lsize = [rows, n];
      var udata = [];
      var usize = [n, columns];
      var i, j, k;
      var p = [];
      for (i = 0; i < rows; i++) {
        p[i] = i;
      }
      for (j = 0; j < columns; j++) {
        if (j > 0) {
          for (i = 0; i < rows; i++) {
            var min = Math.min(i, j);
            var s = 0;
            for (k = 0; k < min; k++) {
              s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
            }
            data[i][j] = subtract(data[i][j], s);
          }
        }
        var pi2 = j;
        var pabsv = 0;
        var vjj = 0;
        for (i = j; i < rows; i++) {
          var v = data[i][j];
          var absv = abs(v);
          if (larger(absv, pabsv)) {
            pi2 = i;
            pabsv = absv;
            vjj = v;
          }
        }
        if (j !== pi2) {
          p[j] = [p[pi2], p[pi2] = p[j]][0];
          DenseMatrix._swapRows(j, pi2, data);
        }
        if (j < rows) {
          for (i = j + 1; i < rows; i++) {
            var vij = data[i][j];
            if (!equalScalar(vij, 0)) {
              data[i][j] = divideScalar(data[i][j], vjj);
            }
          }
        }
      }
      for (j = 0; j < columns; j++) {
        for (i = 0; i < rows; i++) {
          if (j === 0) {
            if (i < columns) {
              udata[i] = [];
            }
            ldata[i] = [];
          }
          if (i < j) {
            if (i < columns) {
              udata[i][j] = data[i][j];
            }
            if (j < rows) {
              ldata[i][j] = 0;
            }
            continue;
          }
          if (i === j) {
            if (i < columns) {
              udata[i][j] = data[i][j];
            }
            if (j < rows) {
              ldata[i][j] = 1;
            }
            continue;
          }
          if (i < columns) {
            udata[i][j] = 0;
          }
          if (j < rows) {
            ldata[i][j] = data[i][j];
          }
        }
      }
      var l = new DenseMatrix({
        data: ldata,
        size: lsize
      });
      var u = new DenseMatrix({
        data: udata,
        size: usize
      });
      var pv = [];
      for (i = 0, n = p.length; i < n; i++) {
        pv[p[i]] = i;
      }
      return {
        L: l,
        U: u,
        p: pv,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
        }
      };
    }
    function _sparseLUP(m) {
      var rows = m._size[0];
      var columns = m._size[1];
      var n = Math.min(rows, columns);
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var lvalues = [];
      var lindex = [];
      var lptr = [];
      var lsize = [rows, n];
      var uvalues = [];
      var uindex = [];
      var uptr = [];
      var usize = [n, columns];
      var i, j, k;
      var pvCo = [];
      var pvOc = [];
      for (i = 0; i < rows; i++) {
        pvCo[i] = i;
        pvOc[i] = i;
      }
      var swapIndeces = function swapIndeces2(x, y) {
        var kx = pvOc[x];
        var ky = pvOc[y];
        pvCo[kx] = y;
        pvCo[ky] = x;
        pvOc[x] = ky;
        pvOc[y] = kx;
      };
      var _loop = function _loop2() {
        var spa = new Spa();
        if (j < rows) {
          lptr.push(lvalues.length);
          lvalues.push(1);
          lindex.push(j);
        }
        uptr.push(uvalues.length);
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (k = k0; k < k1; k++) {
          i = index[k];
          spa.set(pvCo[i], values2[k]);
        }
        if (j > 0) {
          spa.forEach(0, j - 1, function(k2, vkj) {
            SparseMatrix._forEachRow(k2, lvalues, lindex, lptr, function(i2, vik) {
              if (i2 > k2) {
                spa.accumulate(i2, unaryMinus(multiplyScalar(vik, vkj)));
              }
            });
          });
        }
        var pi2 = j;
        var vjj = spa.get(j);
        var pabsv = abs(vjj);
        spa.forEach(j + 1, rows - 1, function(x, v) {
          var absv = abs(v);
          if (larger(absv, pabsv)) {
            pi2 = x;
            pabsv = absv;
            vjj = v;
          }
        });
        if (j !== pi2) {
          SparseMatrix._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
          SparseMatrix._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
          spa.swap(j, pi2);
          swapIndeces(j, pi2);
        }
        spa.forEach(0, rows - 1, function(x, v) {
          if (x <= j) {
            uvalues.push(v);
            uindex.push(x);
          } else {
            v = divideScalar(v, vjj);
            if (!equalScalar(v, 0)) {
              lvalues.push(v);
              lindex.push(x);
            }
          }
        });
      };
      for (j = 0; j < columns; j++) {
        _loop();
      }
      uptr.push(uvalues.length);
      lptr.push(lvalues.length);
      return {
        L: new SparseMatrix({
          values: lvalues,
          index: lindex,
          ptr: lptr,
          size: lsize
        }),
        U: new SparseMatrix({
          values: uvalues,
          index: uindex,
          ptr: uptr,
          size: usize
        }),
        p: pvCo,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
        }
      };
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
  function _extends4() {
    _extends4 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends4.apply(this, arguments);
  }
  var name217 = "qr";
  var dependencies218 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtract", "complex"];
  var createQr = /* @__PURE__ */ factory(name217, dependencies218, (_ref) => {
    var {
      typed,
      matrix,
      zeros: zeros2,
      identity,
      isZero,
      equal,
      sign: sign2,
      sqrt,
      conj,
      unaryMinus,
      addScalar,
      divideScalar,
      multiplyScalar,
      subtract,
      complex
    } = _ref;
    return _extends4(typed(name217, {
      DenseMatrix: function DenseMatrix(m) {
        return _denseQR(m);
      },
      SparseMatrix: function SparseMatrix(m) {
        return _sparseQR(m);
      },
      Array: function Array2(a) {
        var m = matrix(a);
        var r = _denseQR(m);
        return {
          Q: r.Q.valueOf(),
          R: r.R.valueOf()
        };
      }
    }), {
      _denseQRimpl
    });
    function _denseQRimpl(m) {
      var rows = m._size[0];
      var cols = m._size[1];
      var Q2 = identity([rows], "dense");
      var Qdata = Q2._data;
      var R = m.clone();
      var Rdata = R._data;
      var i, j, k;
      var w = zeros2([rows], "");
      for (k = 0; k < Math.min(cols, rows); ++k) {
        var pivot = Rdata[k][k];
        var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign2(pivot));
        var conjSgn = conj(sgn);
        var alphaSquared = 0;
        for (i = k; i < rows; i++) {
          alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
        }
        var alpha = multiplyScalar(sgn, sqrt(alphaSquared));
        if (!isZero(alpha)) {
          var u1 = subtract(pivot, alpha);
          w[k] = 1;
          for (i = k + 1; i < rows; i++) {
            w[i] = divideScalar(Rdata[i][k], u1);
          }
          var tau2 = unaryMinus(conj(divideScalar(u1, alpha)));
          var s = void 0;
          for (j = k; j < cols; j++) {
            s = 0;
            for (i = k; i < rows; i++) {
              s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
            }
            s = multiplyScalar(s, tau2);
            for (i = k; i < rows; i++) {
              Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
            }
          }
          for (i = 0; i < rows; i++) {
            s = 0;
            for (j = k; j < rows; j++) {
              s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
            }
            s = multiplyScalar(s, tau2);
            for (j = k; j < rows; ++j) {
              Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
            }
          }
        }
      }
      return {
        Q: Q2,
        R,
        toString: function toString() {
          return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
        }
      };
    }
    function _denseQR(m) {
      var ret = _denseQRimpl(m);
      var Rdata = ret.R._data;
      if (m._data.length > 0) {
        var zero = Rdata[0][0].type === "Complex" ? complex(0) : 0;
        for (var i = 0; i < Rdata.length; ++i) {
          for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
            Rdata[i][j] = zero;
          }
        }
      }
      return ret;
    }
    function _sparseQR(m) {
      throw new Error("qr not implemented for sparse matrices yet");
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
  function csPermute(a, pinv, q, values2) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var m = asize[0];
    var n = asize[1];
    var cvalues = values2 && a._values ? [] : null;
    var cindex = [];
    var cptr = [];
    var nz = 0;
    for (var k = 0; k < n; k++) {
      cptr[k] = nz;
      var j = q ? q[k] : k;
      for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
        var r = pinv ? pinv[aindex[t]] : aindex[t];
        cindex[nz] = r;
        if (cvalues) {
          cvalues[nz] = avalues[t];
        }
        nz++;
      }
    }
    cptr[n] = nz;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [m, n],
      datatype: adt
    });
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
  function csTdfs(j, k, w, head, next, post, stack) {
    var top = 0;
    w[stack] = j;
    while (top >= 0) {
      var p = w[stack + top];
      var i = w[head + p];
      if (i === -1) {
        top--;
        post[k++] = p;
      } else {
        w[head + p] = w[next + i];
        ++top;
        w[stack + top] = i;
      }
    }
    return k;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
  function csPost(parent, n) {
    if (!parent) {
      return null;
    }
    var k = 0;
    var j;
    var post = [];
    var w = [];
    var head = 0;
    var next = n;
    var stack = 2 * n;
    for (j = 0; j < n; j++) {
      w[head + j] = -1;
    }
    for (j = n - 1; j >= 0; j--) {
      if (parent[j] === -1) {
        continue;
      }
      w[next + j] = w[head + parent[j]];
      w[head + parent[j]] = j;
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        continue;
      }
      k = csTdfs(j, k, w, head, next, post, stack);
    }
    return post;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
  function csEtree(a, ata) {
    if (!a) {
      return null;
    }
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var parent = [];
    var w = [];
    var ancestor = 0;
    var prev = n;
    var i, inext;
    if (ata) {
      for (i = 0; i < m; i++) {
        w[prev + i] = -1;
      }
    }
    for (var k = 0; k < n; k++) {
      parent[k] = -1;
      w[ancestor + k] = -1;
      for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        var r = aindex[p];
        i = ata ? w[prev + r] : r;
        for (; i !== -1 && i < k; i = inext) {
          inext = w[ancestor + i];
          w[ancestor + i] = k;
          if (inext === -1) {
            parent[i] = k;
          }
        }
        if (ata) {
          w[prev + r] = k;
        }
      }
    }
    return parent;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
  function csFkeep(a, callback, other) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var nz = 0;
    for (var j = 0; j < n; j++) {
      var p = aptr[j];
      aptr[j] = nz;
      for (; p < aptr[j + 1]; p++) {
        if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
          aindex[nz] = aindex[p];
          if (avalues) {
            avalues[nz] = avalues[p];
          }
          nz++;
        }
      }
    }
    aptr[n] = nz;
    aindex.splice(nz, aindex.length - nz);
    if (avalues) {
      avalues.splice(nz, avalues.length - nz);
    }
    return nz;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
  function csFlip(i) {
    return -i - 2;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
  var name218 = "csAmd";
  var dependencies219 = ["add", "multiply", "transpose"];
  var createCsAmd = /* @__PURE__ */ factory(name218, dependencies219, (_ref) => {
    var {
      add,
      multiply,
      transpose
    } = _ref;
    return function csAmd(order, a) {
      if (!a || order <= 0 || order > 3) {
        return null;
      }
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      var lemax = 0;
      var dense = Math.max(16, 10 * Math.sqrt(n));
      dense = Math.min(n - 2, dense);
      var cm = _createTargetMatrix(order, a, m, n, dense);
      csFkeep(cm, _diag, null);
      var cindex = cm._index;
      var cptr = cm._ptr;
      var cnz = cptr[n];
      var P2 = [];
      var W = [];
      var len = 0;
      var nv = n + 1;
      var next = 2 * (n + 1);
      var head = 3 * (n + 1);
      var elen = 4 * (n + 1);
      var degree = 5 * (n + 1);
      var w = 6 * (n + 1);
      var hhead = 7 * (n + 1);
      var last = P2;
      var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
      var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
      var mindeg = 0;
      var i, j, k, k1, k2, e2, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;
      while (nel < n) {
        for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) {
          ;
        }
        if (W[next + k] !== -1) {
          last[W[next + k]] = -1;
        }
        W[head + mindeg] = W[next + k];
        var elenk = W[elen + k];
        var nvk = W[nv + k];
        nel += nvk;
        var dk = 0;
        W[nv + k] = -nvk;
        var p = cptr[k];
        var pk1 = elenk === 0 ? p : cnz;
        var pk2 = pk1;
        for (k1 = 1; k1 <= elenk + 1; k1++) {
          if (k1 > elenk) {
            e2 = k;
            pj = p;
            ln = W[len + k] - elenk;
          } else {
            e2 = cindex[p++];
            pj = cptr[e2];
            ln = W[len + e2];
          }
          for (k2 = 1; k2 <= ln; k2++) {
            i = cindex[pj++];
            if ((nvi = W[nv + i]) <= 0) {
              continue;
            }
            dk += nvi;
            W[nv + i] = -nvi;
            cindex[pk2++] = i;
            if (W[next + i] !== -1) {
              last[W[next + i]] = last[i];
            }
            if (last[i] !== -1) {
              W[next + last[i]] = W[next + i];
            } else {
              W[head + W[degree + i]] = W[next + i];
            }
          }
          if (e2 !== k) {
            cptr[e2] = csFlip(k);
            W[w + e2] = 0;
          }
        }
        if (elenk !== 0) {
          cnz = pk2;
        }
        W[degree + k] = dk;
        cptr[k] = pk1;
        W[len + k] = pk2 - pk1;
        W[elen + k] = -2;
        mark = _wclear(mark, lemax, W, w, n);
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if ((eln = W[elen + i]) <= 0) {
            continue;
          }
          nvi = -W[nv + i];
          var wnvi = mark - nvi;
          for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {
            e2 = cindex[p];
            if (W[w + e2] >= mark) {
              W[w + e2] -= nvi;
            } else if (W[w + e2] !== 0) {
              W[w + e2] = W[degree + e2] + wnvi;
            }
          }
        }
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          p1 = cptr[i];
          p2 = p1 + W[elen + i] - 1;
          pn = p1;
          for (h = 0, d = 0, p = p1; p <= p2; p++) {
            e2 = cindex[p];
            if (W[w + e2] !== 0) {
              var dext = W[w + e2] - mark;
              if (dext > 0) {
                d += dext;
                cindex[pn++] = e2;
                h += e2;
              } else {
                cptr[e2] = csFlip(k);
                W[w + e2] = 0;
              }
            }
          }
          W[elen + i] = pn - p1 + 1;
          var p3 = pn;
          var p4 = p1 + W[len + i];
          for (p = p2 + 1; p < p4; p++) {
            j = cindex[p];
            var nvj = W[nv + j];
            if (nvj <= 0) {
              continue;
            }
            d += nvj;
            cindex[pn++] = j;
            h += j;
          }
          if (d === 0) {
            cptr[i] = csFlip(k);
            nvi = -W[nv + i];
            dk -= nvi;
            nvk += nvi;
            nel += nvi;
            W[nv + i] = 0;
            W[elen + i] = -1;
          } else {
            W[degree + i] = Math.min(W[degree + i], d);
            cindex[pn] = cindex[p3];
            cindex[p3] = cindex[p1];
            cindex[p1] = k;
            W[len + i] = pn - p1 + 1;
            h = (h < 0 ? -h : h) % n;
            W[next + i] = W[hhead + h];
            W[hhead + h] = i;
            last[i] = h;
          }
        }
        W[degree + k] = dk;
        lemax = Math.max(lemax, dk);
        mark = _wclear(mark + lemax, lemax, W, w, n);
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if (W[nv + i] >= 0) {
            continue;
          }
          h = last[i];
          i = W[hhead + h];
          W[hhead + h] = -1;
          for (; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
            ln = W[len + i];
            eln = W[elen + i];
            for (p = cptr[i] + 1; p <= cptr[i] + ln - 1; p++) {
              W[w + cindex[p]] = mark;
            }
            var jlast = i;
            for (j = W[next + i]; j !== -1; ) {
              var ok = W[len + j] === ln && W[elen + j] === eln;
              for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {
                if (W[w + cindex[p]] !== mark) {
                  ok = 0;
                }
              }
              if (ok) {
                cptr[j] = csFlip(i);
                W[nv + i] += W[nv + j];
                W[nv + j] = 0;
                W[elen + j] = -1;
                j = W[next + j];
                W[next + jlast] = j;
              } else {
                jlast = j;
                j = W[next + j];
              }
            }
          }
        }
        for (p = pk1, pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if ((nvi = -W[nv + i]) <= 0) {
            continue;
          }
          W[nv + i] = nvi;
          d = W[degree + i] + dk - nvi;
          d = Math.min(d, n - nel - nvi);
          if (W[head + d] !== -1) {
            last[W[head + d]] = i;
          }
          W[next + i] = W[head + d];
          last[i] = -1;
          W[head + d] = i;
          mindeg = Math.min(mindeg, d);
          W[degree + i] = d;
          cindex[p++] = i;
        }
        W[nv + k] = nvk;
        if ((W[len + k] = p - pk1) === 0) {
          cptr[k] = -1;
          W[w + k] = 0;
        }
        if (elenk !== 0) {
          cnz = p;
        }
      }
      for (i = 0; i < n; i++) {
        cptr[i] = csFlip(cptr[i]);
      }
      for (j = 0; j <= n; j++) {
        W[head + j] = -1;
      }
      for (j = n; j >= 0; j--) {
        if (W[nv + j] > 0) {
          continue;
        }
        W[next + j] = W[head + cptr[j]];
        W[head + cptr[j]] = j;
      }
      for (e2 = n; e2 >= 0; e2--) {
        if (W[nv + e2] <= 0) {
          continue;
        }
        if (cptr[e2] !== -1) {
          W[next + e2] = W[head + cptr[e2]];
          W[head + cptr[e2]] = e2;
        }
      }
      for (k = 0, i = 0; i <= n; i++) {
        if (cptr[i] === -1) {
          k = csTdfs(i, k, W, head, next, P2, w);
        }
      }
      P2.splice(P2.length - 1, 1);
      return P2;
    };
    function _createTargetMatrix(order, a, m, n, dense) {
      var at = transpose(a);
      if (order === 1 && n === m) {
        return add(a, at);
      }
      if (order === 2) {
        var tindex = at._index;
        var tptr = at._ptr;
        var p2 = 0;
        for (var j = 0; j < m; j++) {
          var p = tptr[j];
          tptr[j] = p2;
          if (tptr[j + 1] - p > dense) {
            continue;
          }
          for (var p1 = tptr[j + 1]; p < p1; p++) {
            tindex[p2++] = tindex[p];
          }
        }
        tptr[m] = p2;
        a = transpose(at);
        return multiply(at, a);
      }
      return multiply(at, a);
    }
    function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
      for (var k = 0; k < n; k++) {
        W[len + k] = cptr[k + 1] - cptr[k];
      }
      W[len + n] = 0;
      for (var i = 0; i <= n; i++) {
        W[head + i] = -1;
        last[i] = -1;
        W[next + i] = -1;
        W[hhead + i] = -1;
        W[nv + i] = 1;
        W[w + i] = 1;
        W[elen + i] = 0;
        W[degree + i] = W[len + i];
      }
      var mark = _wclear(0, 0, W, w, n);
      W[elen + n] = -2;
      cptr[n] = -1;
      W[w + n] = 0;
      return mark;
    }
    function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
      var nel = 0;
      for (var i = 0; i < n; i++) {
        var d = W[degree + i];
        if (d === 0) {
          W[elen + i] = -2;
          nel++;
          cptr[i] = -1;
          W[w + i] = 0;
        } else if (d > dense) {
          W[nv + i] = 0;
          W[elen + i] = -1;
          nel++;
          cptr[i] = csFlip(n);
          W[nv + n]++;
        } else {
          var h = W[head + d];
          if (h !== -1) {
            last[h] = i;
          }
          W[next + i] = W[head + d];
          W[head + d] = i;
        }
      }
      return nel;
    }
    function _wclear(mark, lemax, W, w, n) {
      if (mark < 2 || mark + lemax < 0) {
        for (var k = 0; k < n; k++) {
          if (W[w + k] !== 0) {
            W[w + k] = 1;
          }
        }
        mark = 2;
      }
      return mark;
    }
    function _diag(i, j) {
      return i !== j;
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
  function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
    var s, sparent;
    var jleaf = 0;
    var q;
    if (i <= j || w[first + j] <= w[maxfirst + i]) {
      return -1;
    }
    w[maxfirst + i] = w[first + j];
    var jprev = w[prevleaf + i];
    w[prevleaf + i] = j;
    if (jprev === -1) {
      jleaf = 1;
      q = i;
    } else {
      jleaf = 2;
      for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {
        ;
      }
      for (s = jprev; s !== q; s = sparent) {
        sparent = w[ancestor + s];
        w[ancestor + s] = q;
      }
    }
    return {
      jleaf,
      q
    };
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
  var name219 = "csCounts";
  var dependencies220 = ["transpose"];
  var createCsCounts = /* @__PURE__ */ factory(name219, dependencies220, (_ref) => {
    var {
      transpose
    } = _ref;
    return function(a, parent, post, ata) {
      if (!a || !parent || !post) {
        return null;
      }
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      var i, j, k, J, p, p0, p1;
      var s = 4 * n + (ata ? n + m + 1 : 0);
      var w = [];
      var ancestor = 0;
      var maxfirst = n;
      var prevleaf = 2 * n;
      var first = 3 * n;
      var head = 4 * n;
      var next = 5 * n + 1;
      for (k = 0; k < s; k++) {
        w[k] = -1;
      }
      var colcount = [];
      var at = transpose(a);
      var tindex = at._index;
      var tptr = at._ptr;
      for (k = 0; k < n; k++) {
        j = post[k];
        colcount[j] = w[first + j] === -1 ? 1 : 0;
        for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
          w[first + j] = k;
        }
      }
      if (ata) {
        for (k = 0; k < n; k++) {
          w[post[k]] = k;
        }
        for (i = 0; i < m; i++) {
          for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {
            k = Math.min(k, w[tindex[p]]);
          }
          w[next + i] = w[head + k];
          w[head + k] = i;
        }
      }
      for (i = 0; i < n; i++) {
        w[ancestor + i] = i;
      }
      for (k = 0; k < n; k++) {
        j = post[k];
        if (parent[j] !== -1) {
          colcount[parent[j]]--;
        }
        for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
          for (p = tptr[J]; p < tptr[J + 1]; p++) {
            i = tindex[p];
            var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);
            if (r.jleaf >= 1) {
              colcount[j]++;
            }
            if (r.jleaf === 2) {
              colcount[r.q]--;
            }
          }
        }
        if (parent[j] !== -1) {
          w[ancestor + j] = parent[j];
        }
      }
      for (j = 0; j < n; j++) {
        if (parent[j] !== -1) {
          colcount[parent[j]] += colcount[j];
        }
      }
      return colcount;
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
  var name220 = "csSqr";
  var dependencies221 = ["add", "multiply", "transpose"];
  var createCsSqr = /* @__PURE__ */ factory(name220, dependencies221, (_ref) => {
    var {
      add,
      multiply,
      transpose
    } = _ref;
    var csAmd = createCsAmd({
      add,
      multiply,
      transpose
    });
    var csCounts = createCsCounts({
      transpose
    });
    return function csSqr(order, a, qr) {
      var aptr = a._ptr;
      var asize = a._size;
      var n = asize[1];
      var k;
      var s = {};
      s.q = csAmd(order, a);
      if (order && !s.q) {
        return null;
      }
      if (qr) {
        var c = order ? csPermute(a, null, s.q, 0) : a;
        s.parent = csEtree(c, 1);
        var post = csPost(s.parent, n);
        s.cp = csCounts(c, s.parent, post, 1);
        if (c && s.parent && s.cp && _vcount(c, s)) {
          for (s.unz = 0, k = 0; k < n; k++) {
            s.unz += s.cp[k];
          }
        }
      } else {
        s.unz = 4 * aptr[n] + n;
        s.lnz = s.unz;
      }
      return s;
    };
    function _vcount(a, s) {
      var aptr = a._ptr;
      var aindex = a._index;
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      s.pinv = [];
      s.leftmost = [];
      var parent = s.parent;
      var pinv = s.pinv;
      var leftmost = s.leftmost;
      var w = [];
      var next = 0;
      var head = m;
      var tail = m + n;
      var nque = m + 2 * n;
      var i, k, p, p0, p1;
      for (k = 0; k < n; k++) {
        w[head + k] = -1;
        w[tail + k] = -1;
        w[nque + k] = 0;
      }
      for (i = 0; i < m; i++) {
        leftmost[i] = -1;
      }
      for (k = n - 1; k >= 0; k--) {
        for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
          leftmost[aindex[p]] = k;
        }
      }
      for (i = m - 1; i >= 0; i--) {
        pinv[i] = -1;
        k = leftmost[i];
        if (k === -1) {
          continue;
        }
        if (w[nque + k]++ === 0) {
          w[tail + k] = i;
        }
        w[next + i] = w[head + k];
        w[head + k] = i;
      }
      s.lnz = 0;
      s.m2 = m;
      for (k = 0; k < n; k++) {
        i = w[head + k];
        s.lnz++;
        if (i < 0) {
          i = s.m2++;
        }
        pinv[i] = k;
        if (--nque[k] <= 0) {
          continue;
        }
        s.lnz += w[nque + k];
        var pa = parent[k];
        if (pa !== -1) {
          if (w[nque + pa] === 0) {
            w[tail + pa] = w[tail + k];
          }
          w[next + w[tail + k]] = w[head + pa];
          w[head + pa] = w[next + i];
          w[nque + pa] += w[nque + k];
        }
      }
      for (i = 0; i < m; i++) {
        if (pinv[i] < 0) {
          pinv[i] = k++;
        }
      }
      return true;
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
  function csMarked(w, j) {
    return w[j] < 0;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
  function csMark(w, j) {
    w[j] = csFlip(w[j]);
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
  function csUnflip(i) {
    return i < 0 ? csFlip(i) : i;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
  function csDfs(j, g, top, xi, pinv) {
    var index = g._index;
    var ptr = g._ptr;
    var size = g._size;
    var n = size[1];
    var i, p, p2;
    var head = 0;
    xi[0] = j;
    while (head >= 0) {
      j = xi[head];
      var jnew = pinv ? pinv[j] : j;
      if (!csMarked(ptr, j)) {
        csMark(ptr, j);
        xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
      }
      var done = 1;
      for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
        i = index[p];
        if (csMarked(ptr, i)) {
          continue;
        }
        xi[n + head] = p;
        xi[++head] = i;
        done = 0;
        break;
      }
      if (done) {
        head--;
        xi[--top] = j;
      }
    }
    return top;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
  function csReach(g, b, k, xi, pinv) {
    var gptr = g._ptr;
    var gsize = g._size;
    var bindex = b._index;
    var bptr = b._ptr;
    var n = gsize[1];
    var p, p0, p1;
    var top = n;
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      var i = bindex[p];
      if (!csMarked(gptr, i)) {
        top = csDfs(i, g, top, xi, pinv);
      }
    }
    for (p = top; p < n; p++) {
      csMark(gptr, xi[p]);
    }
    return top;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
  var name221 = "csSpsolve";
  var dependencies222 = ["divideScalar", "multiply", "subtract"];
  var createCsSpsolve = /* @__PURE__ */ factory(name221, dependencies222, (_ref) => {
    var {
      divideScalar,
      multiply,
      subtract
    } = _ref;
    return function csSpsolve(g, b, k, xi, x, pinv, lo) {
      var gvalues = g._values;
      var gindex = g._index;
      var gptr = g._ptr;
      var gsize = g._size;
      var n = gsize[1];
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var p, p0, p1, q;
      var top = csReach(g, b, k, xi, pinv);
      for (p = top; p < n; p++) {
        x[xi[p]] = 0;
      }
      for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
        x[bindex[p]] = bvalues[p];
      }
      for (var px = top; px < n; px++) {
        var j = xi[px];
        var J = pinv ? pinv[j] : j;
        if (J < 0) {
          continue;
        }
        p0 = gptr[J];
        p1 = gptr[J + 1];
        x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
        p = lo ? p0 + 1 : p0;
        q = lo ? p1 : p1 - 1;
        for (; p < q; p++) {
          var i = gindex[p];
          x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
        }
      }
      return top;
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
  var name222 = "csLu";
  var dependencies223 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
  var createCsLu = /* @__PURE__ */ factory(name222, dependencies223, (_ref) => {
    var {
      abs,
      divideScalar,
      multiply,
      subtract,
      larger,
      largerEq,
      SparseMatrix
    } = _ref;
    var csSpsolve = createCsSpsolve({
      divideScalar,
      multiply,
      subtract
    });
    return function csLu(m, s, tol) {
      if (!m) {
        return null;
      }
      var size = m._size;
      var n = size[1];
      var q;
      var lnz = 100;
      var unz = 100;
      if (s) {
        q = s.q;
        lnz = s.lnz || lnz;
        unz = s.unz || unz;
      }
      var lvalues = [];
      var lindex = [];
      var lptr = [];
      var L = new SparseMatrix({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: [n, n]
      });
      var uvalues = [];
      var uindex = [];
      var uptr = [];
      var U = new SparseMatrix({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: [n, n]
      });
      var pinv = [];
      var i, p;
      var x = [];
      var xi = [];
      for (i = 0; i < n; i++) {
        x[i] = 0;
        pinv[i] = -1;
        lptr[i + 1] = 0;
      }
      lnz = 0;
      unz = 0;
      for (var k = 0; k < n; k++) {
        lptr[k] = lnz;
        uptr[k] = unz;
        var col = q ? q[k] : k;
        var top = csSpsolve(L, m, col, xi, x, pinv, 1);
        var ipiv = -1;
        var a = -1;
        for (p = top; p < n; p++) {
          i = xi[p];
          if (pinv[i] < 0) {
            var xabs = abs(x[i]);
            if (larger(xabs, a)) {
              a = xabs;
              ipiv = i;
            }
          } else {
            uindex[unz] = pinv[i];
            uvalues[unz++] = x[i];
          }
        }
        if (ipiv === -1 || a <= 0) {
          return null;
        }
        if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {
          ipiv = col;
        }
        var pivot = x[ipiv];
        uindex[unz] = k;
        uvalues[unz++] = pivot;
        pinv[ipiv] = k;
        lindex[lnz] = ipiv;
        lvalues[lnz++] = 1;
        for (p = top; p < n; p++) {
          i = xi[p];
          if (pinv[i] < 0) {
            lindex[lnz] = i;
            lvalues[lnz++] = divideScalar(x[i], pivot);
          }
          x[i] = 0;
        }
      }
      lptr[n] = lnz;
      uptr[n] = unz;
      for (p = 0; p < lnz; p++) {
        lindex[p] = pinv[lindex[p]];
      }
      lvalues.splice(lnz, lvalues.length - lnz);
      lindex.splice(lnz, lindex.length - lnz);
      uvalues.splice(unz, uvalues.length - unz);
      uindex.splice(unz, uindex.length - unz);
      return {
        L,
        U,
        pinv
      };
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
  var name223 = "slu";
  var dependencies224 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
  var createSlu = /* @__PURE__ */ factory(name223, dependencies224, (_ref) => {
    var {
      typed,
      abs,
      add,
      multiply,
      transpose,
      divideScalar,
      subtract,
      larger,
      largerEq,
      SparseMatrix
    } = _ref;
    var csSqr = createCsSqr({
      add,
      multiply,
      transpose
    });
    var csLu = createCsLu({
      abs,
      divideScalar,
      multiply,
      subtract,
      larger,
      largerEq,
      SparseMatrix
    });
    return typed(name223, {
      "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
        if (!isInteger(order) || order < 0 || order > 3) {
          throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
        }
        if (threshold < 0 || threshold > 1) {
          throw new Error("Partial pivoting threshold must be a number from 0 to 1");
        }
        var s = csSqr(order, a, false);
        var f = csLu(a, s, threshold);
        return {
          L: f.L,
          U: f.U,
          p: f.pinv,
          q: s.q,
          toString: function toString() {
            return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
          }
        };
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
  function csIpvec(p, b) {
    var k;
    var n = b.length;
    var x = [];
    if (p) {
      for (k = 0; k < n; k++) {
        x[p[k]] = b[k];
      }
    } else {
      for (k = 0; k < n; k++) {
        x[k] = b[k];
      }
    }
    return x;
  }

  // node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
  var name224 = "lusolve";
  var dependencies225 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
  var createLusolve = /* @__PURE__ */ factory(name224, dependencies225, (_ref) => {
    var {
      typed,
      matrix,
      lup,
      slu,
      usolve,
      lsolve,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name224, {
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        a = matrix(a);
        var d = lup(a);
        var x = _lusolve(d.L, d.U, d.p, null, b);
        return x.valueOf();
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
        var d = lup(a);
        return _lusolve(d.L, d.U, d.p, null, b);
      },
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
        var d = lup(a);
        return _lusolve(d.L, d.U, d.p, null, b);
      },
      "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
        var d = slu(a, order, threshold);
        return _lusolve(d.L, d.U, d.p, d.q, b);
      },
      "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
        return _lusolve(d.L, d.U, d.p, d.q, b);
      }
    });
    function _toMatrix(a) {
      if (isMatrix(a)) {
        return a;
      }
      if (isArray(a)) {
        return matrix(a);
      }
      throw new TypeError("Invalid Matrix LU decomposition");
    }
    function _lusolve(l, u, p, q, b) {
      l = _toMatrix(l);
      u = _toMatrix(u);
      if (p) {
        b = solveValidation(l, b, true);
        b._data = csIpvec(p, b._data);
      }
      var y = lsolve(l, b);
      var x = usolve(u, y);
      if (q) {
        x._data = csIpvec(q, x._data);
      }
      return x;
    }
  });

  // node_modules/mathjs/lib/esm/expression/Help.js
  var name225 = "Help";
  var dependencies226 = ["parse"];
  var createHelpClass = /* @__PURE__ */ factory(name225, dependencies226, (_ref) => {
    var {
      parse
    } = _ref;
    function Help(doc) {
      if (!(this instanceof Help)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!doc)
        throw new Error('Argument "doc" missing');
      this.doc = doc;
    }
    Help.prototype.type = "Help";
    Help.prototype.isHelp = true;
    Help.prototype.toString = function() {
      var doc = this.doc || {};
      var desc = "\n";
      if (doc.name) {
        desc += "Name: " + doc.name + "\n\n";
      }
      if (doc.category) {
        desc += "Category: " + doc.category + "\n\n";
      }
      if (doc.description) {
        desc += "Description:\n    " + doc.description + "\n\n";
      }
      if (doc.syntax) {
        desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
      }
      if (doc.examples) {
        desc += "Examples:\n";
        var scope = {};
        for (var i = 0; i < doc.examples.length; i++) {
          var expr = doc.examples[i];
          desc += "    " + expr + "\n";
          var res = void 0;
          try {
            res = parse(expr).compile().evaluate(scope);
          } catch (e2) {
            res = e2;
          }
          if (res !== void 0 && !isHelp(res)) {
            desc += "        " + format3(res, {
              precision: 14
            }) + "\n";
          }
        }
        desc += "\n";
      }
      if (doc.seealso && doc.seealso.length) {
        desc += "See also: " + doc.seealso.join(", ") + "\n";
      }
      return desc;
    };
    Help.prototype.toJSON = function() {
      var obj = clone(this.doc);
      obj.mathjs = "Help";
      return obj;
    };
    Help.fromJSON = function(json) {
      var doc = {};
      Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
        doc[prop] = json[prop];
      });
      return new Help(doc);
    };
    Help.prototype.valueOf = Help.prototype.toString;
    return Help;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/chain/Chain.js
  var name226 = "Chain";
  var dependencies227 = ["?on", "math"];
  var createChainClass = /* @__PURE__ */ factory(name226, dependencies227, (_ref) => {
    var {
      on,
      math: math2
    } = _ref;
    function Chain(value) {
      if (!(this instanceof Chain)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (isChain(value)) {
        this.value = value.value;
      } else {
        this.value = value;
      }
    }
    Chain.prototype.type = "Chain";
    Chain.prototype.isChain = true;
    Chain.prototype.done = function() {
      return this.value;
    };
    Chain.prototype.valueOf = function() {
      return this.value;
    };
    Chain.prototype.toString = function() {
      return format3(this.value);
    };
    Chain.prototype.toJSON = function() {
      return {
        mathjs: "Chain",
        value: this.value
      };
    };
    Chain.fromJSON = function(json) {
      return new Chain(json.value);
    };
    function createProxy(name284, fn) {
      if (typeof fn === "function") {
        Chain.prototype[name284] = chainify(fn);
      }
    }
    function createLazyProxy(name284, resolver) {
      lazy(Chain.prototype, name284, function outerResolver() {
        var fn = resolver();
        if (typeof fn === "function") {
          return chainify(fn);
        }
        return void 0;
      });
    }
    function chainify(fn) {
      return function() {
        var args = [this.value];
        for (var i = 0; i < arguments.length; i++) {
          args[i + 1] = arguments[i];
        }
        return new Chain(fn.apply(fn, args));
      };
    }
    Chain.createProxy = function(arg0, arg1) {
      if (typeof arg0 === "string") {
        createProxy(arg0, arg1);
      } else {
        var _loop = function _loop2(_name2) {
          if (hasOwnProperty2(arg0, _name2) && excludedNames[_name2] === void 0) {
            createLazyProxy(_name2, () => arg0[_name2]);
          }
        };
        for (var _name in arg0) {
          _loop(_name);
        }
      }
    };
    var excludedNames = {
      expression: true,
      docs: true,
      type: true,
      classes: true,
      json: true,
      error: true,
      isChain: true
    };
    Chain.createProxy(math2);
    if (on) {
      on("import", function(name284, resolver, path) {
        if (!path) {
          createLazyProxy(name284, resolver);
        }
      });
    }
    return Chain;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
  var bignumberDocs = {
    name: "bignumber",
    category: "Construction",
    syntax: ["bignumber(x)"],
    description: "Create a big number from a number or string.",
    examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
    seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
  var typeOfDocs = {
    name: "typeOf",
    category: "Utils",
    syntax: ["typeOf(x)"],
    description: "Get the type of a variable.",
    examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
    seealso: ["getMatrixDataType"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
  var isZeroDocs = {
    name: "isZero",
    category: "Utils",
    syntax: ["isZero(x)"],
    description: "Test whether a value is zero.",
    examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
  var isPrimeDocs = {
    name: "isPrime",
    category: "Utils",
    syntax: ["isPrime(x)"],
    description: "Test whether a value is prime: has no divisors other than itself and one.",
    examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
  var isPositiveDocs = {
    name: "isPositive",
    category: "Utils",
    syntax: ["isPositive(x)"],
    description: "Test whether a value is positive: larger than zero.",
    examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
  var isNumericDocs = {
    name: "isNumeric",
    category: "Utils",
    syntax: ["isNumeric(x)"],
    description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
    examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
    seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
  var hasNumericValueDocs = {
    name: "hasNumericValue",
    category: "Utils",
    syntax: ["hasNumericValue(x)"],
    description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
    examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
    seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
  var isNegativeDocs = {
    name: "isNegative",
    category: "Utils",
    syntax: ["isNegative(x)"],
    description: "Test whether a value is negative: smaller than zero.",
    examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
    seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
  var isIntegerDocs = {
    name: "isInteger",
    category: "Utils",
    syntax: ["isInteger(x)"],
    description: "Test whether a value is an integer number.",
    examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
  var isNaNDocs = {
    name: "isNaN",
    category: "Utils",
    syntax: ["isNaN(x)"],
    description: "Test whether a value is NaN (not a number)",
    examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
  var formatDocs = {
    name: "format",
    category: "Utils",
    syntax: ["format(value)", "format(value, precision)"],
    description: "Format a value of any type as string.",
    examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
    seealso: ["print"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
  var binDocs = {
    name: "bin",
    category: "Utils",
    syntax: ["bin(value)"],
    description: "Format a number as binary",
    examples: ["bin(2)"],
    seealso: ["oct", "hex"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
  var octDocs = {
    name: "oct",
    category: "Utils",
    syntax: ["oct(value)"],
    description: "Format a number as octal",
    examples: ["oct(56)"],
    seealso: ["bin", "hex"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
  var hexDocs = {
    name: "hex",
    category: "Utils",
    syntax: ["hex(value)"],
    description: "Format a number as hexadecimal",
    examples: ["hex(240)"],
    seealso: ["bin", "oct"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
  var cloneDocs = {
    name: "clone",
    category: "Utils",
    syntax: ["clone(x)"],
    description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
    examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
  var toDocs = {
    name: "to",
    category: "Units",
    syntax: ["x to unit", "to(x, unit)"],
    description: "Change the unit of a value.",
    examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
  var tanhDocs = {
    name: "tanh",
    category: "Trigonometry",
    syntax: ["tanh(x)"],
    description: "Compute the hyperbolic tangent of x in radians.",
    examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
    seealso: ["sinh", "cosh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
  var tanDocs = {
    name: "tan",
    category: "Trigonometry",
    syntax: ["tan(x)"],
    description: "Compute the tangent of x in radians.",
    examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
    seealso: ["atan", "sin", "cos"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
  var sinhDocs = {
    name: "sinh",
    category: "Trigonometry",
    syntax: ["sinh(x)"],
    description: "Compute the hyperbolic sine of x in radians.",
    examples: ["sinh(0.5)"],
    seealso: ["cosh", "tanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
  var sechDocs = {
    name: "sech",
    category: "Trigonometry",
    syntax: ["sech(x)"],
    description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
    examples: ["sech(2)", "1 / cosh(2)"],
    seealso: ["coth", "csch", "cosh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
  var secDocs = {
    name: "sec",
    category: "Trigonometry",
    syntax: ["sec(x)"],
    description: "Compute the secant of x in radians. Defined as 1/cos(x)",
    examples: ["sec(2)", "1 / cos(2)"],
    seealso: ["cot", "csc", "cos"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
  var cschDocs = {
    name: "csch",
    category: "Trigonometry",
    syntax: ["csch(x)"],
    description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
    examples: ["csch(2)", "1 / sinh(2)"],
    seealso: ["sech", "coth", "sinh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
  var cscDocs = {
    name: "csc",
    category: "Trigonometry",
    syntax: ["csc(x)"],
    description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
    examples: ["csc(2)", "1 / sin(2)"],
    seealso: ["sec", "cot", "sin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
  var cothDocs = {
    name: "coth",
    category: "Trigonometry",
    syntax: ["coth(x)"],
    description: "Compute the hyperbolic cotangent of x in radians.",
    examples: ["coth(2)", "1 / tanh(2)"],
    seealso: ["sech", "csch", "tanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
  var cotDocs = {
    name: "cot",
    category: "Trigonometry",
    syntax: ["cot(x)"],
    description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
    examples: ["cot(2)", "1 / tan(2)"],
    seealso: ["sec", "csc", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
  var coshDocs = {
    name: "cosh",
    category: "Trigonometry",
    syntax: ["cosh(x)"],
    description: "Compute the hyperbolic cosine of x in radians.",
    examples: ["cosh(0.5)"],
    seealso: ["sinh", "tanh", "coth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
  var cosDocs = {
    name: "cos",
    category: "Trigonometry",
    syntax: ["cos(x)"],
    description: "Compute the cosine of x in radians.",
    examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
    seealso: ["acos", "sin", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
  var atan2Docs = {
    name: "atan2",
    category: "Trigonometry",
    syntax: ["atan2(y, x)"],
    description: "Computes the principal value of the arc tangent of y/x in radians.",
    examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
    seealso: ["sin", "cos", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
  var atanhDocs = {
    name: "atanh",
    category: "Trigonometry",
    syntax: ["atanh(x)"],
    description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
    examples: ["atanh(0.5)"],
    seealso: ["acosh", "asinh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
  var atanDocs = {
    name: "atan",
    category: "Trigonometry",
    syntax: ["atan(x)"],
    description: "Compute the inverse tangent of a value in radians.",
    examples: ["atan(0.5)", "atan(tan(0.5))"],
    seealso: ["tan", "acos", "asin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
  var asinhDocs = {
    name: "asinh",
    category: "Trigonometry",
    syntax: ["asinh(x)"],
    description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
    examples: ["asinh(0.5)"],
    seealso: ["acosh", "atanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
  var asinDocs = {
    name: "asin",
    category: "Trigonometry",
    syntax: ["asin(x)"],
    description: "Compute the inverse sine of a value in radians.",
    examples: ["asin(0.5)", "asin(sin(0.5))"],
    seealso: ["sin", "acos", "atan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
  var asechDocs = {
    name: "asech",
    category: "Trigonometry",
    syntax: ["asech(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asech(0.5)"],
    seealso: ["acsch", "acoth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
  var asecDocs = {
    name: "asec",
    category: "Trigonometry",
    syntax: ["asec(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
    seealso: ["acos", "acot", "acsc"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
  var acschDocs = {
    name: "acsch",
    category: "Trigonometry",
    syntax: ["acsch(x)"],
    description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
    examples: ["acsch(0.5)"],
    seealso: ["asech", "acoth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
  var acscDocs = {
    name: "acsc",
    category: "Trigonometry",
    syntax: ["acsc(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
    seealso: ["csc", "asin", "asec"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
  var acothDocs = {
    name: "acoth",
    category: "Trigonometry",
    syntax: ["acoth(x)"],
    description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
    examples: ["acoth(2)", "acoth(0.5)"],
    seealso: ["acsch", "asech"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
  var acotDocs = {
    name: "acot",
    category: "Trigonometry",
    syntax: ["acot(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
    seealso: ["cot", "atan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
  var acoshDocs = {
    name: "acosh",
    category: "Trigonometry",
    syntax: ["acosh(x)"],
    description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
    examples: ["acosh(1.5)"],
    seealso: ["cosh", "asinh", "atanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
  var acosDocs = {
    name: "acos",
    category: "Trigonometry",
    syntax: ["acos(x)"],
    description: "Compute the inverse cosine of a value in radians.",
    examples: ["acos(0.5)", "acos(cos(2.3))"],
    seealso: ["cos", "atan", "asin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
  var sumDocs = {
    name: "sum",
    category: "Statistics",
    syntax: ["sum(a, b, c, ...)", "sum(A)"],
    description: "Compute the sum of all values.",
    examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
  var stdDocs = {
    name: "std",
    category: "Statistics",
    syntax: ["std(a, b, c, ...)", "std(A)", "std(A, normalization)"],
    description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
    seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
  var quantileSeqDocs = {
    name: "quantileSeq",
    category: "Statistics",
    syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
    description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
    examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
    seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
  var prodDocs = {
    name: "prod",
    category: "Statistics",
    syntax: ["prod(a, b, c, ...)", "prod(A)"],
    description: "Compute the product of all values.",
    examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
    seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
  var modeDocs = {
    name: "mode",
    category: "Statistics",
    syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
    description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
    examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
    seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
  var minDocs = {
    name: "min",
    category: "Statistics",
    syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dim)"],
    description: "Compute the minimum value of a list of values.",
    examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
    seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
  var medianDocs = {
    name: "median",
    category: "Statistics",
    syntax: ["median(a, b, c, ...)", "median(A)"],
    description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
    examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
    seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
  var meanDocs = {
    name: "mean",
    category: "Statistics",
    syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dim)"],
    description: "Compute the arithmetic mean of a list of values.",
    examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
    seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
  var maxDocs = {
    name: "max",
    category: "Statistics",
    syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dim)"],
    description: "Compute the maximum value of a list of values.",
    examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
    seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
  var madDocs = {
    name: "mad",
    category: "Statistics",
    syntax: ["mad(a, b, c, ...)", "mad(A)"],
    description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
    examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
    seealso: ["mean", "median", "std", "abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
  var erfDocs = {
    name: "erf",
    category: "Special",
    syntax: ["erf(x)"],
    description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
    examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
  var setUnionDocs = {
    name: "setUnion",
    category: "Set",
    syntax: ["setUnion(set1, set2)"],
    description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
  var setSymDifferenceDocs = {
    name: "setSymDifference",
    category: "Set",
    syntax: ["setSymDifference(set1, set2)"],
    description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
  var setSizeDocs = {
    name: "setSize",
    category: "Set",
    syntax: ["setSize(set)", "setSize(set, unique)"],
    description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
  var setPowersetDocs = {
    name: "setPowerset",
    category: "Set",
    syntax: ["setPowerset(set)"],
    description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setPowerset([1, 2, 3])"],
    seealso: ["setCartesian"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
  var setMultiplicityDocs = {
    name: "setMultiplicity",
    category: "Set",
    syntax: ["setMultiplicity(element, set)"],
    description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
    seealso: ["setDistinct", "setSize"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
  var setIsSubsetDocs = {
    name: "setIsSubset",
    category: "Set",
    syntax: ["setIsSubset(set1, set2)"],
    description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
  var setIntersectDocs = {
    name: "setIntersect",
    category: "Set",
    syntax: ["setIntersect(set1, set2)"],
    description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
  var setDistinctDocs = {
    name: "setDistinct",
    category: "Set",
    syntax: ["setDistinct(set)"],
    description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
    seealso: ["setMultiplicity"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
  var setDifferenceDocs = {
    name: "setDifference",
    category: "Set",
    syntax: ["setDifference(set1, set2)"],
    description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setIntersect", "setSymDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
  var setCartesianDocs = {
    name: "setCartesian",
    category: "Set",
    syntax: ["setCartesian(set1, set2)"],
    description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setCartesian([1, 2], [3, 4])"],
    seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
  var unequalDocs = {
    name: "unequal",
    category: "Relational",
    syntax: ["x != y", "unequal(x, y)"],
    description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
    examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
    seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
  var smallerEqDocs = {
    name: "smallerEq",
    category: "Relational",
    syntax: ["x <= y", "smallerEq(x, y)"],
    description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
    examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
    seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
  var smallerDocs = {
    name: "smaller",
    category: "Relational",
    syntax: ["x < y", "smaller(x, y)"],
    description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
    examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
    seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
  var largerEqDocs = {
    name: "largerEq",
    category: "Relational",
    syntax: ["x >= y", "largerEq(x, y)"],
    description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
    examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
    seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
  var largerDocs = {
    name: "larger",
    category: "Relational",
    syntax: ["x > y", "larger(x, y)"],
    description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
    examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
  var equalTextDocs = {
    name: "equalText",
    category: "Relational",
    syntax: ["equalText(x, y)"],
    description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
    examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
    seealso: ["compare", "compareNatural", "compareText", "equal"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
  var equalDocs = {
    name: "equal",
    category: "Relational",
    syntax: ["x == y", "equal(x, y)"],
    description: "Check equality of two values. Returns true if the values are equal, and false if not.",
    examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
    seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
  var deepEqualDocs = {
    name: "deepEqual",
    category: "Relational",
    syntax: ["deepEqual(x, y)"],
    description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
    examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
    seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
  var compareTextDocs = {
    name: "compareText",
    category: "Relational",
    syntax: ["compareText(x, y)"],
    description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
    seealso: ["compare", "compareNatural"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
  var compareNaturalDocs = {
    name: "compareNatural",
    category: "Relational",
    syntax: ["compareNatural(x, y)"],
    description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
  var compareDocs = {
    name: "compare",
    category: "Relational",
    syntax: ["compare(x, y)"],
    description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
  var randomIntDocs = {
    name: "randomInt",
    category: "Probability",
    syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
    description: "Return a random integer number",
    examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
    seealso: ["pickRandom", "random"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
  var randomDocs = {
    name: "random",
    category: "Probability",
    syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
    description: "Return a random number.",
    examples: ["random()", "random(10, 20)", "random([2, 3])"],
    seealso: ["pickRandom", "randomInt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
  var pickRandomDocs = {
    name: "pickRandom",
    category: "Probability",
    syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
    description: "Pick a random entry from a given array.",
    examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
    seealso: ["random", "randomInt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
  var permutationsDocs = {
    name: "permutations",
    category: "Probability",
    syntax: ["permutations(n)", "permutations(n, k)"],
    description: "Compute the number of permutations of n items taken k at a time",
    examples: ["permutations(5)", "permutations(5, 3)"],
    seealso: ["combinations", "combinationsWithRep", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
  var multinomialDocs = {
    name: "multinomial",
    category: "Probability",
    syntax: ["multinomial(A)"],
    description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
    examples: ["multinomial([1, 2, 1])"],
    seealso: ["combinations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
  var kldivergenceDocs = {
    name: "kldivergence",
    category: "Probability",
    syntax: ["kldivergence(x, y)"],
    description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
    examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
  var gammaDocs = {
    name: "gamma",
    category: "Probability",
    syntax: ["gamma(n)"],
    description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
    examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
    seealso: ["factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
  var factorialDocs = {
    name: "factorial",
    category: "Probability",
    syntax: ["n!", "factorial(n)"],
    description: "Compute the factorial of a value",
    examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
    seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
  var combinationsDocs = {
    name: "combinations",
    category: "Probability",
    syntax: ["combinations(n, k)"],
    description: "Compute the number of combinations of n items taken k at a time",
    examples: ["combinations(7, 5)"],
    seealso: ["combinationsWithRep", "permutations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
  var combinationsWithRepDocs = {
    name: "combinationsWithRep",
    category: "Probability",
    syntax: ["combinationsWithRep(n, k)"],
    description: "Compute the number of combinations of n items taken k at a time with replacements.",
    examples: ["combinationsWithRep(7, 5)"],
    seealso: ["combinations", "permutations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
  var zerosDocs = {
    name: "zeros",
    category: "Matrix",
    syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
    description: "Create a matrix containing zeros.",
    examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
  var transposeDocs = {
    name: "transpose",
    category: "Matrix",
    syntax: ["x'", "transpose(x)"],
    description: "Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
  var traceDocs = {
    name: "trace",
    category: "Matrix",
    syntax: ["trace(A)"],
    description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
    examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
  var subsetDocs = {
    name: "subset",
    category: "Matrix",
    syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
    description: "Get or set a subset of a matrix or string. Indexes are one-based. Both the ranges lower-bound and upper-bound are included.",
    examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
  var squeezeDocs = {
    name: "squeeze",
    category: "Matrix",
    syntax: ["squeeze(x)"],
    description: "Remove inner and outer singleton dimensions from a matrix.",
    examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
  var sortDocs = {
    name: "sort",
    category: "Matrix",
    syntax: ["sort(x)", "sort(x, compare)"],
    description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
    examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"])', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
    seealso: ["map", "filter", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
  var sizeDocs = {
    name: "size",
    category: "Matrix",
    syntax: ["size(x)"],
    description: "Calculate the size of a matrix.",
    examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
    seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
  var diffDocs = {
    name: "diff",
    category: "Matrix",
    syntax: ["diff(arr)", "diff(arr, dim)"],
    description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
    examples: ["diff([1, 2, 4, 7, 0])", "diff([1, 2, 4, 7, 0], 0)", "diff(matrix([1, 2, 4, 7, 0]))", "diff([[1, 2], [3, 4]])", "diff([[1, 2], [3, 4]], 0)", "diff([[1, 2], [3, 4]], 1)", "diff([[1, 2], [3, 4]], bignumber(1))", "diff(matrix([[1, 2], [3, 4]]), 1)", "diff([[1, 2], matrix([3, 4])], 1)"],
    seealso: ["subtract", "partitionSelect"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
  var reshapeDocs = {
    name: "reshape",
    category: "Matrix",
    syntax: ["reshape(x, sizes)"],
    description: "Reshape a multi dimensional array to fit the specified dimensions.",
    examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])"],
    seealso: ["size", "squeeze", "resize"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
  var resizeDocs = {
    name: "resize",
    category: "Matrix",
    syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
    description: "Resize a matrix.",
    examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
    seealso: ["size", "subset", "squeeze", "reshape"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
  var rangeDocs = {
    name: "range",
    category: "Type",
    syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
    description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
    examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
  var partitionSelectDocs = {
    name: "partitionSelect",
    category: "Matrix",
    syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
    description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
    examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1)'],
    seealso: ["sort"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
  var onesDocs = {
    name: "ones",
    category: "Matrix",
    syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
    description: "Create a matrix containing ones.",
    examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
  var mapDocs = {
    name: "map",
    category: "Matrix",
    syntax: ["map(x, callback)"],
    description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
    examples: ["map([1, 2, 3], square)"],
    seealso: ["filter", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
  var kronDocs = {
    name: "kron",
    category: "Matrix",
    syntax: ["kron(x, y)"],
    description: "Calculates the kronecker product of 2 matrices or vectors.",
    examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
    seealso: ["multiply", "dot", "cross"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
  var invDocs = {
    name: "inv",
    category: "Matrix",
    syntax: ["inv(x)"],
    description: "Calculate the inverse of a matrix",
    examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
    seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
  var forEachDocs = {
    name: "forEach",
    category: "Matrix",
    syntax: ["forEach(x, callback)"],
    description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
    examples: ["forEach([1, 2, 3], function(val) { console.log(val) })"],
    seealso: ["map", "sort", "filter"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
  var flattenDocs = {
    name: "flatten",
    category: "Matrix",
    syntax: ["flatten(x)"],
    description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
    seealso: ["concat", "resize", "size", "squeeze"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
  var filterDocs = {
    name: "filter",
    category: "Matrix",
    syntax: ["filter(x, test)"],
    description: "Filter items in a matrix.",
    examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
    seealso: ["sort", "map", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
  var identityDocs = {
    name: "identity",
    category: "Matrix",
    syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
    description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
    examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
    seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
  var getMatrixDataTypeDocs = {
    name: "getMatrixDataType",
    category: "Matrix",
    syntax: ["getMatrixDataType(x)"],
    description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
    examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
    seealso: ["matrix", "sparse", "typeOf"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
  var dotDocs = {
    name: "dot",
    category: "Matrix",
    syntax: ["dot(A, B)", "A * B"],
    description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
    examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
    seealso: ["multiply", "cross"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
  var diagDocs = {
    name: "diag",
    category: "Matrix",
    syntax: ["diag(x)", "diag(x, k)"],
    description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
    examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
    seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
  var detDocs = {
    name: "det",
    category: "Matrix",
    syntax: ["det(x)"],
    description: "Calculate the determinant of a matrix",
    examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
    seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
  var ctransposeDocs = {
    name: "ctranspose",
    category: "Matrix",
    syntax: ["x'", "ctranspose(x)"],
    description: "Complex Conjugate and Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
  var crossDocs = {
    name: "cross",
    category: "Matrix",
    syntax: ["cross(A, B)"],
    description: "Calculate the cross product for two vectors in three dimensional space.",
    examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
    seealso: ["multiply", "dot"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
  var concatDocs = {
    name: "concat",
    category: "Matrix",
    syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
    description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
    examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
    seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
  var countDocs = {
    name: "count",
    category: "Matrix",
    syntax: ["count(x)"],
    description: "Count the number of elements of a matrix, array or string.",
    examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
    seealso: ["size"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
  var xorDocs = {
    name: "xor",
    category: "Logical",
    syntax: ["x xor y", "xor(x, y)"],
    description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
    examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
    seealso: ["not", "and", "or"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
  var orDocs = {
    name: "or",
    category: "Logical",
    syntax: ["x or y", "or(x, y)"],
    description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
    examples: ["true or false", "false or false", "0 or 4"],
    seealso: ["not", "and", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
  var notDocs = {
    name: "not",
    category: "Logical",
    syntax: ["not x", "not(x)"],
    description: "Logical not. Flips the boolean value of given argument.",
    examples: ["not true", "not false", "not 2", "not 0"],
    seealso: ["and", "or", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
  var andDocs = {
    name: "and",
    category: "Logical",
    syntax: ["x and y", "and(x, y)"],
    description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
    examples: ["true and false", "true and true", "2 and 4"],
    seealso: ["not", "or", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
  var intersectDocs = {
    name: "intersect",
    category: "Geometry",
    syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
    description: "Computes the intersection point of lines and/or planes.",
    examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
  var distanceDocs = {
    name: "distance",
    category: "Geometry",
    syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
    description: "Calculates the Euclidean distance between two points.",
    examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
  var helpDocs = {
    name: "help",
    category: "Expression",
    syntax: ["help(object)", "help(string)"],
    description: "Display documentation on a function or data type.",
    examples: ["help(sqrt)", 'help("complex")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
  var evaluateDocs = {
    name: "evaluate",
    category: "Expression",
    syntax: ["evaluate(expression)", "evaluate([expr1, expr2, expr3, ...])"],
    description: "Evaluate an expression or an array with expressions.",
    examples: ['evaluate("2 + 3")', 'evaluate("sqrt(" + 4 + ")")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
  var imDocs = {
    name: "im",
    category: "Complex",
    syntax: ["im(x)"],
    description: "Get the imaginary part of a complex number.",
    examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
    seealso: ["re", "conj", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
  var reDocs = {
    name: "re",
    category: "Complex",
    syntax: ["re(x)"],
    description: "Get the real part of a complex number.",
    examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
    seealso: ["im", "conj", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
  var conjDocs = {
    name: "conj",
    category: "Complex",
    syntax: ["conj(x)"],
    description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
    examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
    seealso: ["re", "im", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
  var argDocs = {
    name: "arg",
    category: "Complex",
    syntax: ["arg(x)"],
    description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
    examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
    seealso: ["re", "im", "conj", "abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
  var typedDocs = {
    name: "typed",
    category: "Core",
    syntax: ["typed(signatures)", "typed(name, signatures)"],
    description: "Create a typed function.",
    examples: ['double = typed({ "number, number": f(x)=x+x })', "double(2)", 'double("hello")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
  var importDocs = {
    name: "import",
    category: "Core",
    syntax: ["import(functions)", "import(functions, options)"],
    description: "Import functions or constants from an object.",
    examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
  var configDocs = {
    name: "config",
    category: "Core",
    syntax: ["config()", "config(options)"],
    description: "Get configuration or change configuration.",
    examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
  var stirlingS2Docs = {
    name: "stirlingS2",
    category: "Combinatorics",
    syntax: ["stirlingS2(n, k)"],
    description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
    examples: ["stirlingS2(5, 3)"],
    seealso: ["bellNumbers"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
  var compositionDocs = {
    name: "composition",
    category: "Combinatorics",
    syntax: ["composition(n, k)"],
    description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
    examples: ["composition(5, 3)"],
    seealso: ["combinations"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
  var catalanDocs = {
    name: "catalan",
    category: "Combinatorics",
    syntax: ["catalan(n)"],
    description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["catalan(3)", "catalan(8)"],
    seealso: ["bellNumbers"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
  var bellNumbersDocs = {
    name: "bellNumbers",
    category: "Combinatorics",
    syntax: ["bellNumbers(n)"],
    description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["bellNumbers(3)", "bellNumbers(8)"],
    seealso: ["stirlingS2"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
  var rightLogShiftDocs = {
    name: "rightLogShift",
    category: "Bitwise",
    syntax: ["x >>> y", "rightLogShift(x, y)"],
    description: "Bitwise right logical shift of a value x by y number of bits.",
    examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
  var rightArithShiftDocs = {
    name: "rightArithShift",
    category: "Bitwise",
    syntax: ["x >> y", "rightArithShift(x, y)"],
    description: "Bitwise right arithmetic shift of a value x by y number of bits.",
    examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
  var leftShiftDocs = {
    name: "leftShift",
    category: "Bitwise",
    syntax: ["x << y", "leftShift(x, y)"],
    description: "Bitwise left logical shift of a value x by y number of bits.",
    examples: ["4 << 1", "8 >> 1"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
  var bitXorDocs = {
    name: "bitXor",
    category: "Bitwise",
    syntax: ["bitXor(x, y)"],
    description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
    examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
    seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
  var bitOrDocs = {
    name: "bitOr",
    category: "Bitwise",
    syntax: ["x | y", "bitOr(x, y)"],
    description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
    examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
    seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
  var bitNotDocs = {
    name: "bitNot",
    category: "Bitwise",
    syntax: ["~x", "bitNot(x)"],
    description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
    examples: ["~1", "~2", "bitNot([2, -3, 4])"],
    seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
  var bitAndDocs = {
    name: "bitAnd",
    category: "Bitwise",
    syntax: ["x & y", "bitAnd(x, y)"],
    description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
    examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
    seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
  var xgcdDocs = {
    name: "xgcd",
    category: "Arithmetic",
    syntax: ["xgcd(a, b)"],
    description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
    examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
    seealso: ["gcd", "lcm"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
  var unaryPlusDocs = {
    name: "unaryPlus",
    category: "Operators",
    syntax: ["+x", "unaryPlus(x)"],
    description: "Converts booleans and strings to numbers.",
    examples: ["+true", '+"2"'],
    seealso: ["add", "subtract", "unaryMinus"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
  var unaryMinusDocs = {
    name: "unaryMinus",
    category: "Operators",
    syntax: ["-x", "unaryMinus(x)"],
    description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
    examples: ["-4.5", "-(-5.6)", '-"22"'],
    seealso: ["add", "subtract", "unaryPlus"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
  var squareDocs = {
    name: "square",
    category: "Arithmetic",
    syntax: ["square(x)"],
    description: "Compute the square of a value. The square of x is x * x.",
    examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
    seealso: ["multiply", "pow", "sqrt", "cube"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
  var sqrtmDocs = {
    name: "sqrtm",
    category: "Arithmetic",
    syntax: ["sqrtm(x)"],
    description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
    examples: ["sqrtm([[1, 2], [3, 4]])"],
    seealso: ["sqrt", "abs", "square", "multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
  var sqrtDocs = {
    name: "sqrt",
    category: "Arithmetic",
    syntax: ["sqrt(x)"],
    description: "Compute the square root value. If x = y * y, then y is the square root of x.",
    examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
    seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
  var signDocs = {
    name: "sign",
    category: "Arithmetic",
    syntax: ["sign(x)"],
    description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
    examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
    seealso: ["abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
  var roundDocs = {
    name: "round",
    category: "Arithmetic",
    syntax: ["round(x)", "round(x, n)"],
    description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
    examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)"],
    seealso: ["ceil", "floor", "fix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
  var powDocs = {
    name: "pow",
    category: "Operators",
    syntax: ["x ^ y", "pow(x, y)"],
    description: "Calculates the power of x to y, x^y.",
    examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)"],
    seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
  var nthRootsDocs = {
    name: "nthRoots",
    category: "Arithmetic",
    syntax: ["nthRoots(A)", "nthRoots(A, root)"],
    description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
    examples: ["nthRoots(1)", "nthRoots(1, 3)"],
    seealso: ["sqrt", "pow", "nthRoot"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
  var nthRootDocs = {
    name: "nthRoot",
    category: "Arithmetic",
    syntax: ["nthRoot(a)", "nthRoot(a, root)"],
    description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
    examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
    seealso: ["nthRoots", "pow", "sqrt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
  var normDocs = {
    name: "norm",
    category: "Arithmetic",
    syntax: ["norm(x)", "norm(x, p)"],
    description: "Calculate the norm of a number, vector or matrix.",
    examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
  var multiplyDocs = {
    name: "multiply",
    category: "Operators",
    syntax: ["x * y", "multiply(x, y)"],
    description: "multiply two values.",
    examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
    seealso: ["divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
  var modDocs = {
    name: "mod",
    category: "Operators",
    syntax: ["x % y", "x mod y", "mod(x, y)"],
    description: "Calculates the modulus, the remainder of an integer division.",
    examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
    seealso: ["divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
  var log10Docs = {
    name: "log10",
    category: "Arithmetic",
    syntax: ["log10(x)"],
    description: "Compute the 10-base logarithm of a value.",
    examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
    seealso: ["exp", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
  var log1pDocs = {
    name: "log1p",
    category: "Arithmetic",
    syntax: ["log1p(x)", "log1p(x, base)"],
    description: "Calculate the logarithm of a `value+1`",
    examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
    seealso: ["exp", "log", "log2", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
  var log2Docs = {
    name: "log2",
    category: "Arithmetic",
    syntax: ["log2(x)"],
    description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
    examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
    seealso: ["exp", "log1p", "log", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
  var logDocs = {
    name: "log",
    category: "Arithmetic",
    syntax: ["log(x)", "log(x, base)"],
    description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
    examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
    seealso: ["exp", "log1p", "log2", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
  var lcmDocs = {
    name: "lcm",
    category: "Arithmetic",
    syntax: ["lcm(x, y)"],
    description: "Compute the least common multiple.",
    examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
    seealso: ["gcd"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
  var hypotDocs = {
    name: "hypot",
    category: "Arithmetic",
    syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
    description: "Calculate the hypotenusa of a list with values. ",
    examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
    seealso: ["abs", "norm"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
  var gcdDocs = {
    name: "gcd",
    category: "Arithmetic",
    syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
    description: "Compute the greatest common divisor.",
    examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
    seealso: ["lcm", "xgcd"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
  var floorDocs = {
    name: "floor",
    category: "Arithmetic",
    syntax: ["floor(x)"],
    description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
    examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
    seealso: ["ceil", "fix", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
  var fixDocs = {
    name: "fix",
    category: "Arithmetic",
    syntax: ["fix(x)"],
    description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
    examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
    seealso: ["ceil", "floor", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
  var expm1Docs = {
    name: "expm1",
    category: "Arithmetic",
    syntax: ["expm1(x)"],
    description: "Calculate the value of subtracting 1 from the exponential value.",
    examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
    seealso: ["exp", "pow", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
  var expmDocs = {
    name: "expm",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
    examples: ["expm([[0,2],[0,0]])"],
    seealso: ["exp"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
  var eigsDocs = {
    name: "eigs",
    category: "Matrix",
    syntax: ["eigs(x)"],
    description: "Calculate the eigenvalues and eigenvectors of a real symmetric matrix",
    examples: ["eigs([[5, 2.3], [2.3, 1]])"],
    seealso: ["inv"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
  var expDocs = {
    name: "exp",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description: "Calculate the exponent of a value.",
    examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
    seealso: ["expm", "expm1", "pow", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
  var dotMultiplyDocs = {
    name: "dotMultiply",
    category: "Operators",
    syntax: ["x .* y", "dotMultiply(x, y)"],
    description: "Multiply two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
    seealso: ["multiply", "divide", "dotDivide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
  var dotDivideDocs = {
    name: "dotDivide",
    category: "Operators",
    syntax: ["x ./ y", "dotDivide(x, y)"],
    description: "Divide two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
    seealso: ["multiply", "dotMultiply", "divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
  var divideDocs = {
    name: "divide",
    category: "Operators",
    syntax: ["x / y", "divide(x, y)"],
    description: "Divide two values.",
    examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
    seealso: ["multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
  var cubeDocs = {
    name: "cube",
    category: "Arithmetic",
    syntax: ["cube(x)"],
    description: "Compute the cube of a value. The cube of x is x * x * x.",
    examples: ["cube(2)", "2^3", "2 * 2 * 2"],
    seealso: ["multiply", "square", "pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
  var ceilDocs = {
    name: "ceil",
    category: "Arithmetic",
    syntax: ["ceil(x)"],
    description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
    examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
    seealso: ["floor", "fix", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
  var cbrtDocs = {
    name: "cbrt",
    category: "Arithmetic",
    syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
    description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
    examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
    seealso: ["square", "sqrt", "cube", "multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
  var addDocs = {
    name: "add",
    category: "Operators",
    syntax: ["x + y", "add(x, y)"],
    description: "Add two values.",
    examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
    seealso: ["subtract"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
  var absDocs = {
    name: "abs",
    category: "Arithmetic",
    syntax: ["abs(x)"],
    description: "Compute the absolute value.",
    examples: ["abs(3.5)", "abs(-4.2)"],
    seealso: ["sign"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
  var qrDocs = {
    name: "qr",
    category: "Algebra",
    syntax: ["qr(A)"],
    description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
    examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
    seealso: ["lup", "slu", "matrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
  var usolveDocs = {
    name: "usolve",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
    seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
  var usolveAllDocs = {
    name: "usolveAll",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
    seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
  var sluDocs = {
    name: "slu",
    category: "Algebra",
    syntax: ["slu(A, order, threshold)"],
    description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
    examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
  var rationalizeDocs = {
    name: "rationalize",
    category: "Algebra",
    syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
    description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
    examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
    seealso: ["simplify"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
  var simplifyDocs = {
    name: "simplify",
    category: "Algebra",
    syntax: ["simplify(expr)", "simplify(expr, rules)"],
    description: "Simplify an expression tree.",
    examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
    seealso: ["derivative", "parse", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
  var lupDocs = {
    name: "lup",
    category: "Algebra",
    syntax: ["lup(m)"],
    description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
    examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
  var lsolveDocs = {
    name: "lsolve",
    category: "Algebra",
    syntax: ["x=lsolve(L, b)"],
    description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
  var lsolveAllDocs = {
    name: "lsolveAll",
    category: "Algebra",
    syntax: ["x=lsolveAll(L, b)"],
    description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
  var derivativeDocs = {
    name: "derivative",
    category: "Algebra",
    syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
    description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
    examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
    seealso: ["simplify", "parse", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
  var versionDocs = {
    name: "version",
    category: "Constants",
    syntax: ["version"],
    description: "A string with the version number of math.js",
    examples: ["version"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
  var trueDocs = {
    name: "true",
    category: "Constants",
    syntax: ["true"],
    description: "Boolean value true",
    examples: ["true"],
    seealso: ["false"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
  var tauDocs = {
    name: "tau",
    category: "Constants",
    syntax: ["tau"],
    description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
    examples: ["tau", "2 * pi"],
    seealso: ["pi"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
  var SQRT2Docs = {
    name: "SQRT2",
    category: "Constants",
    syntax: ["SQRT2"],
    description: "Returns the square root of 2, approximately equal to 1.414",
    examples: ["SQRT2", "sqrt(2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
  var SQRT12Docs = {
    name: "SQRT1_2",
    category: "Constants",
    syntax: ["SQRT1_2"],
    description: "Returns the square root of 1/2, approximately equal to 0.707",
    examples: ["SQRT1_2", "sqrt(1/2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
  var phiDocs = {
    name: "phi",
    category: "Constants",
    syntax: ["phi"],
    description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
    examples: ["phi"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
  var piDocs = {
    name: "pi",
    category: "Constants",
    syntax: ["pi"],
    description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
    examples: ["pi", "sin(pi/2)"],
    seealso: ["tau"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
  var nullDocs = {
    name: "null",
    category: "Constants",
    syntax: ["null"],
    description: "Value null",
    examples: ["null"],
    seealso: ["true", "false"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
  var NaNDocs = {
    name: "NaN",
    category: "Constants",
    syntax: ["NaN"],
    description: "Not a number",
    examples: ["NaN", "0 / 0"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
  var LOG10EDocs = {
    name: "LOG10E",
    category: "Constants",
    syntax: ["LOG10E"],
    description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
    examples: ["LOG10E", "log(e, 10)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
  var LOG2EDocs = {
    name: "LOG2E",
    category: "Constants",
    syntax: ["LOG2E"],
    description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
    examples: ["LOG2E", "log(e, 2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
  var LN10Docs = {
    name: "LN10",
    category: "Constants",
    syntax: ["LN10"],
    description: "Returns the natural logarithm of 10, approximately equal to 2.302",
    examples: ["LN10", "log(10)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
  var LN2Docs = {
    name: "LN2",
    category: "Constants",
    syntax: ["LN2"],
    description: "Returns the natural logarithm of 2, approximately equal to 0.693",
    examples: ["LN2", "log(2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
  var InfinityDocs = {
    name: "Infinity",
    category: "Constants",
    syntax: ["Infinity"],
    description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
    examples: ["Infinity", "1 / 0"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
  var iDocs = {
    name: "i",
    category: "Constants",
    syntax: ["i"],
    description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
    examples: ["i", "i * i", "sqrt(-1)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
  var falseDocs = {
    name: "false",
    category: "Constants",
    syntax: ["false"],
    description: "Boolean value false",
    examples: ["false"],
    seealso: ["true"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
  var eDocs = {
    name: "e",
    category: "Constants",
    syntax: ["e"],
    description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
    examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
    seealso: ["exp"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
  var unitDocs = {
    name: "unit",
    category: "Construction",
    syntax: ["value unit", "unit(value, unit)", "unit(string)"],
    description: "Create a unit.",
    examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
  var stringDocs = {
    name: "string",
    category: "Construction",
    syntax: ['"text"', "string(x)"],
    description: "Create a string or convert a value to a string",
    examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
  var splitUnitDocs = {
    name: "splitUnit",
    category: "Construction",
    syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
    description: "Split a unit in an array of units whose sum is equal to the original unit.",
    examples: ['splitUnit(1 m, ["feet", "inch"])'],
    seealso: ["unit", "createUnit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
  var sparseDocs = {
    name: "sparse",
    category: "Construction",
    syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
    description: "Create a sparse matrix.",
    examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
    seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
  var numberDocs = {
    name: "number",
    category: "Construction",
    syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
    description: "Create a number or convert a string or boolean into a number.",
    examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
    seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
  var matrixDocs = {
    name: "matrix",
    category: "Construction",
    syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
    description: "Create a matrix.",
    examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
    seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
  var indexDocs = {
    name: "index",
    category: "Construction",
    syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
    description: "Create an index to get or replace a subset of a matrix",
    examples: ["[]", "[1, 2, 3]", "A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[0:2, 0:2] = ones(2, 2)"],
    seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
  var fractionDocs = {
    name: "fraction",
    category: "Construction",
    syntax: ["fraction(num)", "fraction(num,den)"],
    description: "Create a fraction from a number or from a numerator and denominator.",
    examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)"],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
  var createUnitDocs = {
    name: "createUnit",
    category: "Construction",
    syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
    description: "Create a user-defined unit and register it with the Unit type.",
    examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
    seealso: ["unit", "splitUnit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
  var complexDocs = {
    name: "complex",
    category: "Construction",
    syntax: ["complex()", "complex(re, im)", "complex(string)"],
    description: "Create a complex number.",
    examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
    seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
  var booleanDocs = {
    name: "boolean",
    category: "Construction",
    syntax: ["x", "boolean(x)"],
    description: "Convert a string or number into a boolean.",
    examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
    seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
  var dotPowDocs = {
    name: "dotPow",
    category: "Operators",
    syntax: ["x .^ y", "dotPow(x, y)"],
    description: "Calculates the power of x to y element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
    seealso: ["pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
  var lusolveDocs = {
    name: "lusolve",
    category: "Algebra",
    syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
    description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
    seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
  var subtractDocs = {
    name: "subtract",
    category: "Operators",
    syntax: ["x - y", "subtract(x, y)"],
    description: "subtract two values.",
    examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
    seealso: ["add"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
  var varianceDocs = {
    name: "variance",
    category: "Statistics",
    syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, normalization)"],
    description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
    seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
  var sinDocs = {
    name: "sin",
    category: "Trigonometry",
    syntax: ["sin(x)"],
    description: "Compute the sine of x in radians.",
    examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
    seealso: ["asin", "cos", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
  var numericDocs = {
    name: "numeric",
    category: "Utils",
    syntax: ["numeric(x)"],
    description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
    examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction)', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number)'],
    seealso: ["number", "fraction", "bignumber", "string", "format"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
  var columnDocs = {
    name: "column",
    category: "Matrix",
    syntax: ["column(x, index)"],
    description: "Return a column from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
    seealso: ["row"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
  var rowDocs = {
    name: "row",
    category: "Matrix",
    syntax: ["row(x, index)"],
    description: "Return a row from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
    seealso: ["column"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
  var rotationMatrixDocs = {
    name: "rotationMatrix",
    category: "Matrix",
    syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
    description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
    seealso: ["cos", "sin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
  var rotateDocs = {
    name: "rotate",
    category: "Matrix",
    syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
    description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: ["rotate([1, 0], math.pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
    seealso: ["matrix", "rotationMatrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
  var embeddedDocs = {
    bignumber: bignumberDocs,
    boolean: booleanDocs,
    complex: complexDocs,
    createUnit: createUnitDocs,
    fraction: fractionDocs,
    index: indexDocs,
    matrix: matrixDocs,
    number: numberDocs,
    sparse: sparseDocs,
    splitUnit: splitUnitDocs,
    string: stringDocs,
    unit: unitDocs,
    e: eDocs,
    E: eDocs,
    false: falseDocs,
    i: iDocs,
    Infinity: InfinityDocs,
    LN2: LN2Docs,
    LN10: LN10Docs,
    LOG2E: LOG2EDocs,
    LOG10E: LOG10EDocs,
    NaN: NaNDocs,
    null: nullDocs,
    pi: piDocs,
    PI: piDocs,
    phi: phiDocs,
    SQRT1_2: SQRT12Docs,
    SQRT2: SQRT2Docs,
    tau: tauDocs,
    true: trueDocs,
    version: versionDocs,
    speedOfLight: {
      description: "Speed of light in vacuum",
      examples: ["speedOfLight"]
    },
    gravitationConstant: {
      description: "Newtonian constant of gravitation",
      examples: ["gravitationConstant"]
    },
    planckConstant: {
      description: "Planck constant",
      examples: ["planckConstant"]
    },
    reducedPlanckConstant: {
      description: "Reduced Planck constant",
      examples: ["reducedPlanckConstant"]
    },
    magneticConstant: {
      description: "Magnetic constant (vacuum permeability)",
      examples: ["magneticConstant"]
    },
    electricConstant: {
      description: "Electric constant (vacuum permeability)",
      examples: ["electricConstant"]
    },
    vacuumImpedance: {
      description: "Characteristic impedance of vacuum",
      examples: ["vacuumImpedance"]
    },
    coulomb: {
      description: "Coulomb's constant",
      examples: ["coulomb"]
    },
    elementaryCharge: {
      description: "Elementary charge",
      examples: ["elementaryCharge"]
    },
    bohrMagneton: {
      description: "Borh magneton",
      examples: ["bohrMagneton"]
    },
    conductanceQuantum: {
      description: "Conductance quantum",
      examples: ["conductanceQuantum"]
    },
    inverseConductanceQuantum: {
      description: "Inverse conductance quantum",
      examples: ["inverseConductanceQuantum"]
    },
    magneticFluxQuantum: {
      description: "Magnetic flux quantum",
      examples: ["magneticFluxQuantum"]
    },
    nuclearMagneton: {
      description: "Nuclear magneton",
      examples: ["nuclearMagneton"]
    },
    klitzing: {
      description: "Von Klitzing constant",
      examples: ["klitzing"]
    },
    bohrRadius: {
      description: "Borh radius",
      examples: ["bohrRadius"]
    },
    classicalElectronRadius: {
      description: "Classical electron radius",
      examples: ["classicalElectronRadius"]
    },
    electronMass: {
      description: "Electron mass",
      examples: ["electronMass"]
    },
    fermiCoupling: {
      description: "Fermi coupling constant",
      examples: ["fermiCoupling"]
    },
    fineStructure: {
      description: "Fine-structure constant",
      examples: ["fineStructure"]
    },
    hartreeEnergy: {
      description: "Hartree energy",
      examples: ["hartreeEnergy"]
    },
    protonMass: {
      description: "Proton mass",
      examples: ["protonMass"]
    },
    deuteronMass: {
      description: "Deuteron Mass",
      examples: ["deuteronMass"]
    },
    neutronMass: {
      description: "Neutron mass",
      examples: ["neutronMass"]
    },
    quantumOfCirculation: {
      description: "Quantum of circulation",
      examples: ["quantumOfCirculation"]
    },
    rydberg: {
      description: "Rydberg constant",
      examples: ["rydberg"]
    },
    thomsonCrossSection: {
      description: "Thomson cross section",
      examples: ["thomsonCrossSection"]
    },
    weakMixingAngle: {
      description: "Weak mixing angle",
      examples: ["weakMixingAngle"]
    },
    efimovFactor: {
      description: "Efimov factor",
      examples: ["efimovFactor"]
    },
    atomicMass: {
      description: "Atomic mass constant",
      examples: ["atomicMass"]
    },
    avogadro: {
      description: "Avogadro's number",
      examples: ["avogadro"]
    },
    boltzmann: {
      description: "Boltzmann constant",
      examples: ["boltzmann"]
    },
    faraday: {
      description: "Faraday constant",
      examples: ["faraday"]
    },
    firstRadiation: {
      description: "First radiation constant",
      examples: ["firstRadiation"]
    },
    loschmidt: {
      description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
      examples: ["loschmidt"]
    },
    gasConstant: {
      description: "Gas constant",
      examples: ["gasConstant"]
    },
    molarPlanckConstant: {
      description: "Molar Planck constant",
      examples: ["molarPlanckConstant"]
    },
    molarVolume: {
      description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
      examples: ["molarVolume"]
    },
    sackurTetrode: {
      description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
      examples: ["sackurTetrode"]
    },
    secondRadiation: {
      description: "Second radiation constant",
      examples: ["secondRadiation"]
    },
    stefanBoltzmann: {
      description: "Stefan-Boltzmann constant",
      examples: ["stefanBoltzmann"]
    },
    wienDisplacement: {
      description: "Wien displacement law constant",
      examples: ["wienDisplacement"]
    },
    molarMass: {
      description: "Molar mass constant",
      examples: ["molarMass"]
    },
    molarMassC12: {
      description: "Molar mass constant of carbon-12",
      examples: ["molarMassC12"]
    },
    gravity: {
      description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
      examples: ["gravity"]
    },
    planckLength: {
      description: "Planck length",
      examples: ["planckLength"]
    },
    planckMass: {
      description: "Planck mass",
      examples: ["planckMass"]
    },
    planckTime: {
      description: "Planck time",
      examples: ["planckTime"]
    },
    planckCharge: {
      description: "Planck charge",
      examples: ["planckCharge"]
    },
    planckTemperature: {
      description: "Planck temperature",
      examples: ["planckTemperature"]
    },
    derivative: derivativeDocs,
    lsolve: lsolveDocs,
    lsolveAll: lsolveAllDocs,
    lup: lupDocs,
    lusolve: lusolveDocs,
    simplify: simplifyDocs,
    rationalize: rationalizeDocs,
    slu: sluDocs,
    usolve: usolveDocs,
    usolveAll: usolveAllDocs,
    qr: qrDocs,
    abs: absDocs,
    add: addDocs,
    cbrt: cbrtDocs,
    ceil: ceilDocs,
    cube: cubeDocs,
    divide: divideDocs,
    dotDivide: dotDivideDocs,
    dotMultiply: dotMultiplyDocs,
    dotPow: dotPowDocs,
    exp: expDocs,
    expm: expmDocs,
    expm1: expm1Docs,
    fix: fixDocs,
    floor: floorDocs,
    gcd: gcdDocs,
    hypot: hypotDocs,
    lcm: lcmDocs,
    log: logDocs,
    log2: log2Docs,
    log1p: log1pDocs,
    log10: log10Docs,
    mod: modDocs,
    multiply: multiplyDocs,
    norm: normDocs,
    nthRoot: nthRootDocs,
    nthRoots: nthRootsDocs,
    pow: powDocs,
    round: roundDocs,
    sign: signDocs,
    sqrt: sqrtDocs,
    sqrtm: sqrtmDocs,
    square: squareDocs,
    subtract: subtractDocs,
    unaryMinus: unaryMinusDocs,
    unaryPlus: unaryPlusDocs,
    xgcd: xgcdDocs,
    bitAnd: bitAndDocs,
    bitNot: bitNotDocs,
    bitOr: bitOrDocs,
    bitXor: bitXorDocs,
    leftShift: leftShiftDocs,
    rightArithShift: rightArithShiftDocs,
    rightLogShift: rightLogShiftDocs,
    bellNumbers: bellNumbersDocs,
    catalan: catalanDocs,
    composition: compositionDocs,
    stirlingS2: stirlingS2Docs,
    config: configDocs,
    import: importDocs,
    typed: typedDocs,
    arg: argDocs,
    conj: conjDocs,
    re: reDocs,
    im: imDocs,
    evaluate: evaluateDocs,
    help: helpDocs,
    distance: distanceDocs,
    intersect: intersectDocs,
    and: andDocs,
    not: notDocs,
    or: orDocs,
    xor: xorDocs,
    concat: concatDocs,
    count: countDocs,
    cross: crossDocs,
    column: columnDocs,
    ctranspose: ctransposeDocs,
    det: detDocs,
    diag: diagDocs,
    diff: diffDocs,
    dot: dotDocs,
    getMatrixDataType: getMatrixDataTypeDocs,
    identity: identityDocs,
    filter: filterDocs,
    flatten: flattenDocs,
    forEach: forEachDocs,
    inv: invDocs,
    eigs: eigsDocs,
    kron: kronDocs,
    map: mapDocs,
    ones: onesDocs,
    partitionSelect: partitionSelectDocs,
    range: rangeDocs,
    resize: resizeDocs,
    reshape: reshapeDocs,
    rotate: rotateDocs,
    rotationMatrix: rotationMatrixDocs,
    row: rowDocs,
    size: sizeDocs,
    sort: sortDocs,
    squeeze: squeezeDocs,
    subset: subsetDocs,
    trace: traceDocs,
    transpose: transposeDocs,
    zeros: zerosDocs,
    combinations: combinationsDocs,
    combinationsWithRep: combinationsWithRepDocs,
    factorial: factorialDocs,
    gamma: gammaDocs,
    kldivergence: kldivergenceDocs,
    multinomial: multinomialDocs,
    permutations: permutationsDocs,
    pickRandom: pickRandomDocs,
    random: randomDocs,
    randomInt: randomIntDocs,
    compare: compareDocs,
    compareNatural: compareNaturalDocs,
    compareText: compareTextDocs,
    deepEqual: deepEqualDocs,
    equal: equalDocs,
    equalText: equalTextDocs,
    larger: largerDocs,
    largerEq: largerEqDocs,
    smaller: smallerDocs,
    smallerEq: smallerEqDocs,
    unequal: unequalDocs,
    setCartesian: setCartesianDocs,
    setDifference: setDifferenceDocs,
    setDistinct: setDistinctDocs,
    setIntersect: setIntersectDocs,
    setIsSubset: setIsSubsetDocs,
    setMultiplicity: setMultiplicityDocs,
    setPowerset: setPowersetDocs,
    setSize: setSizeDocs,
    setSymDifference: setSymDifferenceDocs,
    setUnion: setUnionDocs,
    erf: erfDocs,
    mad: madDocs,
    max: maxDocs,
    mean: meanDocs,
    median: medianDocs,
    min: minDocs,
    mode: modeDocs,
    prod: prodDocs,
    quantileSeq: quantileSeqDocs,
    std: stdDocs,
    sum: sumDocs,
    variance: varianceDocs,
    acos: acosDocs,
    acosh: acoshDocs,
    acot: acotDocs,
    acoth: acothDocs,
    acsc: acscDocs,
    acsch: acschDocs,
    asec: asecDocs,
    asech: asechDocs,
    asin: asinDocs,
    asinh: asinhDocs,
    atan: atanDocs,
    atanh: atanhDocs,
    atan2: atan2Docs,
    cos: cosDocs,
    cosh: coshDocs,
    cot: cotDocs,
    coth: cothDocs,
    csc: cscDocs,
    csch: cschDocs,
    sec: secDocs,
    sech: sechDocs,
    sin: sinDocs,
    sinh: sinhDocs,
    tan: tanDocs,
    tanh: tanhDocs,
    to: toDocs,
    clone: cloneDocs,
    format: formatDocs,
    bin: binDocs,
    oct: octDocs,
    hex: hexDocs,
    isNaN: isNaNDocs,
    isInteger: isIntegerDocs,
    isNegative: isNegativeDocs,
    isNumeric: isNumericDocs,
    hasNumericValue: hasNumericValueDocs,
    isPositive: isPositiveDocs,
    isPrime: isPrimeDocs,
    isZero: isZeroDocs,
    typeOf: typeOfDocs,
    numeric: numericDocs
  };

  // node_modules/mathjs/lib/esm/expression/function/help.js
  var name227 = "help";
  var dependencies228 = ["typed", "mathWithTransform", "Help"];
  var createHelp = /* @__PURE__ */ factory(name227, dependencies228, (_ref) => {
    var {
      typed,
      mathWithTransform,
      Help
    } = _ref;
    return typed(name227, {
      any: function any(search) {
        var prop;
        var searchName = search;
        if (typeof search !== "string") {
          for (prop in mathWithTransform) {
            if (hasOwnProperty2(mathWithTransform, prop) && search === mathWithTransform[prop]) {
              searchName = prop;
              break;
            }
          }
        }
        var doc = getSafeProperty(embeddedDocs, searchName);
        if (!doc) {
          var searchText = typeof searchName === "function" ? searchName.name : searchName;
          throw new Error('No documentation found on "' + searchText + '"');
        }
        return new Help(doc);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/chain/function/chain.js
  var name228 = "chain";
  var dependencies229 = ["typed", "Chain"];
  var createChain = /* @__PURE__ */ factory(name228, dependencies229, (_ref) => {
    var {
      typed,
      Chain
    } = _ref;
    return typed(name228, {
      "": function _4() {
        return new Chain();
      },
      any: function any(value) {
        return new Chain(value);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/det.js
  var name229 = "det";
  var dependencies230 = ["typed", "matrix", "subtract", "multiply", "unaryMinus", "lup"];
  var createDet = /* @__PURE__ */ factory(name229, dependencies230, (_ref) => {
    var {
      typed,
      matrix,
      subtract,
      multiply,
      unaryMinus,
      lup
    } = _ref;
    return typed(name229, {
      any: function any(x) {
        return clone(x);
      },
      "Array | Matrix": function det(x) {
        var size;
        if (isMatrix(x)) {
          size = x.size();
        } else if (Array.isArray(x)) {
          x = matrix(x);
          size = x.size();
        } else {
          size = [];
        }
        switch (size.length) {
          case 0:
            return clone(x);
          case 1:
            if (size[0] === 1) {
              return clone(x.valueOf()[0]);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
            }
          case 2: {
            var rows = size[0];
            var cols = size[1];
            if (rows === cols) {
              return _det(x.clone().valueOf(), rows, cols);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
        }
      }
    });
    function _det(matrix2, rows, cols) {
      if (rows === 1) {
        return clone(matrix2[0][0]);
      } else if (rows === 2) {
        return subtract(multiply(matrix2[0][0], matrix2[1][1]), multiply(matrix2[1][0], matrix2[0][1]));
      } else {
        var decomp = lup(matrix2);
        var det = decomp.U[0][0];
        for (var _i = 1; _i < rows; _i++) {
          det = multiply(det, decomp.U[_i][_i]);
        }
        var evenCycles = 0;
        var i = 0;
        var visited = [];
        while (true) {
          while (visited[i]) {
            i++;
          }
          if (i >= rows)
            break;
          var j = i;
          var cycleLen = 0;
          while (!visited[decomp.p[j]]) {
            visited[decomp.p[j]] = true;
            j = decomp.p[j];
            cycleLen++;
          }
          if (cycleLen % 2 === 0) {
            evenCycles++;
          }
        }
        return evenCycles % 2 === 0 ? det : unaryMinus(det);
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/inv.js
  var name230 = "inv";
  var dependencies231 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
  var createInv = /* @__PURE__ */ factory(name230, dependencies231, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      addScalar,
      multiply,
      unaryMinus,
      det,
      identity,
      abs
    } = _ref;
    return typed(name230, {
      "Array | Matrix": function ArrayMatrix(x) {
        var size = isMatrix(x) ? x.size() : arraySize(x);
        switch (size.length) {
          case 1:
            if (size[0] === 1) {
              if (isMatrix(x)) {
                return matrix([divideScalar(1, x.valueOf()[0])]);
              } else {
                return [divideScalar(1, x[0])];
              }
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
            }
          case 2: {
            var rows = size[0];
            var cols = size[1];
            if (rows === cols) {
              if (isMatrix(x)) {
                return matrix(_inv(x.valueOf(), rows, cols), x.storage());
              } else {
                return _inv(x, rows, cols);
              }
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
        }
      },
      any: function any(x) {
        return divideScalar(1, x);
      }
    });
    function _inv(mat, rows, cols) {
      var r, s, f, value, temp;
      if (rows === 1) {
        value = mat[0][0];
        if (value === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar(1, value)]];
      } else if (rows === 2) {
        var d = det(mat);
        if (d === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
      } else {
        var A = mat.concat();
        for (r = 0; r < rows; r++) {
          A[r] = A[r].concat();
        }
        var B = identity(rows).valueOf();
        for (var c = 0; c < cols; c++) {
          var ABig = abs(A[c][c]);
          var rBig = c;
          r = c + 1;
          while (r < rows) {
            if (abs(A[r][c]) > ABig) {
              ABig = abs(A[r][c]);
              rBig = r;
            }
            r++;
          }
          if (ABig === 0) {
            throw Error("Cannot calculate inverse, determinant is zero");
          }
          r = rBig;
          if (r !== c) {
            temp = A[c];
            A[c] = A[r];
            A[r] = temp;
            temp = B[c];
            B[c] = B[r];
            B[r] = temp;
          }
          var Ac = A[c];
          var Bc = B[c];
          for (r = 0; r < rows; r++) {
            var Ar = A[r];
            var Br = B[r];
            if (r !== c) {
              if (Ar[c] !== 0) {
                f = divideScalar(unaryMinus(Ar[c]), Ac[c]);
                for (s = c; s < cols; s++) {
                  Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
                }
                for (s = 0; s < cols; s++) {
                  Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
                }
              }
            } else {
              f = Ac[c];
              for (s = c; s < cols; s++) {
                Ar[s] = divideScalar(Ar[s], f);
              }
              for (s = 0; s < cols; s++) {
                Br[s] = divideScalar(Br[s], f);
              }
            }
          }
        }
        return B;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/eigs.js
  var name231 = "eigs";
  var dependencies232 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "inv", "bignumber", "multiply", "add"];
  var createEigs = /* @__PURE__ */ factory(name231, dependencies232, (_ref) => {
    var {
      config,
      typed,
      matrix,
      addScalar,
      subtract,
      equal,
      abs,
      atan,
      cos,
      sin,
      multiplyScalar,
      inv,
      bignumber,
      multiply,
      add
    } = _ref;
    return typed("eigs", {
      Array: function Array2(x) {
        var mat = matrix(x);
        var size = mat.size();
        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        }
        var ans = checkAndSubmit(mat, size[0]);
        return {
          values: ans[0],
          vectors: ans[1]
        };
      },
      Matrix: function Matrix(x) {
        var size = x.size();
        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        }
        var ans = checkAndSubmit(x, size[0]);
        return {
          values: matrix(ans[0]),
          vectors: matrix(ans[1])
        };
      }
    });
    function isSymmetric(x, n) {
      for (var i = 0; i < n; i++) {
        for (var j = i; j < n; j++) {
          if (!equal(x[i][j], x[j][i])) {
            throw new TypeError("Input matrix is not symmetric");
          }
        }
      }
    }
    function checkAndSubmit(x, n) {
      var type = x.datatype();
      if (type === void 0) {
        type = x.getDataType();
      }
      if (type !== "number" && type !== "BigNumber" && type !== "Fraction") {
        if (type === "mixed") {
          throw new TypeError("Mixed matrix element type is not supported");
        } else {
          throw new TypeError("Matrix element type not supported (" + type + ")");
        }
      } else {
        isSymmetric(x.toArray(), n);
      }
      if (type === "number") {
        return diag(x.toArray());
      } else if (type === "Fraction") {
        var xArr = x.toArray();
        for (var i = 0; i < n; i++) {
          for (var j = i; j < n; j++) {
            xArr[i][j] = xArr[i][j].valueOf();
            xArr[j][i] = xArr[i][j];
          }
        }
        return diag(x.toArray());
      } else if (type === "BigNumber") {
        return diagBig(x.toArray());
      }
    }
    function diag(x) {
      var N = x.length;
      var e0 = Math.abs(config.epsilon / N);
      var psi;
      var Sij = new Array(N);
      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1;
      }
      var Vab = getAij(x);
      while (Math.abs(Vab[1]) >= Math.abs(e0)) {
        var _i = Vab[0][0];
        var j = Vab[0][1];
        psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
        x = x1(x, psi, _i, j);
        Sij = Sij1(Sij, psi, _i, j);
        Vab = getAij(x);
      }
      var Ei = createArray(N, 0);
      for (var _i2 = 0; _i2 < N; _i2++) {
        Ei[_i2] = x[_i2][_i2];
      }
      return sorting(clone(Ei), clone(Sij));
    }
    function diagBig(x) {
      var N = x.length;
      var e0 = abs(config.epsilon / N);
      var psi;
      var Sij = new Array(N);
      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1;
      }
      var Vab = getAijBig(x);
      while (abs(Vab[1]) >= abs(e0)) {
        var _i3 = Vab[0][0];
        var j = Vab[0][1];
        psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
        x = x1Big(x, psi, _i3, j);
        Sij = Sij1Big(Sij, psi, _i3, j);
        Vab = getAijBig(x);
      }
      var Ei = createArray(N, 0);
      for (var _i4 = 0; _i4 < N; _i4++) {
        Ei[_i4] = x[_i4][_i4];
      }
      return sorting(clone(Ei), clone(Sij));
    }
    function getTheta(aii, ajj, aij) {
      var denom = ajj - aii;
      if (Math.abs(denom) <= config.epsilon) {
        return Math.PI / 4;
      } else {
        return 0.5 * Math.atan(2 * aij / (ajj - aii));
      }
    }
    function getThetaBig(aii, ajj, aij) {
      var denom = subtract(ajj, aii);
      if (abs(denom) <= config.epsilon) {
        return bignumber(-1).acos().div(4);
      } else {
        return multiplyScalar(0.5, atan(multiply(2, aij, inv(denom))));
      }
    }
    function Sij1(Sij, theta, i, j) {
      var N = Sij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var Ski = createArray(N, 0);
      var Skj = createArray(N, 0);
      for (var k = 0; k < N; k++) {
        Ski[k] = c * Sij[k][i] - s * Sij[k][j];
        Skj[k] = s * Sij[k][i] + c * Sij[k][j];
      }
      for (var _k = 0; _k < N; _k++) {
        Sij[_k][i] = Ski[_k];
        Sij[_k][j] = Skj[_k];
      }
      return Sij;
    }
    function Sij1Big(Sij, theta, i, j) {
      var N = Sij.length;
      var c = cos(theta);
      var s = sin(theta);
      var Ski = createArray(N, bignumber(0));
      var Skj = createArray(N, bignumber(0));
      for (var k = 0; k < N; k++) {
        Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
        Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
      }
      for (var _k2 = 0; _k2 < N; _k2++) {
        Sij[_k2][i] = Ski[_k2];
        Sij[_k2][j] = Skj[_k2];
      }
      return Sij;
    }
    function x1Big(Hij, theta, i, j) {
      var N = Hij.length;
      var c = bignumber(cos(theta));
      var s = bignumber(sin(theta));
      var c2 = multiplyScalar(c, c);
      var s2 = multiplyScalar(s, s);
      var Aki = createArray(N, bignumber(0));
      var Akj = createArray(N, bignumber(0));
      var csHij = multiply(bignumber(2), c, s, Hij[i][j]);
      var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
      var Ajj = add(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j]));
      for (var k = 0; k < N; k++) {
        Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
        Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
      }
      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = bignumber(0);
      Hij[j][i] = bignumber(0);
      for (var _k3 = 0; _k3 < N; _k3++) {
        if (_k3 !== i && _k3 !== j) {
          Hij[i][_k3] = Aki[_k3];
          Hij[_k3][i] = Aki[_k3];
          Hij[j][_k3] = Akj[_k3];
          Hij[_k3][j] = Akj[_k3];
        }
      }
      return Hij;
    }
    function x1(Hij, theta, i, j) {
      var N = Hij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var c2 = c * c;
      var s2 = s * s;
      var Aki = createArray(N, 0);
      var Akj = createArray(N, 0);
      var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
      var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];
      for (var k = 0; k < N; k++) {
        Aki[k] = c * Hij[i][k] - s * Hij[j][k];
        Akj[k] = s * Hij[i][k] + c * Hij[j][k];
      }
      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = 0;
      Hij[j][i] = 0;
      for (var _k4 = 0; _k4 < N; _k4++) {
        if (_k4 !== i && _k4 !== j) {
          Hij[i][_k4] = Aki[_k4];
          Hij[_k4][i] = Aki[_k4];
          Hij[j][_k4] = Akj[_k4];
          Hij[_k4][j] = Akj[_k4];
        }
      }
      return Hij;
    }
    function getAij(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
            maxMij = Math.abs(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function getAijBig(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (abs(maxMij) < abs(Mij[i][j])) {
            maxMij = abs(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function sorting(E, S) {
      var N = E.length;
      var Ef = Array(N);
      var Sf = Array(N);
      for (var k = 0; k < N; k++) {
        Sf[k] = Array(N);
      }
      for (var i = 0; i < N; i++) {
        var minID = 0;
        var minE = E[0];
        for (var j = 0; j < E.length; j++) {
          if (E[j] < minE) {
            minID = j;
            minE = E[minID];
          }
        }
        Ef[i] = E.splice(minID, 1)[0];
        for (var _k5 = 0; _k5 < N; _k5++) {
          Sf[_k5][i] = S[_k5][minID];
          S[_k5].splice(minID, 1);
        }
      }
      return [clone(Ef), clone(Sf)];
    }
    function createArray(size, value) {
      var array = new Array(size);
      for (var i = 0; i < size; i++) {
        array[i] = value;
      }
      return array;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/expm.js
  var name232 = "expm";
  var dependencies233 = ["typed", "abs", "add", "identity", "inv", "multiply"];
  var createExpm = /* @__PURE__ */ factory(name232, dependencies233, (_ref) => {
    var {
      typed,
      abs,
      add,
      identity,
      inv,
      multiply
    } = _ref;
    return typed(name232, {
      Matrix: function Matrix(A) {
        var size = A.size();
        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        }
        var n = size[0];
        var eps = 1e-15;
        var infNorm = infinityNorm(A);
        var params = findParams(infNorm, eps);
        var q = params.q;
        var j = params.j;
        var Apos = multiply(A, Math.pow(2, -j));
        var N = identity(n);
        var D = identity(n);
        var factor = 1;
        var AposToI = Apos;
        var alternate = -1;
        for (var i = 1; i <= q; i++) {
          if (i > 1) {
            AposToI = multiply(AposToI, Apos);
            alternate = -alternate;
          }
          factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
          N = add(N, multiply(factor, AposToI));
          D = add(D, multiply(factor * alternate, AposToI));
        }
        var R = multiply(inv(D), N);
        for (var _i = 0; _i < j; _i++) {
          R = multiply(R, R);
        }
        return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
      }
    });
    function infinityNorm(A) {
      var n = A.size()[0];
      var infNorm = 0;
      for (var i = 0; i < n; i++) {
        var rowSum = 0;
        for (var j = 0; j < n; j++) {
          rowSum += abs(A.get([i, j]));
        }
        infNorm = Math.max(rowSum, infNorm);
      }
      return infNorm;
    }
    function findParams(infNorm, eps) {
      var maxSearchSize = 30;
      for (var k = 0; k < maxSearchSize; k++) {
        for (var q = 0; q <= k; q++) {
          var j = k - q;
          if (errorEstimate(infNorm, q, j) < eps) {
            return {
              q,
              j
            };
          }
        }
      }
      throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
    }
    function errorEstimate(infNorm, q, j) {
      var qfac = 1;
      for (var i = 2; i <= q; i++) {
        qfac *= i;
      }
      var twoqfac = qfac;
      for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
        twoqfac *= _i2;
      }
      var twoqp1fac = twoqfac * (2 * q + 1);
      return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
  var name233 = "sqrtm";
  var dependencies234 = ["typed", "abs", "add", "multiply", "sqrt", "subtract", "inv", "size", "max", "identity"];
  var createSqrtm = /* @__PURE__ */ factory(name233, dependencies234, (_ref) => {
    var {
      typed,
      abs,
      add,
      multiply,
      sqrt,
      subtract,
      inv,
      size,
      max,
      identity
    } = _ref;
    var _maxIterations = 1e3;
    var _tolerance = 1e-6;
    function _denmanBeavers(A) {
      var error;
      var iterations = 0;
      var Y = A;
      var Z = identity(size(A));
      do {
        var Yk = Y;
        Y = multiply(0.5, add(Yk, inv(Z)));
        Z = multiply(0.5, add(Z, inv(Yk)));
        error = max(abs(subtract(Y, Yk)));
        if (error > _tolerance && ++iterations > _maxIterations) {
          throw new Error("computing square root of matrix: iterative method could not converge");
        }
      } while (error > _tolerance);
      return Y;
    }
    return typed(name233, {
      "Array | Matrix": function ArrayMatrix(A) {
        var size2 = isMatrix(A) ? A.size() : arraySize(A);
        switch (size2.length) {
          case 1:
            if (size2[0] === 1) {
              return sqrt(A);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          case 2: {
            var rows = size2[0];
            var cols = size2[1];
            if (rows === cols) {
              return _denmanBeavers(A);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be at most two dimensional (size: " + format3(size2) + ")");
        }
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/divide.js
  var name234 = "divide";
  var dependencies235 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
  var createDivide = /* @__PURE__ */ factory(name234, dependencies235, (_ref) => {
    var {
      typed,
      matrix,
      multiply,
      equalScalar,
      divideScalar,
      inv
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    return typed("divide", extend({
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
        return multiply(x, inv(y));
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, divideScalar, false);
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, divideScalar, false);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix(x), y, divideScalar, false).valueOf();
      },
      "any, Array | Matrix": function anyArrayMatrix(x, y) {
        return multiply(x, inv(y));
      }
    }, divideScalar.signatures));
  });

  // node_modules/mathjs/lib/esm/function/geometry/distance.js
  var name235 = "distance";
  var dependencies236 = ["typed", "addScalar", "subtract", "divideScalar", "multiplyScalar", "unaryMinus", "sqrt", "abs"];
  var createDistance = /* @__PURE__ */ factory(name235, dependencies236, (_ref) => {
    var {
      typed,
      addScalar,
      subtract,
      multiplyScalar,
      divideScalar,
      unaryMinus,
      sqrt,
      abs
    } = _ref;
    return typed(name235, {
      "Array, Array, Array": function ArrayArrayArray(x, y, z) {
        if (x.length === 2 && y.length === 2 && z.length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
          }
          if (!_2d(y)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
          }
          if (!_2d(z)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
          }
          var m = divideScalar(subtract(z[1], z[0]), subtract(y[1], y[0]));
          var xCoeff = multiplyScalar(multiplyScalar(m, m), y[0]);
          var yCoeff = unaryMinus(multiplyScalar(m, y[0]));
          var constant = x[1];
          return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Object, Object, Object": function ObjectObjectObject(x, y, z) {
        if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
          }
          if (!_2d(y)) {
            throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
          }
          if (!_2d(z)) {
            throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
          }
          if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
            var m = divideScalar(subtract(z.lineTwoPtY, z.lineTwoPtX), subtract(y.lineOnePtY, y.lineOnePtX));
            var xCoeff = multiplyScalar(multiplyScalar(m, m), y.lineOnePtX);
            var yCoeff = unaryMinus(multiplyScalar(m, y.lineOnePtX));
            var constant = x.pointX;
            return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Array, Array": function ArrayArray(x, y) {
        if (x.length === 2 && y.length === 3) {
          if (!_2d(x)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
          }
          if (!_3d(y)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
          }
          return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
        } else if (x.length === 3 && y.length === 6) {
          if (!_3d(x)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
          }
          if (!_parametricLine(y)) {
            throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
          }
          return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
        } else if (x.length === y.length && x.length > 0) {
          if (!_containsOnlyNumbers(x)) {
            throw new TypeError("All values of an array should be numbers or BigNumbers");
          }
          if (!_containsOnlyNumbers(y)) {
            throw new TypeError("All values of an array should be numbers or BigNumbers");
          }
          return _euclideanDistance(x, y);
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Object, Object": function ObjectObject(x, y) {
        if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
          }
          if (!_3d(y)) {
            throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
          }
          if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
            return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
          if (!_3d(x)) {
            throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
          }
          if (!_parametricLine(y)) {
            throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
          }
          if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
            return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
          }
          if (!_2d(y)) {
            throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
          }
          if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
            return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
          if (!_3d(x)) {
            throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
          }
          if (!_3d(y)) {
            throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
          }
          if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
            return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      Array: function Array2(arr) {
        if (!_pairwise(arr)) {
          throw new TypeError("Incorrect array format entered for pairwise distance calculation");
        }
        return _distancePairwise(arr);
      }
    });
    function _isNumber(a) {
      return typeof a === "number" || isBigNumber(a);
    }
    function _2d(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]);
    }
    function _3d(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
    }
    function _containsOnlyNumbers(a) {
      if (!Array.isArray(a)) {
        a = _objectToArray(a);
      }
      return a.every(_isNumber);
    }
    function _parametricLine(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
    }
    function _objectToArray(o) {
      var keys = Object.keys(o);
      var a = [];
      for (var i = 0; i < keys.length; i++) {
        a.push(o[keys[i]]);
      }
      return a;
    }
    function _pairwise(a) {
      if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
        if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
          return false;
        }
      } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
        if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
          return false;
        }
      } else {
        return false;
      }
      return true;
    }
    function _distancePointLine2D(x, y, a, b, c) {
      var num = abs(addScalar(addScalar(multiplyScalar(a, x), multiplyScalar(b, y)), c));
      var den = sqrt(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)));
      return divideScalar(num, den);
    }
    function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
      var num = [subtract(multiplyScalar(subtract(y0, y), c), multiplyScalar(subtract(z0, z), b)), subtract(multiplyScalar(subtract(z0, z), a), multiplyScalar(subtract(x0, x), c)), subtract(multiplyScalar(subtract(x0, x), b), multiplyScalar(subtract(y0, y), a))];
      num = sqrt(addScalar(addScalar(multiplyScalar(num[0], num[0]), multiplyScalar(num[1], num[1])), multiplyScalar(num[2], num[2])));
      var den = sqrt(addScalar(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)), multiplyScalar(c, c)));
      return divideScalar(num, den);
    }
    function _euclideanDistance(x, y) {
      var vectorSize = x.length;
      var result = 0;
      var diff = 0;
      for (var i = 0; i < vectorSize; i++) {
        diff = subtract(x[i], y[i]);
        result = addScalar(multiplyScalar(diff, diff), result);
      }
      return sqrt(result);
    }
    function _distancePairwise(a) {
      var result = [];
      var pointA = [];
      var pointB = [];
      for (var i = 0; i < a.length - 1; i++) {
        for (var j = i + 1; j < a.length; j++) {
          if (a[0].length === 2) {
            pointA = [a[i][0], a[i][1]];
            pointB = [a[j][0], a[j][1]];
          } else if (a[0].length === 3) {
            pointA = [a[i][0], a[i][1], a[i][2]];
            pointB = [a[j][0], a[j][1], a[j][2]];
          }
          result.push(_euclideanDistance(pointA, pointB));
        }
      }
      return result;
    }
  });

  // node_modules/mathjs/lib/esm/function/geometry/intersect.js
  var name236 = "intersect";
  var dependencies237 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar"];
  var createIntersect = /* @__PURE__ */ factory(name236, dependencies237, (_ref) => {
    var {
      typed,
      config,
      abs,
      add,
      addScalar,
      matrix,
      multiply,
      multiplyScalar,
      divideScalar,
      subtract,
      smaller,
      equalScalar
    } = _ref;
    return typed("intersect", {
      "Array, Array, Array": function ArrayArrayArray(x, y, plane) {
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        if (!_4d(plane)) {
          throw new TypeError("Array with 4 numbers expected as third argument");
        }
        return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
      },
      "Array, Array, Array, Array": function ArrayArrayArrayArray(w, x, y, z) {
        if (w.length === 2) {
          if (!_2d(w)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
          }
          if (!_2d(x)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
          }
          if (!_2d(y)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
          }
          if (!_2d(z)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
          }
          return _intersect2d(w, x, y, z);
        } else if (w.length === 3) {
          if (!_3d(w)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
          }
          if (!_3d(x)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
          }
          if (!_3d(y)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
          }
          if (!_3d(z)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
          }
          return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
        } else {
          throw new TypeError("Arrays with two or thee dimensional points expected");
        }
      },
      "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
        return matrix(this(x.valueOf(), y.valueOf(), plane.valueOf()));
      },
      "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z) {
        return matrix(this(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf()));
      }
    });
    function _isNumeric(a) {
      return typeof a === "number" || isBigNumber(a);
    }
    function _2d(x) {
      return x.length === 2 && _isNumeric(x[0]) && _isNumeric(x[1]);
    }
    function _3d(x) {
      return x.length === 3 && _isNumeric(x[0]) && _isNumeric(x[1]) && _isNumeric(x[2]);
    }
    function _4d(x) {
      return x.length === 4 && _isNumeric(x[0]) && _isNumeric(x[1]) && _isNumeric(x[2]) && _isNumeric(x[3]);
    }
    function _intersect2d(p1a, p1b, p2a, p2b) {
      var o1 = p1a;
      var o2 = p2a;
      var d1 = subtract(o1, p1b);
      var d2 = subtract(o2, p2b);
      var det = subtract(multiplyScalar(d1[0], d2[1]), multiplyScalar(d2[0], d1[1]));
      if (smaller(abs(det), config.epsilon)) {
        return null;
      }
      var d20o11 = multiplyScalar(d2[0], o1[1]);
      var d21o10 = multiplyScalar(d2[1], o1[0]);
      var d20o21 = multiplyScalar(d2[0], o2[1]);
      var d21o20 = multiplyScalar(d2[1], o2[0]);
      var t = divideScalar(addScalar(subtract(subtract(d20o11, d21o10), d20o21), d21o20), det);
      return add(multiply(d1, t), o1);
    }
    function _intersect3dHelper(a, b, c, d, e2, f, g, h, i, j, k, l) {
      var add1 = multiplyScalar(subtract(a, b), subtract(c, d));
      var add2 = multiplyScalar(subtract(e2, f), subtract(g, h));
      var add3 = multiplyScalar(subtract(i, j), subtract(k, l));
      return addScalar(addScalar(add1, add2), add3);
    }
    function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
      var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
      var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
      var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
      var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
      var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
      var ta = divideScalar(subtract(multiplyScalar(d1343, d4321), multiplyScalar(d1321, d4343)), subtract(multiplyScalar(d2121, d4343), multiplyScalar(d4321, d4321)));
      var tb = divideScalar(addScalar(d1343, multiplyScalar(ta, d4321)), d4343);
      var pax = addScalar(x1, multiplyScalar(ta, subtract(x2, x1)));
      var pay = addScalar(y1, multiplyScalar(ta, subtract(y2, y1)));
      var paz = addScalar(z1, multiplyScalar(ta, subtract(z2, z1)));
      var pbx = addScalar(x3, multiplyScalar(tb, subtract(x4, x3)));
      var pby = addScalar(y3, multiplyScalar(tb, subtract(y4, y3)));
      var pbz = addScalar(z3, multiplyScalar(tb, subtract(z4, z3)));
      if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
        return [pax, pay, paz];
      } else {
        return null;
      }
    }
    function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
      var x1x = multiplyScalar(x1, x);
      var x2x = multiplyScalar(x2, x);
      var y1y = multiplyScalar(y1, y);
      var y2y = multiplyScalar(y2, y);
      var z1z = multiplyScalar(z1, z);
      var z2z = multiplyScalar(z2, z);
      var t = divideScalar(subtract(subtract(subtract(c, x1x), y1y), z1z), subtract(subtract(subtract(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y), z1z));
      var px = addScalar(x1, multiplyScalar(t, subtract(x2, x1)));
      var py = addScalar(y1, multiplyScalar(t, subtract(y2, y1)));
      var pz = addScalar(z1, multiplyScalar(t, subtract(z2, z1)));
      return [px, py, pz];
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/sum.js
  var name237 = "sum";
  var dependencies238 = ["typed", "config", "add", "numeric"];
  var createSum = /* @__PURE__ */ factory(name237, dependencies238, (_ref) => {
    var {
      typed,
      config,
      add,
      numeric: numeric2
    } = _ref;
    return typed(name237, {
      "Array | Matrix": _sum,
      "Array | Matrix, number | BigNumber": _nsumDim,
      "...": function _4(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function sum");
        }
        return _sum(args);
      }
    });
    function _sum(array) {
      var sum;
      deepForEach(array, function(value) {
        try {
          sum = sum === void 0 ? value : add(sum, value);
        } catch (err) {
          throw improveErrorMessage(err, "sum", value);
        }
      });
      if (sum === void 0) {
        sum = numeric2(0, config.number);
      }
      if (typeof sum === "string") {
        sum = numeric2(sum, config.number);
      }
      return sum;
    }
    function _nsumDim(array, dim) {
      try {
        var sum = reduce(array, dim, add);
        return sum;
      } catch (err) {
        throw improveErrorMessage(err, "sum");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/mean.js
  var name238 = "mean";
  var dependencies239 = ["typed", "add", "divide"];
  var createMean = /* @__PURE__ */ factory(name238, dependencies239, (_ref) => {
    var {
      typed,
      add,
      divide
    } = _ref;
    return typed(name238, {
      "Array | Matrix": _mean,
      "Array | Matrix, number | BigNumber": _nmeanDim,
      "...": function _4(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function mean");
        }
        return _mean(args);
      }
    });
    function _nmeanDim(array, dim) {
      try {
        var sum = reduce(array, dim, add);
        var s = Array.isArray(array) ? arraySize(array) : array.size();
        return divide(sum, s[dim]);
      } catch (err) {
        throw improveErrorMessage(err, "mean");
      }
    }
    function _mean(array) {
      var sum;
      var num = 0;
      deepForEach(array, function(value) {
        try {
          sum = sum === void 0 ? value : add(sum, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, "mean", value);
        }
      });
      if (num === 0) {
        throw new Error("Cannot calculate the mean of an empty array");
      }
      return divide(sum, num);
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/median.js
  var name239 = "median";
  var dependencies240 = ["typed", "add", "divide", "compare", "partitionSelect"];
  var createMedian = /* @__PURE__ */ factory(name239, dependencies240, (_ref) => {
    var {
      typed,
      add,
      divide,
      compare,
      partitionSelect
    } = _ref;
    function _median(array) {
      try {
        array = flatten(array.valueOf());
        var num = array.length;
        if (num === 0) {
          throw new Error("Cannot calculate median of an empty array");
        }
        if (num % 2 === 0) {
          var mid = num / 2 - 1;
          var right = partitionSelect(array, mid + 1);
          var left = array[mid];
          for (var i = 0; i < mid; ++i) {
            if (compare(array[i], left) > 0) {
              left = array[i];
            }
          }
          return middle2(left, right);
        } else {
          var m = partitionSelect(array, (num - 1) / 2);
          return middle(m);
        }
      } catch (err) {
        throw improveErrorMessage(err, "median");
      }
    }
    var middle = typed({
      "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
        return value;
      }
    });
    var middle2 = typed({
      "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
        return divide(add(left, right), 2);
      }
    });
    return typed(name239, {
      "Array | Matrix": _median,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        throw new Error("median(A, dim) is not yet supported");
      },
      "...": function _4(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function median");
        }
        return _median(args);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/statistics/mad.js
  var name240 = "mad";
  var dependencies241 = ["typed", "abs", "map", "median", "subtract"];
  var createMad = /* @__PURE__ */ factory(name240, dependencies241, (_ref) => {
    var {
      typed,
      abs,
      map: map2,
      median,
      subtract
    } = _ref;
    return typed(name240, {
      "Array | Matrix": _mad,
      "...": function _4(args) {
        return _mad(args);
      }
    });
    function _mad(array) {
      array = flatten(array.valueOf());
      if (array.length === 0) {
        throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
      }
      try {
        var med = median(array);
        return median(map2(array, function(value) {
          return abs(subtract(value, med));
        }));
      } catch (err) {
        if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
          throw new TypeError(err.message.replace("median", "mad"));
        } else {
          throw improveErrorMessage(err, "mad");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/variance.js
  var DEFAULT_NORMALIZATION = "unbiased";
  var name241 = "variance";
  var dependencies242 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
  var createVariance = /* @__PURE__ */ factory(name241, dependencies242, (_ref) => {
    var {
      typed,
      add,
      subtract,
      multiply,
      divide,
      apply,
      isNaN: isNaN2
    } = _ref;
    return typed(name241, {
      "Array | Matrix": function ArrayMatrix(array) {
        return _var(array, DEFAULT_NORMALIZATION);
      },
      "Array | Matrix, string": _var,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return _varDim(array, dim, DEFAULT_NORMALIZATION);
      },
      "Array | Matrix, number | BigNumber, string": _varDim,
      "...": function _4(args) {
        return _var(args, DEFAULT_NORMALIZATION);
      }
    });
    function _var(array, normalization) {
      var sum;
      var num = 0;
      if (array.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      deepForEach(array, function(value) {
        try {
          sum = sum === void 0 ? value : add(sum, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, "variance", value);
        }
      });
      if (num === 0)
        throw new Error("Cannot calculate variance of an empty array");
      var mean = divide(sum, num);
      sum = void 0;
      deepForEach(array, function(value) {
        var diff = subtract(value, mean);
        sum = sum === void 0 ? multiply(diff, diff) : add(sum, multiply(diff, diff));
      });
      if (isNaN2(sum)) {
        return sum;
      }
      switch (normalization) {
        case "uncorrected":
          return divide(sum, num);
        case "biased":
          return divide(sum, num + 1);
        case "unbiased": {
          var zero = isBigNumber(sum) ? sum.mul(0) : 0;
          return num === 1 ? zero : divide(sum, num - 1);
        }
        default:
          throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
      }
    }
    function _varDim(array, dim, normalization) {
      try {
        if (array.length === 0) {
          throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
        }
        return apply(array, dim, (x) => _var(x, normalization));
      } catch (err) {
        throw improveErrorMessage(err, "variance");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
  var name242 = "quantileSeq";
  var dependencies243 = ["typed", "add", "multiply", "partitionSelect", "compare"];
  var createQuantileSeq = /* @__PURE__ */ factory(name242, dependencies243, (_ref) => {
    var {
      typed,
      add,
      multiply,
      partitionSelect,
      compare
    } = _ref;
    function quantileSeq(data, probOrN, sorted) {
      var probArr, dataArr, one;
      if (arguments.length < 2 || arguments.length > 3) {
        throw new SyntaxError("Function quantileSeq requires two or three parameters");
      }
      if (isCollection(data)) {
        sorted = sorted || false;
        if (typeof sorted === "boolean") {
          dataArr = data.valueOf();
          if (isNumber(probOrN)) {
            if (probOrN < 0) {
              throw new Error("N/prob must be non-negative");
            }
            if (probOrN <= 1) {
              return _quantileSeq(dataArr, probOrN, sorted);
            }
            if (probOrN > 1) {
              if (!isInteger(probOrN)) {
                throw new Error("N must be a positive integer");
              }
              var nPlusOne = probOrN + 1;
              probArr = new Array(probOrN);
              for (var i = 0; i < probOrN; ) {
                probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);
              }
              return probArr;
            }
          }
          if (isBigNumber(probOrN)) {
            var BigNumber = probOrN.constructor;
            if (probOrN.isNegative()) {
              throw new Error("N/prob must be non-negative");
            }
            one = new BigNumber(1);
            if (probOrN.lte(one)) {
              return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));
            }
            if (probOrN.gt(one)) {
              if (!probOrN.isInteger()) {
                throw new Error("N must be a positive integer");
              }
              var intN = probOrN.toNumber();
              if (intN > 4294967295) {
                throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
              }
              var _nPlusOne = new BigNumber(intN + 1);
              probArr = new Array(intN);
              for (var _i = 0; _i < intN; ) {
                probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));
              }
              return probArr;
            }
          }
          if (Array.isArray(probOrN)) {
            probArr = new Array(probOrN.length);
            for (var _i2 = 0; _i2 < probArr.length; ++_i2) {
              var currProb = probOrN[_i2];
              if (isNumber(currProb)) {
                if (currProb < 0 || currProb > 1) {
                  throw new Error("Probability must be between 0 and 1, inclusive");
                }
              } else if (isBigNumber(currProb)) {
                one = new currProb.constructor(1);
                if (currProb.isNegative() || currProb.gt(one)) {
                  throw new Error("Probability must be between 0 and 1, inclusive");
                }
              } else {
                throw new TypeError("Unexpected type of argument in function quantileSeq");
              }
              probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);
            }
            return probArr;
          }
          throw new TypeError("Unexpected type of argument in function quantileSeq");
        }
        throw new TypeError("Unexpected type of argument in function quantileSeq");
      }
      throw new TypeError("Unexpected type of argument in function quantileSeq");
    }
    function _quantileSeq(array, prob, sorted) {
      var flat = flatten(array);
      var len = flat.length;
      if (len === 0) {
        throw new Error("Cannot calculate quantile of an empty sequence");
      }
      if (isNumber(prob)) {
        var _index = prob * (len - 1);
        var _fracPart = _index % 1;
        if (_fracPart === 0) {
          var value = sorted ? flat[_index] : partitionSelect(flat, _index);
          validate2(value);
          return value;
        }
        var _integerPart = Math.floor(_index);
        var _left;
        var _right;
        if (sorted) {
          _left = flat[_integerPart];
          _right = flat[_integerPart + 1];
        } else {
          _right = partitionSelect(flat, _integerPart + 1);
          _left = flat[_integerPart];
          for (var i = 0; i < _integerPart; ++i) {
            if (compare(flat[i], _left) > 0) {
              _left = flat[i];
            }
          }
        }
        validate2(_left);
        validate2(_right);
        return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));
      }
      var index = prob.times(len - 1);
      if (index.isInteger()) {
        index = index.toNumber();
        var _value = sorted ? flat[index] : partitionSelect(flat, index);
        validate2(_value);
        return _value;
      }
      var integerPart = index.floor();
      var fracPart = index.minus(integerPart);
      var integerPartNumber = integerPart.toNumber();
      var left;
      var right;
      if (sorted) {
        left = flat[integerPartNumber];
        right = flat[integerPartNumber + 1];
      } else {
        right = partitionSelect(flat, integerPartNumber + 1);
        left = flat[integerPartNumber];
        for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {
          if (compare(flat[_i3], left) > 0) {
            left = flat[_i3];
          }
        }
      }
      validate2(left);
      validate2(right);
      var one = new fracPart.constructor(1);
      return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));
    }
    var validate2 = typed({
      "number | BigNumber | Unit": function numberBigNumberUnit(x) {
        return x;
      }
    });
    return quantileSeq;
  });

  // node_modules/mathjs/lib/esm/function/statistics/std.js
  var name243 = "std";
  var dependencies244 = ["typed", "sqrt", "variance"];
  var createStd = /* @__PURE__ */ factory(name243, dependencies244, (_ref) => {
    var {
      typed,
      sqrt,
      variance
    } = _ref;
    return typed(name243, {
      "Array | Matrix": _std,
      "Array | Matrix, string": _std,
      "Array | Matrix, number | BigNumber": _std,
      "Array | Matrix, number | BigNumber, string": _std,
      "...": function _4(args) {
        return _std(args);
      }
    });
    function _std(array, normalization) {
      if (array.length === 0) {
        throw new SyntaxError("Function std requires one or more parameters (0 provided)");
      }
      try {
        return sqrt(variance.apply(null, arguments));
      } catch (err) {
        if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
          throw new TypeError(err.message.replace(" variance", " std"));
        } else {
          throw err;
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/combinations.js
  var name244 = "combinations";
  var dependencies245 = ["typed"];
  var createCombinations = /* @__PURE__ */ factory(name244, dependencies245, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name244, {
      "number, number": combinationsNumber,
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var BigNumber = n.constructor;
        var result, i;
        var nMinusk = n.minus(k);
        var one = new BigNumber(1);
        if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
          throw new TypeError("Positive integer value expected in function combinations");
        }
        if (k.gt(n)) {
          throw new TypeError("k must be less than n in function combinations");
        }
        result = one;
        if (k.lt(nMinusk)) {
          for (i = one; i.lte(nMinusk); i = i.plus(one)) {
            result = result.times(k.plus(i)).dividedBy(i);
          }
        } else {
          for (i = one; i.lte(k); i = i.plus(one)) {
            result = result.times(nMinusk.plus(i)).dividedBy(i);
          }
        }
        return result;
      }
    });
  });
  function isPositiveInteger(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
  var name245 = "combinationsWithRep";
  var dependencies246 = ["typed"];
  var createCombinationsWithRep = /* @__PURE__ */ factory(name245, dependencies246, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name245, {
      "number, number": function numberNumber2(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (!isInteger(k) || k < 0) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (n < 1) {
          throw new TypeError("k must be less than or equal to n + k - 1");
        }
        if (k < n - 1) {
          var _prodrange = product2(n, n + k - 1);
          return _prodrange / product2(1, k);
        }
        var prodrange = product2(k + 1, n + k - 1);
        return prodrange / product2(1, n - 1);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var BigNumber = n.constructor;
        var result, i;
        var one = new BigNumber(1);
        var nMinusOne = n.minus(one);
        if (!isPositiveInteger2(n) || !isPositiveInteger2(k)) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (n.lt(one)) {
          throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
        }
        result = one;
        if (k.lt(nMinusOne)) {
          for (i = one; i.lte(nMinusOne); i = i.plus(one)) {
            result = result.times(k.plus(i)).dividedBy(i);
          }
        } else {
          for (i = one; i.lte(k); i = i.plus(one)) {
            result = result.times(nMinusOne.plus(i)).dividedBy(i);
          }
        }
        return result;
      }
    });
  });
  function isPositiveInteger2(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/gamma.js
  var name246 = "gamma";
  var dependencies247 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
  var createGamma = /* @__PURE__ */ factory(name246, dependencies247, (_ref) => {
    var {
      typed,
      config,
      multiplyScalar,
      pow,
      BigNumber: _BigNumber,
      Complex: _Complex
    } = _ref;
    return typed(name246, {
      number: gammaNumber,
      Complex: function Complex2(n) {
        if (n.im === 0) {
          return this(n.re);
        }
        n = new _Complex(n.re - 1, n.im);
        var x = new _Complex(gammaP[0], 0);
        for (var i = 1; i < gammaP.length; ++i) {
          var real = n.re + i;
          var den = real * real + n.im * n.im;
          if (den !== 0) {
            x.re += gammaP[i] * real / den;
            x.im += -(gammaP[i] * n.im) / den;
          } else {
            x.re = gammaP[i] < 0 ? -Infinity : Infinity;
          }
        }
        var t = new _Complex(n.re + gammaG + 0.5, n.im);
        var twoPiSqrt = Math.sqrt(2 * Math.PI);
        n.re += 0.5;
        var result = pow(t, n);
        if (result.im === 0) {
          result.re *= twoPiSqrt;
        } else if (result.re === 0) {
          result.im *= twoPiSqrt;
        } else {
          result.re *= twoPiSqrt;
          result.im *= twoPiSqrt;
        }
        var r = Math.exp(-t.re);
        t.re = r * Math.cos(-t.im);
        t.im = r * Math.sin(-t.im);
        return multiplyScalar(multiplyScalar(result, t), x);
      },
      BigNumber: function BigNumber(n) {
        if (n.isInteger()) {
          return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
        }
        if (!n.isFinite()) {
          return new _BigNumber(n.isNegative() ? NaN : Infinity);
        }
        throw new Error("Integer BigNumber expected");
      },
      "Array | Matrix": function ArrayMatrix(n) {
        return deepMap(n, this);
      }
    });
    function bigFactorial(n) {
      if (n < 8) {
        return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
      }
      var precision = config.precision + (Math.log(n.toNumber()) | 0);
      var Big = _BigNumber.clone({
        precision
      });
      if (n % 2 === 1) {
        return n.times(bigFactorial(new _BigNumber(n - 1)));
      }
      var p = n;
      var prod = new Big(n);
      var sum = n.toNumber();
      while (p > 2) {
        p -= 2;
        sum += p;
        prod = prod.times(sum);
      }
      return new _BigNumber(prod.toPrecision(_BigNumber.precision));
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/factorial.js
  var name247 = "factorial";
  var dependencies248 = ["typed", "gamma"];
  var createFactorial = /* @__PURE__ */ factory(name247, dependencies248, (_ref) => {
    var {
      typed,
      gamma
    } = _ref;
    return typed(name247, {
      number: function number(n) {
        if (n < 0) {
          throw new Error("Value must be non-negative");
        }
        return gamma(n + 1);
      },
      BigNumber: function BigNumber(n) {
        if (n.isNegative()) {
          throw new Error("Value must be non-negative");
        }
        return gamma(n.plus(1));
      },
      "Array | Matrix": function ArrayMatrix(n) {
        return deepMap(n, this);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/probability/kldivergence.js
  var name248 = "kldivergence";
  var dependencies249 = ["typed", "matrix", "divide", "sum", "multiply", "dotDivide", "log", "isNumeric"];
  var createKldivergence = /* @__PURE__ */ factory(name248, dependencies249, (_ref) => {
    var {
      typed,
      matrix,
      divide,
      sum,
      multiply,
      dotDivide,
      log,
      isNumeric
    } = _ref;
    return typed(name248, {
      "Array, Array": function ArrayArray(q, p) {
        return _kldiv(matrix(q), matrix(p));
      },
      "Matrix, Array": function MatrixArray(q, p) {
        return _kldiv(q, matrix(p));
      },
      "Array, Matrix": function ArrayMatrix(q, p) {
        return _kldiv(matrix(q), p);
      },
      "Matrix, Matrix": function MatrixMatrix(q, p) {
        return _kldiv(q, p);
      }
    });
    function _kldiv(q, p) {
      var plength = p.size().length;
      var qlength = q.size().length;
      if (plength > 1) {
        throw new Error("first object must be one dimensional");
      }
      if (qlength > 1) {
        throw new Error("second object must be one dimensional");
      }
      if (plength !== qlength) {
        throw new Error("Length of two vectors must be equal");
      }
      var sumq = sum(q);
      if (sumq === 0) {
        throw new Error("Sum of elements in first object must be non zero");
      }
      var sump = sum(p);
      if (sump === 0) {
        throw new Error("Sum of elements in second object must be non zero");
      }
      var qnorm = divide(q, sum(q));
      var pnorm = divide(p, sum(p));
      var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));
      if (isNumeric(result)) {
        return result;
      } else {
        return Number.NaN;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/multinomial.js
  var name249 = "multinomial";
  var dependencies250 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
  var createMultinomial = /* @__PURE__ */ factory(name249, dependencies250, (_ref) => {
    var {
      typed,
      add,
      divide,
      multiply,
      factorial,
      isInteger: isInteger2,
      isPositive
    } = _ref;
    return typed(name249, {
      "Array | Matrix": function ArrayMatrix(a) {
        var sum = 0;
        var denom = 1;
        deepForEach(a, function(ai) {
          if (!isInteger2(ai) || !isPositive(ai)) {
            throw new TypeError("Positive integer value expected in function multinomial");
          }
          sum = add(sum, ai);
          denom = multiply(denom, factorial(ai));
        });
        return divide(factorial(sum), denom);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/probability/permutations.js
  var name250 = "permutations";
  var dependencies251 = ["typed", "factorial"];
  var createPermutations = /* @__PURE__ */ factory(name250, dependencies251, (_ref) => {
    var {
      typed,
      factorial
    } = _ref;
    return typed(name250, {
      "number | BigNumber": factorial,
      "number, number": function numberNumber2(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (!isInteger(k) || k < 0) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (k > n) {
          throw new TypeError("second argument k must be less than or equal to first argument n");
        }
        return product2(n - k + 1, n);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var result, i;
        if (!isPositiveInteger3(n) || !isPositiveInteger3(k)) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (k.gt(n)) {
          throw new TypeError("second argument k must be less than or equal to first argument n");
        }
        var one = n.mul(0).add(1);
        result = one;
        for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
          result = result.times(i);
        }
        return result;
      }
    });
  });
  function isPositiveInteger3(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
  var import_seedrandom = __toModule(require_seedrandom2());
  var singletonRandom = /* @__PURE__ */ (0, import_seedrandom.default)(Date.now());
  function createRng(randomSeed) {
    var random;
    function setSeed(seed) {
      random = seed === null ? singletonRandom : (0, import_seedrandom.default)(String(seed));
    }
    setSeed(randomSeed);
    function rng() {
      return random();
    }
    return rng;
  }

  // node_modules/mathjs/lib/esm/function/probability/pickRandom.js
  var name251 = "pickRandom";
  var dependencies252 = ["typed", "config", "?on"];
  var createPickRandom = /* @__PURE__ */ factory(name251, dependencies252, (_ref) => {
    var {
      typed,
      config,
      on
    } = _ref;
    var rng = createRng(config.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed({
      "Array | Matrix": function ArrayMatrix(possibles) {
        return _pickRandom(possibles, {});
      },
      "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
        return _pickRandom(possibles, options);
      },
      "Array | Matrix, number": function ArrayMatrixNumber(possibles, number) {
        return _pickRandom(possibles, {
          number
        });
      },
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
        return _pickRandom(possibles, {
          weights
        });
      },
      "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number) {
        return _pickRandom(possibles, {
          number,
          weights
        });
      },
      "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number, weights) {
        return _pickRandom(possibles, {
          number,
          weights
        });
      }
    });
    function _pickRandom(possibles, _ref2) {
      var {
        number,
        weights,
        elementWise = true
      } = _ref2;
      var single = typeof number === "undefined";
      if (single) {
        number = 1;
      }
      var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
      possibles = possibles.valueOf();
      if (weights) {
        weights = weights.valueOf();
      }
      if (elementWise === true) {
        possibles = flatten(possibles);
        weights = flatten(weights);
      }
      var totalWeights = 0;
      if (typeof weights !== "undefined") {
        if (weights.length !== possibles.length) {
          throw new Error("Weights must have the same length as possibles");
        }
        for (var i = 0, len = weights.length; i < len; i++) {
          if (!isNumber(weights[i]) || weights[i] < 0) {
            throw new Error("Weights must be an array of positive numbers");
          }
          totalWeights += weights[i];
        }
      }
      var length = possibles.length;
      var result = [];
      var pick;
      while (result.length < number) {
        if (typeof weights === "undefined") {
          pick = possibles[Math.floor(rng() * length)];
        } else {
          var randKey = rng() * totalWeights;
          for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
            randKey -= weights[_i];
            if (randKey < 0) {
              pick = possibles[_i];
              break;
            }
          }
        }
        result.push(pick);
      }
      return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
  function randomMatrix(size, random) {
    var data = [];
    size = size.slice(0);
    if (size.length > 1) {
      for (var i = 0, length = size.shift(); i < length; i++) {
        data.push(randomMatrix(size, random));
      }
    } else {
      for (var _i = 0, _length = size.shift(); _i < _length; _i++) {
        data.push(random());
      }
    }
    return data;
  }

  // node_modules/mathjs/lib/esm/function/probability/random.js
  var name252 = "random";
  var dependencies253 = ["typed", "config", "?on"];
  var createRandom = /* @__PURE__ */ factory(name252, dependencies253, (_ref) => {
    var {
      typed,
      config,
      on
    } = _ref;
    var rng = createRng(config.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed(name252, {
      "": () => _random(0, 1),
      number: (max) => _random(0, max),
      "number, number": (min, max) => _random(min, max),
      "Array | Matrix": (size) => _randomMatrix(size, 0, 1),
      "Array | Matrix, number": (size, max) => _randomMatrix(size, 0, max),
      "Array | Matrix, number, number": (size, min, max) => _randomMatrix(size, min, max)
    });
    function _randomMatrix(size, min, max) {
      var res = randomMatrix(size.valueOf(), () => _random(min, max));
      return isMatrix(size) ? size.create(res) : res;
    }
    function _random(min, max) {
      return min + rng() * (max - min);
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/randomInt.js
  var name253 = "randomInt";
  var dependencies254 = ["typed", "config", "?on"];
  var createRandomInt = /* @__PURE__ */ factory(name253, dependencies254, (_ref) => {
    var {
      typed,
      config,
      on
    } = _ref;
    var rng = createRng(config.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed(name253, {
      "": () => _randomInt(0, 1),
      number: (max) => _randomInt(0, max),
      "number, number": (min, max) => _randomInt(min, max),
      "Array | Matrix": (size) => _randomIntMatrix(size, 0, 1),
      "Array | Matrix, number": (size, max) => _randomIntMatrix(size, 0, max),
      "Array | Matrix, number, number": (size, min, max) => _randomIntMatrix(size, min, max)
    });
    function _randomIntMatrix(size, min, max) {
      var res = randomMatrix(size.valueOf(), () => _randomInt(min, max));
      return isMatrix(size) ? size.create(res) : res;
    }
    function _randomInt(min, max) {
      return Math.floor(min + rng() * (max - min));
    }
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
  var name254 = "stirlingS2";
  var dependencies255 = ["typed", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "larger"];
  var createStirlingS2 = /* @__PURE__ */ factory(name254, dependencies255, (_ref) => {
    var {
      typed,
      addScalar,
      subtract,
      multiplyScalar,
      divideScalar,
      pow,
      factorial,
      combinations,
      isNegative,
      isInteger: isInteger2,
      larger
    } = _ref;
    return typed(name254, {
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
        if (!isInteger2(n) || isNegative(n) || !isInteger2(k) || isNegative(k)) {
          throw new TypeError("Non-negative integer value expected in function stirlingS2");
        } else if (larger(k, n)) {
          throw new TypeError("k must be less than or equal to n in function stirlingS2");
        }
        var kFactorial = factorial(k);
        var result = 0;
        for (var i = 0; i <= k; i++) {
          var negativeOne = pow(-1, subtract(k, i));
          var kChooseI = combinations(k, i);
          var iPower = pow(i, n);
          result = addScalar(result, multiplyScalar(multiplyScalar(kChooseI, iPower), negativeOne));
        }
        return divideScalar(result, kFactorial);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
  var name255 = "bellNumbers";
  var dependencies256 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
  var createBellNumbers = /* @__PURE__ */ factory(name255, dependencies256, (_ref) => {
    var {
      typed,
      addScalar,
      isNegative,
      isInteger: isInteger2,
      stirlingS2
    } = _ref;
    return typed(name255, {
      "number | BigNumber": function numberBigNumber(n) {
        if (!isInteger2(n) || isNegative(n)) {
          throw new TypeError("Non-negative integer value expected in function bellNumbers");
        }
        var result = 0;
        for (var i = 0; i <= n; i++) {
          result = addScalar(result, stirlingS2(n, i));
        }
        return result;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
  var name256 = "catalan";
  var dependencies257 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
  var createCatalan = /* @__PURE__ */ factory(name256, dependencies257, (_ref) => {
    var {
      typed,
      addScalar,
      divideScalar,
      multiplyScalar,
      combinations,
      isNegative,
      isInteger: isInteger2
    } = _ref;
    return typed(name256, {
      "number | BigNumber": function numberBigNumber(n) {
        if (!isInteger2(n) || isNegative(n)) {
          throw new TypeError("Non-negative integer value expected in function catalan");
        }
        return divideScalar(combinations(multiplyScalar(n, 2), n), addScalar(n, 1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/composition.js
  var name257 = "composition";
  var dependencies258 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
  var createComposition = /* @__PURE__ */ factory(name257, dependencies258, (_ref) => {
    var {
      typed,
      addScalar,
      combinations,
      isPositive,
      isNegative,
      isInteger: isInteger2,
      larger
    } = _ref;
    return typed(name257, {
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
        if (!isInteger2(n) || !isPositive(n) || !isInteger2(k) || !isPositive(k)) {
          throw new TypeError("Positive integer value expected in function composition");
        } else if (larger(k, n)) {
          throw new TypeError("k must be less than or equal to n in function composition");
        }
        return combinations(addScalar(n, -1), addScalar(k, -1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
  var name258 = "simplifyUtil";
  var dependencies259 = ["FunctionNode", "OperatorNode", "SymbolNode"];
  var createUtil = /* @__PURE__ */ factory(name258, dependencies259, (_ref) => {
    var {
      FunctionNode,
      OperatorNode,
      SymbolNode
    } = _ref;
    var commutative = {
      add: true,
      multiply: true
    };
    var associative = {
      add: true,
      multiply: true
    };
    function isCommutative(node, context) {
      if (!isOperatorNode(node)) {
        return true;
      }
      var name284 = node.fn.toString();
      if (context && hasOwnProperty2(context, name284) && hasOwnProperty2(context[name284], "commutative")) {
        return context[name284].commutative;
      }
      return commutative[name284] || false;
    }
    function isAssociative(node, context) {
      if (!isOperatorNode(node)) {
        return false;
      }
      var name284 = node.fn.toString();
      if (context && hasOwnProperty2(context, name284) && hasOwnProperty2(context[name284], "associative")) {
        return context[name284].associative;
      }
      return associative[name284] || false;
    }
    function flatten2(node) {
      if (!node.args || node.args.length === 0) {
        return node;
      }
      node.args = allChildren(node);
      for (var i = 0; i < node.args.length; i++) {
        flatten2(node.args[i]);
      }
    }
    function allChildren(node) {
      var op;
      var children = [];
      var findChildren = function findChildren2(node2) {
        for (var i = 0; i < node2.args.length; i++) {
          var child = node2.args[i];
          if (isOperatorNode(child) && op === child.op) {
            findChildren2(child);
          } else {
            children.push(child);
          }
        }
      };
      if (isAssociative(node)) {
        op = node.op;
        findChildren(node);
        return children;
      } else {
        return node.args;
      }
    }
    function unflattenr(node) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      var makeNode = createMakeNodeFunction(node);
      var l = node.args.length;
      for (var i = 0; i < l; i++) {
        unflattenr(node.args[i]);
      }
      if (l > 2 && isAssociative(node)) {
        var curnode = node.args.pop();
        while (node.args.length > 0) {
          curnode = makeNode([node.args.pop(), curnode]);
        }
        node.args = curnode.args;
      }
    }
    function unflattenl(node) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      var makeNode = createMakeNodeFunction(node);
      var l = node.args.length;
      for (var i = 0; i < l; i++) {
        unflattenl(node.args[i]);
      }
      if (l > 2 && isAssociative(node)) {
        var curnode = node.args.shift();
        while (node.args.length > 0) {
          curnode = makeNode([curnode, node.args.shift()]);
        }
        node.args = curnode.args;
      }
    }
    function createMakeNodeFunction(node) {
      if (isOperatorNode(node)) {
        return function(args) {
          try {
            return new OperatorNode(node.op, node.fn, args, node.implicit);
          } catch (err) {
            console.error(err);
            return [];
          }
        };
      } else {
        return function(args) {
          return new FunctionNode(new SymbolNode(node.name), args);
        };
      }
    }
    return {
      createMakeNodeFunction,
      isCommutative,
      isAssociative,
      flatten: flatten2,
      allChildren,
      unflattenr,
      unflattenl
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyCore.js
  var name259 = "simplifyCore";
  var dependencies260 = ["equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "ConstantNode", "OperatorNode", "FunctionNode", "ParenthesisNode"];
  var createSimplifyCore = /* @__PURE__ */ factory(name259, dependencies260, (_ref) => {
    var {
      equal,
      isZero,
      add,
      subtract,
      multiply,
      divide,
      pow,
      ConstantNode,
      OperatorNode,
      FunctionNode,
      ParenthesisNode
    } = _ref;
    var node0 = new ConstantNode(0);
    var node1 = new ConstantNode(1);
    function simplifyCore(node) {
      if (isOperatorNode(node) && node.isUnary()) {
        var a0 = simplifyCore(node.args[0]);
        if (node.op === "+") {
          return a0;
        }
        if (node.op === "-") {
          if (isOperatorNode(a0)) {
            if (a0.isUnary() && a0.op === "-") {
              return a0.args[0];
            } else if (a0.isBinary() && a0.fn === "subtract") {
              return new OperatorNode("-", "subtract", [a0.args[1], a0.args[0]]);
            }
          }
          return new OperatorNode(node.op, node.fn, [a0]);
        }
      } else if (isOperatorNode(node) && node.isBinary()) {
        var _a = simplifyCore(node.args[0]);
        var a1 = simplifyCore(node.args[1]);
        if (node.op === "+") {
          if (isConstantNode(_a)) {
            if (isZero(_a.value)) {
              return a1;
            } else if (isConstantNode(a1)) {
              return new ConstantNode(add(_a.value, a1.value));
            }
          }
          if (isConstantNode(a1) && isZero(a1.value)) {
            return _a;
          }
          if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
            return new OperatorNode("-", "subtract", [_a, a1.args[0]]);
          }
          return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);
        } else if (node.op === "-") {
          if (isConstantNode(_a) && a1) {
            if (isConstantNode(a1)) {
              return new ConstantNode(subtract(_a.value, a1.value));
            } else if (isZero(_a.value)) {
              return new OperatorNode("-", "unaryMinus", [a1]);
            }
          }
          if (node.fn === "subtract") {
            if (isConstantNode(a1) && isZero(a1.value)) {
              return _a;
            }
            if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
              return simplifyCore(new OperatorNode("+", "add", [_a, a1.args[0]]));
            }
            return new OperatorNode(node.op, node.fn, [_a, a1]);
          }
        } else if (node.op === "*") {
          if (isConstantNode(_a)) {
            if (isZero(_a.value)) {
              return node0;
            } else if (equal(_a.value, 1)) {
              return a1;
            } else if (isConstantNode(a1)) {
              return new ConstantNode(multiply(_a.value, a1.value));
            }
          }
          if (isConstantNode(a1)) {
            if (isZero(a1.value)) {
              return node0;
            } else if (equal(a1.value, 1)) {
              return _a;
            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {
              var a00 = _a.args[0];
              if (isConstantNode(a00)) {
                var a00a1 = new ConstantNode(multiply(a00.value, a1.value));
                return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit);
              }
            }
            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit);
          }
          return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);
        } else if (node.op === "/") {
          if (isConstantNode(_a)) {
            if (isZero(_a.value)) {
              return node0;
            } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {
              return new ConstantNode(divide(_a.value, a1.value));
            }
          }
          return new OperatorNode(node.op, node.fn, [_a, a1]);
        } else if (node.op === "^") {
          if (isConstantNode(a1)) {
            if (isZero(a1.value)) {
              return node1;
            } else if (equal(a1.value, 1)) {
              return _a;
            } else {
              if (isConstantNode(_a)) {
                return new ConstantNode(pow(_a.value, a1.value));
              } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === "^") {
                var a01 = _a.args[1];
                if (isConstantNode(a01)) {
                  return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);
                }
              }
            }
          }
          return new OperatorNode(node.op, node.fn, [_a, a1]);
        }
      } else if (isParenthesisNode(node)) {
        var c = simplifyCore(node.content);
        if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {
          return c;
        }
        return new ParenthesisNode(c);
      } else if (isFunctionNode(node)) {
        var args = node.args.map(simplifyCore).map(function(arg) {
          return isParenthesisNode(arg) ? arg.content : arg;
        });
        return new FunctionNode(simplifyCore(node.fn), args);
      } else {
      }
      return node;
    }
    return simplifyCore;
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyConstant.js
  var name260 = "simplifyConstant";
  var dependencies261 = ["typed", "config", "mathWithTransform", "?fraction", "?bignumber", "ConstantNode", "OperatorNode", "FunctionNode", "SymbolNode"];
  var createSimplifyConstant = /* @__PURE__ */ factory(name260, dependencies261, (_ref) => {
    var {
      typed,
      config,
      mathWithTransform,
      fraction,
      bignumber,
      ConstantNode,
      OperatorNode,
      FunctionNode,
      SymbolNode
    } = _ref;
    var {
      isCommutative,
      isAssociative,
      allChildren,
      createMakeNodeFunction
    } = createUtil({
      FunctionNode,
      OperatorNode,
      SymbolNode
    });
    function simplifyConstant(expr, options) {
      var res = foldFraction(expr, options);
      return isNode(res) ? res : _toNode(res);
    }
    function _eval(fnname, args, options) {
      try {
        return _toNumber(mathWithTransform[fnname].apply(null, args), options);
      } catch (ignore) {
        args = args.map(function(x) {
          if (isFraction(x)) {
            return x.valueOf();
          }
          return x;
        });
        return _toNumber(mathWithTransform[fnname].apply(null, args), options);
      }
    }
    var _toNode = typed({
      Fraction: _fractionToNode,
      number: function number(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode(-n));
        }
        return new ConstantNode(n);
      },
      BigNumber: function BigNumber(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode(-n));
        }
        return new ConstantNode(n);
      },
      Complex: function Complex2(s) {
        throw new Error("Cannot convert Complex number to Node");
      }
    });
    function _exactFraction(n, options) {
      var exactFractions = options && options.exactFractions !== false;
      if (exactFractions && isFinite(n) && fraction) {
        var f = fraction(n);
        var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
        if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
          return f;
        }
      }
      return n;
    }
    var _toNumber = typed({
      "string, Object": function stringObject(s, options) {
        if (config.number === "BigNumber") {
          if (bignumber === void 0) {
            noBignumber();
          }
          return bignumber(s);
        } else if (config.number === "Fraction") {
          if (fraction === void 0) {
            noFraction();
          }
          return fraction(s);
        } else {
          var n = parseFloat(s);
          return _exactFraction(n, options);
        }
      },
      "Fraction, Object": function FractionObject(s, options) {
        return s;
      },
      "BigNumber, Object": function BigNumberObject(s, options) {
        return s;
      },
      "number, Object": function numberObject(s, options) {
        return _exactFraction(s, options);
      },
      "Complex, Object": function ComplexObject(s, options) {
        if (s.im !== 0) {
          return s;
        }
        return _exactFraction(s.re, options);
      }
    });
    function unaryMinusNode(n) {
      return new OperatorNode("-", "unaryMinus", [n]);
    }
    function _fractionToNode(f) {
      var n;
      var vn = f.s * f.n;
      if (vn < 0) {
        n = new OperatorNode("-", "unaryMinus", [new ConstantNode(-vn)]);
      } else {
        n = new ConstantNode(vn);
      }
      if (f.d === 1) {
        return n;
      }
      return new OperatorNode("/", "divide", [n, new ConstantNode(f.d)]);
    }
    function foldOp(fn, args, makeNode, options) {
      return args.reduce(function(a, b) {
        if (!isNode(a) && !isNode(b)) {
          try {
            return _eval(fn, [a, b], options);
          } catch (ignoreandcontinue) {
          }
          a = _toNode(a);
          b = _toNode(b);
        } else if (!isNode(a)) {
          a = _toNode(a);
        } else if (!isNode(b)) {
          b = _toNode(b);
        }
        return makeNode([a, b]);
      });
    }
    function foldFraction(node, options) {
      switch (node.type) {
        case "SymbolNode":
          return node;
        case "ConstantNode":
          if (typeof node.value === "number" || !isNaN(node.value)) {
            return _toNumber(node.value, options);
          }
          return node;
        case "FunctionNode":
          if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
            return node;
          }
          {
            var operatorFunctions = ["add", "multiply"];
            if (operatorFunctions.indexOf(node.name) === -1) {
              var args = node.args.map((arg) => foldFraction(arg, options));
              if (!args.some(isNode)) {
                try {
                  return _eval(node.name, args, options);
                } catch (ignoreandcontine) {
                }
              }
              args = args.map(function(arg) {
                return isNode(arg) ? arg : _toNode(arg);
              });
              return new FunctionNode(node.name, args);
            } else {
            }
          }
        case "OperatorNode": {
          var fn = node.fn.toString();
          var _args;
          var res;
          var makeNode = createMakeNodeFunction(node);
          if (isOperatorNode(node) && node.isUnary()) {
            _args = [foldFraction(node.args[0], options)];
            if (!isNode(_args[0])) {
              res = _eval(fn, _args, options);
            } else {
              res = makeNode(_args);
            }
          } else if (isAssociative(node)) {
            _args = allChildren(node);
            _args = _args.map((arg) => foldFraction(arg, options));
            if (isCommutative(fn)) {
              var consts = [];
              var vars = [];
              for (var i = 0; i < _args.length; i++) {
                if (!isNode(_args[i])) {
                  consts.push(_args[i]);
                } else {
                  vars.push(_args[i]);
                }
              }
              if (consts.length > 1) {
                res = foldOp(fn, consts, makeNode, options);
                vars.unshift(res);
                res = foldOp(fn, vars, makeNode, options);
              } else {
                res = foldOp(fn, _args, makeNode, options);
              }
            } else {
              res = foldOp(fn, _args, makeNode, options);
            }
          } else {
            _args = node.args.map((arg) => foldFraction(arg, options));
            res = foldOp(fn, _args, makeNode, options);
          }
          return res;
        }
        case "ParenthesisNode":
          return foldFraction(node.content, options);
        case "AccessorNode":
        case "ArrayNode":
        case "AssignmentNode":
        case "BlockNode":
        case "FunctionAssignmentNode":
        case "IndexNode":
        case "ObjectNode":
        case "RangeNode":
        case "ConditionalNode":
        default:
          throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
      }
    }
    return simplifyConstant;
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify/resolve.js
  var name261 = "resolve";
  var dependencies262 = ["parse", "FunctionNode", "OperatorNode", "ParenthesisNode"];
  var createResolve = /* @__PURE__ */ factory(name261, dependencies262, (_ref) => {
    var {
      parse,
      FunctionNode,
      OperatorNode,
      ParenthesisNode
    } = _ref;
    function resolve(node, scope) {
      if (!scope) {
        return node;
      }
      if (isSymbolNode(node)) {
        var value = scope[node.name];
        if (isNode(value)) {
          return resolve(value, scope);
        } else if (typeof value === "number") {
          return parse(String(value));
        }
      } else if (isOperatorNode(node)) {
        var args = node.args.map(function(arg) {
          return resolve(arg, scope);
        });
        return new OperatorNode(node.op, node.fn, args, node.implicit);
      } else if (isParenthesisNode(node)) {
        return new ParenthesisNode(resolve(node.content, scope));
      } else if (isFunctionNode(node)) {
        var _args = node.args.map(function(arg) {
          return resolve(arg, scope);
        });
        return new FunctionNode(node.name, _args);
      }
      return node;
    }
    return resolve;
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify.js
  var name262 = "simplify";
  var dependencies263 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "?fraction", "?bignumber", "mathWithTransform", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
  var createSimplify = /* @__PURE__ */ factory(name262, dependencies263, (_ref) => {
    var {
      config,
      typed,
      parse,
      add,
      subtract,
      multiply,
      divide,
      pow,
      isZero,
      equal,
      fraction,
      bignumber,
      mathWithTransform,
      ConstantNode,
      FunctionNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode
    } = _ref;
    var simplifyConstant = createSimplifyConstant({
      typed,
      config,
      mathWithTransform,
      fraction,
      bignumber,
      ConstantNode,
      OperatorNode,
      FunctionNode,
      SymbolNode
    });
    var simplifyCore = createSimplifyCore({
      equal,
      isZero,
      add,
      subtract,
      multiply,
      divide,
      pow,
      ConstantNode,
      OperatorNode,
      FunctionNode,
      ParenthesisNode
    });
    var resolve = createResolve({
      parse,
      FunctionNode,
      OperatorNode,
      ParenthesisNode
    });
    var {
      isCommutative,
      isAssociative,
      flatten: flatten2,
      unflattenr,
      unflattenl,
      createMakeNodeFunction
    } = createUtil({
      FunctionNode,
      OperatorNode,
      SymbolNode
    });
    var simplify = typed("simplify", {
      string: function string(expr) {
        return this(parse(expr), this.rules, {}, {});
      },
      "string, Object": function stringObject(expr, scope) {
        return this(parse(expr), this.rules, scope, {});
      },
      "string, Object, Object": function stringObjectObject(expr, scope, options) {
        return this(parse(expr), this.rules, scope, options);
      },
      "string, Array": function stringArray(expr, rules) {
        return this(parse(expr), rules, {}, {});
      },
      "string, Array, Object": function stringArrayObject(expr, rules, scope) {
        return this(parse(expr), rules, scope, {});
      },
      "string, Array, Object, Object": function stringArrayObjectObject(expr, rules, scope, options) {
        return this(parse(expr), rules, scope, options);
      },
      "Node, Object": function NodeObject(expr, scope) {
        return this(expr, this.rules, scope, {});
      },
      "Node, Object, Object": function NodeObjectObject(expr, scope, options) {
        return this(expr, this.rules, scope, options);
      },
      Node: function Node(expr) {
        return this(expr, this.rules, {}, {});
      },
      "Node, Array": function NodeArray(expr, rules) {
        return this(expr, rules, {}, {});
      },
      "Node, Array, Object": function NodeArrayObject(expr, rules, scope) {
        return this(expr, rules, scope, {});
      },
      "Node, Array, Object, Object": function NodeArrayObjectObject(expr, rules, scope, options) {
        rules = _buildRules(rules);
        var res = resolve(expr, scope);
        res = removeParens(res);
        var visited = {};
        var str = res.toString({
          parenthesis: "all"
        });
        while (!visited[str]) {
          visited[str] = true;
          _lastsym = 0;
          for (var i = 0; i < rules.length; i++) {
            if (typeof rules[i] === "function") {
              res = rules[i](res, options);
            } else {
              flatten2(res);
              res = applyRule(res, rules[i]);
            }
            unflattenl(res);
          }
          str = res.toString({
            parenthesis: "all"
          });
        }
        return res;
      }
    });
    simplify.simplifyCore = simplifyCore;
    simplify.resolve = resolve;
    function removeParens(node) {
      return node.transform(function(node2, path, parent) {
        return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
      });
    }
    var SUPPORTED_CONSTANTS = {
      true: true,
      false: true,
      e: true,
      i: true,
      Infinity: true,
      LN2: true,
      LN10: true,
      LOG2E: true,
      LOG10E: true,
      NaN: true,
      phi: true,
      pi: true,
      SQRT1_2: true,
      SQRT2: true,
      tau: true
    };
    simplify.rules = [
      simplifyCore,
      {
        l: "log(e)",
        r: "1"
      },
      {
        l: "n-n1",
        r: "n+-n1"
      },
      {
        l: "-(c*v)",
        r: "(-c) * v"
      },
      {
        l: "-v",
        r: "(-1) * v"
      },
      {
        l: "n/n1^n2",
        r: "n*n1^-n2"
      },
      {
        l: "n/n1",
        r: "n*n1^-1"
      },
      {
        l: "(n ^ n1) ^ n2",
        r: "n ^ (n1 * n2)"
      },
      {
        l: "n*n",
        r: "n^2"
      },
      {
        l: "n * n^n1",
        r: "n^(n1+1)"
      },
      {
        l: "n^n1 * n^n2",
        r: "n^(n1+n2)"
      },
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      {
        l: "n1*n2 + n2",
        r: "(n1+1)*n2"
      },
      {
        l: "n1*n3 + n2*n3",
        r: "(n1+n2)*n3"
      },
      {
        l: "n1 + -1 * (n2 + n3)",
        r: "n1 + -1 * n2 + -1 * n3"
      },
      simplifyConstant,
      {
        l: "(-n)*n1",
        r: "-(n*n1)"
      },
      {
        l: "c+v",
        r: "v+c",
        context: {
          add: {
            commutative: false
          }
        }
      },
      {
        l: "v*c",
        r: "c*v",
        context: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        l: "n+-n1",
        r: "n-n1"
      },
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "n-(n1+n2)",
        r: "n-n1-n2"
      },
      {
        l: "1*n",
        r: "n"
      },
      {
        l: "n1/(n2/n3)",
        r: "(n1*n3)/n2"
      }
    ];
    function _buildRules(rules) {
      var ruleSet = [];
      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        var newRule = void 0;
        var ruleType = typeof rule;
        switch (ruleType) {
          case "string": {
            var lr = rule.split("->");
            if (lr.length === 2) {
              rule = {
                l: lr[0],
                r: lr[1]
              };
            } else {
              throw SyntaxError("Could not parse rule: " + rule);
            }
          }
          case "object":
            newRule = {
              l: removeParens(parse(rule.l)),
              r: removeParens(parse(rule.r))
            };
            if (rule.context) {
              newRule.evaluate = rule.context;
            }
            if (rule.evaluate) {
              newRule.evaluate = parse(rule.evaluate);
            }
            if (isAssociative(newRule.l)) {
              var makeNode = createMakeNodeFunction(newRule.l);
              var expandsym = _getExpandPlaceholderSymbol();
              newRule.expanded = {};
              newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]);
              flatten2(newRule.expanded.l);
              unflattenr(newRule.expanded.l);
              newRule.expanded.r = makeNode([newRule.r, expandsym]);
            }
            break;
          case "function":
            newRule = rule;
            break;
          default:
            throw TypeError("Unsupported type of rule: " + ruleType);
        }
        ruleSet.push(newRule);
      }
      return ruleSet;
    }
    var _lastsym = 0;
    function _getExpandPlaceholderSymbol() {
      return new SymbolNode("_p" + _lastsym++);
    }
    var applyRule = typed("applyRule", {
      "Node, Object": function NodeObject(node, rule) {
        var res = node;
        if (res instanceof OperatorNode || res instanceof FunctionNode) {
          if (res.args) {
            for (var i = 0; i < res.args.length; i++) {
              res.args[i] = applyRule(res.args[i], rule);
            }
          }
        } else if (res instanceof ParenthesisNode) {
          if (res.content) {
            res.content = applyRule(res.content, rule);
          }
        }
        var repl = rule.r;
        var matches = _ruleMatch(rule.l, res)[0];
        if (!matches && rule.expanded) {
          repl = rule.expanded.r;
          matches = _ruleMatch(rule.expanded.l, res)[0];
        }
        if (matches) {
          var implicit = res.implicit;
          res = repl.clone();
          if (implicit && "implicit" in repl) {
            res.implicit = true;
          }
          res = res.transform(function(node2) {
            if (node2.isSymbolNode && hasOwnProperty2(matches.placeholders, node2.name)) {
              return matches.placeholders[node2.name].clone();
            } else {
              return node2;
            }
          });
        }
        return res;
      }
    });
    function getSplits(node, context) {
      var res = [];
      var right, rightArgs;
      var makeNode = createMakeNodeFunction(node);
      if (isCommutative(node, context)) {
        for (var i = 0; i < node.args.length; i++) {
          rightArgs = node.args.slice(0);
          rightArgs.splice(i, 1);
          right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
          res.push(makeNode([node.args[i], right]));
        }
      } else {
        rightArgs = node.args.slice(1);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([node.args[0], right]));
      }
      return res;
    }
    function mergeMatch(match1, match2) {
      var res = {
        placeholders: {}
      };
      if (!match1.placeholders && !match2.placeholders) {
        return res;
      } else if (!match1.placeholders) {
        return match2;
      } else if (!match2.placeholders) {
        return match1;
      }
      for (var key in match1.placeholders) {
        if (hasOwnProperty2(match1.placeholders, key)) {
          res.placeholders[key] = match1.placeholders[key];
          if (hasOwnProperty2(match2.placeholders, key)) {
            if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
              return null;
            }
          }
        }
      }
      for (var _key in match2.placeholders) {
        if (hasOwnProperty2(match2.placeholders, _key)) {
          res.placeholders[_key] = match2.placeholders[_key];
        }
      }
      return res;
    }
    function combineChildMatches(list1, list2) {
      var res = [];
      if (list1.length === 0 || list2.length === 0) {
        return res;
      }
      var merged;
      for (var i1 = 0; i1 < list1.length; i1++) {
        for (var i2 = 0; i2 < list2.length; i2++) {
          merged = mergeMatch(list1[i1], list2[i2]);
          if (merged) {
            res.push(merged);
          }
        }
      }
      return res;
    }
    function mergeChildMatches(childMatches) {
      if (childMatches.length === 0) {
        return childMatches;
      }
      var sets = childMatches.reduce(combineChildMatches);
      var uniqueSets = [];
      var unique = {};
      for (var i = 0; i < sets.length; i++) {
        var s = JSON.stringify(sets[i]);
        if (!unique[s]) {
          unique[s] = true;
          uniqueSets.push(sets[i]);
        }
      }
      return uniqueSets;
    }
    function _ruleMatch(rule, node, isSplit) {
      var res = [{
        placeholders: {}
      }];
      if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
        if (rule instanceof OperatorNode) {
          if (rule.op !== node.op || rule.fn !== node.fn) {
            return [];
          }
        } else if (rule instanceof FunctionNode) {
          if (rule.name !== node.name) {
            return [];
          }
        }
        if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) && node.args.length === rule.args.length || isSplit) {
          var childMatches = [];
          for (var i = 0; i < rule.args.length; i++) {
            var childMatch = _ruleMatch(rule.args[i], node.args[i]);
            if (childMatch.length === 0) {
              return [];
            }
            childMatches.push(childMatch);
          }
          res = mergeChildMatches(childMatches);
        } else if (node.args.length >= 2 && rule.args.length === 2) {
          var splits = getSplits(node, rule.context);
          var splitMatches = [];
          for (var _i = 0; _i < splits.length; _i++) {
            var matchSet = _ruleMatch(rule, splits[_i], true);
            splitMatches = splitMatches.concat(matchSet);
          }
          return splitMatches;
        } else if (rule.args.length > 2) {
          throw Error("Unexpected non-binary associative function: " + rule.toString());
        } else {
          return [];
        }
      } else if (rule instanceof SymbolNode) {
        if (rule.name.length === 0) {
          throw new Error("Symbol in rule has 0 length...!?");
        }
        if (SUPPORTED_CONSTANTS[rule.name]) {
          if (rule.name !== node.name) {
            return [];
          }
        } else if (rule.name[0] === "n" || rule.name.substring(0, 2) === "_p") {
          res[0].placeholders[rule.name] = node;
        } else if (rule.name[0] === "v") {
          if (!isConstantNode(node)) {
            res[0].placeholders[rule.name] = node;
          } else {
            return [];
          }
        } else if (rule.name[0] === "c") {
          if (node instanceof ConstantNode) {
            res[0].placeholders[rule.name] = node;
          } else {
            return [];
          }
        } else {
          throw new Error("Invalid symbol in rule: " + rule.name);
        }
      } else if (rule instanceof ConstantNode) {
        if (!equal(rule.value, node.value)) {
          return [];
        }
      } else {
        return [];
      }
      return res;
    }
    function _exactMatch(p, q) {
      if (p instanceof ConstantNode && q instanceof ConstantNode) {
        if (!equal(p.value, q.value)) {
          return false;
        }
      } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
        if (p.name !== q.name) {
          return false;
        }
      } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
        if (p instanceof OperatorNode) {
          if (p.op !== q.op || p.fn !== q.fn) {
            return false;
          }
        } else if (p instanceof FunctionNode) {
          if (p.name !== q.name) {
            return false;
          }
        }
        if (p.args.length !== q.args.length) {
          return false;
        }
        for (var i = 0; i < p.args.length; i++) {
          if (!_exactMatch(p.args[i], q.args[i])) {
            return false;
          }
        }
      } else {
        return false;
      }
      return true;
    }
    return simplify;
  });

  // node_modules/mathjs/lib/esm/function/algebra/derivative.js
  var name263 = "derivative";
  var dependencies264 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
  var createDerivative = /* @__PURE__ */ factory(name263, dependencies264, (_ref) => {
    var {
      typed,
      config,
      parse,
      simplify,
      equal,
      isZero,
      numeric: numeric2,
      ConstantNode,
      FunctionNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode
    } = _ref;
    var derivative = typed("derivative", {
      "Node, SymbolNode, Object": function NodeSymbolNodeObject(expr, variable, options) {
        var constNodes = {};
        constTag(constNodes, expr, variable.name);
        var res = _derivative(expr, constNodes);
        return options.simplify ? simplify(res) : res;
      },
      "Node, SymbolNode": function NodeSymbolNode(expr, variable) {
        return this(expr, variable, {
          simplify: true
        });
      },
      "string, SymbolNode": function stringSymbolNode(expr, variable) {
        return this(parse(expr), variable);
      },
      "string, SymbolNode, Object": function stringSymbolNodeObject(expr, variable, options) {
        return this(parse(expr), variable, options);
      },
      "string, string": function stringString(expr, variable) {
        return this(parse(expr), parse(variable));
      },
      "string, string, Object": function stringStringObject(expr, variable, options) {
        return this(parse(expr), parse(variable), options);
      },
      "Node, string": function NodeString(expr, variable) {
        return this(expr, parse(variable));
      },
      "Node, string, Object": function NodeStringObject(expr, variable, options) {
        return this(expr, parse(variable), options);
      }
    });
    derivative._simplify = true;
    derivative.toTex = function(deriv) {
      return _derivTex.apply(null, deriv.args);
    };
    var _derivTex = typed("_derivTex", {
      "Node, SymbolNode": function NodeSymbolNode(expr, x) {
        if (isConstantNode(expr) && typeOf(expr.value) === "string") {
          return _derivTex(parse(expr.value).toString(), x.toString(), 1);
        } else {
          return _derivTex(expr.toString(), x.toString(), 1);
        }
      },
      "Node, ConstantNode": function NodeConstantNode(expr, x) {
        if (typeOf(x.value) === "string") {
          return _derivTex(expr, parse(x.value));
        } else {
          throw new Error("The second parameter to 'derivative' is a non-string constant");
        }
      },
      "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
        return _derivTex(expr.toString(), x.name, order.value);
      },
      "string, string, number": function stringStringNumber(expr, x, order) {
        var d;
        if (order === 1) {
          d = "{d\\over d" + x + "}";
        } else {
          d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
        }
        return d + "\\left[".concat(expr, "\\right]");
      }
    });
    var constTag = typed("constTag", {
      "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
        constNodes[node] = true;
        return true;
      },
      "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
        if (node.name !== varName) {
          constNodes[node] = true;
          return true;
        }
        return false;
      },
      "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
        return constTag(constNodes, node.content, varName);
      },
      "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
        if (node.params.indexOf(varName) === -1) {
          constNodes[node] = true;
          return true;
        }
        return constTag(constNodes, node.expr, varName);
      },
      "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
        if (node.args.length > 0) {
          var isConst = constTag(constNodes, node.args[0], varName);
          for (var i = 1; i < node.args.length; ++i) {
            isConst = constTag(constNodes, node.args[i], varName) && isConst;
          }
          if (isConst) {
            constNodes[node] = true;
            return true;
          }
        }
        return false;
      }
    });
    var _derivative = typed("_derivative", {
      "ConstantNode, Object": function ConstantNodeObject(node) {
        return createConstantNode2(0);
      },
      "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        return createConstantNode2(1);
      },
      "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
        return new ParenthesisNode(_derivative(node.content, constNodes));
      },
      "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        return _derivative(node.expr, constNodes);
      },
      "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
        if (node.args.length !== 1) {
          funcArgsCheck(node);
        }
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        var arg0 = node.args[0];
        var arg1;
        var div = false;
        var negative = false;
        var funcDerivative;
        switch (node.name) {
          case "cbrt":
            div = true;
            funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(3), new OperatorNode("^", "pow", [arg0, new OperatorNode("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
            break;
          case "sqrt":
          case "nthRoot":
            if (node.args.length === 1) {
              div = true;
              funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(2), new FunctionNode("sqrt", [arg0])]);
            } else if (node.args.length === 2) {
              arg1 = new OperatorNode("/", "divide", [createConstantNode2(1), node.args[1]]);
              constNodes[arg1] = constNodes[node.args[1]];
              return _derivative(new OperatorNode("^", "pow", [arg0, arg1]), constNodes);
            }
            break;
          case "log10":
            arg1 = createConstantNode2(10);
          case "log":
            if (!arg1 && node.args.length === 1) {
              funcDerivative = arg0.clone();
              div = true;
            } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
              funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("log", [arg1 || node.args[1]])]);
              div = true;
            } else if (node.args.length === 2) {
              return _derivative(new OperatorNode("/", "divide", [new FunctionNode("log", [arg0]), new FunctionNode("log", [node.args[1]])]), constNodes);
            }
            break;
          case "pow":
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode("^", "pow", [arg0, node.args[1]]), constNodes);
          case "exp":
            funcDerivative = new FunctionNode("exp", [arg0.clone()]);
            break;
          case "sin":
            funcDerivative = new FunctionNode("cos", [arg0.clone()]);
            break;
          case "cos":
            funcDerivative = new OperatorNode("-", "unaryMinus", [new FunctionNode("sin", [arg0.clone()])]);
            break;
          case "tan":
            funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sec", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "sec":
            funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tan", [arg0.clone()])]);
            break;
          case "csc":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("cot", [arg0.clone()])]);
            break;
          case "cot":
            negative = true;
            funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csc", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "asin":
            div = true;
            funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
            break;
          case "acos":
            div = true;
            negative = true;
            funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
            break;
          case "atan":
            div = true;
            funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
            break;
          case "asec":
            div = true;
            funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acsc":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acot":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
            break;
          case "sinh":
            funcDerivative = new FunctionNode("cosh", [arg0.clone()]);
            break;
          case "cosh":
            funcDerivative = new FunctionNode("sinh", [arg0.clone()]);
            break;
          case "tanh":
            funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sech", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "sech":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tanh", [arg0.clone()])]);
            break;
          case "csch":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("coth", [arg0.clone()])]);
            break;
          case "coth":
            negative = true;
            funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csch", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "asinh":
            div = true;
            funcDerivative = new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
            break;
          case "acosh":
            div = true;
            funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
            break;
          case "atanh":
            div = true;
            funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
            break;
          case "asech":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
            break;
          case "acsch":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acoth":
            div = true;
            negative = true;
            funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
            break;
          case "abs":
            funcDerivative = new OperatorNode("/", "divide", [new FunctionNode(new SymbolNode("abs"), [arg0.clone()]), arg0.clone()]);
            break;
          case "gamma":
          default:
            throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
        }
        var op, func;
        if (div) {
          op = "/";
          func = "divide";
        } else {
          op = "*";
          func = "multiply";
        }
        var chainDerivative = _derivative(arg0, constNodes);
        if (negative) {
          chainDerivative = new OperatorNode("-", "unaryMinus", [chainDerivative]);
        }
        return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
      },
      "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        if (node.op === "+") {
          return new OperatorNode(node.op, node.fn, node.args.map(function(arg) {
            return _derivative(arg, constNodes);
          }));
        }
        if (node.op === "-") {
          if (node.isUnary()) {
            return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
          }
          if (node.isBinary()) {
            return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
          }
        }
        if (node.op === "*") {
          var constantTerms = node.args.filter(function(arg) {
            return constNodes[arg] !== void 0;
          });
          if (constantTerms.length > 0) {
            var nonConstantTerms = node.args.filter(function(arg) {
              return constNodes[arg] === void 0;
            });
            var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode("*", "multiply", nonConstantTerms);
            var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
            return new OperatorNode("*", "multiply", newArgs);
          }
          return new OperatorNode("+", "add", node.args.map(function(argOuter) {
            return new OperatorNode("*", "multiply", node.args.map(function(argInner) {
              return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
            }));
          }));
        }
        if (node.op === "/" && node.isBinary()) {
          var arg0 = node.args[0];
          var arg1 = node.args[1];
          if (constNodes[arg1] !== void 0) {
            return new OperatorNode("/", "divide", [_derivative(arg0, constNodes), arg1]);
          }
          if (constNodes[arg0] !== void 0) {
            return new OperatorNode("*", "multiply", [new OperatorNode("-", "unaryMinus", [arg0]), new OperatorNode("/", "divide", [_derivative(arg1, constNodes), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
          }
          return new OperatorNode("/", "divide", [new OperatorNode("-", "subtract", [new OperatorNode("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
        }
        if (node.op === "^" && node.isBinary()) {
          var _arg = node.args[0];
          var _arg2 = node.args[1];
          if (constNodes[_arg] !== void 0) {
            if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {
              return createConstantNode2(0);
            }
            return new OperatorNode("*", "multiply", [node, new OperatorNode("*", "multiply", [new FunctionNode("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
          }
          if (constNodes[_arg2] !== void 0) {
            if (isConstantNode(_arg2)) {
              if (isZero(_arg2.value)) {
                return createConstantNode2(0);
              }
              if (equal(_arg2.value, 1)) {
                return _derivative(_arg, constNodes);
              }
            }
            var powMinusOne = new OperatorNode("^", "pow", [_arg.clone(), new OperatorNode("-", "subtract", [_arg2, createConstantNode2(1)])]);
            return new OperatorNode("*", "multiply", [_arg2.clone(), new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
          }
          return new OperatorNode("*", "multiply", [new OperatorNode("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode("+", "add", [new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode("log", [_arg.clone()])])])]);
        }
        throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
      }
    });
    function funcArgsCheck(node) {
      if ((node.name === "log" || node.name === "nthRoot" || node.name === "pow") && node.args.length === 2) {
        return;
      }
      for (var i = 0; i < node.args.length; ++i) {
        node.args[i] = createConstantNode2(0);
      }
      node.compile().evaluate();
      throw new Error("Expected TypeError, but none found");
    }
    function createConstantNode2(value, valueType) {
      return new ConstantNode(numeric2(value, valueType || config.number));
    }
    return derivative;
  });

  // node_modules/mathjs/lib/esm/function/algebra/rationalize.js
  var name264 = "rationalize";
  var dependencies265 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplify", "?bignumber", "?fraction", "mathWithTransform", "ConstantNode", "OperatorNode", "FunctionNode", "SymbolNode", "ParenthesisNode"];
  var createRationalize = /* @__PURE__ */ factory(name264, dependencies265, (_ref) => {
    var {
      config,
      typed,
      equal,
      isZero,
      add,
      subtract,
      multiply,
      divide,
      pow,
      parse,
      simplify,
      fraction,
      bignumber,
      mathWithTransform,
      ConstantNode,
      OperatorNode,
      FunctionNode,
      SymbolNode,
      ParenthesisNode
    } = _ref;
    var simplifyConstant = createSimplifyConstant({
      typed,
      config,
      mathWithTransform,
      fraction,
      bignumber,
      ConstantNode,
      OperatorNode,
      FunctionNode,
      SymbolNode
    });
    var simplifyCore = createSimplifyCore({
      equal,
      isZero,
      add,
      subtract,
      multiply,
      divide,
      pow,
      ConstantNode,
      OperatorNode,
      FunctionNode,
      ParenthesisNode
    });
    return typed(name264, {
      string: function string(expr) {
        return this(parse(expr), {}, false);
      },
      "string, boolean": function stringBoolean(expr, detailed) {
        return this(parse(expr), {}, detailed);
      },
      "string, Object": function stringObject(expr, scope) {
        return this(parse(expr), scope, false);
      },
      "string, Object, boolean": function stringObjectBoolean(expr, scope, detailed) {
        return this(parse(expr), scope, detailed);
      },
      Node: function Node(expr) {
        return this(expr, {}, false);
      },
      "Node, boolean": function NodeBoolean(expr, detailed) {
        return this(expr, {}, detailed);
      },
      "Node, Object": function NodeObject(expr, scope) {
        return this(expr, scope, false);
      },
      "Node, Object, boolean": function NodeObjectBoolean(expr, scope, detailed) {
        var setRules = rulesRationalize();
        var polyRet = polynomial(expr, scope, true, setRules.firstRules);
        var nVars = polyRet.variables.length;
        expr = polyRet.expression;
        if (nVars >= 1) {
          expr = expandPower(expr);
          var sBefore;
          var rules;
          var eDistrDiv = true;
          var redoInic = false;
          expr = simplify(expr, setRules.firstRules, {}, {
            exactFractions: false
          });
          var s;
          while (true) {
            rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
            expr = simplify(expr, rules);
            eDistrDiv = !eDistrDiv;
            s = expr.toString();
            if (s === sBefore) {
              break;
            }
            redoInic = true;
            sBefore = s;
          }
          if (redoInic) {
            expr = simplify(expr, setRules.firstRulesAgain, {}, {
              exactFractions: false
            });
          }
          expr = simplify(expr, setRules.finalRules, {}, {
            exactFractions: false
          });
        }
        var coefficients = [];
        var retRationalize = {};
        if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
          if (nVars === 1) {
            expr.args[0] = polyToCanonical(expr.args[0], coefficients);
            expr.args[1] = polyToCanonical(expr.args[1]);
          }
          if (detailed) {
            retRationalize.numerator = expr.args[0];
            retRationalize.denominator = expr.args[1];
          }
        } else {
          if (nVars === 1) {
            expr = polyToCanonical(expr, coefficients);
          }
          if (detailed) {
            retRationalize.numerator = expr;
            retRationalize.denominator = null;
          }
        }
        if (!detailed)
          return expr;
        retRationalize.coefficients = coefficients;
        retRationalize.variables = polyRet.variables;
        retRationalize.expression = expr;
        return retRationalize;
      }
    });
    function polynomial(expr, scope, extended, rules) {
      var variables = [];
      var node = simplify(expr, rules, scope, {
        exactFractions: false
      });
      extended = !!extended;
      var oper = "+-*" + (extended ? "/" : "");
      recPoly(node);
      var retFunc = {};
      retFunc.expression = node;
      retFunc.variables = variables;
      return retFunc;
      function recPoly(node2) {
        var tp = node2.type;
        if (tp === "FunctionNode") {
          throw new Error("There is an unsolved function call");
        } else if (tp === "OperatorNode") {
          if (node2.op === "^") {
            if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
              throw new Error("There is a non-integer exponent");
            } else {
              recPoly(node2.args[0]);
            }
          } else {
            if (oper.indexOf(node2.op) === -1) {
              throw new Error("Operator " + node2.op + " invalid in polynomial expression");
            }
            for (var i = 0; i < node2.args.length; i++) {
              recPoly(node2.args[i]);
            }
          }
        } else if (tp === "SymbolNode") {
          var _name = node2.name;
          var pos = variables.indexOf(_name);
          if (pos === -1) {
            variables.push(_name);
          }
        } else if (tp === "ParenthesisNode") {
          recPoly(node2.content);
        } else if (tp !== "ConstantNode") {
          throw new Error("type " + tp + " is not allowed in polynomial expression");
        }
      }
    }
    function rulesRationalize() {
      var oldRules = [
        simplifyCore,
        {
          l: "n+n",
          r: "2*n"
        },
        {
          l: "n+-n",
          r: "0"
        },
        simplifyConstant,
        {
          l: "n*(n1^-1)",
          r: "n/n1"
        },
        {
          l: "n*n1^-n2",
          r: "n/n1^n2"
        },
        {
          l: "n1^-1",
          r: "1/n1"
        },
        {
          l: "n*(n1/n2)",
          r: "(n*n1)/n2"
        },
        {
          l: "1*n",
          r: "n"
        }
      ];
      var rulesFirst = [
        {
          l: "(-n1)/(-n2)",
          r: "n1/n2"
        },
        {
          l: "(-n1)*(-n2)",
          r: "n1*n2"
        },
        {
          l: "n1--n2",
          r: "n1+n2"
        },
        {
          l: "n1-n2",
          r: "n1+(-n2)"
        },
        {
          l: "(n1+n2)*n3",
          r: "(n1*n3 + n2*n3)"
        },
        {
          l: "n1*(n2+n3)",
          r: "(n1*n2+n1*n3)"
        },
        {
          l: "c1*n + c2*n",
          r: "(c1+c2)*n"
        },
        {
          l: "c1*n + n",
          r: "(c1+1)*n"
        },
        {
          l: "c1*n - c2*n",
          r: "(c1-c2)*n"
        },
        {
          l: "c1*n - n",
          r: "(c1-1)*n"
        },
        {
          l: "v/c",
          r: "(1/c)*v"
        },
        {
          l: "v/-c",
          r: "-(1/c)*v"
        },
        {
          l: "-v*-c",
          r: "c*v"
        },
        {
          l: "-v*c",
          r: "-c*v"
        },
        {
          l: "v*-c",
          r: "-c*v"
        },
        {
          l: "v*c",
          r: "c*v"
        },
        {
          l: "-(-n1*n2)",
          r: "(n1*n2)"
        },
        {
          l: "-(n1*n2)",
          r: "(-n1*n2)"
        },
        {
          l: "-(-n1+n2)",
          r: "(n1-n2)"
        },
        {
          l: "-(n1+n2)",
          r: "(-n1-n2)"
        },
        {
          l: "(n1^n2)^n3",
          r: "(n1^(n2*n3))"
        },
        {
          l: "-(-n1/n2)",
          r: "(n1/n2)"
        },
        {
          l: "-(n1/n2)",
          r: "(-n1/n2)"
        }
      ];
      var rulesDistrDiv = [
        {
          l: "(n1/n2 + n3/n4)",
          r: "((n1*n4 + n3*n2)/(n2*n4))"
        },
        {
          l: "(n1/n2 + n3)",
          r: "((n1 + n3*n2)/n2)"
        },
        {
          l: "(n1 + n2/n3)",
          r: "((n1*n3 + n2)/n3)"
        }
      ];
      var rulesSucDiv = [
        {
          l: "(n1/(n2/n3))",
          r: "((n1*n3)/n2)"
        },
        {
          l: "(n1/n2/n3)",
          r: "(n1/(n2*n3))"
        }
      ];
      var setRules = {};
      setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
      setRules.distrDivRules = rulesDistrDiv;
      setRules.sucDivRules = rulesSucDiv;
      setRules.firstRulesAgain = oldRules.concat(rulesFirst);
      setRules.finalRules = [
        simplifyCore,
        {
          l: "n*-n",
          r: "-n^2"
        },
        {
          l: "n*n",
          r: "n^2"
        },
        simplifyConstant,
        {
          l: "n*-n^n1",
          r: "-n^(n1+1)"
        },
        {
          l: "n*n^n1",
          r: "n^(n1+1)"
        },
        {
          l: "n^n1*-n^n2",
          r: "-n^(n1+n2)"
        },
        {
          l: "n^n1*n^n2",
          r: "n^(n1+n2)"
        },
        {
          l: "n^n1*-n",
          r: "-n^(n1+1)"
        },
        {
          l: "n^n1*n",
          r: "n^(n1+1)"
        },
        {
          l: "n^n1/-n",
          r: "-n^(n1-1)"
        },
        {
          l: "n^n1/n",
          r: "n^(n1-1)"
        },
        {
          l: "n/-n^n1",
          r: "-n^(1-n1)"
        },
        {
          l: "n/n^n1",
          r: "n^(1-n1)"
        },
        {
          l: "n^n1/-n^n2",
          r: "n^(n1-n2)"
        },
        {
          l: "n^n1/n^n2",
          r: "n^(n1-n2)"
        },
        {
          l: "n1+(-n2*n3)",
          r: "n1-n2*n3"
        },
        {
          l: "v*(-c)",
          r: "-c*v"
        },
        {
          l: "n1+-n2",
          r: "n1-n2"
        },
        {
          l: "v*c",
          r: "c*v"
        },
        {
          l: "(n1^n2)^n3",
          r: "(n1^(n2*n3))"
        }
      ];
      return setRules;
    }
    function expandPower(node, parent, indParent) {
      var tp = node.type;
      var internal = arguments.length > 1;
      if (tp === "OperatorNode" && node.isBinary()) {
        var does = false;
        var val;
        if (node.op === "^") {
          if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
            val = parseFloat(node.args[1].value);
            does = val >= 2 && isInteger(val);
          }
        }
        if (does) {
          if (val > 2) {
            var nEsqTopo = node.args[0];
            var nDirTopo = new OperatorNode("^", "pow", [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);
            node = new OperatorNode("*", "multiply", [nEsqTopo, nDirTopo]);
          } else {
            node = new OperatorNode("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
          }
          if (internal) {
            if (indParent === "content") {
              parent.content = node;
            } else {
              parent.args[indParent] = node;
            }
          }
        }
      }
      if (tp === "ParenthesisNode") {
        expandPower(node.content, node, "content");
      } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
        for (var i = 0; i < node.args.length; i++) {
          expandPower(node.args[i], node, i);
        }
      }
      if (!internal) {
        return node;
      }
    }
    function polyToCanonical(node, coefficients) {
      if (coefficients === void 0) {
        coefficients = [];
      }
      coefficients[0] = 0;
      var o = {};
      o.cte = 1;
      o.oper = "+";
      o.fire = "";
      var maxExpo = 0;
      var varname = "";
      recurPol(node, null, o);
      maxExpo = coefficients.length - 1;
      var first = true;
      var no;
      for (var i = maxExpo; i >= 0; i--) {
        if (coefficients[i] === 0)
          continue;
        var n16 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));
        var op = coefficients[i] < 0 ? "-" : "+";
        if (i > 0) {
          var n25 = new SymbolNode(varname);
          if (i > 1) {
            var n3 = new ConstantNode(i);
            n25 = new OperatorNode("^", "pow", [n25, n3]);
          }
          if (coefficients[i] === -1 && first) {
            n16 = new OperatorNode("-", "unaryMinus", [n25]);
          } else if (Math.abs(coefficients[i]) === 1) {
            n16 = n25;
          } else {
            n16 = new OperatorNode("*", "multiply", [n16, n25]);
          }
        }
        if (first) {
          no = n16;
        } else if (op === "+") {
          no = new OperatorNode("+", "add", [no, n16]);
        } else {
          no = new OperatorNode("-", "subtract", [no, n16]);
        }
        first = false;
      }
      if (first) {
        return new ConstantNode(0);
      } else {
        return no;
      }
      function recurPol(node2, noPai, o2) {
        var tp = node2.type;
        if (tp === "FunctionNode") {
          throw new Error("There is an unsolved function call");
        } else if (tp === "OperatorNode") {
          if ("+-*^".indexOf(node2.op) === -1)
            throw new Error("Operator " + node2.op + " invalid");
          if (noPai !== null) {
            if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
              throw new Error("Invalid " + node2.op + " placing");
            }
            if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
              throw new Error("Invalid " + node2.op + " placing");
            }
            if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
              throw new Error("Invalid " + node2.op + " placing");
            }
          }
          if (node2.op === "^" || node2.op === "*") {
            o2.fire = node2.op;
          }
          for (var _i = 0; _i < node2.args.length; _i++) {
            if (node2.fn === "unaryMinus")
              o2.oper = "-";
            if (node2.op === "+" || node2.fn === "subtract") {
              o2.fire = "";
              o2.cte = 1;
              o2.oper = _i === 0 ? "+" : node2.op;
            }
            o2.noFil = _i;
            recurPol(node2.args[_i], node2, o2);
          }
        } else if (tp === "SymbolNode") {
          if (node2.name !== varname && varname !== "") {
            throw new Error("There is more than one variable");
          }
          varname = node2.name;
          if (noPai === null) {
            coefficients[1] = 1;
            return;
          }
          if (noPai.op === "^" && o2.noFil !== 0) {
            throw new Error("In power the variable should be the first parameter");
          }
          if (noPai.op === "*" && o2.noFil !== 1) {
            throw new Error("In multiply the variable should be the second parameter");
          }
          if (o2.fire === "" || o2.fire === "*") {
            if (maxExpo < 1)
              coefficients[1] = 0;
            coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
            maxExpo = Math.max(1, maxExpo);
          }
        } else if (tp === "ConstantNode") {
          var valor = parseFloat(node2.value);
          if (noPai === null) {
            coefficients[0] = valor;
            return;
          }
          if (noPai.op === "^") {
            if (o2.noFil !== 1)
              throw new Error("Constant cannot be powered");
            if (!isInteger(valor) || valor <= 0) {
              throw new Error("Non-integer exponent is not allowed");
            }
            for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {
              coefficients[_i2] = 0;
            }
            if (valor > maxExpo)
              coefficients[valor] = 0;
            coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
            maxExpo = Math.max(valor, maxExpo);
            return;
          }
          o2.cte = valor;
          if (o2.fire === "") {
            coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
          }
        } else {
          throw new Error("Type " + tp + " is not allowed");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/json/reviver.js
  var name265 = "reviver";
  var dependencies266 = ["classes"];
  var createReviver = /* @__PURE__ */ factory(name265, dependencies266, (_ref) => {
    var {
      classes
    } = _ref;
    return function reviver(key, value) {
      var constructor = classes[value && value.mathjs];
      if (constructor && typeof constructor.fromJSON === "function") {
        return constructor.fromJSON(value);
      }
      return value;
    };
  });

  // node_modules/mathjs/lib/esm/json/replacer.js
  var name266 = "replacer";
  var dependencies267 = [];
  var createReplacer = /* @__PURE__ */ factory(name266, dependencies267, () => {
    return function replacer(key, value) {
      if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
        return {
          mathjs: "number",
          value: String(value)
        };
      }
      return value;
    };
  });

  // node_modules/mathjs/lib/esm/version.js
  var version = "9.3.0";

  // node_modules/mathjs/lib/esm/constants.js
  var createTrue = /* @__PURE__ */ factory("true", [], () => true);
  var createFalse = /* @__PURE__ */ factory("false", [], () => false);
  var createNull = /* @__PURE__ */ factory("null", [], () => null);
  var createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
    var {
      config,
      BigNumber
    } = _ref;
    return config.number === "BigNumber" ? new BigNumber(Infinity) : Infinity;
  });
  var createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
    var {
      config,
      BigNumber
    } = _ref2;
    return config.number === "BigNumber" ? new BigNumber(NaN) : NaN;
  });
  var createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
    var {
      config,
      BigNumber
    } = _ref3;
    return config.number === "BigNumber" ? createBigNumberPi(BigNumber) : pi;
  });
  var createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
    var {
      config,
      BigNumber
    } = _ref4;
    return config.number === "BigNumber" ? createBigNumberTau(BigNumber) : tau;
  });
  var createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
    var {
      config,
      BigNumber
    } = _ref5;
    return config.number === "BigNumber" ? createBigNumberE(BigNumber) : e;
  });
  var createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
    var {
      config,
      BigNumber
    } = _ref6;
    return config.number === "BigNumber" ? createBigNumberPhi(BigNumber) : phi;
  });
  var createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
    var {
      config,
      BigNumber
    } = _ref7;
    return config.number === "BigNumber" ? new BigNumber(2).ln() : Math.LN2;
  });
  var createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
    var {
      config,
      BigNumber
    } = _ref8;
    return config.number === "BigNumber" ? new BigNumber(10).ln() : Math.LN10;
  });
  var createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
    var {
      config,
      BigNumber
    } = _ref9;
    return config.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(2).ln()) : Math.LOG2E;
  });
  var createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
    var {
      config,
      BigNumber
    } = _ref10;
    return config.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E;
  });
  var createSQRT1_2 = /* @__PURE__ */ recreateFactory("SQRT1_2", ["config", "?BigNumber"], (_ref11) => {
    var {
      config,
      BigNumber
    } = _ref11;
    return config.number === "BigNumber" ? new BigNumber("0.5").sqrt() : Math.SQRT1_2;
  });
  var createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
    var {
      config,
      BigNumber
    } = _ref12;
    return config.number === "BigNumber" ? new BigNumber(2).sqrt() : Math.SQRT2;
  });
  var createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
    var {
      Complex: Complex2
    } = _ref13;
    return Complex2.I;
  });
  var createUppercasePi = /* @__PURE__ */ factory("PI", ["pi"], (_ref14) => {
    var {
      pi: pi2
    } = _ref14;
    return pi2;
  });
  var createUppercaseE = /* @__PURE__ */ factory("E", ["e"], (_ref15) => {
    var {
      e: e2
    } = _ref15;
    return e2;
  });
  var createVersion = /* @__PURE__ */ factory("version", [], () => version);
  function recreateFactory(name284, dependencies285, create2) {
    return factory(name284, dependencies285, create2, {
      recreateOnConfigChange: true
    });
  }

  // node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
  var createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
  var createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
  var createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
  var createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
  var createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
  var createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
  var createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
  var createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
  var createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
  var createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
  var createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
  var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
  var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
  var createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
  var createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
  var createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
  var createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
  var createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
  var createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
  var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
  var createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
  var createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
  var createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
  var createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
  var createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
  var createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
  var createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
  var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
  var createEfimovFactor = numberFactory("efimovFactor", 22.7);
  var createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
  var createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
  var createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
  var createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
  var createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
  var createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
  var createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
  var createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
  var createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
  var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
  var createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
  var createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
  var createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
  var createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
  var createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
  var createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
  var createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
  var createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
  var createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
  var createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
  var createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
  function unitFactory(name284, valueStr, unitStr) {
    var dependencies285 = ["config", "Unit", "BigNumber"];
    return factory(name284, dependencies285, (_ref) => {
      var {
        config,
        Unit,
        BigNumber
      } = _ref;
      var value = config.number === "BigNumber" ? new BigNumber(valueStr) : parseFloat(valueStr);
      var unit = new Unit(value, unitStr);
      unit.fixPrefix = true;
      return unit;
    });
  }
  function numberFactory(name284, value) {
    var dependencies285 = ["config", "BigNumber"];
    return factory(name284, dependencies285, (_ref2) => {
      var {
        config,
        BigNumber
      } = _ref2;
      return config.number === "BigNumber" ? new BigNumber(value) : value;
    });
  }

  // node_modules/mathjs/lib/esm/expression/transform/apply.transform.js
  var name267 = "apply";
  var dependencies268 = ["typed", "isInteger"];
  var createApplyTransform = /* @__PURE__ */ factory(name267, dependencies268, (_ref) => {
    var {
      typed,
      isInteger: isInteger2
    } = _ref;
    var apply = createApply({
      typed,
      isInteger: isInteger2
    });
    return typed("apply", {
      "...any": function any(args) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
        try {
          return apply.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/column.transform.js
  var name268 = "column";
  var dependencies269 = ["typed", "Index", "matrix", "range"];
  var createColumnTransform = /* @__PURE__ */ factory(name268, dependencies269, (_ref) => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;
    var column = createColumn({
      typed,
      Index,
      matrix,
      range
    });
    return typed("column", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }
        try {
          return column.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
  function compileInlineExpression(expression, math2, scope) {
    var symbol = expression.filter(function(node) {
      return isSymbolNode(node) && !(node.name in math2) && !(node.name in scope);
    })[0];
    if (!symbol) {
      throw new Error('No undefined variable found in inline expression "' + expression + '"');
    }
    var name284 = symbol.name;
    var subScope = Object.create(scope);
    var eq = expression.compile();
    return function inlineExpression(x) {
      subScope[name284] = x;
      return eq.evaluate(subScope);
    };
  }

  // node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
  var name269 = "filter";
  var dependencies270 = ["typed"];
  var createFilterTransform = /* @__PURE__ */ factory(name269, dependencies270, (_ref) => {
    var {
      typed
    } = _ref;
    function filterTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return filter2(x, callback);
    }
    filterTransform.rawArgs = true;
    var filter2 = typed("filter", {
      "Array, function": _filter,
      "Matrix, function": function MatrixFunction(x, test) {
        return x.create(_filter(x.toArray(), test));
      },
      "Array, RegExp": filterRegExp,
      "Matrix, RegExp": function MatrixRegExp(x, test) {
        return x.create(filterRegExp(x.toArray(), test));
      }
    });
    return filterTransform;
  }, {
    isTransformFunction: true
  });
  function _filter(x, callback) {
    var args = maxArgumentCount(callback);
    return filter(x, function(value, index, array) {
      if (args === 1) {
        return callback(value);
      } else if (args === 2) {
        return callback(value, [index + 1]);
      } else {
        return callback(value, [index + 1], array);
      }
    });
  }

  // node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
  var name270 = "forEach";
  var dependencies271 = ["typed"];
  var createForEachTransform = /* @__PURE__ */ factory(name270, dependencies271, (_ref) => {
    var {
      typed
    } = _ref;
    function forEachTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return _forEach2(x, callback);
    }
    forEachTransform.rawArgs = true;
    var _forEach2 = typed("forEach", {
      "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
        var args = maxArgumentCount(callback);
        var recurse = function recurse2(value, index) {
          if (Array.isArray(value)) {
            forEach(value, function(child, i) {
              recurse2(child, index.concat(i + 1));
            });
          } else {
            if (args === 1) {
              callback(value);
            } else if (args === 2) {
              callback(value, index);
            } else {
              callback(value, index, array);
            }
          }
        };
        recurse(array.valueOf(), []);
      }
    });
    return forEachTransform;
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/index.transform.js
  var name271 = "index";
  var dependencies272 = ["Index"];
  var createIndexTransform = /* @__PURE__ */ factory(name271, dependencies272, (_ref) => {
    var {
      Index
    } = _ref;
    return function indexTransform() {
      var args = [];
      for (var i = 0, ii = arguments.length; i < ii; i++) {
        var arg = arguments[i];
        if (isRange(arg)) {
          arg.start--;
          arg.end -= arg.step > 0 ? 0 : 2;
        } else if (arg && arg.isSet === true) {
          arg = arg.map(function(v) {
            return v - 1;
          });
        } else if (isArray(arg) || isMatrix(arg)) {
          arg = arg.map(function(v) {
            return v - 1;
          });
        } else if (isNumber(arg)) {
          arg--;
        } else if (isBigNumber(arg)) {
          arg = arg.toNumber() - 1;
        } else if (typeof arg === "string") {
        } else {
          throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
        }
        args[i] = arg;
      }
      var res = new Index();
      Index.apply(res, args);
      return res;
    };
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/map.transform.js
  var name272 = "map";
  var dependencies273 = ["typed"];
  var createMapTransform = /* @__PURE__ */ factory(name272, dependencies273, (_ref) => {
    var {
      typed
    } = _ref;
    function mapTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return map2(x, callback);
    }
    mapTransform.rawArgs = true;
    var map2 = typed("map", {
      "Array, function": function ArrayFunction(x, callback) {
        return _map2(x, callback, x);
      },
      "Matrix, function": function MatrixFunction(x, callback) {
        return x.create(_map2(x.valueOf(), callback, x));
      }
    });
    return mapTransform;
  }, {
    isTransformFunction: true
  });
  function _map2(array, callback, orig) {
    var argsCount = maxArgumentCount(callback);
    function recurse(value, index) {
      if (Array.isArray(value)) {
        return map(value, function(child, i) {
          return recurse(child, index.concat(i + 1));
        });
      } else {
        if (argsCount === 1) {
          return callback(value);
        } else if (argsCount === 2) {
          return callback(value, index);
        } else {
          return callback(value, index, orig);
        }
      }
    }
    return recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
  function lastDimToZeroBase(args) {
    if (args.length === 2 && isCollection(args[0])) {
      args = args.slice();
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
    }
    return args;
  }

  // node_modules/mathjs/lib/esm/expression/transform/max.transform.js
  var name273 = "max";
  var dependencies274 = ["typed", "config", "numeric", "larger"];
  var createMaxTransform = /* @__PURE__ */ factory(name273, dependencies274, (_ref) => {
    var {
      typed,
      config,
      numeric: numeric2,
      larger
    } = _ref;
    var max = createMax({
      typed,
      config,
      numeric: numeric2,
      larger
    });
    return typed("max", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return max.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
  var name274 = "mean";
  var dependencies275 = ["typed", "add", "divide"];
  var createMeanTransform = /* @__PURE__ */ factory(name274, dependencies275, (_ref) => {
    var {
      typed,
      add,
      divide
    } = _ref;
    var mean = createMean({
      typed,
      add,
      divide
    });
    return typed("mean", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return mean.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/min.transform.js
  var name275 = "min";
  var dependencies276 = ["typed", "config", "numeric", "smaller"];
  var createMinTransform = /* @__PURE__ */ factory(name275, dependencies276, (_ref) => {
    var {
      typed,
      config,
      numeric: numeric2,
      smaller
    } = _ref;
    var min = createMin({
      typed,
      config,
      numeric: numeric2,
      smaller
    });
    return typed("min", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return min.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/range.transform.js
  var name276 = "range";
  var dependencies277 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
  var createRangeTransform = /* @__PURE__ */ factory(name276, dependencies277, (_ref) => {
    var {
      typed,
      config,
      matrix,
      bignumber,
      smaller,
      smallerEq,
      larger,
      largerEq
    } = _ref;
    var range = createRange({
      typed,
      config,
      matrix,
      bignumber,
      smaller,
      smallerEq,
      larger,
      largerEq
    });
    return typed("range", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (typeof last !== "boolean") {
          args.push(true);
        }
        return range.apply(null, args);
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/row.transform.js
  var name277 = "row";
  var dependencies278 = ["typed", "Index", "matrix", "range"];
  var createRowTransform = /* @__PURE__ */ factory(name277, dependencies278, (_ref) => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;
    var row = createRow({
      typed,
      Index,
      matrix,
      range
    });
    return typed("row", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }
        try {
          return row.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
  var name278 = "subset";
  var dependencies279 = ["typed", "matrix"];
  var createSubsetTransform = /* @__PURE__ */ factory(name278, dependencies279, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    var subset = createSubset({
      typed,
      matrix
    });
    return typed("subset", {
      "...any": function any(args) {
        try {
          return subset.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
  var name279 = "concat";
  var dependencies280 = ["typed", "matrix", "isInteger"];
  var createConcatTransform = /* @__PURE__ */ factory(name279, dependencies280, (_ref) => {
    var {
      typed,
      matrix,
      isInteger: isInteger2
    } = _ref;
    var concat = createConcat({
      typed,
      matrix,
      isInteger: isInteger2
    });
    return typed("concat", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        } else if (isBigNumber(last)) {
          args[lastIndex] = last.minus(1);
        }
        try {
          return concat.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
  var name280 = "diff";
  var dependencies281 = ["typed", "matrix", "subtract", "number", "bignumber"];
  var createDiffTransform = /* @__PURE__ */ factory(name280, dependencies281, (_ref) => {
    var {
      typed,
      matrix,
      subtract,
      number,
      bignumber
    } = _ref;
    var diff = createDiff({
      typed,
      matrix,
      subtract,
      number,
      bignumber
    });
    return typed(name280, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return diff.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/std.transform.js
  var name281 = "std";
  var dependencies282 = ["typed", "sqrt", "variance"];
  var createStdTransform = /* @__PURE__ */ factory(name281, dependencies282, (_ref) => {
    var {
      typed,
      sqrt,
      variance
    } = _ref;
    var std = createStd({
      typed,
      sqrt,
      variance
    });
    return typed("std", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return std.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
  var name282 = "sum";
  var dependencies283 = ["typed", "config", "add", "numeric"];
  var createSumTransform = /* @__PURE__ */ factory(name282, dependencies283, (_ref) => {
    var {
      typed,
      config,
      add,
      numeric: numeric2
    } = _ref;
    var sum = createSum({
      typed,
      config,
      add,
      numeric: numeric2
    });
    return typed(name282, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return sum.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
  var name283 = "variance";
  var dependencies284 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
  var createVarianceTransform = /* @__PURE__ */ factory(name283, dependencies284, (_ref) => {
    var {
      typed,
      add,
      subtract,
      multiply,
      divide,
      apply,
      isNaN: isNaN2
    } = _ref;
    var variance = createVariance({
      typed,
      add,
      subtract,
      multiply,
      divide,
      apply,
      isNaN: isNaN2
    });
    return typed(name283, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return variance.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/entry/allFactoriesAny.js
  var all = factoriesAny_exports;

  // node_modules/mathjs/lib/esm/utils/emitter.js
  var import_tiny_emitter = __toModule(require_tiny_emitter());
  function mixin(obj) {
    var emitter2 = new import_tiny_emitter.default();
    obj.on = emitter2.on.bind(emitter2);
    obj.off = emitter2.off.bind(emitter2);
    obj.once = emitter2.once.bind(emitter2);
    obj.emit = emitter2.emit.bind(emitter2);
    return obj;
  }

  // node_modules/mathjs/lib/esm/core/function/import.js
  function importFactory(typed, load, math2, importedFactories) {
    function mathImport(functions, options) {
      var num = arguments.length;
      if (num !== 1 && num !== 2) {
        throw new ArgumentsError("import", num, 1, 2);
      }
      if (!options) {
        options = {};
      }
      function flattenImports(flatValues2, value2, name285) {
        if (Array.isArray(value2)) {
          value2.forEach((item) => flattenImports(flatValues2, item));
        } else if (typeof value2 === "object") {
          for (var _name in value2) {
            if (hasOwnProperty2(value2, _name)) {
              flattenImports(flatValues2, value2[_name], _name);
            }
          }
        } else if (isFactory(value2) || name285 !== void 0) {
          var flatName = isFactory(value2) ? isTransformFunctionFactory(value2) ? value2.fn + ".transform" : value2.fn : name285;
          if (hasOwnProperty2(flatValues2, flatName) && flatValues2[flatName] !== value2 && !options.silent) {
            throw new Error('Cannot import "' + flatName + '" twice');
          }
          flatValues2[flatName] = value2;
        } else {
          if (!options.silent) {
            throw new TypeError("Factory, Object, or Array expected");
          }
        }
      }
      var flatValues = {};
      flattenImports(flatValues, functions);
      for (var name284 in flatValues) {
        if (hasOwnProperty2(flatValues, name284)) {
          var value = flatValues[name284];
          if (isFactory(value)) {
            _importFactory(value, options);
          } else if (isSupportedType(value)) {
            _import(name284, value, options);
          } else {
            if (!options.silent) {
              throw new TypeError("Factory, Object, or Array expected");
            }
          }
        }
      }
    }
    function _import(name284, value, options) {
      if (options.wrap && typeof value === "function") {
        value = _wrap(value);
      }
      if (hasTypedFunctionSignature(value)) {
        value = typed(name284, {
          [value.signature]: value
        });
      }
      if (isTypedFunction(math2[name284]) && isTypedFunction(value)) {
        if (options.override) {
          value = typed(name284, value.signatures);
        } else {
          value = typed(math2[name284], value);
        }
        math2[name284] = value;
        delete importedFactories[name284];
        _importTransform(name284, value);
        math2.emit("import", name284, function resolver() {
          return value;
        });
        return;
      }
      if (math2[name284] === void 0 || options.override) {
        math2[name284] = value;
        delete importedFactories[name284];
        _importTransform(name284, value);
        math2.emit("import", name284, function resolver() {
          return value;
        });
        return;
      }
      if (!options.silent) {
        throw new Error('Cannot import "' + name284 + '": already exists');
      }
    }
    function _importTransform(name284, value) {
      if (value && typeof value.transform === "function") {
        math2.expression.transform[name284] = value.transform;
        if (allowedInExpressions(name284)) {
          math2.expression.mathWithTransform[name284] = value.transform;
        }
      } else {
        delete math2.expression.transform[name284];
        if (allowedInExpressions(name284)) {
          math2.expression.mathWithTransform[name284] = value;
        }
      }
    }
    function _deleteTransform(name284) {
      delete math2.expression.transform[name284];
      if (allowedInExpressions(name284)) {
        math2.expression.mathWithTransform[name284] = math2[name284];
      } else {
        delete math2.expression.mathWithTransform[name284];
      }
    }
    function _wrap(fn) {
      var wrapper = function wrapper2() {
        var args = [];
        for (var i = 0, len = arguments.length; i < len; i++) {
          var arg = arguments[i];
          args[i] = arg && arg.valueOf();
        }
        return fn.apply(math2, args);
      };
      if (fn.transform) {
        wrapper.transform = fn.transform;
      }
      return wrapper;
    }
    function _importFactory(factory2, options) {
      var name284 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : factory2.fn;
      if (contains2(name284, ".")) {
        throw new Error("Factory name should not contain a nested path. Name: " + JSON.stringify(name284));
      }
      var namespace = isTransformFunctionFactory(factory2) ? math2.expression.transform : math2;
      var existingTransform = name284 in math2.expression.transform;
      var existing = hasOwnProperty2(namespace, name284) ? namespace[name284] : void 0;
      var resolver = function resolver2() {
        var dependencies285 = {};
        factory2.dependencies.map(stripOptionalNotation).forEach((dependency) => {
          if (contains2(dependency, ".")) {
            throw new Error("Factory dependency should not contain a nested path. Name: " + JSON.stringify(dependency));
          }
          if (dependency === "math") {
            dependencies285.math = math2;
          } else if (dependency === "mathWithTransform") {
            dependencies285.mathWithTransform = math2.expression.mathWithTransform;
          } else if (dependency === "classes") {
            dependencies285.classes = math2;
          } else {
            dependencies285[dependency] = math2[dependency];
          }
        });
        var instance = /* @__PURE__ */ factory2(dependencies285);
        if (instance && typeof instance.transform === "function") {
          throw new Error('Transforms cannot be attached to factory functions. Please create a separate function for it with exports.path="expression.transform"');
        }
        if (existing === void 0 || options.override) {
          return instance;
        }
        if (isTypedFunction(existing) && isTypedFunction(instance)) {
          return typed(existing, instance);
        }
        if (options.silent) {
          return existing;
        } else {
          throw new Error('Cannot import "' + name284 + '": already exists');
        }
      };
      if (!factory2.meta || factory2.meta.lazy !== false) {
        lazy(namespace, name284, resolver);
        if (existing && existingTransform) {
          _deleteTransform(name284);
        } else {
          if (isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2)) {
            lazy(math2.expression.mathWithTransform, name284, () => namespace[name284]);
          }
        }
      } else {
        namespace[name284] = resolver();
        if (existing && existingTransform) {
          _deleteTransform(name284);
        } else {
          if (isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2)) {
            lazy(math2.expression.mathWithTransform, name284, () => namespace[name284]);
          }
        }
      }
      importedFactories[name284] = factory2;
      math2.emit("import", name284, resolver);
    }
    function isSupportedType(object) {
      return typeof object === "function" || typeof object === "number" || typeof object === "string" || typeof object === "boolean" || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);
    }
    function isTypedFunction(fn) {
      return typeof fn === "function" && typeof fn.signatures === "object";
    }
    function hasTypedFunctionSignature(fn) {
      return typeof fn === "function" && typeof fn.signature === "string";
    }
    function allowedInExpressions(name284) {
      return !hasOwnProperty2(unsafe, name284);
    }
    function factoryAllowedInExpressions(factory2) {
      return factory2.fn.indexOf(".") === -1 && !hasOwnProperty2(unsafe, factory2.fn) && (!factory2.meta || !factory2.meta.isClass);
    }
    function isTransformFunctionFactory(factory2) {
      return factory2 !== void 0 && factory2.meta !== void 0 && factory2.meta.isTransformFunction === true || false;
    }
    var unsafe = {
      expression: true,
      type: true,
      docs: true,
      error: true,
      json: true,
      chain: true
    };
    return mathImport;
  }

  // node_modules/mathjs/lib/esm/core/create.js
  function _extends5() {
    _extends5 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends5.apply(this, arguments);
  }
  function create(factories, config) {
    var configInternal = _extends5({}, DEFAULT_CONFIG, config);
    if (typeof Object.create !== "function") {
      throw new Error("ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility.");
    }
    var math2 = mixin({
      isNumber,
      isComplex,
      isBigNumber,
      isFraction,
      isUnit,
      isString,
      isArray,
      isMatrix,
      isCollection,
      isDenseMatrix,
      isSparseMatrix,
      isRange,
      isIndex,
      isBoolean,
      isResultSet,
      isHelp,
      isFunction,
      isDate,
      isRegExp,
      isObject,
      isNull,
      isUndefined,
      isAccessorNode,
      isArrayNode,
      isAssignmentNode,
      isBlockNode,
      isConditionalNode,
      isConstantNode,
      isFunctionAssignmentNode,
      isFunctionNode,
      isIndexNode,
      isNode,
      isObjectNode,
      isOperatorNode,
      isParenthesisNode,
      isRangeNode,
      isSymbolNode,
      isChain
    });
    math2.config = configFactory(configInternal, math2.emit);
    math2.expression = {
      transform: {},
      mathWithTransform: {
        config: math2.config
      }
    };
    var legacyFactories = [];
    var legacyInstances = [];
    function load(factory2) {
      if (isFactory(factory2)) {
        return factory2(math2);
      }
      var firstProperty = factory2[Object.keys(factory2)[0]];
      if (isFactory(firstProperty)) {
        return firstProperty(math2);
      }
      if (!isLegacyFactory(factory2)) {
        console.warn("Factory object with properties `type`, `name`, and `factory` expected", factory2);
        throw new Error("Factory object with properties `type`, `name`, and `factory` expected");
      }
      var index = legacyFactories.indexOf(factory2);
      var instance;
      if (index === -1) {
        if (factory2.math === true) {
          instance = factory2.factory(math2.type, configInternal, load, math2.typed, math2);
        } else {
          instance = factory2.factory(math2.type, configInternal, load, math2.typed);
        }
        legacyFactories.push(factory2);
        legacyInstances.push(instance);
      } else {
        instance = legacyInstances[index];
      }
      return instance;
    }
    var importedFactories = {};
    function lazyTyped() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return math2.typed.apply(math2.typed, args);
    }
    var internalImport = importFactory(lazyTyped, load, math2, importedFactories);
    math2.import = internalImport;
    math2.on("config", () => {
      values(importedFactories).forEach((factory2) => {
        if (factory2 && factory2.meta && factory2.meta.recreateOnConfigChange) {
          internalImport(factory2, {
            override: true
          });
        }
      });
    });
    math2.create = create.bind(null, factories);
    math2.factory = factory;
    math2.import(values(deepFlatten(factories)));
    math2.ArgumentsError = ArgumentsError;
    math2.DimensionError = DimensionError;
    math2.IndexError = IndexError;
    return math2;
  }

  // src/index.js
  var import_lodash3 = __toModule(require_lodash());

  // src/polyhedron-calc.js
  var import_lodash2 = __toModule(require_lodash());

  // src/geometry-utils.js
  function intersectPlanes(plane1, plane2) {
    const parser = math.parser();
    parser.set("P1", plane1.point);
    parser.set("N1", plane1.normal);
    parser.set("P2", plane2.point);
    parser.set("N2", plane2.normal);
    parser.evaluate("H = cross(N1, N2)");
    parser.evaluate("H = H / norm(H)");
    parser.evaluate("P = dot(P2-P1, N2) / dot(cross(N1, H), N2) * cross(N1, H) + P1");
    return {
      point: parser.get("P"),
      heading: parser.get("H")
    };
  }
  function intersectPlaneLine(plane, line) {
    const parser = math.parser();
    parser.set("Pp", plane.point);
    parser.set("N", plane.normal);
    parser.set("Pl", line.point);
    parser.set("H", line.heading);
    parser.evaluate("lambda = dot(Pp-Pl,N) / dot(H,N)");
    parser.evaluate("P = Pl + lambda * H");
    return parser.get("P");
  }
  function joinLines(line1, line2) {
    const parser = math.parser();
    parser.set("P1", line1.point);
    parser.set("H1", line1.heading);
    parser.set("P2", line2.point);
    parser.set("H2", line2.heading);
    parser.evaluate("N = cross(H1, H2)");
    parser.evaluate("N = N / norm(N)");
    return {
      point: parser.get("P1"),
      normal: parser.get("N")
    };
  }
  function joinPoints(point1, point2, point3) {
    const line1 = {
      point: point1,
      heading: math.subtract(point2, point1)
    };
    const line2 = {
      point: point1,
      heading: math.subtract(point3, point1)
    };
    return joinLines(line1, line2);
  }
  function slack(point, plane) {
    return math.dot(math.subtract(plane.point, point), plane.normal);
  }
  function pointInPlane(point, plane) {
    return math.equal(0, slack(point, plane));
  }

  // src/utils.js
  var import_lodash = __toModule(require_lodash());
  var isEqualAbsTol = (x) => (y) => {
    const epsilon = 1e-12;
    return import_lodash.default.every(math.smaller(math.abs(math.subtract(x, y)), epsilon));
  };

  // src/polyhedron-calc.js
  function getPlanes(vertices2, directions) {
    const basePlane = {normal: [0, 0, -1], point: [0, 0, 0]};
    const startingPoint = [
      math.mean(math.column(vertices2, 0)),
      math.mean(math.column(vertices2, 1)),
      1
    ];
    const startingPlane = joinPoints(startingPoint, vertices2[vertices2.length - 1], vertices2[0]);
    const planes = [startingPlane, basePlane];
    for (let i = 0; i < vertices2.length - 1; i++) {
      const normalPlane = joinPoints(vertices2[i], math.add(vertices2[i], directions[i]), math.add(vertices2[i], [0, 0, 1]));
      const lineIntersection = intersectPlanes(normalPlane, planes[0]);
      const baseLine = {
        point: vertices2[i],
        heading: math.subtract(vertices2[i + 1], vertices2[i])
      };
      const plane = joinLines(lineIntersection, baseLine);
      planes.unshift(plane);
    }
    return planes;
  }
  function getEdges(vertices2, planes) {
    const queue = vertices2.slice();
    const visited = vertices2.slice();
    const edges = [];
    while (queue.length > 0) {
      const vertex = queue.shift();
      const neighbors = getNeighbors(vertex, planes);
      for (const neighbor of neighbors) {
        edges.push([vertex, neighbor]);
        if (visited.some(isEqualAbsTol(neighbor))) {
          continue;
        }
        queue.push(neighbor);
        visited.push(neighbor);
      }
    }
    return edges;
  }
  function getNeighbors(vertex, planes) {
    const [containingPlanes, otherPlanes] = import_lodash2.default.partition(planes, (plane) => pointInPlane(vertex, plane));
    const rays = [];
    for (let i = 0; i < containingPlanes.length; i++) {
      for (let j = i + 1; j < containingPlanes.length; j++) {
        const line = intersectPlanes(containingPlanes[i], containingPlanes[j]);
        const otherPlanes2 = containingPlanes.filter((_p, index) => ![i, j].includes(index));
        const dotProducts = otherPlanes2.map((plane) => math.dot(plane.normal, line.heading));
        if (dotProducts.every((d) => d < 0)) {
          rays.push(line);
        } else if (dotProducts.every((d) => d > 0)) {
          rays.push({...line, heading: math.multiply(-1, line.heading)});
        }
      }
    }
    const neighbors = [];
    for (const ray of rays) {
      const intersections = otherPlanes.map((plane) => intersectPlaneLine(plane, ray)).filter((point) => 0 < math.dot(ray.heading, math.subtract(point, vertex)));
      const closestIntersection = import_lodash2.default.minBy(intersections, (point) => math.distance(point, vertex));
      closestIntersection && neighbors.push(closestIntersection);
    }
    return neighbors;
  }

  // src/index.js
  var import_jsxgraphcore = __toModule(require_jsxgraphcore());
  var import_js_file_download = __toModule(require_file_download());
  var math = create(all);
  var board = JXG.JSXGraph.initBoard("box", {
    boundingbox: [-1.5, 1.5, 1.5, -1.5],
    axis: false
  });
  var numberOfPoints = 10;
  var debounceInMs = 200;
  document.querySelector("#svg-export").addEventListener("click", () => (0, import_js_file_download.default)(new XMLSerializer().serializeToString(board.renderer.svgRoot), "export.svg"));
  var {
    initialVertexCoordinates,
    initialDirectionCoordinates
  } = getInitialCoordinates(numberOfPoints);
  var {vertices, directionVertices, edgeObjects} = setupBoardElements();
  vertices.concat(directionVertices).forEach((vertex) => vertex.on("drag", import_lodash3.default.debounce(updateEdges, debounceInMs)));
  updateEdges();
  function getInitialCoordinates(n) {
    const initialVertexCoordinates2 = Array(n).fill().map((_value, index) => [
      Math.cos(index * 2 * Math.PI / n),
      Math.sin(index * 2 * Math.PI / n),
      0
    ]);
    const initialDirectionCoordinates2 = initialVertexCoordinates2.slice(0, -1).map((vertex) => math.multiply(vertex, -0.2));
    return {initialVertexCoordinates: initialVertexCoordinates2, initialDirectionCoordinates: initialDirectionCoordinates2};
  }
  function setupBoardElements() {
    const vertices2 = initialVertexCoordinates.map((vertex) => board.create("point", vertex.slice(0, 2), {withLabel: false}));
    const directionVertices2 = initialDirectionCoordinates.map((_d, i) => board.create("point", math.add(initialVertexCoordinates[i], initialDirectionCoordinates[i]).slice(0, 2), {withLabel: false, color: "blue"}));
    let edgeObjects2 = [];
    return {vertices: vertices2, directionVertices: directionVertices2, edgeObjects: edgeObjects2};
  }
  function updateEdges() {
    const {vertexCoordinates3d, directionCoordinates3d} = getCoordinates();
    const planes = getPlanes(vertexCoordinates3d, directionCoordinates3d);
    const edges = getEdges(vertexCoordinates3d, planes);
    updateEdgeObjects(edges);
  }
  function getCoordinates() {
    const vertexCoordinates3d = vertices.map((v) => [v.X(), v.Y(), 0]);
    const directionCoordinates3d = directionVertices.map((d, i) => math.subtract([d.X(), d.Y(), 0], vertexCoordinates3d[i]));
    return {vertexCoordinates3d, directionCoordinates3d};
  }
  function updateEdgeObjects(edges) {
    board.removeObject(edgeObjects.flatMap((edge) => [edge.point1, edge.point2, edge]));
    edgeObjects = edges.map(([p1, p2]) => board.create("line", [p1.slice(0, 2), p2.slice(0, 2)], {
      straightFirst: false,
      straightLast: false,
      fixed: true,
      color: "black"
    }));
  }
})();
